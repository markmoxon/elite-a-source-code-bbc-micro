\ ******************************************************************************
\
\ ELITE-A GAME SOURCE (PARASITE)
\
\ Elite-A is an extended version of BBC Micro Elite by Angus Duggan
\
\ The original Elite was written by Ian Bell and David Braben and is copyright
\ Acornsoft 1984, and the extra code in Elite-A is copyright Angus Duggan
\
\ The code on this site is identical to Angus Duggan's source discs (it's just
\ been reformatted, and the label names have been changed to be consistent with
\ the sources for the original BBC Micro disc version on which it is based)
\
\ The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
\ in the documentation are entirely my fault
\
\ The terminology and notations used in this commentary are explained at
\ https://www.bbcelite.com/about_site/terminology_used_in_this_commentary.html
\
\ The deep dive articles referred to in this commentary can be found at
\ https://www.bbcelite.com/deep_dives
\
\ ------------------------------------------------------------------------------
\
\ This source file produces the following binary file:
\
\   * 2.T.bin
\
\ ******************************************************************************

 INCLUDE "1-source-files/main-sources/elite-build-options.asm"

 _RELEASED              = (_VARIANT = 1)
 _SOURCE_DISC           = (_VARIANT = 2)
 _BUG_FIX               = (_VARIANT = 3)

 GUARD &F800            \ Guard against assembling over MOS memory

\ ******************************************************************************
\
\ Configuration variables
\
\ ******************************************************************************

 Q% = _REMOVE_CHECKSUMS \ Set Q% to TRUE to max out the default commander, FALSE
                        \ for the standard default commander (this is set to
                        \ TRUE if checksums are disabled, just for convenience)

 NOST = 18              \ The number of stardust particles in normal space (this
                        \ goes down to 3 in witchspace)

 NOSH = 12              \ The maximum number of ships in our local bubble of
                        \ universe

 NTY = 31               \ The number of different ship types

 ship_total = 38        \ The number of different ship blueprints in Elite-A

 MSL = 1                \ Ship blueprint position for the missile
 SST = 2                \ Ship blueprint position for the space station
 ESC = 3                \ Ship blueprint position for the escape pod
 PLT = 4                \ Ship blueprint position for the alloy plate
 OIL = 5                \ Ship blueprint position for the cargo canister
 AST = 7                \ Ship blueprint position for the asteroid
 SPL = 8                \ Ship blueprint position for the splinter
 SHU = 9                \ Ship blueprint position for the shuttle
 COPS = 16              \ Ship blueprint position for the cop
 THG = 29               \ Ship blueprint position for the Thargoid
 TGL = 30               \ Ship blueprint position for the Thargon
 CON = 31               \ Ship blueprint position for the Constrictor

 CYL = 11               \ Ship blueprint position for the title's Cobra Mk III
 KRA = 19               \ Ship blueprint position for the title's Krait

 JL = ESC               \ Junk is defined as starting from the escape pod

 JH = SHU+2             \ Junk is defined as ending before the Cobra Mk III
                        \
                        \ So junk is defined as the following: escape pod,
                        \ alloy plate, cargo canister, asteroid, splinter,
                        \ Shuttle or Transporter

 NI% = 37               \ The number of bytes in each ship's data block (as
                        \ stored in INWK and K%)

 X = 128                \ The centre x-coordinate of the 256 x 192 space view
 Y = 96                 \ The centre y-coordinate of the 256 x 192 space view

 f0 = &20               \ Internal key number for red key f0 (Launch, Front)
 f1 = &71               \ Internal key number for red key f1 (Buy Cargo, Rear)
 f2 = &72               \ Internal key number for red key f2 (Sell Cargo, Left)
 f3 = &73               \ Internal key number for red key f3 (Equip Ship, Right)
 f4 = &14               \ Internal key number for red key f4 (Long-range Chart)
 f5 = &74               \ Internal key number for red key f5 (Short-range Chart)
 f6 = &75               \ Internal key number for red key f6 (Data on System)
 f7 = &16               \ Internal key number for red key f7 (Market Price)
 f8 = &76               \ Internal key number for red key f8 (Status Mode)
 f9 = &77               \ Internal key number for red key f9 (Inventory)

 NRU% = 25              \ The number of planetary systems with extended system
                        \ description overrides in the RUTOK table

 RE = &23               \ The obfuscation byte used to hide the recursive tokens
                        \ table from crackers viewing the binary code

 VE = 0                 \ The obfuscation byte used to hide the extended tokens
                        \ table from crackers viewing the binary code, which is
                        \ zero in Elite-A as the token table is not obfuscated

 LL = 30                \ The length of lines (in characters) of justified text
                        \ in the extended tokens system

 BRKV = &0202           \ The address of the break vector

 save_lock = &0233      \ This flag indicates whether we should be asking for
                        \ confirmation before saving or loading a commander
                        \ file:
                        \
                        \   * 0 = last file operation was a save, or we just
                        \         started a new game, so there are no unsaved
                        \         changes (so ask for confirmation on saving)
                        \
                        \   * &FF = last file operation was a load, or we have
                        \           just docked and have unsaved changes (so ask
                        \           for confirmation on loading)
                        \
                        \ It shares a location with the IND2V+1 vector, which we
                        \ do not use, so we can reuse the location

 LS% = &0CFF            \ The start of the descending ship line heap

 VIA = &FE00            \ Memory-mapped space for accessing internal hardware,
                        \ such as the video ULA, 6845 CRTC and 6522 VIAs (also
                        \ known as SHEILA)

 tube_r1s = &FEF8       \ The Tube's memory-mapped FIFO 1 status register
 tube_r1d = &FEF9       \ The Tube's memory-mapped FIFO 1 data register
 tube_r2s = &FEFA       \ The Tube's memory-mapped FIFO 2 status register
 tube_r2d = &FEFB       \ The Tube's memory-mapped FIFO 2 data register
 tube_r3s = &FEFC       \ The Tube's memory-mapped FIFO 3 data register
 tube_r3d = &FEFD       \ The Tube's memory-mapped FIFO 3 status register
 tube_r4s = &FEFE       \ The Tube's memory-mapped FIFO 4 data register
 tube_r4d = &FEFF       \ The Tube's memory-mapped FIFO 4 status register

 OSBYTE = &FFF4         \ The address for the OSBYTE routine
 OSWORD = &FFF1         \ The address for the OSWORD routine
 OSFILE = &FFDD         \ The address for the OSFILE routine
 OSWRCH = &FFEE         \ The address for the OSWRCH routine
 OSCLI = &FFF7          \ The address for the OSCLI routine

\ ******************************************************************************
\
\       Name: ZP
\       Type: Workspace
\    Address: &0000 to &00B0
\   Category: Workspaces
\    Summary: Lots of important variables are stored in the zero page workspace
\             as it is quicker and more space-efficient to access memory here
\
\ ******************************************************************************

 ORG &0000

.ZP

 SKIP 0                 \ The start of the zero page workspace

.RAND

 SKIP 4                 \ Four 8-bit seeds for the random number generation
                        \ system implemented in the DORND routine

.TRTB%

 SKIP 2                 \ Contains the address of the keyboard translation
                        \ table, which is used to translate internal key
                        \ numbers to ASCII

.T1

 SKIP 1                 \ Temporary storage, used in a number of places

.SC

 SKIP 1                 \ Screen address (low byte)
                        \
                        \ Elite draws on-screen by poking bytes directly into
                        \ screen memory, and SC(1 0) is typically set to the
                        \ address of the character block containing the pixel
                        \ we want to draw (see the deep dives on "Drawing
                        \ monochrome pixels in mode 4" and "Drawing colour
                        \ pixels in mode 5" for more details)

.SCH

 SKIP 1                 \ Screen address (high byte)

.XX16

 SKIP 18                \ Temporary storage for a block of values, used in a
                        \ number of places

.P

 SKIP 3                 \ Temporary storage, used in a number of places

.XX0

 SKIP 2                 \ Temporary storage, used to store the address of a ship
                        \ blueprint. For example, it is used when we add a new
                        \ ship to the local bubble in routine NWSHP, and it
                        \ contains the address of the current ship's blueprint
                        \ as we loop through all the nearby ships in the main
                        \ flight loop

.INF

 SKIP 2                 \ Temporary storage, typically used for storing the
                        \ address of a ship's data block, so it can be copied
                        \ to and from the internal workspace at INWK

.V

 SKIP 2                 \ Temporary storage, typically used for storing an
                        \ address pointer

.XX

 SKIP 2                 \ Temporary storage, typically used for storing a 16-bit
                        \ x-coordinate

.YY

 SKIP 2                 \ Temporary storage, typically used for storing a 16-bit
                        \ y-coordinate

.SUNX

 SKIP 2                 \ The 16-bit x-coordinate of the vertical centre axis
                        \ of the sun (which might be off-screen)

.BETA

 SKIP 1                 \ The current pitch angle beta, which is reduced from
                        \ JSTY to a sign-magnitude value between -8 and +8
                        \
                        \ This describes how fast we are pitching our ship, and
                        \ determines how fast the universe pitches around us
                        \
                        \ The sign bit is also stored in BET2, while the
                        \ opposite sign is stored in BET2+1

.BET1

 SKIP 1                 \ The magnitude of the pitch angle beta, i.e. |beta|,
                        \ which is a positive value between 0 and 8

.XC

 SKIP 1                 \ The x-coordinate of the text cursor (i.e. the text
                        \ column), which can be from 0 to 32
                        \
                        \ A value of 0 denotes the leftmost column and 32 the
                        \ rightmost column, but because the top part of the
                        \ screen (the space view) has a white border that
                        \ clashes with columns 0 and 32, text is only shown
                        \ in columns 1-31

.YC

 SKIP 1                 \ The y-coordinate of the text cursor (i.e. the text
                        \ row), which can be from 0 to 23
                        \
                        \ The screen actually has 31 character rows if you
                        \ include the dashboard, but the text printing routines
                        \ only work on the top part (the space view), so the
                        \ text cursor only goes up to a maximum of 23, the row
                        \ just before the screen splits
                        \
                        \ A value of 0 denotes the top row, but because the
                        \ top part of the screen has a white border that clashes
                        \ with row 0, text is always shown at row 1 or greater

.QQ22

 SKIP 2                 \ The two hyperspace countdown counters
                        \
                        \ Before a hyperspace jump, both QQ22 and QQ22+1 are
                        \ set to 15
                        \
                        \ QQ22 is an internal counter that counts down by 1
                        \ each time TT102 is called, which happens every
                        \ iteration of the main game loop. When it reaches
                        \ zero, the on-screen counter in QQ22+1 gets
                        \ decremented, and QQ22 gets set to 5 and the countdown
                        \ continues (so the first tick of the hyperspace counter
                        \ takes 15 iterations to happen, but subsequent ticks
                        \ take 5 iterations each)
                        \
                        \ QQ22+1 contains the number that's shown on-screen
                        \ during the countdown. It counts down from 15 to 1, and
                        \ when it hits 0, the hyperspace engines kick in

.ECMA

 SKIP 1                 \ The E.C.M. countdown timer, which determines whether
                        \ an E.C.M. system is currently operating:
                        \
                        \   * 0 = E.C.M. is off
                        \
                        \   * Non-zero = E.C.M. is on and is counting down
                        \
                        \ The counter starts at 32 when an E.C.M. is activated,
                        \ either by us or by an opponent, and it decreases by 1
                        \ in each iteration of the main flight loop until it
                        \ reaches zero, at which point the E.C.M. switches off.
                        \ Only one E.C.M. can be active at any one time, so
                        \ there is only one counter

.ALP1

 SKIP 1                 \ Magnitude of the roll angle alpha, i.e. |alpha|,
                        \ which is a positive value between 0 and 31

.ALP2

 SKIP 2                 \ Bit 7 of ALP2 = sign of the roll angle in ALPHA
                        \
                        \ Bit 7 of ALP2+1 = opposite sign to ALP2 and ALPHA

.XX15

 SKIP 0                 \ Temporary storage, typically used for storing screen
                        \ coordinates in line-drawing routines
                        \
                        \ There are six bytes of storage, from XX15 TO XX15+5.
                        \ The first four bytes have the following aliases:
                        \
                        \   X1 = XX15
                        \   Y1 = XX15+1
                        \   X2 = XX15+2
                        \   Y2 = XX15+3
                        \
                        \ These are typically used for describing lines in terms
                        \ of screen coordinates, i.e. (X1, Y1) to (X2, Y2)
                        \
                        \ The last two bytes of XX15 do not have aliases

.X1

 SKIP 1                 \ Temporary storage, typically used for x-coordinates in
                        \ line-drawing routines

.Y1

 SKIP 1                 \ Temporary storage, typically used for y-coordinates in
                        \ line-drawing routines

.X2

 SKIP 1                 \ Temporary storage, typically used for x-coordinates in
                        \ line-drawing routines

.Y2

 SKIP 1                 \ Temporary storage, typically used for y-coordinates in
                        \ line-drawing routines

 SKIP 2                 \ The last two bytes of the XX15 block

.XX12

 SKIP 6                 \ Temporary storage for a block of values, used in a
                        \ number of places

.K

 SKIP 4                 \ Temporary storage, used in a number of places

.LAS

 SKIP 1                 \ Contains the laser power of the laser fitted to the
                        \ current space view (or 0 if there is no laser fitted
                        \ to the current view)
                        \
                        \ This gets set to bits 0-6 of the laser power byte from
                        \ the commander data block, which contains the laser's
                        \ power (bit 7 doesn't denote laser power, just whether
                        \ or not the laser pulses, so that is not stored here)

.MSTG

 SKIP 1                 \ The current missile lock target
                        \
                        \   * &FF = no target
                        \
                        \   * 1-12 = the slot number of the ship that our
                        \            missile is locked onto

.XX1

 SKIP 0                 \ This is an alias for INWK that is used in the main
                        \ ship-drawing routine at LL9

.INWK

 SKIP 33                \ The zero-page internal workspace for the current ship
                        \ data block
                        \
                        \ As operations on zero page locations are faster and
                        \ have smaller opcodes than operations on the rest of
                        \ the addressable memory, Elite tends to store oft-used
                        \ data here. A lot of the routines in Elite need to
                        \ access and manipulate ship data, so to make this an
                        \ efficient exercise, the ship data is first copied from
                        \ the ship data blocks at K% into INWK (or, when new
                        \ ships are spawned, from the blueprints at XX21). See
                        \ the deep dive on "Ship data blocks" for details of
                        \ what each of the bytes in the INWK data block
                        \ represents

.XX19

 SKIP NI% - 34          \ XX19(1 0) shares its location with INWK(34 33), which
                        \ contains the address of the ship line heap

.NEWB

 SKIP 1                 \ The ship's "new byte flags" (or NEWB flags)
                        \
                        \ Contains details about the ship's type and associated
                        \ behaviour, such as whether they are a trader, a bounty
                        \ hunter, a pirate, currently hostile, in the process of
                        \ docking, inside the hold having been scooped, and so
                        \ on. The default values for each ship type are taken
                        \ from the table at E%, and you can find out more detail
                        \ in the deep dive on "Advanced tactics with the NEWB
                        \ flags"

.LSP

 SKIP 1                 \ The ball line heap pointer, which contains the number
                        \ of the first free byte after the end of the LSX2 and
                        \ LSY2 heaps (see the deep dive on "The ball line heap"
                        \ for details)

.QQ15

 SKIP 6                 \ The three 16-bit seeds for the selected system, i.e.
                        \ the one in the crosshairs in the Short-range Chart
                        \
                        \ See the deep dives on "Galaxy and system seeds" and
                        \ "Twisting the system seeds" for more details

.K5

 SKIP 0                 \ Temporary storage used to store segment coordinates
                        \ across successive calls to BLINE, the ball line
                        \ routine

.XX18

 SKIP 0                 \ Temporary storage used to store coordinates in the
                        \ LL9 ship-drawing routine

.QQ17

 SKIP 1                 \ Contains a number of flags that affect how text tokens
                        \ are printed, particularly capitalisation:
                        \
                        \   * If all bits are set (255) then text printing is
                        \     disabled
                        \
                        \   * Bit 7: 0 = ALL CAPS
                        \            1 = Sentence Case, bit 6 determines the
                        \                case of the next letter to print
                        \
                        \   * Bit 6: 0 = print the next letter in upper case
                        \            1 = print the next letter in lower case
                        \
                        \   * Bits 0-5: If any of bits 0-5 are set, print in
                        \               lower case
                        \
                        \ So:
                        \
                        \   * QQ17 = 0 means case is set to ALL CAPS
                        \
                        \   * QQ17 = %10000000 means Sentence Case, currently
                        \            printing upper case
                        \
                        \   * QQ17 = %11000000 means Sentence Case, currently
                        \            printing lower case
                        \
                        \   * QQ17 = %11111111 means printing is disabled

.QQ19

 SKIP 3                 \ Temporary storage, used in a number of places

.K6

 SKIP 5                 \ Temporary storage, typically used for storing
                        \ coordinates during vector calculations

.BET2

 SKIP 2                 \ Bit 7 of BET2 = sign of the pitch angle in BETA
                        \
                        \ Bit 7 of BET2+1 = opposite sign to BET2 and BETA

.DELTA

 SKIP 1                 \ Our current speed, in the range 1-40

.DELT4

 SKIP 2                 \ Our current speed * 64 as a 16-bit value
                        \
                        \ This is stored as DELT4(1 0), so the high byte in
                        \ DELT4+1 therefore contains our current speed / 4

.U

 SKIP 1                 \ Temporary storage, used in a number of places

.Q

 SKIP 1                 \ Temporary storage, used in a number of places

.R

 SKIP 1                 \ Temporary storage, used in a number of places

.S

 SKIP 1                 \ Temporary storage, used in a number of places

.XSAV

 SKIP 1                 \ Temporary storage for saving the value of the X
                        \ register, used in a number of places

.YSAV

 SKIP 1                 \ Temporary storage for saving the value of the Y
                        \ register, used in a number of places

.XX17

 SKIP 1                 \ Temporary storage, used in BPRNT to store the number
                        \ of characters to print, and as the edge counter in the
                        \ main ship-drawing routine

.QQ11

 SKIP 1                 \ The number of the current view:
                        \
                        \   0   = Space view
                        \   1   = Title screen
                        \         Get commander name ("@", save/load commander)
                        \         In-system jump just arrived ("J")
                        \         Data on System screen (red key f6)
                        \   2   = Buy Cargo screen (red key f1)
                        \   3   = Mis-jump just arrived (witchspace)
                        \   4   = Sell Cargo screen (red key f2)
                        \   6   = Death screen
                        \   8   = Status Mode screen (red key f8)
                        \         Inventory screen (red key f9)
                        \   16  = Market Price screen (red key f7)
                        \   32  = Equip Ship screen (red key f3)
                        \   64  = Long-range Chart (red key f4)
                        \   128 = Short-range Chart (red key f5)
                        \   255 = Launch view
                        \
                        \ This value is typically set by calling routine TT66

.ZZ

 SKIP 1                 \ Temporary storage, typically used for distance values

.XX13

 SKIP 1                 \ Temporary storage, typically used in the line-drawing
                        \ routines

.MCNT

 SKIP 1                 \ The main loop counter
                        \
                        \ This counter determines how often certain actions are
                        \ performed within the main loop. See the deep dive on
                        \ "Scheduling tasks with the main loop counter" for more
                        \ details

.DL

 SKIP 1                 \ Vertical sync flag
                        \
                        \ DL gets set to 30 every time we reach vertical sync on
                        \ the video system, which happens 50 times a second
                        \ (50Hz). The WSCAN routine uses this to pause until the
                        \ vertical sync, by setting DL to 0 and then monitoring
                        \ its value until it changes to 30

.TYPE

 SKIP 1                 \ The current ship type
                        \
                        \ This is where we store the current ship type for when
                        \ we are iterating through the ships in the local bubble
                        \ as part of the main flight loop. See the table at XX21
                        \ for information about ship types

.ALPHA

 SKIP 1                 \ The current roll angle alpha, which is reduced from
                        \ JSTX to a sign-magnitude value between -31 and +31
                        \
                        \ This describes how fast we are rolling our ship, and
                        \ determines how fast the universe rolls around us
                        \
                        \ The sign bit is also stored in ALP2, while the
                        \ opposite sign is stored in ALP2+1

.QQ12

 SKIP 1                 \ Our "docked" status
                        \
                        \   * 0 = we are not docked
                        \
                        \   * &FF = we are docked

.TGT

 SKIP 1                 \ Temporary storage, typically used as a target value
                        \ for counters when drawing explosion clouds and partial
                        \ circles

.SWAP

 SKIP 1                 \ Temporary storage, used to store a flag that records
                        \ whether or not we had to swap a line's start and end
                        \ coordinates around when clipping the line in routine
                        \ LL145 (the flag is used in places like BLINE to swap
                        \ them back)

.COL

 SKIP 1                 \ Temporary storage, used to store colour information
                        \ when drawing pixels in the dashboard

.FLAG

 SKIP 1                 \ A flag that's used to define whether this is the first
                        \ call to the ball line routine in BLINE, so it knows
                        \ whether to wait for the second call before storing
                        \ segment data in the ball line heap

.CNT

 SKIP 1                 \ Temporary storage, typically used for storing the
                        \ number of iterations required when looping

.CNT2

 SKIP 1                 \ Temporary storage, used in the planet-drawing routine
                        \ to store the segment number where the arc of a partial
                        \ circle should start

.STP

 SKIP 1                 \ The step size for drawing circles
                        \
                        \ Circles in Elite are split up into 64 points, and the
                        \ step size determines how many points to skip with each
                        \ straight-line segment, so the smaller the step size,
                        \ the smoother the circle. The values used are:
                        \
                        \   * 2 for big planets and the circles on the charts
                        \   * 4 for medium planets and the launch tunnel
                        \   * 8 for small planets and the hyperspace tunnel
                        \
                        \ As the step size increases we move from smoother
                        \ circles at the top to more polygonal at the bottom.
                        \ See the CIRCLE2 routine for more details

.XX4

 SKIP 1                 \ Temporary storage, used in a number of places

.XX20

 SKIP 1                 \ Temporary storage, used in a number of places

.XX14

 SKIP 1                 \ This byte appears to be unused

.RAT

 SKIP 1                 \ Used to store different signs depending on the current
                        \ space view, for use in calculating stardust movement

.RAT2

 SKIP 1                 \ Temporary storage, used to store the pitch and roll
                        \ signs when moving objects and stardust

.K2

 SKIP 4                 \ Temporary storage, used in a number of places

.finder

 SKIP 1                 \ Toggle whether the compass shows the planet or sun
                        \
                        \   * 0 = show the planet on the compass
                        \
                        \   * NI% = show the sun on the compass
                        \
                        \ When inside the space station's safe zone, the compass
                        \ always shows the space station
                        \
                        \ Toggled by pressing "F" when paused, see the DK4
                        \ routine for details

.dockedp

 SKIP 1                 \ A flag that determines whether or not we are docked
                        \
                        \   * 0 = we are docked
                        \
                        \   * &FF = we are not docked

 ORG &00D1

.T

 SKIP 1                 \ Temporary storage, used in a number of places

.K3

 SKIP 0                 \ Temporary storage, used in a number of places

.XX2

 SKIP 14                \ Temporary storage, used to store the visibility of the
                        \ ship's faces during the ship-drawing routine at LL9

.K4

 SKIP 2                 \ Temporary storage, used in a number of places

 PRINT "Zero page variables from ", ~ZP, " to ", ~P%

\ ******************************************************************************
\
\       Name: XX3
\       Type: Workspace
\    Address: &0100 to the top of the descending stack
\   Category: Workspaces
\    Summary: Temporary storage space for complex calculations
\
\ ------------------------------------------------------------------------------
\
\ Used as heap space for storing temporary data during calculations. Shared with
\ the descending 6502 stack, which works down from &01FF.
\
\ ******************************************************************************

 ORG &0100

.XX3

 SKIP 0                 \ Temporary storage, typically used for storing tables
                        \ of values such as screen coordinates or ship data

\ ******************************************************************************
\
\       Name: UP
\       Type: Workspace
\    Address: &0300 to &03CF
\   Category: Workspaces
\    Summary: Ship slots, variables
\
\ ******************************************************************************

 ORG &0300

.KL

 SKIP 1                 \ The following bytes implement a key logger that
                        \ enables Elite to scan for concurrent key presses of
                        \ the primary flight keys, plus a secondary flight key
                        \
                        \ See the deep dive on "The key logger" for more details
                        \
                        \ If a key is being pressed that is not in the keyboard
                        \ table at KYTB, it can be stored here (as seen in
                        \ routine DK4, for example)

.KY1

 SKIP 1                 \ "?" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY2

 SKIP 1                 \ Space is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY3

 SKIP 1                 \ "<" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY4

 SKIP 1                 \ ">" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY5

 SKIP 1                 \ "X" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY6

 SKIP 1                 \ "S" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY7

 SKIP 1                 \ "A" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes
                        \
                        \ This is also set when the joystick fire button has
                        \ been pressed

.KY12

 SKIP 1                 \ TAB is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY13

 SKIP 1                 \ ESCAPE is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY14

 SKIP 1                 \ "T" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY15

 SKIP 1                 \ "U" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY16

 SKIP 1                 \ "M" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY17

 SKIP 1                 \ "E" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY18

 SKIP 1                 \ "J" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY19

 SKIP 1                 \ "C" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.KY20

 SKIP 1                 \ "P" is being pressed
                        \
                        \   * 0 = no
                        \
                        \   * Non-zero = yes

.FRIN

 SKIP NOSH + 1          \ Slots for the ships in the local bubble of universe
                        \
                        \ There are #NOSH + 1 slots, but the ship-spawning
                        \ routine at NWSHP only populates #NOSH of them, so
                        \ there are 13 slots but only 12 are used for ships
                        \ (the last slot is effectively used as a null
                        \ terminator when shuffling the slots down in the
                        \ KILLSHP routine)
                        \
                        \ See the deep dive on "The local bubble of universe"
                        \ for details of how Elite stores the local universe in
                        \ FRIN, UNIV and K%

.MANY

 SKIP SST               \ The number of ships of each type in the local bubble
                        \ of universe
                        \
                        \ The number of ships of type X in the local bubble is
                        \ stored at MANY+X, so the number of Sidewinders is at
                        \ MANY+1, the number of Mambas is at MANY+2, and so on
                        \
                        \ See the deep dive on "Ship blueprints" for a list of
                        \ ship types

.SSPR

 SKIP NTY + 1 - SST     \ "Space station present" flag
                        \
                        \   * Non-zero if we are inside the space station's safe
                        \     zone
                        \
                        \   * 0 if we aren't (in which case we can show the sun)
                        \
                        \ This flag is at MANY+SST, which is no coincidence, as
                        \ MANY+SST is a count of how many space stations there
                        \ are in our local bubble, which is the same as saying
                        \ "space station present"

.JUNK

 SKIP 1                 \ The amount of junk in the local bubble
                        \
                        \ "Junk" is defined as being one of these:
                        \
                        \   * Escape pod
                        \   * Alloy plate
                        \   * Cargo canister
                        \   * Asteroid
                        \   * Splinter
                        \   * Shuttle
                        \   * Transporter
                        \
                        \ Junk is the range of ship types from #JL to #JH - 1

.auto

 SKIP 1                 \ Docking computer activation status
                        \
                        \   * 0 = Docking computer is off
                        \
                        \   * Non-zero = Docking computer is running

.ECMP

 SKIP 1                 \ Our E.C.M. status
                        \
                        \   * 0 = E.C.M. is off
                        \
                        \   * Non-zero = E.C.M. is on

.MJ

 SKIP 1                 \ Are we in witchspace (i.e. have we mis-jumped)?
                        \
                        \   * 0 = no, we are in normal space
                        \
                        \   * &FF = yes, we are in witchspace

.CABTMP

 SKIP 1                 \ Cabin temperature
                        \
                        \ The ambient cabin temperature in deep space is 30,
                        \ which is displayed as one notch on the dashboard bar
                        \
                        \ We get higher temperatures closer to the sun
                        \
                        \ CABTMP shares a location with MANY, but that's OK as
                        \ MANY+0 would contain the number of ships of type 0,
                        \ and as there is no ship type 0 (they start at 1), the
                        \ byte at MANY+0 is not used for storing a ship type
                        \ and can be used for the cabin temperature instead

.LAS2

 SKIP 1                 \ Laser power for the current laser
                        \
                        \   * Bits 0-6 contain the laser power of the current
                        \     space view
                        \
                        \   * Bit 7 denotes whether or not the laser pulses:
                        \
                        \     * 0 = pulsing laser
                        \
                        \     * 1 = beam laser (i.e. always on)

.MSAR

 SKIP 1                 \ The targeting state of our leftmost missile
                        \
                        \   * 0 = missile is not looking for a target, or it
                        \     already has a target lock (indicator is not
                        \     yellow/white)
                        \
                        \   * Non-zero = missile is currently looking for a
                        \     target (indicator is yellow/white)

.VIEW

 SKIP 1                 \ The number of the current space view
                        \
                        \   * 0 = front
                        \   * 1 = rear
                        \   * 2 = left
                        \   * 3 = right

.LASCT

 SKIP 1                 \ The laser pulse count for the current laser
                        \
                        \ This is a counter that defines the gap between the
                        \ pulses of a pulse laser. It is set as follows:
                        \
                        \   * 0 for a beam laser
                        \
                        \   * 10 for a pulse laser
                        \
                        \ It gets decremented every vertical sync (in the LINSCN
                        \ routine, which is called 50 times a second) and is set
                        \ to a non-zero value for pulse lasers only
                        \
                        \ The laser only fires when the value of LASCT hits
                        \ zero, so for pulse lasers with a value of 10, that
                        \ means the laser fires once every 10 vertical syncs (or
                        \ 5 times a second)
                        \
                        \ In comparison, beam lasers fire continuously as the
                        \ value of LASCT is always 0

.GNTMP

 SKIP 1                 \ Laser temperature (or "gun temperature")
                        \
                        \ If the laser temperature exceeds 242 then the laser
                        \ overheats and cannot be fired again until it has
                        \ cooled down

.HFX

 SKIP 1                 \ A flag that toggles the hyperspace colour effect
                        \
                        \   * 0 = no colour effect
                        \
                        \   * Non-zero = hyperspace colour effect enabled
                        \
                        \ When HFX is set to 1, the mode 4 screen that makes
                        \ up the top part of the display is temporarily switched
                        \ to mode 5 (the same screen mode as the dashboard),
                        \ which has the effect of blurring and colouring the
                        \ hyperspace rings in the top part of the screen. The
                        \ code to do this is in the LINSCN routine, which is
                        \ called as part of the screen mode routine at IRQ1.
                        \ It's in LINSCN that HFX is checked, and if it is
                        \ non-zero, the top part of the screen is not switched
                        \ to mode 4, thus leaving the top part of the screen in
                        \ the more colourful mode 5

.EV

 SKIP 1                 \ The "extra vessels" spawning counter
                        \
                        \ This counter is set to 0 on arrival in a system and
                        \ following an in-system jump, and is bumped up when we
                        \ spawn bounty hunters or pirates (i.e. "extra vessels")
                        \
                        \ It decreases by 1 each time we consider spawning more
                        \ "extra vessels" in part 4 of the main game loop, so
                        \ increasing the value of EV has the effect of delaying
                        \ the spawning of more vessels
                        \
                        \ In other words, this counter stops bounty hunters and
                        \ pirates from continually appearing, and ensures that
                        \ there's a delay between spawnings

.DLY

 SKIP 1                 \ In-flight message delay
                        \
                        \ This counter is used to keep an in-flight message up
                        \ for a specified time before it gets removed. The value
                        \ in DLY is decremented each time we start another
                        \ iteration of the main game loop at TT100

.de

 SKIP 1                 \ Equipment destruction flag
                        \
                        \   * Bit 1 denotes whether or not the in-flight message
                        \     about to be shown by the MESS routine is about
                        \     destroyed equipment:
                        \
                        \     * 0 = the message is shown normally
                        \
                        \     * 1 = the string " DESTROYED" gets added to the
                        \       end of the message

.JSTX

 SKIP 1                 \ Our current roll rate
                        \
                        \ This value is shown in the dashboard's RL indicator,
                        \ and determines the rate at which we are rolling
                        \
                        \ The value ranges from 1 to 255 with 128 as the centre
                        \ point, so 1 means roll is decreasing at the maximum
                        \ rate, 128 means roll is not changing, and 255 means
                        \ roll is increasing at the maximum rate
                        \
                        \ This value is updated by "<" and ">" key presses, or
                        \ if joysticks are enabled, from the joystick. If
                        \ keyboard damping is enabled (which it is by default),
                        \ the value is slowly moved towards the centre value of
                        \ 128 (no roll) if there are no key presses or joystick
                        \ movement

.JSTY

 SKIP 1                 \ Our current pitch rate
                        \
                        \ This value is shown in the dashboard's DC indicator,
                        \ and determines the rate at which we are pitching
                        \
                        \ The value ranges from 1 to 255 with 128 as the centre
                        \ point, so 1 means pitch is decreasing at the maximum
                        \ rate, 128 means pitch is not changing, and 255 means
                        \ pitch is increasing at the maximum rate
                        \
                        \ This value is updated by "S" and "X" key presses, or
                        \ if joysticks are enabled, from the joystick. If
                        \ keyboard damping is enabled (which it is by default),
                        \ the value is slowly moved towards the centre value of
                        \ 128 (no pitch) if there are no key presses or joystick
                        \ movement
.XSAV2

 SKIP 1                 \ Temporary storage, used for storing the value of the X
                        \ register in the CHPR routine

.YSAV2

 SKIP 1                 \ Temporary storage, used for storing the value of the Y
                        \ register in the CHPR routine

.NAME

 SKIP 8                 \ The current commander name
                        \
                        \ The commander name can be up to 7 characters (the DFS
                        \ limit for filenames), and is terminated by a carriage
                        \ return

.TP

 SKIP 1                 \ The current mission status
                        \
                        \   * Bits 0-1 = Mission 1 status
                        \
                        \     * %00 = Mission not started
                        \     * %01 = Mission in progress, hunting for ship
                        \     * %11 = Constrictor killed, not debriefed yet
                        \     * %10 = Mission and debrief complete
                        \
                        \   * Bits 2-3 = Mission 2 status
                        \
                        \     * %00 = Mission not started
                        \     * %01 = Mission in progress, plans not picked up
                        \     * %10 = Mission in progress, plans picked up
                        \     * %11 = Mission complete

.QQ0

 SKIP 1                 \ The current system's galactic x-coordinate (0-256)

.QQ1

 SKIP 1                 \ The current system's galactic y-coordinate (0-256)

.QQ21

 SKIP 6                 \ The three 16-bit seeds for the current galaxy
                        \
                        \ These seeds define system 0 in the current galaxy, so
                        \ they can be used as a starting point to generate all
                        \ 256 systems in the galaxy
                        \
                        \ Using a galactic hyperdrive rotates each byte to the
                        \ left (rolling each byte within itself) to get the
                        \ seeds for the next galaxy, so after eight galactic
                        \ jumps, the seeds roll around to the first galaxy again
                        \
                        \ See the deep dives on "Galaxy and system seeds" and
                        \ "Twisting the system seeds" for more details

.CASH

 SKIP 4                 \ Our current cash pot
                        \
                        \ The cash stash is stored as a 32-bit unsigned integer,
                        \ with the most significant byte in CASH and the least
                        \ significant in CASH+3. This is big-endian, which is
                        \ the opposite way round to most of the numbers used in
                        \ Elite - to use our notation for multi-byte numbers,
                        \ the amount of cash is CASH(0 1 2 3)

.QQ14

 SKIP 1                 \ Our current fuel level (0-70)
                        \
                        \ The fuel level is stored as the number of light years
                        \ multiplied by 10, so QQ14 = 1 represents 0.1 light
                        \ years, and the maximum possible value is 70, for 7.0
                        \ light years

.COK

 SKIP 1                 \ Flags used to generate the competition code
                        \
                        \ See the deep dive on "The competition code" for
                        \ details of these flags and how they are used in
                        \ generating and decoding the competition code

.GCNT

 SKIP 1                 \ The number of the current galaxy (0-7)
                        \
                        \ When this is displayed in-game, 1 is added to the
                        \ number, so we start in galaxy 1 in-game, but it's
                        \ stored as galaxy 0 internally
                        \
                        \ The galaxy number increases by one every time a
                        \ galactic hyperdrive is used, and wraps back around to
                        \ the start after eight galaxies

.LASER

 SKIP 4                 \ The specifications of the lasers fitted to each of the
                        \ four space views:
                        \
                        \   * Byte #0 = front view (red key f0)
                        \   * Byte #1 = rear view (red key f1)
                        \   * Byte #2 = left view (red key f2)
                        \   * Byte #3 = right view (red key f3)
                        \
                        \ For each of the views:
                        \
                        \   * 0 = no laser is fitted to this view
                        \
                        \   * Non-zero = a laser is fitted to this view, with
                        \     the following specification:
                        \
                        \     * Bits 0-6 contain the laser's power
                        \
                        \     * Bit 7 determines whether or not the laser pulses
                        \       (0 = pulse or mining laser) or is always on
                        \       (1 = beam or military laser)

 SKIP 1                 \ This byte appears to be unused

.cmdr_type

 SKIP 1                 \ The type of our current ship

.CRGO

 SKIP 1                 \ I.F.F. system
                        \
                        \   * 0 = not fitted
                        \
                        \   * &FF = fitted
                        \
                        \ Elite-A doesn't sell the large cargo bay as you can
                        \ buy different ships with different capacities, so we
                        \ reuse the CRGO variable to determine whether an I.F.F.
                        \ system is fitted

.QQ20

 SKIP 17                \ The contents of our cargo hold
                        \
                        \ The amount of market item X that we have in our hold
                        \ can be found in the X-th byte of QQ20. For example:
                        \
                        \   * QQ20 contains the amount of food (item 0)
                        \
                        \   * QQ20+7 contains the amount of computers (item 7)
                        \
                        \ See QQ23 for a list of market item numbers and their
                        \ storage units

.ECM

 SKIP 1                 \ E.C.M. system
                        \
                        \   * 0 = not fitted
                        \
                        \   * &FF = fitted

.BST

 SKIP 1                 \ Fuel scoops (BST stands for "barrel status")
                        \
                        \   * 0 = not fitted
                        \
                        \   * &FF = fitted

.BOMB

 SKIP 1                 \ Hyperspace unit
                        \
                        \   * 0 = not fitted
                        \
                        \   * &FF = fitted
                        \
                        \ Elite-A replaces the energy bomb with the hyperspace
                        \ unit, reusing the BOMB variable to determine whether
                        \ one is fitted

.ENGY

 SKIP 1                 \ Energy unit
                        \
                        \   * 0 = not fitted
                        \
                        \   * Non-zero = fitted
                        \
                        \ The actual value determines the refresh rate of our
                        \ energy banks, as they refresh by ENGY+1 each time (so
                        \ our ship's energy level goes up by 2 each time if we
                        \ have an energy unit fitted, otherwise it goes up by 1)
                        \
                        \ In Elite-A, the value of ENGY depends on the ship type
                        \ so some ships recharge faster than others

.DKCMP

 SKIP 1                 \ Docking computer
                        \
                        \   * 0 = not fitted
                        \
                        \   * &FF = fitted

.GHYP

 SKIP 1                 \ Galactic hyperdrive
                        \
                        \   * 0 = not fitted
                        \
                        \   * &FF = fitted

.ESCP

 SKIP 1                 \ Escape pod
                        \
                        \   * 0 = not fitted
                        \
                        \   * &FF = fitted

.cmdr_cour

 SKIP 2                 \ The mission reward for the current special cargo
                        \ delivery destination
                        \
                        \ While doing a special cargo delivery, the reward is
                        \ halved on every visit to a station (and again if we
                        \ choose to pay a docking fee), and if it runs down to
                        \ zero, the mission is lost

.cmdr_courx

 SKIP 1                 \ The galactic x-coordinate for the current special
                        \ cargo delivery destination

.cmdr_coury

 SKIP 1                 \ The galactic y-coordinate for the current special
                        \ cargo delivery destination

.NOMSL

 SKIP 1                 \ The number of missiles we have fitted (0-4)

.FIST

 SKIP 1                 \ Our legal status (FIST stands for "fugitive/innocent
                        \ status"):
                        \
                        \   * 0 = Clean
                        \
                        \   * 1-49 = Offender
                        \
                        \   * 50+ = Fugitive
                        \
                        \ You get 64 points if you kill a cop, so that's a fast
                        \ ticket to fugitive status

.AVL

 SKIP 17                \ Market availability in the current system
                        \
                        \ The available amount of market item X is stored in
                        \ the X-th byte of AVL, so for example:
                        \
                        \   * AVL contains the amount of food (item 0)
                        \
                        \   * AVL+7 contains the amount of computers (item 7)
                        \
                        \ See QQ23 for a list of market item numbers and their
                        \ storage units, and the deep dive on "Market item
                        \ prices and availability" for details of the algorithm
                        \ used for calculating each item's availability

.QQ26

 SKIP 1                 \ A random value used to randomise market data
                        \
                        \ This value is set to a new random number for each
                        \ change of system, so we can add a random factor into
                        \ the calculations for market prices (for details of how
                        \ this is used, see the deep dive on "Market prices")

.TALLY

 SKIP 2                 \ Our combat rank
                        \
                        \ The combat rank is stored as the number of kills, in a
                        \ 16-bit number TALLY(1 0) - so the high byte is in
                        \ TALLY+1 and the low byte in TALLY
                        \
                        \ If the high byte in TALLY+1 is 0 then we have between
                        \ 0 and 255 kills, so our rank is Harmless, Mostly
                        \ Harmless, Poor, Average or Above Average, according to
                        \ the value of the low byte in TALLY:
                        \
                        \   Harmless        = %00000000 to %00000011 = 0 to 3
                        \   Mostly Harmless = %00000100 to %00000111 = 4 to 7
                        \   Poor            = %00001000 to %00001111 = 8 to 15
                        \   Average         = %00010000 to %00011111 = 16 to 31
                        \   Above Average   = %00100000 to %11111111 = 32 to 255
                        \
                        \ If the high byte in TALLY+1 is non-zero then we are
                        \ Competent, Dangerous, Deadly or Elite, according to
                        \ the high byte in TALLY+1:
                        \
                        \   Competent       = 1           = 256 to 511 kills
                        \   Dangerous       = 2 to 9      = 512 to 2559 kills
                        \   Deadly          = 10 to 24    = 2560 to 6399 kills
                        \   Elite           = 25 and up   = 6400 kills and up
                        \
                        \ You can see the rating calculation in STATUS

.SVC

 SKIP 1                 \ The save count
                        \
                        \ When a new commander is created, the save count gets
                        \ set to 128. This value gets halved each time the
                        \ commander file is saved, but it is otherwise unused.
                        \ It is presumably part of the security system for the
                        \ competition, possibly another flag to catch out
                        \ entries with manually altered commander files

 SKIP 2                 \ The commander file checksum
                        \
                        \ These two bytes are reserved for the commander file
                        \ checksum, so when the current commander block is
                        \ copied from here to the last saved commander block at
                        \ NA%, CHK and CHK2 get overwritten

 NT% = SVC + 2 - TP     \ This sets the variable NT% to the size of the current
                        \ commander data block, which starts at TP and ends at
                        \ SVC+2 (inclusive)

.MCH

 SKIP 1                 \ The text token number of the in-flight message that is
                        \ currently being shown, and which will be removed by
                        \ the me2 routine when the counter in DLY reaches zero

.FSH

 SKIP 1                 \ Forward shield status
                        \
                        \   * 0 = empty
                        \
                        \   * &FF = full

.ASH

 SKIP 1                 \ Aft shield status
                        \
                        \   * 0 = empty
                        \
                        \   * &FF = full

.ENERGY

 SKIP 1                 \ Energy bank status
                        \
                        \   * 0 = empty
                        \
                        \   * &FF = full

.COMX

 SKIP 1                 \ The x-coordinate of the compass dot

.COMY

 SKIP 1                 \ The y-coordinate of the compass dot

.QQ24

 SKIP 1                 \ Temporary storage, used to store the current market
                        \ item's price in routine TT151

.QQ25

 SKIP 1                 \ Temporary storage, used to store the current market
                        \ item's availability in routine TT151

.QQ28

 SKIP 1                 \ The current system's economy (0-7)
                        \
                        \   * 0 = Rich Industrial
                        \   * 1 = Average Industrial
                        \   * 2 = Poor Industrial
                        \   * 3 = Mainly Industrial
                        \   * 4 = Mainly Agricultural
                        \   * 5 = Rich Agricultural
                        \   * 6 = Average Agricultural
                        \   * 7 = Poor Agricultural
                        \
                        \ See the deep dive on "Generating system data" for more
                        \ information on economies

.QQ29

 SKIP 1                 \ Temporary storage, used in a number of places

.gov

 SKIP 1                 \ The current system's government type (0-7)
                        \
                        \ See the deep dive on "Generating system data" for
                        \ details of the various government types

.tek

 SKIP 1                 \ The current system's tech level (0-14)
                        \
                        \ See the deep dive on "Generating system data" for more
                        \ information on tech levels

.SLSP

 SKIP 2                 \ The address of the bottom of the ship line heap
                        \
                        \ The ship line heap is a descending block of memory
                        \ that starts at WP and descends down to SLSP. It can be
                        \ extended downwards by the NWSHP routine when adding
                        \ new ships (and their associated ship line heaps), in
                        \ which case SLSP is lowered to provide more heap space,
                        \ assuming there is enough free memory to do so

.QQ2

 SKIP 6                 \ The three 16-bit seeds for the current system, i.e.
                        \ the one we are currently in
                        \
                        \ See the deep dives on "Galaxy and system seeds" and
                        \ "Twisting the system seeds" for more details

.QQ3

 SKIP 1                 \ The selected system's economy (0-7)
                        \
                        \   * 0 = Rich Industrial
                        \   * 1 = Average Industrial
                        \   * 2 = Poor Industrial
                        \   * 3 = Mainly Industrial
                        \   * 4 = Mainly Agricultural
                        \   * 5 = Rich Agricultural
                        \   * 6 = Average Agricultural
                        \   * 7 = Poor Agricultural
                        \
                        \ See the deep dive on "Generating system data" for more
                        \ information on economies

.QQ4

 SKIP 1                 \ The selected system's government (0-7)
                        \
                        \ See the deep dive on "Generating system data" for more
                        \ details of the various government types

.QQ5

 SKIP 1                 \ The selected system's tech level (0-14)
                        \
                        \ See the deep dive on "Generating system data" for more
                        \ information on tech levels

.QQ6

 SKIP 2                 \ The selected system's population in billions * 10
                        \ (1-71), so the maximum population is 7.1 billion
                        \
                        \ See the deep dive on "Generating system data" for more
                        \ details on population levels

.QQ7

 SKIP 2                 \ The selected system's productivity in M CR (96-62480)
                        \
                        \ See the deep dive on "Generating system data" for more
                        \ details about productivity levels

.QQ8

 SKIP 2                 \ The distance from the current system to the selected
                        \ system in light years * 10, stored as a 16-bit number
                        \
                        \ The distance will be 0 if the selected system is the
                        \ current system
                        \
                        \ The galaxy chart is 102.4 light years wide and 51.2
                        \ light years tall (see the intra-system distance
                        \ calculations in routine TT111 for details), which
                        \ equates to 1024 x 512 in terms of QQ8

.QQ9

 SKIP 1                 \ The galactic x-coordinate of the crosshairs in the
                        \ galaxy chart (and, most of the time, the selected
                        \ system's galactic x-coordinate)

.QQ10

 SKIP 1                 \ The galactic y-coordinate of the crosshairs in the
                        \ galaxy chart (and, most of the time, the selected
                        \ system's galactic y-coordinate)

.NOSTM

 SKIP 1                 \ The number of stardust particles shown on screen,
                        \ which is 18 (#NOST) for normal space, and 3 for
                        \ witchspace

 SKIP 1                 \ This byte appears to be unused

.COMC

 SKIP 1                 \ The colour of the dot on the compass
                        \
                        \   * &F0 = the object in the compass is in front of us,
                        \     so the dot is yellow/white
                        \
                        \   * &FF = the object in the compass is behind us, so
                        \     the dot is green/cyan

.DNOIZ

 SKIP 1                 \ Sound on/off configuration setting
                        \
                        \   * 0 = sound is on (default)
                        \
                        \   * Non-zero = sound is off
                        \
                        \ Toggled by pressing "S" when paused, see the DK4
                        \ routine for details

.DAMP

 SKIP 1                 \ Keyboard damping configuration setting
                        \
                        \   * 0 = damping is enabled (default)
                        \
                        \   * &FF = damping is disabled
                        \
                        \ Toggled by pressing CAPS LOCK when paused, see the
                        \ DKS3 routine for details

.DJD

 SKIP 1                 \ Keyboard auto-recentre configuration setting
                        \
                        \   * 0 = auto-recentre is enabled (default)
                        \
                        \   * &FF = auto-recentre is disabled
                        \
                        \ Toggled by pressing "A" when paused, see the DKS3
                        \ routine for details

.PATG

 SKIP 1                 \ Configuration setting to show the author names on the
                        \ start-up screen and enable manual hyperspace mis-jumps
                        \
                        \   * 0 = no author names or manual mis-jumps (default)
                        \
                        \   * &FF = show author names and allow manual mis-jumps
                        \
                        \ Toggled by pressing "X" when paused, see the DKS3
                        \ routine for details
                        \
                        \ This needs to be turned on for manual mis-jumps to be
                        \ possible. To do a manual mis-jump, first toggle the
                        \ author display by pausing the game (COPY) and pressing
                        \ "X", and during the next hyperspace, hold down CTRL to
                        \ force a mis-jump. See routine ee5 for the "AND PATG"
                        \ instruction that implements this logic

.FLH

 SKIP 1                 \ Flashing console bars configuration setting
                        \
                        \   * 0 = static bars (default)
                        \
                        \   * &FF = flashing bars
                        \
                        \ Toggled by pressing "F" when paused, see the DKS3
                        \ routine for details

.JSTGY

 SKIP 1                 \ Reverse joystick Y-channel configuration setting
                        \
                        \   * 0 = standard Y-channel (default)
                        \
                        \   * &FF = reversed Y-channel
                        \
                        \ Toggled by pressing "Y" when paused, see the DKS3
                        \ routine for details

.JSTE

 SKIP 1                 \ Reverse both joystick channels configuration setting
                        \
                        \   * 0 = standard channels (default)
                        \
                        \   * &FF = reversed channels
                        \
                        \ Toggled by pressing "J" when paused, see the DKS3
                        \ routine for details

.JSTK

 SKIP 1                 \ Keyboard or joystick configuration setting
                        \
                        \   * 0 = keyboard (default)
                        \
                        \   * &FF = joystick
                        \
                        \ Toggled by pressing "K" when paused, see the DKS3
                        \ routine for details

.BSTK

 SKIP 1                 \ Delta 14B joystick configuration setting
                        \
                        \   * 127 = keyboard
                        \
                        \   * 128 = Delta 14B joystick
                        \
                        \ Elite-A doesn't support the Bitstik, but instead it
                        \ supports the multi-button Voltmace Delta 14B joystick,
                        \ reusing the BSTK variable to determine whether it is
                        \ configured

.CATF

 SKIP 1                 \ The disc catalogue flag
                        \
                        \ Determines whether a disc catalogue is currently in
                        \ progress, so the TT26 print routine can format the
                        \ output correctly:
                        \
                        \   * 0 = disc is not currently being catalogued
                        \
                        \   * 1 = disc is currently being catalogued
                        \
                        \ Specifically, when CATF is non-zero, TT26 will omit
                        \ column 17 from the catalogue so that it will fit
                        \ on-screen (column 17 is blank column in the middle
                        \ of the catalogue, between the two lists of filenames,
                        \ so it can be dropped without affecting the layout)

.new_pulse

 SKIP 1                 \ The power level of pulse lasers when fitted to our
                        \ current ship type
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_beam

 SKIP 1                 \ The power level of beam lasers when fitted to our
                        \ current ship type
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_military

 SKIP 1                 \ The power level of military lasers when fitted to our
                        \ current ship type
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_mining

 SKIP 1                 \ The power level of mining lasers when fitted to our
                        \ current ship type
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_mounts

 SKIP 1                 \ The available laser mounts in our current ship
                        \
                        \   * 1 = Front only
                        \   * 2 = Front and rear
                        \   * 4 = Front, rear, left and right
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_missiles

 SKIP 1                 \ The maximum number of missiles that can be fitted to
                        \ our current ship
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_shields

 SKIP 1                 \ Our current ship's shield level
                        \
                        \ If our ship is damaged and the level of damage is less
                        \ than our shield level, then the ship emerges unscathed
                        \
                        \ If the damage level is greater than the shield level,
                        \ then the damage level is reduced by the shield level
                        \ before being applied to the ship (i.e. the shields
                        \ absorb the amount of damage given in new_shields)
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_energy

 SKIP 1                 \ Our current ship's ship energy refresh rate when
                        \ fitted with an energy unit
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_speed

 SKIP 1                 \ Our current ship's maximum speed
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_hold

 SKIP 1                 \ The amount of free space in our current ship's hold
                        \
                        \ The value is actually the amount of free space plus 1,
                        \ as this makes the maths slightly easier in the tnpr
                        \ routine
                        \
                        \ In Elite-A, hold space is taken up by both equipment
                        \ and cargo
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_range

 SKIP 1                 \ Our current ship's hyperspace range (i.e. the size of
                        \ the fuel tank)
                        \
                        \ The range is stored as the number of light years
                        \ multiplied by 10, so a value of 1 represents 0.1 light
                        \ years, while 70 represents 7.0 light years
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_costs

 SKIP 1                 \ The price table offset for our current ship
                        \
                        \ In Elite-A the PRXS table (which contains equipment
                        \ prices) has multiple sections, for the different types
                        \ of ship we can buy, and the offset into this table for
                        \ our current ship is held here
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_max

 SKIP 1                 \ Our current ship's maximum pitch/roll rate
                        \
                        \ When we buy a new ship, this is set to the relevant
                        \ value from the ship's flight characteristics table
                        \ at new_details

.new_min

 SKIP 1                 \ Our current ship's minimum pitch/roll rate
                        \
                        \ This is always equal to 255 - new_max, so when we buy
                        \ a new ship, the correct value is calculated rather
                        \ than being fetched from the new_details table (there
                        \ are default values for this in the new_details table,
                        \ though these are commented out)

.new_space

 SKIP 1                 \ This byte appears to be unused
                        \
                        \ It does have a label in the original source, and there
                        \ are default values for it in the new_details table,
                        \ though these are commented out

\ ******************************************************************************
\
\       Name: K%
\       Type: Workspace
\    Address: &0900 to &0D3F
\   Category: Workspaces
\    Summary: Ship data blocks and ship line heaps
\  Deep dive: Ship data blocks
\             The local bubble of universe
\
\ ------------------------------------------------------------------------------
\
\ Contains ship data for all the ships, planets, suns and space stations in our
\ local bubble of universe, along with their corresponding ship line heaps.
\
\ The blocks are pointed to by the lookup table at location UNIV. The first 444
\ bytes of the K% workspace hold ship data on up to 12 ships, with 37 (NI%)
\ bytes per ship, and the ship line heap grows downwards from WP at the end of
\ the K% workspace.
\
\ See the deep dive on "Ship data blocks" for details on ship data blocks, and
\ the deep dive on "The local bubble of universe" for details of how Elite
\ stores the local universe in K%, FRIN and UNIV.
\
\ ******************************************************************************

 ORG &0900

.K%

 SKIP 0                 \ Ship data blocks and ship line heap

\ ******************************************************************************
\
\       Name: WP
\       Type: Workspace
\    Address: &0E00 to &0E3B
\   Category: Workspaces
\    Summary: Variables
\
\ ******************************************************************************

 ORG &0E00

.WP

 SKIP 0                 \ The start of the WP workspace

.LSX

 SKIP 0                 \ LSX is an alias that points to the first byte of the
                        \ sun line heap at LSO
                        \
                        \   * &FF indicates the sun line heap is empty
                        \
                        \   * Otherwise the LSO heap contains the line data for
                        \     the sun

.LSO

 SKIP 1                 \ The ship line heap for the space station (see NWSPS)
                        \ and the sun line heap (see SUN)
                        \
                        \ The spaces can be shared as our local bubble of
                        \ universe can support either the sun or a space
                        \ station, but not both

.BUF

 SKIP 191               \ The line buffer used by DASC to print justified text
                        \
                        \ This buffer shares space with the LSO buffer, which
                        \ works because neither the sun or space station are
                        \ shown at the same time as printing justified text

.LSX2

 SKIP 78                \ The ball line heap for storing x-coordinates (see the
                        \ deep dive on "The ball line heap" for details)

.LSY2

 SKIP 78                \ The ball line heap for storing y-coordinates (see the
                        \ deep dive on "The ball line heap" for details)

.SX

 SKIP NOST + 1          \ This is where we store the x_hi coordinates for all
                        \ the stardust particles

.SXL

 SKIP NOST + 1          \ This is where we store the x_lo coordinates for all
                        \ the stardust particles

.SY

 SKIP NOST + 1          \ This is where we store the y_hi coordinates for all
                        \ the stardust particles

.SYL

 SKIP NOST + 1          \ This is where we store the y_lo coordinates for all
                        \ the stardust particles

.SZ

 SKIP NOST + 1          \ This is where we store the z_hi coordinates for all
                        \ the stardust particles

.SZL

 SKIP NOST + 1          \ This is where we store the z_lo coordinates for all
                        \ the stardust particles

.LASX

 SKIP 1                 \ The x-coordinate of the tip of the laser line

.LASY

 SKIP 1                 \ The y-coordinate of the tip of the laser line

.XX24

 SKIP 1                 \ This byte appears to be unused

.ALTIT

 SKIP 1                 \ Our altitude above the surface of the planet or sun
                        \
                        \   * 255 = we are a long way above the surface
                        \
                        \   * 1-254 = our altitude as the square root of:
                        \
                        \       x_hi^2 + y_hi^2 + z_hi^2 - 6^2
                        \
                        \     where our ship is at the origin, the centre of the
                        \     planet/sun is at (x_hi, y_hi, z_hi), and the
                        \     radius of the planet/sun is 6
                        \
                        \   * 0 = we have crashed into the surface

.CPIR

 SKIP 1                 \ A counter used when spawning pirates, to work our way
                        \ through the list of pirate ship blueprints until we
                        \ find one that has been loaded

 PRINT "WP workspace from  ", ~WP," to ", ~P%

\ ******************************************************************************
\
\ ELITE A FILE
\
\ ******************************************************************************

 CODE% = &1000
 LOAD% = &1000

 ORG CODE%

 LOAD_A% = LOAD%

\ ******************************************************************************
\
\       Name: S1%
\       Type: Variable
\   Category: Save and load
\    Summary: The drive and directory number used when saving or loading a
\             commander file
\  Deep dive: Commander save files
\
\ ------------------------------------------------------------------------------
\
\ The drive part of this string (the "0") is updated with the chosen drive in
\ the GTNMEW routine, but the directory part (the "E") is fixed. The variable
\ is followed directly by the commander file at NA%, which starts with the
\ commander name, so the full string at S1% is in the format ":0.E.JAMESON",
\ which gives the full filename of the commander file.
\
\ ******************************************************************************

.S1%

 EQUS ":0.E."

\ ******************************************************************************
\
\       Name: NA%
\       Type: Variable
\   Category: Save and load
\    Summary: The data block for the last saved commander
\  Deep dive: Commander save files
\             The competition code
\
\ ------------------------------------------------------------------------------
\
\ Contains the last saved commander data, with the name at NA% and the data at
\ NA%+8 onwards. The size of the data block is given in NT% (which also includes
\ the two checksum bytes that follow this block). This block is initially set up
\ with the default commander, which can be maxed out for testing purposes by
\ setting Q% to TRUE.
\
\ The commander's name is stored at NA%, and can be up to 7 characters long
\ (the DFS filename limit). It is terminated with a carriage return character,
\ ASCII 13.
\
\ The offset of each byte within a saved commander file is also shown as #0, #1
\ and so on, so the kill tally, for example, is in bytes #71 and #72 of the
\ saved file. The related variable name from the current commander block is
\ also shown.
\
\ ******************************************************************************

.NA%

 EQUS "NEWCOME"         \ The current commander name, which defaults to NEWCOME
 EQUB 13                \
                        \ The commander name can be up to 7 characters (the DFS
                        \ limit for filenames), and is terminated by a carriage
                        \ return

                        \ NA%+8 is the start of the commander data block
                        \
                        \ This block contains the last saved commander data
                        \ block. As the game is played it uses an identical
                        \ block at location TP to store the current commander
                        \ state, and that block is copied here when the game is
                        \ saved. Conversely, when the game starts up, the block
                        \ here is copied to TP, which restores the last saved
                        \ commander when we die
                        \
                        \ The initial state of this block defines the default
                        \ commander. Q% can be set to TRUE to give the default
                        \ commander lots of credits and equipment

 EQUB 0                 \ TP = Mission status, #0

 EQUB 20                \ QQ0 = Current system X-coordinate (Lave), #1
 EQUB 173               \ QQ1 = Current system Y-coordinate (Lave), #2

 EQUW &5A4A             \ QQ21 = Seed s0 for system 0, galaxy 0 (Tibedied), #3-4
 EQUW &0248             \ QQ21 = Seed s1 for system 0, galaxy 0 (Tibedied), #5-6
 EQUW &B753             \ QQ21 = Seed s2 for system 0, galaxy 0 (Tibedied), #7-8

IF Q%
 EQUD &00CA9A3B         \ CASH = Amount of cash (100,000,000 Cr), #9-12
ELSE
 EQUD &88130000         \ CASH = Amount of cash (500 Cr), #9-12
ENDIF

 EQUB 60 + (15 AND Q%)  \ QQ14 = Fuel level, #13

 EQUB 0                 \ COK = Competition flags, #14

 EQUB 0                 \ GCNT = Galaxy number, 0-7, #15

 EQUB &9C AND Q%        \ LASER = Front laser, #16

 EQUB &9C AND Q%        \ LASER+1 = Rear laser, #17

 EQUB 0                 \ LASER+2 = Left laser, #18

 EQUB 0                 \ LASER+3 = Right laser, #19

 EQUB 0                 \ This byte appears to be unused, #20

 EQUB 8 AND Q%          \ cmdr_type = Type of our current ship, #21

 EQUB Q%                \ CRGO = I.F.F. system, #22

 EQUB 0                 \ QQ20+0  = Amount of food in cargo hold, #23
 EQUB 0                 \ QQ20+1  = Amount of textiles in cargo hold, #24
 EQUB 0                 \ QQ20+2  = Amount of radioactives in cargo hold, #25
 EQUB 0                 \ QQ20+3  = Amount of slaves in cargo hold, #26
 EQUB 0                 \ QQ20+4  = Amount of liquor/Wines in cargo hold, #27
 EQUB 0                 \ QQ20+5  = Amount of luxuries in cargo hold, #28
 EQUB 0                 \ QQ20+6  = Amount of narcotics in cargo hold, #29
 EQUB 0                 \ QQ20+7  = Amount of computers in cargo hold, #30
 EQUB 0                 \ QQ20+8  = Amount of machinery in cargo hold, #31
 EQUB 0                 \ QQ20+9  = Amount of alloys in cargo hold, #32
 EQUB 0                 \ QQ20+10 = Amount of firearms in cargo hold, #33
 EQUB 0                 \ QQ20+11 = Amount of furs in cargo hold, #34
 EQUB 0                 \ QQ20+12 = Amount of minerals in cargo hold, #35
 EQUB 0                 \ QQ20+13 = Amount of gold in cargo hold, #36
 EQUB 0                 \ QQ20+14 = Amount of platinum in cargo hold, #37
 EQUB 0                 \ QQ20+15 = Amount of gem-stones in cargo hold, #38
 EQUB 0                 \ QQ20+16 = Amount of alien items in cargo hold, #39

 EQUB Q%                \ ECM = E.C.M. system, #40

 EQUB Q%                \ BST = Fuel scoops ("barrel status"), #41

 EQUB Q%                \ BOMB = Hyperspace unit, #42

 EQUB Q% AND 1          \ ENGY = Energy/shield level, #43

 EQUB Q%                \ DKCMP = Docking computer, #44

 EQUB Q%                \ GHYP = Galactic hyperdrive, #45

 EQUB Q%                \ ESCP = Escape pod, #46

 EQUW 0                 \ cmdr_cour = Special cargo mission timer, #47

 EQUB 0                 \ cmdr_courx = Special cargo destination x-coord, #49

 EQUB 0                 \ cmdr_coury = Special cargo destination y-coord, #50

 EQUB 0                 \ NOMSL = Number of missiles, #51

 EQUB 0                 \ FIST = Legal status ("fugitive/innocent status"), #52

 EQUB 0                 \ AVL+0  = Market availability of food, #53
 EQUB 15                \ AVL+1  = Market availability of textiles, #54
 EQUB 17                \ AVL+2  = Market availability of radioactives, #55
 EQUB 0                 \ AVL+3  = Market availability of slaves, #56
 EQUB 3                 \ AVL+4  = Market availability of liquor/Wines, #57
 EQUB 28                \ AVL+5  = Market availability of luxuries, #58
 EQUB 14                \ AVL+6  = Market availability of narcotics, #59
 EQUB 0                 \ AVL+7  = Market availability of computers, #60
 EQUB 0                 \ AVL+8  = Market availability of machinery, #61
 EQUB 10                \ AVL+9  = Market availability of alloys, #62
 EQUB 0                 \ AVL+10 = Market availability of firearms, #63
 EQUB 17                \ AVL+11 = Market availability of furs, #64
 EQUB 58                \ AVL+12 = Market availability of minerals, #65
 EQUB 7                 \ AVL+13 = Market availability of gold, #66
 EQUB 9                 \ AVL+14 = Market availability of platinum, #67
 EQUB 8                 \ AVL+15 = Market availability of gem-stones, #68
 EQUB 0                 \ AVL+16 = Market availability of alien items, #69

 EQUB 0                 \ QQ26 = Random byte that changes for each visit to a
                        \ system, for randomising market prices, #70

 EQUW 0                 \ TALLY = Number of kills, #71-72

 EQUB 32                \ SVC = Save count, #73

\ ******************************************************************************
\
\       Name: CHK2
\       Type: Variable
\   Category: Save and load
\    Summary: Second checksum byte for the saved commander data file
\  Deep dive: Commander save files
\             The competition code
\
\ ------------------------------------------------------------------------------
\
\ Second commander checksum byte. If the default commander is changed, a new
\ checksum will be calculated and inserted by the elite-checksum.py script.
\
\ The offset of this byte within a saved commander file is also shown (it's at
\ byte #74).
\
\ ******************************************************************************

.CHK2

 EQUB &58 EOR &A9       \ The checksum value for the default commander, EOR'd
                        \ with &A9 to make it harder to tamper with the checksum
                        \ byte, #74

\ ******************************************************************************
\
\       Name: CHK
\       Type: Variable
\   Category: Save and load
\    Summary: First checksum byte for the saved commander data file
\  Deep dive: Commander save files
\             The competition code
\
\ ------------------------------------------------------------------------------
\
\ Commander checksum byte. If the default commander is changed, a new checksum
\ will be calculated and inserted by the elite-checksum.py script.
\
\ The offset of this byte within a saved commander file is also shown (it's at
\ byte #75).
\
\ ******************************************************************************

.CHK

 EQUB &58               \ The checksum value for the default commander, #75

\ ******************************************************************************
\
\       Name: tube_write
\       Type: Subroutine
\   Category: Tube
\    Summary: As the parasite, send a byte across the Tube to the I/O processor
\  Deep dive: Tube communication in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ Tube communication in Elite-A uses the following protocol:
\
\ Parasite -> I/O processor
\
\   * Uses the FIFO 1 status and data registers to transmit the data
\   * The parasite calls tube_write to send a byte to the I/O processor
\   * The I/O processor calls tube_get to receive that byte from the parasite
\
\ I/O processor -> Parasite
\
\   * Uses the FIFO 2 status and data registers to transmit the data
\   * The I/O processor calls tube_put to send a byte to the parasite
\   * The parasite calls tube_read to receive that byte from the I/O processor
\
\ This routine is called by the parasite to send a byte to the I/O processor.
\
\ The code is identical to Acorn's MOS routine that runs on the parasite to
\ implement OSWRCH across the Tube.
\
\ ******************************************************************************

.tube_write

 BIT tube_r1s           \ Check whether FIFO 1 is available for use, so we can
                        \ use it to transmit a byte to the I/O processor. We do
                        \ this by checking bit 6 of the FIFO 1 status register

 NOP                    \ Pause while the register is checked

 BVC tube_write         \ If FIFO 1 is available for use then bit 6 of the
                        \ status register will be set, so this loops back to
                        \ tube_write until FIFO 1 is available for us to use

 STA tube_r1d           \ FIFO 1 is available for use, so store the value we
                        \ want to transmit in the FIFO 1 data register, so it
                        \ gets sent to the I/O processor

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: tube_read
\       Type: Subroutine
\   Category: Tube
\    Summary: As the parasite, fetch a byte that's been sent over the Tube from
\             the I/O processor
\  Deep dive: Tube communication in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ Tube communication in Elite-A uses the following protocol:
\
\ Parasite -> I/O processor
\
\   * Uses the FIFO 1 status and data registers to transmit the data
\   * The parasite calls tube_write to send a byte to the I/O processor
\   * The I/O processor calls tube_get to receive that byte from the parasite
\
\ I/O processor -> Parasite
\
\   * Uses the FIFO 2 status and data registers to transmit the data
\   * The I/O processor calls tube_put to send a byte to the parasite
\   * The parasite calls tube_read to receive that byte from the I/O processor
\
\ This routine is called by the parasite to receive a byte from the I/O
\ processor.
\
\ The code is identical to Acorn's MOS routine that runs on the parasite to
\ implement OSWRCH across the Tube (except this uses FIFO 2 instead of FIFO 1).
\
\ ******************************************************************************

.tube_read

 BIT tube_r2s           \ Check whether FIFO 2 has received a byte from the I/O
                        \ processor (which it will have sent by calling its own
                        \ tube_put routine). We do this by checking bit 7 of the
                        \ FIFO 2 status register

 NOP                    \ Pause while the register is checked

 BPL tube_read          \ If FIFO 2 has received a byte then bit 7 of the status
                        \ register will be set, so this loops back to tube_read
                        \ until FIFO 2 contains the byte transmitted from the
                        \ I/O processor

 LDA tube_r2d           \ Fetch the transmitted byte by reading the FIFO 2 data
                        \ register into A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DOENTRY
\       Type: Subroutine
\   Category: Flight
\    Summary: Dock at the space station, show the ship hangar and work out any
\             mission progression
\
\ ******************************************************************************

.DOENTRY

 LDA #0                 \ Set dockedp = 0 to indicate we are docked
 STA dockedp

 LDA #&FF               \ Call SCRAM to set save_lock to &FF (i.e. we have just
 JSR SCRAM              \ docked and have unsaved changes) and set the break
                        \ handler

 JSR RES2               \ Reset a number of flight variables and workspaces

 JSR HFS1               \ Show the space station docking tunnel

 JSR HALL               \ Show the ship hangar

 LDY #44                \ Wait for 44/50 of a second (0.88 seconds)
 JSR DELAY

 JSR cour_dock          \ Update the current special cargo delivery mission

 LDA TP                 \ Fetch bits 0 and 1 of TP, and if they are non-zero
 AND #%00000011         \ (i.e. mission 1 is either in progress or has been
 BNE EN1                \ completed), skip to EN1

 LDA TALLY+1            \ If the high byte of TALLY is zero (so we have a combat
 BEQ EN4                \ rank below Competent), jump to EN4 as we are not yet
                        \ good enough to qualify for a mission

 LDA GCNT               \ Fetch the galaxy number into A, and if any of bits 1-7
 LSR A                  \ are set (i.e. A > 1), jump to EN4 as mission 1 can
 BNE EN4                \ only be triggered in the first two galaxies

 JMP BRIEF              \ If we get here, mission 1 hasn't started, we have
                        \ reached a combat rank of Competent, and we are in
                        \ galaxy 0 or 1 (shown in-game as galaxy 1 or 2), so
                        \ it's time to start mission 1 by calling BRIEF

.EN1

                        \ If we get here then mission 1 is either in progress or
                        \ has been completed

 CMP #%00000011         \ If bits 0 and 1 are not both set, then jump to EN2
 BNE EN2

 JMP DEBRIEF            \ Bits 0 and 1 are both set, so mission 1 is both in
                        \ progress and has been completed, which means we have
                        \ only just completed it, so jump to DEBRIEF to end the
                        \ mission get our reward

.EN2

                        \ Mission 1 has been completed, so now to check for
                        \ mission 2

 LDA TP                 \ Extract bits 0-3 of TP into A
 AND #%00001111

 CMP #%00000010         \ If mission 1 is complete and no longer in progress,
 BNE EN3                \ and mission 2 is not yet started, then bits 0-3 of TP
                        \ will be %0010, so this jumps to EN3 if this is not the
                        \ case

 LDA TALLY+1            \ If the high byte of TALLY is < 5 (so we have a combat
 CMP #5                 \ rank that is less than 3/8 of the way from Dangerous
 BCC EN4                \ to Deadly), jump to EN4 as our rank isn't high enough
                        \ for mission 2

 LDA GCNT               \ Fetch the galaxy number into A

 CMP #2                 \ If this is not galaxy 2 (shown in-game as galaxy 3),
 BNE EN4                \ jump to EN4 as we can only start mission 2 in the
                        \ third galaxy

 JMP BRIEF2             \ If we get here, mission 1 is complete and no longer in
                        \ progress, mission 2 hasn't started, we have reached a
                        \ combat rank of 3/8 of the way from Dangerous to
                        \ Deadly, and we are in galaxy 2 (shown in-game as
                        \ galaxy 3), so it's time to start mission 2 by calling
                        \ BRIEF2

.EN3

 CMP #%00000110         \ If mission 1 is complete and no longer in progress,
 BNE EN5                \ and mission 2 has started but we have not yet been
                        \ briefed and picked up the plans, then bits 0-3 of TP
                        \ will be %0110, so this jumps to EN5 if this is not the
                        \ case

 LDA GCNT               \ Fetch the galaxy number into A

 CMP #2                 \ If this is not galaxy 2 (shown in-game as galaxy 3),
 BNE EN4                \ jump to EN4 as we can only start mission 2 in the
                        \ third galaxy

 LDA QQ0                \ Set A = the current system's galactic x-coordinate

 CMP #215               \ If A <> 215 then jump to EN4
 BNE EN4

 LDA QQ1                \ Set A = the current system's galactic y-coordinate

 CMP #84                \ If A <> 84 then jump to EN4
 BNE EN4

 JMP BRIEF3             \ If we get here, mission 1 is complete and no longer in
                        \ progress, mission 2 has started but we have not yet
                        \ picked up the plans, and we have just arrived at
                        \ Ceerdi at galactic coordinates (215, 84), so we jump
                        \ to BRIEF3 to get a mission brief and pick up the plans
                        \ that we need to carry to Birera

.EN5

 CMP #%00001010         \ If mission 1 is complete and no longer in progress,
 BNE EN4                \ and mission 2 has started and we have picked up the
                        \ plans, then bits 0-3 of TP will be %1010, so this
                        \ jumps to EN5 if this is not the case

 LDA GCNT               \ Fetch the galaxy number into A

 CMP #2                 \ If this is not galaxy 2 (shown in-game as galaxy 3),
 BNE EN4                \ jump to EN4 as we can only start mission 2 in the
                        \ third galaxy

 LDA QQ0                \ Set A = the current system's galactic x-coordinate

 CMP #63                \ If A <> 63 then jump to EN4
 BNE EN4

 LDA QQ1                \ Set A = the current system's galactic y-coordinate

 CMP #72                \ If A <> 72 then jump to EN4
 BNE EN4

 JMP DEBRIEF2           \ If we get here, mission 1 is complete and no longer in
                        \ progress, mission 2 has started and we have picked up
                        \ the plans, and we have just arrived at Birera at
                        \ galactic coordinates (63, 72), so we jump to DEBRIEF2
                        \ to end the mission and get our reward

.EN4

 JMP BAY                \ If we get here them we didn't start or any missions,
                        \ so jump to BAY to go to the docking bay (i.e. show the
                        \ Status Mode screen)

\ ******************************************************************************
\
\       Name: SCRAM
\       Type: Subroutine
\   Category: Loader
\    Summary: Set the save_lock variable and break handler
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Set the save_lock flag as follows:
\
\                         * 0 = this is a new game, so there are no unsaved
\                               changes in the commander file
\
\                         * &FF = we just docked, so there are unsaved changes
\                                 in the commander file
\
\ ******************************************************************************

.SCRAM

 STA save_lock          \ Set the save_lock variable to the value in A (which
                        \ will be either 0 or &FF)

                        \ Fall through into BRKBK to set the standard BRKV
                        \ handler for the game and return from the subroutine

\ ******************************************************************************
\
\       Name: BRKBK
\       Type: Subroutine
\   Category: Save and load
\    Summary: Set the standard BRKV handler for the game
\
\ ******************************************************************************

.BRKBK

 LDA #LO(BRBR)          \ Set BRKV to point to the BRBR routine
 STA BRKV
 LDA #HI(BRBR)
 STA BRKV+1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: write_msg3
\       Type: Subroutine
\   Category: Text
\    Summary: Print an extended recursive token from the msg_3 token table
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The recursive token to be printed, in the range 0-255
\
\ Returns:
\
\   A                   A is preserved
\
\   Y                   Y is preserved
\
\   V(1 0)              V(1 0) is preserved
\
\ ******************************************************************************

.write_msg3

 PHA                    \ Store A on the stack, so we can retrieve it later

 TAX                    \ Copy the token number from A into X

 TYA                    \ Store Y on the stack
 PHA

 LDA V                  \ Store V(1 0) on the stack
 PHA
 LDA V+1
 PHA

 LDA #LO(msg_3)         \ Set V to the low byte of msg_3
 STA V

 LDA #HI(msg_3)         \ Set A to the high byte of msg_3

 BNE DTEN               \ Call DTEN to print token number X from the msg_3
                        \ table and restore the values of A, Y and V(1 0) from
                        \ the stack, returning from the subroutine using a tail
                        \ call (this BNE is effectively a JMP as A is never
                        \ zero)

\ ******************************************************************************
\
\       Name: DETOK3
\       Type: Subroutine
\   Category: Text
\    Summary: Print an extended recursive token from the RUTOK token table
\  Deep dive: Extended system descriptions
\             Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The recursive token to be printed, in the range 0-255
\
\ Returns:
\
\   A                   A is preserved
\
\   Y                   Y is preserved
\
\   V(1 0)              V(1 0) is preserved
\
\ ******************************************************************************

.DETOK3

 PHA                    \ Store A on the stack, so we can retrieve it later

 TAX                    \ Copy the token number from A into X

 TYA                    \ Store Y on the stack
 PHA

 LDA V                  \ Store V(1 0) on the stack
 PHA
 LDA V+1
 PHA

 LDA #LO(RUTOK)         \ Set V to the low byte of RUTOK
 STA V

 LDA #HI(RUTOK)         \ Set A to the high byte of RUTOK

 BNE DTEN               \ Call DTEN to print token number X from the RUTOK
                        \ table and restore the values of A, Y and V(1 0) from
                        \ the stack, returning from the subroutine using a tail
                        \ call (this BNE is effectively a JMP as A is never
                        \ zero)

\ ******************************************************************************
\
\       Name: MT27
\       Type: Subroutine
\   Category: Text
\    Summary: Print the captain's name during mission briefings
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine prints the following tokens, depending on the galaxy number:
\
\   * Token 217 ("CURRUTHERS") in galaxy 0
\
\   * Token 218 ("FOSDYKE SMYTHE") in galaxy 1
\
\   * Token 219 ("FORTESQUE") in galaxy 2
\
\ This is used when printing extended token 213 as part of the mission
\ briefings, which looks like this when printed:
\
\   Commander {commander name}, I am Captain {mission captain's name} of Her
\   Majesty's Space Navy
\
\ where {mission captain's name} is replaced by one of the names above.
\
\ ******************************************************************************

.MT27

 LDA #217               \ Set A = 217, so when we fall through into MT28, the
                        \ 217 gets added to the current galaxy number, so the
                        \ extended token that is printed is 217-219 (as this is
                        \ only called in galaxies 0 through 2)

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &DC, or BIT &DCA9, which does nothing apart
                        \ from affect the flags

\ ******************************************************************************
\
\       Name: MT28
\       Type: Subroutine
\   Category: Text
\    Summary: Print the location hint during the mission 1 briefing
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine prints the following tokens, depending on the galaxy number:
\
\   * Token 220 ("WAS LAST SEEN AT {single cap}REESDICE") in galaxy 0
\
\   * Token 221 ("IS BELIEVED TO HAVE JUMPED TO THIS GALAXY") in galaxy 1
\
\ This is used when printing extended token 10 as part of the mission 1
\ briefing, which looks like this when printed:
\
\   It went missing from our ship yard on Xeer five months ago and {mission 1
\   location hint}
\
\ where {mission 1 location hint} is replaced by one of the names above.
\
\ ******************************************************************************

.MT28

 LDA #220               \ Set A = galaxy number in GCNT + 220, which is in the
 CLC                    \ range 220-221, as this is only called in galaxies 0
 ADC GCNT               \ and 1

                        \ Fall through into DETOK to print extended token
                        \ 220-221

\ ******************************************************************************
\
\       Name: DETOK
\       Type: Subroutine
\   Category: Text
\    Summary: Print an extended recursive token from the TKN1 token table
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The recursive token to be printed, in the range 1-255
\
\ Returns:
\
\   A                   A is preserved
\
\   Y                   Y is preserved
\
\   V(1 0)              V(1 0) is preserved
\
\ Other entry points:
\
\   DTEN                Print recursive token number X from the token table
\                       pointed to by (A V), used to print tokens from the RUTOK
\                       table via calls to DETOK3
\
\ ******************************************************************************

.DETOK

 PHA                    \ Store A on the stack, so we can retrieve it later

 TAX                    \ Copy the token number from A into X

 TYA                    \ Store Y on the stack
 PHA

 LDA V                  \ Store V(1 0) on the stack
 PHA
 LDA V+1
 PHA

 LDA #LO(TKN1)          \ Set V to the low byte of TKN1
 STA V

 LDA #HI(TKN1)          \ Set A to the high byte of TKN1, so when we fall
                        \ through into DTEN, V(1 0) gets set to the address of
                        \ the TKN1 token table

.DTEN

 STA V+1                \ Set the high byte of V(1 0) to A, so V(1 0) now points
                        \ to the start of the token table to use

 LDY #0                 \ First, we need to work our way through the table until
                        \ we get to the token that we want to print. Tokens are
                        \ delimited by #VE, and VE EOR VE = 0, so we work our
                        \ way through the table in, counting #VE delimiters
                        \ until we have passed X of them, at which point we jump
                        \ down to DTL2 to do the actual printing. So first, we
                        \ set a counter Y to point to the character offset as we
                        \ scan through the table

.DTL1

 LDA (V),Y              \ Load the character at offset Y in the token table,
                        \ which is the next character from the token table

 BNE DT1                \ If the result is non-zero, then this is a character
                        \ in a token rather than the delimiter (which is #VE),
                        \ so jump to DT1

 DEX                    \ We have just scanned the end of a token, so decrement
                        \ X, which contains the token number we are looking for

 BEQ DTL2               \ If X has now reached zero then we have found the token
                        \ we are looking for, so jump down to DTL2 to print it

.DT1

 INY                    \ Otherwise this isn't the token we are looking for, so
                        \ increment the character pointer

 BNE DTL1               \ If Y hasn't just wrapped around to 0, loop back to
                        \ DTL1 to process the next character

 INC V+1                \ We have just crossed into a new page, so increment
                        \ V+1 so that V points to the start of the new page

 BNE DTL1               \ Jump back to DTL1 to process the next character (this
                        \ BNE is effectively a JMP as V+1 won't reach zero
                        \ before we reach the end of the token table)

.DTL2

 INY                    \ We just detected the delimiter byte before the token
                        \ that we want to print, so increment the character
                        \ pointer to point to the first character of the token,
                        \ rather than the delimiter

 BNE P%+4               \ If Y hasn't just wrapped around to 0, skip the next
                        \ instruction

 INC V+1                \ We have just crossed into a new page, so increment
                        \ V+1 so that V points to the start of the new page

 LDA (V),Y              \ Load the character at offset Y in the token table,
                        \ which is the next character from the token we want to
                        \ print

 BEQ DTEX               \ If the result is zero, then this is the delimiter at
                        \ the end of the token to print (which is #VE), so jump
                        \ to DTEX to return from the subroutine, as we are done
                        \ printing

 JSR DETOK2             \ Otherwise call DETOK2 to print this part of the token

 JMP DTL2               \ Jump back to DTL2 to process the next character

.DTEX

 PLA                    \ Restore V(1 0) from the stack, so it is preserved
 STA V+1                \ through calls to this routine
 PLA
 STA V

 PLA                    \ Restore Y from the stack, so it is preserved through
 TAY                    \ calls to this routine

 PLA                    \ Restore A from the stack, so it is preserved through
                        \ calls to this routine

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DETOK2
\       Type: Subroutine
\   Category: Text
\    Summary: Print an extended text token (1-255)
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The token to be printed (1-255)
\
\ Returns:
\
\   A                   A is preserved
\
\   Y                   Y is preserved
\
\   V(1 0)              V(1 0) is preserved
\
\ Other entry points:
\
\   DTS                 Print a single letter in the correct case
\
\
\   DT3                 Print the jump token given in A (where A is in the range
\                       0 to 31)
\
\   msg_pairs           Print the extended two-letter token in A (where A is in
\                       the range 215 to 255)
\
\ ******************************************************************************

.DETOK2

 CMP #32                \ If A < 32 then this is a jump token, so skip to DT3 to
 BCC DT3                \ process it

 BIT DTW3               \ If bit 7 of DTW3 is clear, then extended tokens are
 BPL DT8                \ enabled, so jump to DT8 to process them

                        \ If we get there then this is not a jump token and
                        \ extended tokens are not enabled, so we can call the
                        \ standard text token routine at TT27 to print the token

 TAX                    \ Copy the token number from A into X

 TYA                    \ Store Y on the stack
 PHA

 LDA V                  \ Store V(1 0) on the stack
 PHA
 LDA V+1
 PHA

 TXA                    \ Copy the token number from X back into A

 JSR TT27               \ Call TT27 to print the text token

 JMP DT7                \ Jump to DT7 to restore V(1 0) and Y from the stack and
                        \ return from the subroutine

.DT8

                        \ If we get here then this is not a jump token and
                        \ extended tokens are enabled

 CMP #'['               \ If A < ASCII "[" (i.e. A <= ASCII "Z", or 90) then
 BCC DTS                \ this is a printable ASCII character, so jump down to
                        \ DTS to print it

 CMP #129               \ If A < 129, so A is in the range 91-128, jump down to
 BCC DT6                \ DT6 to print a randomised token from the MTIN table

 CMP #215               \ If A < 215, so A is in the range 129-214, jump to
 BCC DETOK              \ DETOK as this is a recursive token, returning from the
                        \ subroutine using a tail call

                        \ If we get here then A >= 215, so this is a two-letter
                        \ token from the extended TKN2/QQ16 table

.msg_pairs

 SBC #215               \ Subtract 215 to get a token number in the range 0-12
                        \ (the C flag is set as we passed through the BCC above,
                        \ so this subtraction is correct)

 ASL A                  \ Set A = A * 2, so it can be used as a pointer into the
                        \ two-letter token tables at TKN2 and QQ16

 PHA                    \ Store A on the stack, so we can restore it for the
                        \ second letter below

 TAX                    \ Fetch the first letter of the two-letter token from
 LDA TKN2,X             \ TKN2, which is at TKN2 + X

 JSR DTS                \ Call DTS to print it

 PLA                    \ Restore A from the stack and transfer it into X
 TAX

 LDA TKN2+1,X           \ Fetch the second letter of the two-letter token from
                        \ TKN2, which is at TKN2 + X + 1, and fall through into
                        \ DTS to print it

.DTS

 CMP #'A'               \ If A < ASCII "A", jump to DT9 to print this as ASCII
 BCC DT9

 BIT DTW6               \ If bit 7 of DTW6 is set, then lower case has been
 BMI DT10               \ enabled by jump token 13, {lower case}, so jump to
                        \ DT10 to apply the lower case and single cap masks

 BIT DTW2               \ If bit 7 of DTW2 is set, then we are not currently
 BMI DT5                \ printing a word, so jump to DT5 so we skip the setting
                        \ of lower case in Sentence Case (which we only want to
                        \ do when we are already printing a word)

.DT10

 ORA DTW1               \ Convert the character to lower case if DTW1 is
                        \ %00100000 (i.e. if we are in {sentence case} mode)

.DT5

 AND DTW8               \ Convert the character to upper case if DTW8 is
                        \ %11011111 (i.e. after a {single cap} token)

.DT9

 JMP DASC               \ Jump to DASC to print the ASCII character in A,
                        \ returning from the routine using a tail call

.DT3

                        \ If we get here then the token number in A is in the
                        \ range 1 to 32, so this is a jump token that should
                        \ call the corresponding address in the jump table at
                        \ JMTB

 TAX                    \ Copy the token number from A into X

 TYA                    \ Store Y on the stack
 PHA

 LDA V                  \ Store V(1 0) on the stack
 PHA
 LDA V+1
 PHA

 TXA                    \ Copy the token number from X back into A

 ASL A                  \ Set A = A * 2, so it can be used as a pointer into the
                        \ jump table at JMTB, though because the original range
                        \ of values is 1-32, so the doubled range is 2-64, we
                        \ need to take the offset into the jump table from
                        \ JMTB-2 rather than JMTB

 TAX                    \ Copy the doubled token number from A into X

 LDA JMTB-2,X           \ Set DTM(2 1) to the X-th address from the table at
 STA DTM+1              \ JTM-2, which modifies the JSR DASC instruction at
 LDA JMTB-1,X           \ label DTM below so that it calls the subroutine at the
 STA DTM+2              \ relevant address from the JMTB table

 TXA                    \ Copy the doubled token number from X back into A

 LSR A                  \ Halve A to get the original token number

.DTM

 JSR DASC               \ Call the relevant JMTB subroutine, as this instruction
                        \ will have been modified by the above to point to the
                        \ relevant address

.DT7

 PLA                    \ Restore V(1 0) from the stack, so it is preserved
 STA V+1                \ through calls to this routine
 PLA
 STA V

 PLA                    \ Restore Y from the stack, so it is preserved through
 TAY                    \ calls to this routine

 RTS                    \ Return from the subroutine

.DT6

                        \ If we get here then the token number in A is in the
                        \ range 91-128, which means we print a randomly picked
                        \ token from the token range given in the corresponding
                        \ entry in the MTIN table

 STA SC                 \ Store the token number in SC

 TYA                    \ Store Y on the stack
 PHA

 LDA V                  \ Store V(1 0) on the stack
 PHA
 LDA V+1
 PHA

 JSR DORND              \ Set X to a random number
 TAX

 LDA #0                 \ Set A to 0, so we can build a random number from 0 to
                        \ 4 in A plus the C flag, with each number being equally
                        \ likely

 CPX #51                \ Add 1 to A if X >= 51
 ADC #0

 CPX #102               \ Add 1 to A if X >= 102
 ADC #0

 CPX #153               \ Add 1 to A if X >= 153
 ADC #0

 CPX #204               \ Set the C flag if X >= 204

 LDX SC                 \ Fetch the token number from SC into X, so X is now in
                        \ the range 91-128

 ADC MTIN-91,X          \ Set A = MTIN-91 + token number (91-128) + random (0-4)
                        \       = MTIN + token number (0-37) + random (0-4)

 JSR DETOK              \ Call DETOK to print the extended recursive token in A

 JMP DT7                \ Jump to DT7 to restore V(1 0) and Y from the stack and
                        \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: MT1
\       Type: Subroutine
\   Category: Text
\    Summary: Switch to ALL CAPS when printing extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * DTW1 = %00000000 (do not change case to lower case)
\
\   * DTW6 = %00000000 (lower case is not enabled)
\
\ ******************************************************************************

.MT1

 LDA #%00000000         \ Set A = %00000000, so when we fall through into MT2,
                        \ both DTW1 and DTW6 get set to %00000000

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &20, or BIT &20A9, which does nothing apart
                        \ from affect the flags

\ ******************************************************************************
\
\       Name: MT2
\       Type: Subroutine
\   Category: Text
\    Summary: Switch to Sentence Case when printing extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * DTW1 = %00100000 (apply lower case to the second letter of a word onwards)
\
\   * DTW6 = %00000000 (lower case is not enabled)
\
\ ******************************************************************************

.MT2

 LDA #%00100000         \ Set DTW1 = %00100000
 STA DTW1

 LDA #00000000          \ Set DTW6 = %00000000
 STA DTW6

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MT8
\       Type: Subroutine
\   Category: Text
\    Summary: Tab to column 6 and start a new word when printing extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * XC = 6 (tab to column 6)
\
\   * DTW2 = %11111111 (we are not currently printing a word)
\
\ ******************************************************************************

.MT8

 LDA #6                 \ Move the text cursor to column 6
 STA XC

 LDA #%11111111         \ Set all the bits in DTW2
 STA DTW2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MT9
\       Type: Subroutine
\   Category: Text
\    Summary: Clear the screen and set the current view type to 1
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * XC = 1 (tab to column 1)
\
\ before calling TT66 to clear the screen and set the view type to 1.
\
\ ******************************************************************************

.MT9

 LDA #1                 \ Move the text cursor to column 1
 STA XC

 JMP TT66               \ Jump to TT66 to clear the screen and set the current
                        \ view type to 1, returning from the subroutine using a
                        \ tail call

\ ******************************************************************************
\
\       Name: MT13
\       Type: Subroutine
\   Category: Text
\    Summary: Switch to lower case when printing extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * DTW1 = %00100000 (apply lower case to the second letter of a word onwards)
\
\   * DTW6 = %10000000 (lower case is enabled)
\
\ ******************************************************************************

.MT13

 LDA #%10000000         \ Set DTW6 = %10000000
 STA DTW6

 LDA #%00100000         \ Set DTW1 = %00100000
 STA DTW1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MT6
\       Type: Subroutine
\   Category: Text
\    Summary: Switch to standard tokens in Sentence Case
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * QQ17 = %10000000 (set Sentence Case for standard tokens)
\
\   * DTW3 = %11111111 (print standard tokens)
\
\ Other entry points:
\
\   set_token           Switch to standard tokens, keeping the current case
\
\ ******************************************************************************

.MT6

 LDA #%10000000         \ Set bit 7 of QQ17 to switch standard tokens to
 STA QQ17               \ Sentence Case

.set_token

 LDA #%11111111         \ Set A = %11111111, so when we fall through into MT5,
                        \ DTW3 gets set to %11111111 and calls to DETOK print
                        \ standard tokens

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &00, or BIT &00A9, which does nothing apart
                        \ from affect the flags

\ ******************************************************************************
\
\       Name: MT5
\       Type: Subroutine
\   Category: Text
\    Summary: Switch to extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * DTW3 = %00000000 (print extended tokens)
\
\ ******************************************************************************

.MT5

 LDA #%00000000         \ Set DTW3 = %00000000, so that calls to DETOK print
 STA DTW3               \ extended tokens

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MT14
\       Type: Subroutine
\   Category: Text
\    Summary: Switch to justified text when printing extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * DTW4 = %10000000 (justify text, print buffer on carriage return)
\
\   * DTW5 = 0 (reset line buffer size)
\
\ ******************************************************************************

.MT14

 LDA #%10000000         \ Set A = %10000000, so when we fall through into MT15,
                        \ DTW4 gets set to %10000000

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &00, or BIT &00A9, which does nothing apart
                        \ from affect the flags

\ ******************************************************************************
\
\       Name: MT15
\       Type: Subroutine
\   Category: Text
\    Summary: Switch to left-aligned text when printing extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * DTW4 = %00000000 (do not justify text, print buffer on carriage return)
\
\   * DTW5 = 0 (reset line buffer size)
\
\ ******************************************************************************

.MT15

 LDA #0                 \ Set DTW4 = %00000000
 STA DTW4

 ASL A                  \ Set DTW5 = 0 (even when we fall through from MT14 with
 STA DTW5               \ A set to %10000000)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MT17
\       Type: Subroutine
\   Category: Text
\    Summary: Print the selected system's adjective, e.g. Lavian for Lave
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ The adjective for the current system is generated by taking the system name,
\ removing the last character if it is a vowel, and adding "-ian" to the end,
\ so:
\
\   * Lave gives Lavian (as in "Lavian tree grub")
\
\   * Leesti gives Leestian (as in "Leestian Evil Juice")
\
\ This routine is called by jump token 17, {system name adjective}, and it can
\ only be used when justified text is being printed - i.e. following jump token
\ 14, {justify} - because the routine needs to use the line buffer to work.
\
\ ******************************************************************************

.MT17

 LDA QQ17               \ Set QQ17 = %10111111 to switch to Sentence Case
 AND #%10111111
 STA QQ17

 LDA #3                 \ Print control code 3 (selected system name) into the
 JSR TT27               \ line buffer

 LDX DTW5               \ Load the last character of the line buffer BUF into A
 LDA BUF-1,X            \ (as DTW5 contains the buffer size, so character DTW5-1
                        \ is the last character in the buffer BUF)

 JSR VOWEL              \ Test whether the character is a vowel, in which case
                        \ this will set the C flag

 BCC MT171              \ If the character is not a vowel, skip the following
                        \ instruction

 DEC DTW5               \ The character is a vowel, so decrement DTW5, which
                        \ removes the last character from the line buffer (i.e.
                        \ it removes the trailing vowel from the system name)

.MT171

 LDA #153               \ Print extended token 153 ("IAN"), returning from the
 JMP DETOK              \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: MT18
\       Type: Subroutine
\   Category: Text
\    Summary: Print a random 1-8 letter word in Sentence Case
\  Deep dive: Extended text tokens
\
\ ******************************************************************************

.MT18

 JSR MT19               \ Call MT19 to capitalise the next letter (i.e. set
                        \ Sentence Case for this word only)

 JSR DORND              \ Set A and X to random numbers and reduce A to a
 AND #3                 \ random number in the range 0-3

 TAY                    \ Copy the random number into Y, so we can use Y as a
                        \ loop counter to print 1-4 words (i.e. Y+1 words)

.MT18L

 JSR DORND              \ Set A and X to random numbers and reduce A to an even
 AND #62                \ random number in the range 0-62 (as bit 0 of 62 is 0)

 TAX                    \ Copy the random number into X, so X contains the table
                        \ offset of a random extended two-letter token from 0-31
                        \ which we can now use to pick a token from the combined
                        \ tables at TKN2+2 and QQ16 (we intentionally exclude
                        \ the first token in TKN2, which contains a newline)

 LDA TKN2+2,X           \ Print the first letter of the token at TKN2+2 + X
 JSR DTS

 LDA TKN2+3,X           \ Print the second letter of the token at TKN2+2 + X
 JSR DTS

 DEY                    \ Decrement the loop counter

 BPL MT18L              \ Loop back to MT18L to print another two-letter token
                        \ until we have printed Y+1 of them

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MT19
\       Type: Subroutine
\   Category: Text
\    Summary: Capitalise the next letter
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * DTW8 = %11011111 (capitalise the next letter)
\
\ ******************************************************************************

.MT19

 LDA #%11011111         \ Set DTW8 = %11011111
 STA DTW8

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: VOWEL
\       Type: Subroutine
\   Category: Text
\    Summary: Test whether a character is a vowel
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The character to be tested
\
\ Returns:
\
\   C flag              The C flag is set if the character is a vowel, otherwise
\                       it is clear
\
\ ******************************************************************************

.VOWEL

 ORA #%00100000         \ Set bit 5 of the character to make it lower case

 CMP #'a'               \ If the letter is a vowel, jump to VRTS to return from
 BEQ VRTS               \ the subroutine with the C flag set (as the CMP will
 CMP #'e'               \ set the C flag if the comparison is equal)
 BEQ VRTS
 CMP #'i'
 BEQ VRTS
 CMP #'o'
 BEQ VRTS
 CMP #'u'
 BEQ VRTS

 CLC                    \ The character is not a vowel, so clear the C flag

.VRTS

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: JMTB
\       Type: Variable
\   Category: Text
\    Summary: The extended token table for jump tokens 1-32 (DETOK)
\  Deep dive: Extended text tokens
\
\ ******************************************************************************

.JMTB

 EQUW MT1               \ Token  1: Switch to ALL CAPS
 EQUW MT2               \ Token  2: Switch to Sentence Case
 EQUW TT27              \ Token  3: Print the selected system name
 EQUW TT27              \ Token  4: Print the commander's name
 EQUW MT5               \ Token  5: Switch to extended tokens
 EQUW MT6               \ Token  6: Switch to standard tokens, in Sentence Case
 EQUW DASC              \ Token  7: Beep
 EQUW MT8               \ Token  8: Tab to column 6
 EQUW MT9               \ Token  9: Clear screen, tab to column 1, view type = 1
 EQUW DASC              \ Token 10: Line feed
 EQUW NLIN4             \ Token 11: Draw box around title (line at pixel row 19)
 EQUW DASC              \ Token 12: Carriage return
 EQUW MT13              \ Token 13: Switch to lower case
 EQUW MT14              \ Token 14: Switch to justified text
 EQUW MT15              \ Token 15: Switch to left-aligned text
 EQUW MT16              \ Token 16: Print the character in DTW7 (drive number)
 EQUW MT17              \ Token 17: Print system name adjective in Sentence Case
 EQUW MT18              \ Token 18: Randomly print 1 to 4 two-letter tokens
 EQUW MT19              \ Token 19: Capitalise first letter of next word only
 EQUW DASC              \ Token 20: Unused
 EQUW CLYNS             \ Token 21: Clear the bottom few lines of the space view
 EQUW PAUSE             \ Token 22: Display ship and wait for key press
 EQUW MT23              \ Token 23: Move to row 10, white text, set lower case
 EQUW PAUSE2            \ Token 24: Wait for a key press
 EQUW BRIS              \ Token 25: Show incoming message screen, wait 2 seconds
 EQUW MT26              \ Token 26: Fetch line input from keyboard (filename)
 EQUW MT27              \ Token 27: Print mission captain's name (217-219)
 EQUW MT28              \ Token 28: Print mission 1 location hint (220-221)
 EQUW MT29              \ Token 29: Column 6, white text, lower case in words
 EQUW DASC              \ Token 30: Unused
 EQUW DASC              \ Token 31: Unused
 EQUW DASC              \ Token 32: Unused

\ ******************************************************************************
\
\       Name: TKN2
\       Type: Variable
\   Category: Text
\    Summary: The extended two-letter token lookup table
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ Two-letter token lookup table for extended tokens 215-227.
\
\ ******************************************************************************

.TKN2

 EQUB 12, 10            \ Token 215 = {crlf}
 EQUS "AB"              \ Token 216
 EQUS "OU"              \ Token 217
 EQUS "SE"              \ Token 218
 EQUS "IT"              \ Token 219
 EQUS "IL"              \ Token 220
 EQUS "ET"              \ Token 221
 EQUS "ST"              \ Token 222
 EQUS "ON"              \ Token 223
 EQUS "LO"              \ Token 224
 EQUS "NU"              \ Token 225
 EQUS "TH"              \ Token 226
 EQUS "NO"              \ Token 227

\ ******************************************************************************
\
\       Name: QQ16
\       Type: Variable
\   Category: Text
\    Summary: The two-letter token lookup table
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ Two-letter token lookup table for tokens 128-159. See the deep dive on
\ "Printing text tokens" for details of how the two-letter token system works.
\
\ ******************************************************************************

.QQ16

 EQUS "AL"              \ Token 128
 EQUS "LE"              \ Token 129
 EQUS "XE"              \ Token 130
 EQUS "GE"              \ Token 131
 EQUS "ZA"              \ Token 132
 EQUS "CE"              \ Token 133
 EQUS "BI"              \ Token 134
 EQUS "SO"              \ Token 135
 EQUS "US"              \ Token 136
 EQUS "ES"              \ Token 137
 EQUS "AR"              \ Token 138
 EQUS "MA"              \ Token 139
 EQUS "IN"              \ Token 140
 EQUS "DI"              \ Token 141
 EQUS "RE"              \ Token 142
 EQUS "A?"              \ Token 143
 EQUS "ER"              \ Token 144
 EQUS "AT"              \ Token 145
 EQUS "EN"              \ Token 146
 EQUS "BE"              \ Token 147
 EQUS "RA"              \ Token 148
 EQUS "LA"              \ Token 149
 EQUS "VE"              \ Token 150
 EQUS "TI"              \ Token 151
 EQUS "ED"              \ Token 152
 EQUS "OR"              \ Token 153
 EQUS "QU"              \ Token 154
 EQUS "AN"              \ Token 155
 EQUS "TE"              \ Token 156
 EQUS "IS"              \ Token 157
 EQUS "RI"              \ Token 158
 EQUS "ON"              \ Token 159

\ ******************************************************************************
\
\       Name: MVEIT (Part 1 of 9)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Tidy the orientation vectors
\  Deep dive: Program flow of the ship-moving routine
\             Scheduling tasks with the main loop counter
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * Tidy the orientation vectors for one of the ship slots
\
\ Arguments:
\
\   INWK                The current ship/planet/sun's data block
\
\   XSAV                The slot number of the current ship/planet/sun
\
\   TYPE                The type of the current ship/planet/sun
\
\ ******************************************************************************

.MVEIT

 LDA INWK+31            \ If bit 5 of ship byte #31 is set, jump to MV3 as the
 AND #%00100000         \ ship is exploding, so we don't need to tidy its
 BNE MV3                \ orientation vectors

 LDA MCNT               \ Fetch the main loop counter

 EOR XSAV               \ Fetch the slot number of the ship we are moving, EOR
 AND #15                \ with the loop counter and apply mod 15 to the result.
 BNE MV3                \ The result will be zero when "counter mod 15" matches
                        \ the slot number, so this makes sure we call TIDY 12
                        \ times every 16 main loop iterations, like this:
                        \
                        \   Iteration 0, tidy the ship in slot 0
                        \   Iteration 1, tidy the ship in slot 1
                        \   Iteration 2, tidy the ship in slot 2
                        \     ...
                        \   Iteration 11, tidy the ship in slot 11
                        \   Iteration 12, do nothing
                        \   Iteration 13, do nothing
                        \   Iteration 14, do nothing
                        \   Iteration 15, do nothing
                        \   Iteration 16, tidy the ship in slot 0
                        \     ...
                        \
                        \ and so on

 JSR TIDY               \ Call TIDY to tidy up the orientation vectors, to
                        \ prevent the ship from getting elongated and out of
                        \ shape due to the imprecise nature of trigonometry
                        \ in assembly language

.MV3

                        \ Fall through into part 7 (parts 2-6 are not required
                        \ when we are docked)

\ ******************************************************************************
\
\       Name: MVEIT (Part 7 of 9)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Rotate ship's orientation vectors by pitch/roll
\  Deep dive: Orientation vectors
\             Pitching and rolling
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * Rotate the ship's orientation vectors according to our pitch and roll
\
\ As with the previous step, this is all about moving the other ships rather
\ than us (even though we are the one doing the moving). So we rotate the
\ current ship's orientation vectors (which defines its orientation in space),
\ by the angles we are "moving" the rest of the sky through (alpha and beta, our
\ roll and pitch), so the ship appears to us to be stationary while we rotate.
\
\ ******************************************************************************

 LDY #9                 \ Apply our pitch and roll rotations to the current
 JSR MVS4               \ ship's nosev vector

 LDY #15                \ Apply our pitch and roll rotations to the current
 JSR MVS4               \ ship's roofv vector

 LDY #21                \ Apply our pitch and roll rotations to the current
 JSR MVS4               \ ship's sidev vector

\ ******************************************************************************
\
\       Name: MVEIT (Part 8 of 9)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Rotate ship about itself by its own pitch/roll
\  Deep dive: Orientation vectors
\             Pitching and rolling by a fixed angle
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * If the ship we are processing is rolling or pitching itself, rotate it and
\     apply damping if required
\
\ ******************************************************************************

 LDA INWK+30            \ Fetch the ship's pitch counter and extract the sign
 AND #%10000000         \ into RAT2
 STA RAT2

 LDA INWK+30            \ Fetch the ship's pitch counter and extract the value
 AND #%01111111         \ without the sign bit into A

 BEQ MV8                \ If the pitch counter is 0, then jump to MV8 to skip
                        \ the following, as the ship is not pitching

 CMP #%01111111         \ If bits 0-6 are set in the pitch counter (i.e. the
                        \ ship's pitch is not damping down), then the C flag
                        \ will be set by this instruction

 SBC #0                 \ Set A = A - 0 - (1 - C), so if we are damping then we
                        \ reduce A by 1, otherwise it is unchanged

 ORA RAT2               \ Change bit 7 of A to the sign we saved in RAT2, so
                        \ the updated pitch counter in A retains its sign

 STA INWK+30            \ Store the updated pitch counter in byte #30

 LDX #15                \ Rotate (roofv_x, nosev_x) by a small angle (pitch)
 LDY #9
 JSR MVS5

 LDX #17                \ Rotate (roofv_y, nosev_y) by a small angle (pitch)
 LDY #11
 JSR MVS5

 LDX #19                \ Rotate (roofv_z, nosev_z) by a small angle (pitch)
 LDY #13
 JSR MVS5

.MV8

 LDA INWK+29            \ Fetch the ship's roll counter and extract the sign
 AND #%10000000         \ into RAT2
 STA RAT2

 LDA INWK+29            \ Fetch the ship's roll counter and extract the value
 AND #%01111111         \ without the sign bit into A

 BEQ MV5                \ If the roll counter is 0, then jump to MV5 to skip the
                        \ following, as the ship is not rolling

 CMP #%01111111         \ If bits 0-6 are set in the roll counter (i.e. the
                        \ ship's roll is not damping down), then the C flag
                        \ will be set by this instruction

 SBC #0                 \ Set A = A - 0 - (1 - C), so if we are damping then we
                        \ reduce A by 1, otherwise it is unchanged

 ORA RAT2               \ Change bit 7 of A to the sign we saved in RAT2, so
                        \ the updated roll counter in A retains its sign

 STA INWK+29            \ Store the updated pitch counter in byte #29

 LDX #15                \ Rotate (roofv_x, sidev_x) by a small angle (roll)
 LDY #21
 JSR MVS5

 LDX #17                \ Rotate (roofv_y, sidev_y) by a small angle (roll)
 LDY #23
 JSR MVS5

 LDX #19                \ Rotate (roofv_z, sidev_z) by a small angle (roll)
 LDY #25
 JSR MVS5

\ ******************************************************************************
\
\       Name: MVEIT (Part 9 of 9)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Redraw on scanner, if it hasn't been destroyed
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * If the ship is exploding or being removed, hide it on the scanner
\
\   * Otherwise redraw the ship on the scanner, now that it's been moved
\
\ ******************************************************************************

.MV5

 BIT dockedp            \ If bit 7 of dockedp is clear, then we are docked, so
 BPL l_noradar          \ jump to l_noradar to return from the subroutine as the
                        \ scanner is not being used

 LDA INWK+31            \ Fetch the ship's exploding/killed state from byte #31

 AND #%10100000         \ If we are exploding or removing this ship then jump to
 BNE MVD1               \ MVD1 to remove it from the scanner permanently

 LDA INWK+31            \ Set bit 4 to keep the ship visible on the scanner
 ORA #%00010000
 STA INWK+31

 JMP SCAN               \ Display the ship on the scanner, returning from the
                        \ subroutine using a tail call

.MVD1

 LDA INWK+31            \ Clear bit 4 to hide the ship on the scanner
 AND #%11101111
 STA INWK+31

.l_noradar

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MVS4
\       Type: Subroutine
\   Category: Moving
\    Summary: Apply pitch and roll to an orientation vector
\  Deep dive: Orientation vectors
\             Pitching and rolling
\
\ ------------------------------------------------------------------------------
\
\ Apply pitch and roll angles alpha and beta to the orientation vector in Y.
\
\ Specifically, this routine rotates a point (x, y, z) around the origin by
\ pitch alpha and roll beta, using the small angle approximation to make the
\ maths easier, and incorporating the Minsky circle algorithm to make the
\ rotation more stable (though more elliptic).
\
\ If that paragraph makes sense to you, then you should probably be writing
\ this commentary! For the rest of us, there's a detailed explanation of all
\ this in the deep dive on "Pitching and rolling".
\
\ Arguments:
\
\   Y                   Determines which of the INWK orientation vectors to
\                       transform:
\
\                         * Y = 9 rotates nosev: (nosev_x, nosev_y, nosev_z)
\
\                         * Y = 15 rotates roofv: (roofv_x, roofv_y, roofv_z)
\
\                         * Y = 21 rotates sidev: (sidev_x, sidev_y, sidev_z)
\
\ ******************************************************************************

.MVS4

 LDA ALPHA              \ Set Q = alpha (the roll angle to rotate through)
 STA Q

 LDX INWK+2,Y           \ Set (S R) = nosev_y
 STX R
 LDX INWK+3,Y
 STX S

 LDX INWK,Y             \ These instructions have no effect as MAD overwrites
 STX P                  \ X and P when called, but they set X = P = nosev_x_lo

 LDA INWK+1,Y           \ Set A = -nosev_x_hi
 EOR #%10000000

 JSR MAD                \ Set (A X) = Q * A + (S R)
 STA INWK+3,Y           \           = alpha * -nosev_x_hi + nosev_y
 STX INWK+2,Y           \
                        \ and store (A X) in nosev_y, so this does:
                        \
                        \ nosev_y = nosev_y - alpha * nosev_x_hi

 STX P                  \ This instruction has no effect as MAD overwrites P,
                        \ but it sets P = nosev_y_lo

 LDX INWK,Y             \ Set (S R) = nosev_x
 STX R
 LDX INWK+1,Y
 STX S

 LDA INWK+3,Y           \ Set A = nosev_y_hi

 JSR MAD                \ Set (A X) = Q * A + (S R)
 STA INWK+1,Y           \           = alpha * nosev_y_hi + nosev_x
 STX INWK,Y             \
                        \ and store (A X) in nosev_x, so this does:
                        \
                        \ nosev_x = nosev_x + alpha * nosev_y_hi

 STX P                  \ This instruction has no effect as MAD overwrites P,
                        \ but it sets P = nosev_x_lo

 LDA BETA               \ Set Q = beta (the pitch angle to rotate through)
 STA Q

 LDX INWK+2,Y           \ Set (S R) = nosev_y
 STX R
 LDX INWK+3,Y
 STX S
 LDX INWK+4,Y

 STX P                  \ This instruction has no effect as MAD overwrites P,
                        \ but it sets P = nosev_y

 LDA INWK+5,Y           \ Set A = -nosev_z_hi
 EOR #%10000000

 JSR MAD                \ Set (A X) = Q * A + (S R)
 STA INWK+3,Y           \           = beta * -nosev_z_hi + nosev_y
 STX INWK+2,Y           \
                        \ and store (A X) in nosev_y, so this does:
                        \
                        \ nosev_y = nosev_y - beta * nosev_z_hi

 STX P                  \ This instruction has no effect as MAD overwrites P,
                        \ but it sets P = nosev_y_lo

 LDX INWK+4,Y           \ Set (S R) = nosev_z
 STX R
 LDX INWK+5,Y
 STX S

 LDA INWK+3,Y           \ Set A = nosev_y_hi

 JSR MAD                \ Set (A X) = Q * A + (S R)
 STA INWK+5,Y           \           = beta * nosev_y_hi + nosev_z
 STX INWK+4,Y           \
                        \ and store (A X) in nosev_z, so this does:
                        \
                        \ nosev_z = nosev_z + beta * nosev_y_hi

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MVS5
\       Type: Subroutine
\   Category: Moving
\    Summary: Apply a 3.6 degree pitch or roll to an orientation vector
\  Deep dive: Orientation vectors
\             Pitching and rolling by a fixed angle
\
\ ------------------------------------------------------------------------------
\
\ Pitch or roll a ship by a small, fixed amount (1/16 radians, or 3.6 degrees),
\ in a specified direction, by rotating the orientation vectors. The vectors to
\ rotate are given in X and Y, and the direction of the rotation is given in
\ RAT2. The calculation is as follows:
\
\   * If the direction is positive:
\
\     X = X * (1 - 1/512) + Y / 16
\     Y = Y * (1 - 1/512) - X / 16
\
\   * If the direction is negative:
\
\     X = X * (1 - 1/512) - Y / 16
\     Y = Y * (1 - 1/512) + X / 16
\
\ So if X = 15 (roofv_x), Y = 21 (sidev_x) and RAT2 is positive, it does this:
\
\   roofv_x = roofv_x * (1 - 1/512)  + sidev_x / 16
\   sidev_x = sidev_x * (1 - 1/512)  - roofv_x / 16
\
\ Arguments:
\
\   X                   The first vector to rotate:
\
\                         * If X = 15, rotate roofv_x
\
\                         * If X = 17, rotate roofv_y
\
\                         * If X = 19, rotate roofv_z
\
\                         * If X = 21, rotate sidev_x
\
\                         * If X = 23, rotate sidev_y
\
\                         * If X = 25, rotate sidev_z
\
\   Y                   The second vector to rotate:
\
\                         * If Y = 9,  rotate nosev_x
\
\                         * If Y = 11, rotate nosev_y
\
\                         * If Y = 13, rotate nosev_z
\
\                         * If Y = 21, rotate sidev_x
\
\                         * If Y = 23, rotate sidev_y
\
\                         * If Y = 25, rotate sidev_z
\
\   RAT2                The direction of the pitch or roll to perform, positive
\                       or negative (i.e. the sign of the roll or pitch counter
\                       in bit 7)
\
\ ******************************************************************************

.MVS5

 LDA INWK+1,X           \ Fetch roofv_x_hi, clear the sign bit, divide by 2 and
 AND #%01111111         \ store in T, so:
 LSR A                  \
 STA T                  \ T = |roofv_x_hi| / 2
                        \   = |roofv_x| / 512
                        \
                        \ The above is true because:
                        \
                        \ |roofv_x| = |roofv_x_hi| * 256 + roofv_x_lo
                        \
                        \ so:
                        \
                        \ |roofv_x| / 512 = |roofv_x_hi| * 256 / 512
                        \                    + roofv_x_lo / 512
                        \                  = |roofv_x_hi| / 2

 LDA INWK,X             \ Now we do the following subtraction:
 SEC                    \
 SBC T                  \ (S R) = (roofv_x_hi roofv_x_lo) - |roofv_x| / 512
 STA R                  \       = (1 - 1/512) * roofv_x
                        \
                        \ by doing the low bytes first

 LDA INWK+1,X           \ And then the high bytes (the high byte of the right
 SBC #0                 \ side of the subtraction being 0)
 STA S

 LDA INWK,Y             \ Set P = nosev_x_lo
 STA P

 LDA INWK+1,Y           \ Fetch the sign of nosev_x_hi (bit 7) and store in T
 AND #%10000000
 STA T

 LDA INWK+1,Y           \ Fetch nosev_x_hi into A and clear the sign bit, so
 AND #%01111111         \ A = |nosev_x_hi|

 LSR A                  \ Set (A P) = (A P) / 16
 ROR P                  \           = |nosev_x_hi nosev_x_lo| / 16
 LSR A                  \           = |nosev_x| / 16
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P

 ORA T                  \ Set the sign of A to the sign in T (i.e. the sign of
                        \ the original nosev_x), so now:
                        \
                        \ (A P) = nosev_x / 16

 EOR RAT2               \ Give it the sign as if we multiplied by the direction
                        \ by the pitch or roll direction

 STX Q                  \ Store the value of X so it can be restored after the
                        \ call to ADD

 JSR ADD                \ (A X) = (A P) + (S R)
                        \       = +/-nosev_x / 16 + (1 - 1/512) * roofv_x

 STA K+1                \ Set K(1 0) = (1 - 1/512) * roofv_x +/- nosev_x / 16
 STX K

 LDX Q                  \ Restore the value of X from before the call to ADD

 LDA INWK+1,Y           \ Fetch nosev_x_hi, clear the sign bit, divide by 2 and
 AND #%01111111         \ store in T, so:
 LSR A                  \
 STA T                  \ T = |nosev_x_hi| / 2
                        \   = |nosev_x| / 512

 LDA INWK,Y             \ Now we do the following subtraction:
 SEC                    \
 SBC T                  \ (S R) = (nosev_x_hi nosev_x_lo) - |nosev_x| / 512
 STA R                  \       = (1 - 1/512) * nosev_x
                        \
                        \ by doing the low bytes first

 LDA INWK+1,Y           \ And then the high bytes (the high byte of the right
 SBC #0                 \ side of the subtraction being 0)
 STA S

 LDA INWK,X             \ Set P = roofv_x_lo
 STA P

 LDA INWK+1,X           \ Fetch the sign of roofv_x_hi (bit 7) and store in T
 AND #%10000000
 STA T

 LDA INWK+1,X           \ Fetch roofv_x_hi into A and clear the sign bit, so
 AND #%01111111         \ A = |roofv_x_hi|

 LSR A                  \ Set (A P) = (A P) / 16
 ROR P                  \           = |roofv_x_hi roofv_x_lo| / 16
 LSR A                  \           = |roofv_x| / 16
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P

 ORA T                  \ Set the sign of A to the opposite sign to T (i.e. the
 EOR #%10000000         \ sign of the original -roofv_x), so now:
                        \
                        \ (A P) = -roofv_x / 16

 EOR RAT2               \ Give it the sign as if we multiplied by the direction
                        \ by the pitch or roll direction

 STX Q                  \ Store the value of X so it can be restored after the
                        \ call to ADD

 JSR ADD                \ (A X) = (A P) + (S R)
                        \       = -/+roofv_x / 16 + (1 - 1/512) * nosev_x

 STA INWK+1,Y           \ Set nosev_x = (1-1/512) * nosev_x -/+ roofv_x / 16
 STX INWK,Y

 LDX Q                  \ Restore the value of X from before the call to ADD

 LDA K                  \ Set roofv_x = K(1 0)
 STA INWK,X             \              = (1-1/512) * roofv_x +/- nosev_x / 16
 LDA K+1
 STA INWK+1,X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\ Save ELTA.bin
\
\ ******************************************************************************

 PRINT "ELITE A"
 PRINT "Assembled at ", ~CODE%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_A%

 PRINT "S.2.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
\SAVE "3-assembled-output/2.ELTA.bin", CODE%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE B FILE
\
\ ******************************************************************************

 CODE_B% = P%
 LOAD_B% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: LL30
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Draw a one-segment line by sending a draw_line command to the I/O
\             processor
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X1                  The screen x-coordinate of the start of the line
\
\   Y1                  The screen y-coordinate of the start of the line
\
\   X2                  The screen x-coordinate of the end of the line
\
\   Y2                  The screen y-coordinate of the end of the line
\
\ ******************************************************************************

.LOIN
.LL30

 LDA #&80               \ Send command &80 to the I/O processor:
 JSR tube_write         \
                        \   draw_line(x1, y1, x2, y2)
                        \
                        \ which will draw a line from (x1, y1) to (x2, y2)

 LDA X1                 \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * x1 = X1

 LDA Y1                 \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * y1 = Y1

 LDA X2                 \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * x2 = X2

 LDA Y2                 \ Send the first parameter to the I/O processor:
 JMP tube_write         \
                        \   * y2 = Y2
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: FLKB
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Flush the keyboard buffer
\
\ ******************************************************************************

.FLKB

 LDA #15                \ Call OSBYTE with A = 15 and Y <> 0 to flush the input
 TAX                    \ buffers (i.e. flush the operating system's keyboard
 JMP OSBYTE             \ buffer) and return from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: NLIN3
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Print a title and draw a horizontal line at row 19 to box it in
\
\ ------------------------------------------------------------------------------
\
\ This routine print a text token at the cursor position and draws a horizontal
\ line at pixel row 19. It is used for the Status Mode screen, the Short-range
\ Chart, the Market Price screen and the Equip Ship screen.
\
\ ******************************************************************************

.NLIN3

 JSR TT27               \ Print the text token in A

                        \ Fall through into NLIN4 to draw a horizontal line at
                        \ pixel row 19

\ ******************************************************************************
\
\       Name: NLIN4
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Draw a horizontal line at pixel row 19 to box in a title
\
\ ------------------------------------------------------------------------------
\
\ This routine is used on the Inventory screen to draw a horizontal line at
\ pixel row 19 to box in the title.
\
\ ******************************************************************************

.NLIN4

 LDA #19                \ Jump to NLIN2 to draw a horizontal line at pixel row
 BNE NLIN2              \ 19, returning from the subroutine with using a tail
                        \ call (this BNE is effectively a JMP as A will never
                        \ be zero)

\ ******************************************************************************
\
\       Name: NLIN
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Draw a horizontal line at pixel row 23 to box in a title
\
\ ------------------------------------------------------------------------------
\
\ Draw a horizontal line at pixel row 23 and move the text cursor down one
\ line.
\
\ ******************************************************************************

.NLIN

 LDA #23                \ Set A = 23 so NLIN2 below draws a horizontal line at
                        \ pixel row 23

 INC YC                 \ Move the text cursor down one line

                        \ Fall through into NLIN2 to draw the horizontal line
                        \ at row 23

\ ******************************************************************************
\
\       Name: NLIN2
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Draw a screen-wide horizontal line at the pixel row in A
\
\ ------------------------------------------------------------------------------
\
\ This draws a line from (2, A) to (254, A), which is almost screen-wide and
\ fits in nicely between the white borders without clashing with it.
\
\ Arguments:
\
\   A                   The pixel row on which to draw the horizontal line
\
\ ******************************************************************************

.NLIN2

 STA Y1                 \ Set Y1 = A

 LDX #2                 \ Set X1 = 2, so (X1, Y1) = (2, A)
 STX X1

 LDX #254               \ Set X2 = 254, so (X2, Y2) = (254, A)
 STX X2

 BNE HLOIN              \ Call HLOIN to draw a horizontal line from (2, A) to
                        \ (254, A) and return from the subroutine (this BNE is
                        \ effectively a JMP as A will never be zero)

\ ******************************************************************************
\
\       Name: HLOIN2
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Remove a line from the sun line heap and draw it on-screen
\
\ ------------------------------------------------------------------------------
\
\ Specifically, this does the following:
\
\   * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
\     centre YY(1 0) and length A to the left and right
\
\   * Set the Y-th byte of the LSO block to 0 (i.e. remove this line from the
\     sun line heap)
\
\   * Draw a horizontal line from (X1, Y) to (X2, Y)
\
\ Arguments:
\
\   YY(1 0)             The x-coordinate of the centre point of the line
\
\   A                   The half-width of the line, i.e. the contents of the
\                       Y-th byte of the sun line heap
\
\   Y                   The number of the entry in the sun line heap (which is
\                       also the y-coordinate of the line)
\
\ Returns:
\
\   Y                   Y is preserved
\
\ ******************************************************************************

.HLOIN2

 JSR EDGES              \ Call EDGES to calculate X1 and X2 for the horizontal
                        \ line centred on YY(1 0) and with half-width A

 STY Y1                 \ Set Y1 = Y

 LDA #0                 \ Set the Y-th byte of the LSO block to 0
 STA LSO,Y

                        \ Fall through into HLOIN to draw a horizontal line from
                        \ (X1, Y) to (X2, Y)

\ ******************************************************************************
\
\       Name: HLOIN
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Draw a horizontal line by sending a draw_hline command to the I/O
\             processor
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X1                  The screen x-coordinate of the start of the line
\
\   X2                  The screen x-coordinate of the end of the line
\
\   Y1                  The screen y-coordinate of the line
\
\ ******************************************************************************

.HLOIN

 LDA #&81               \ Send command &81 to the I/O processor:
 JSR tube_write         \
                        \   draw_hline(x1, y1, x2)
                        \
                        \ which will draw a horizontal line from (x1, y1) to
                        \ (x2, y1)

 LDA X1                 \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * x1 = X1

 LDA Y1                 \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * y1 = Y1

 LDA X2                 \ Send the first parameter to the I/O processor:
 JMP tube_write         \
                        \   * x2 = X2
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PIXEL
\       Type: Subroutine
\   Category: Drawing pixels
\    Summary: Draw a 1-pixel dot, 2-pixel dash or 4-pixel square by sending a
\             draw_pixel command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Draw a point at screen coordinate (X, A) with the point size determined by the
\ distance in ZZ. This applies to the top part of the screen (the monochrome
\ mode 4 portion).
\
\ Arguments:
\
\   X                   The screen x-coordinate of the point to draw
\
\   A                   The screen y-coordinate of the point to draw
\
\   ZZ                  The distance of the point (further away = smaller point)
\
\ ******************************************************************************

.PIXEL

 PHA                    \ Store the y-coordinate on the stack

 LDA #&82               \ Send command &82 to the I/O processor:
 JSR tube_write         \
                        \   draw_pixel(x, y, distance)
                        \
                        \ which will draw a pixel at (x, y) with the size
                        \ determined by the distance

 TXA                    \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * x = X

 PLA                    \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * y = A

 LDA ZZ                 \ Send the third parameter to the I/O processor:
 JMP tube_write         \
                        \   * distance = ZZ
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: BLINE
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Draw a circle segment and add it to the ball line heap
\  Deep dive: The ball line heap
\             Drawing circles
\
\ ------------------------------------------------------------------------------
\
\ Draw a single segment of a circle, adding the point to the ball line heap.
\
\ Arguments:
\
\   CNT                 The number of this segment
\
\   STP                 The step size for the circle
\
\   K6(1 0)             The x-coordinate of the new point on the circle, as
\                       a screen coordinate
\
\   (T X)               The y-coordinate of the new point on the circle, as
\                       an offset from the centre of the circle
\
\   FLAG                Set to &FF for the first call, so it sets up the first
\                       point in the heap but waits until the second call before
\                       drawing anything (as we need two points, i.e. two calls,
\                       before we can draw a line)
\
\   K                   The circle's radius
\
\   K3(1 0)             Pixel x-coordinate of the centre of the circle
\
\   K4(1 0)             Pixel y-coordinate of the centre of the circle
\
\   K5(1 0)             Screen x-coordinate of the previous point added to the
\                       ball line heap (if this is not the first point)
\
\   K5(3 2)             Screen y-coordinate of the previous point added to the
\                       ball line heap (if this is not the first point)
\
\   SWAP                If non-zero, we swap (X1, Y1) and (X2, Y2)
\
\ Returns:
\
\   CNT                 CNT is updated to CNT + STP
\
\   A                   The new value of CNT
\
\   K5(1 0)             Screen x-coordinate of the point that we just added to
\                       the ball line heap
\
\   K5(3 2)             Screen y-coordinate of the point that we just added to
\                       the ball line heap
\
\   FLAG                Set to 0
\
\ ******************************************************************************

.BLINE

 TXA                    \ Set K6(3 2) = (T X) + K4(1 0)
 ADC K4                 \             = y-coord of centre + y-coord of new point
 STA K6+2               \
 LDA K4+1               \ so K6(3 2) now contains the y-coordinate of the new
 ADC T                  \ point on the circle but as a screen coordinate, to go
 STA K6+3               \ along with the screen y-coordinate in K6(1 0)

 LDA FLAG               \ If FLAG = 0, jump down to BL1
 BEQ BL1

 INC FLAG               \ Flag is &FF so this is the first call to BLINE, so
                        \ increment FLAG to set it to 0, as then the next time
                        \ we call BLINE it can draw the first line, from this
                        \ point to the next

.BL5

                        \ The following inserts a &FF marker into the LSY2 line
                        \ heap to indicate that the next call to BLINE should
                        \ store both the (X1, Y1) and (X2, Y2) points. We do
                        \ this on the very first call to BLINE (when FLAG is
                        \ &FF), and on subsequent calls if the segment does not
                        \ fit on-screen, in which case we don't draw or store
                        \ that segment, and we start a new segment with the next
                        \ call to BLINE that does fit on-screen

 LDY LSP                \ If byte LSP-1 of LSY2 = &FF, jump to BL7 to tidy up
 LDA #&FF               \ and return from the subroutine, as the point that has
 CMP LSY2-1,Y           \ been passed to BLINE is the start of a segment, so all
 BEQ BL7                \ we need to do is save the coordinate in K5, without
                        \ moving the pointer in LSP

 STA LSY2,Y             \ Otherwise we just tried to plot a segment but it
                        \ didn't fit on-screen, so put the &FF marker into the
                        \ heap for this point, so the next call to BLINE starts
                        \ a new segment

 INC LSP                \ Increment LSP to point to the next point in the heap

 BNE BL7                \ Jump to BL7 to tidy up and return from the subroutine
                        \ (this BNE is effectively a JMP, as LSP will never be
                        \ zero)

.BL1

 LDA K5                 \ Set XX15 = K5 = x_lo of previous point
 STA XX15

 LDA K5+1               \ Set XX15+1 = K5+1 = x_hi of previous point
 STA XX15+1

 LDA K5+2               \ Set XX15+2 = K5+2 = y_lo of previous point
 STA XX15+2

 LDA K5+3               \ Set XX15+3 = K5+3 = y_hi of previous point
 STA XX15+3

 LDA K6                 \ Set XX15+4 = x_lo of new point
 STA XX15+4

 LDA K6+1               \ Set XX15+5 = x_hi of new point
 STA XX15+5

 LDA K6+2               \ Set XX12 = y_lo of new point
 STA XX12

 LDA K6+3               \ Set XX12+1 = y_hi of new point
 STA XX12+1

 JSR LL145              \ Call LL145 to see if the new line segment needs to be
                        \ clipped to fit on-screen, returning the clipped line's
                        \ end-points in (X1, Y1) and (X2, Y2)

 BCS BL5                \ If the C flag is set then the line is not visible on
                        \ screen anyway, so jump to BL5, to avoid drawing and
                        \ storing this line

 LDA SWAP               \ If SWAP = 0, then we didn't have to swap the line
 BEQ BL9                \ coordinates around during the clipping process, so
                        \ jump to BL9 to skip the following swap

 LDA X1                 \ Otherwise the coordinates were swapped by the call to
 LDY X2                 \ LL145 above, so we swap (X1, Y1) and (X2, Y2) back
 STA X2                 \ again
 STY X1
 LDA Y1
 LDY Y2
 STA Y2
 STY Y1

.BL9

 LDY LSP                \ Set Y = LSP

 LDA LSY2-1,Y           \ If byte LSP-1 of LSY2 is not &FF, jump down to BL8
 CMP #&FF               \ to skip the following (X1, Y1) code
 BNE BL8

                        \ Byte LSP-1 of LSY2 is &FF, which indicates that we
                        \ need to store (X1, Y1) in the heap

 LDA X1                 \ Store X1 in the LSP-th byte of LSX2
 STA LSX2,Y

 LDA Y1                 \ Store Y1 in the LSP-th byte of LSY2
 STA LSY2,Y

 INY                    \ Increment Y to point to the next byte in LSX2/LSY2

.BL8

 LDA X2                 \ Store X2 in the LSP-th byte of LSX2
 STA LSX2,Y

 LDA Y2                 \ Store Y2 in the LSP-th byte of LSX2
 STA LSY2,Y

 INY                    \ Increment Y to point to the next byte in LSX2/LSY2

 STY LSP                \ Update LSP to point to the same as Y

 JSR LOIN               \ Draw a line from (X1, Y1) to (X2, Y2)

 LDA XX13               \ If XX13 is non-zero, jump up to BL5 to add a &FF
 BNE BL5                \ marker to the end of the line heap. XX13 is non-zero
                        \ after the call to the clipping routine LL145 above if
                        \ the end of the line was clipped, meaning the next line
                        \ sent to BLINE can't join onto the end but has to start
                        \ a new segment, and that's what inserting the &FF
                        \ marker does

.BL7

 LDA K6                 \ Copy the data for this step point from K6(3 2 1 0)
 STA K5                 \ into K5(3 2 1 0), for use in the next call to BLINE:
 LDA K6+1               \
 STA K5+1               \   * K5(1 0) = screen x-coordinate of this point
 LDA K6+2               \
 STA K5+2               \   * K5(3 2) = screen y-coordinate of this point
 LDA K6+3               \
 STA K5+3               \ They now become the "previous point" in the next call

 LDA CNT                \ Set CNT = CNT + STP
 CLC
 ADC STP
 STA CNT

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PRXS
\       Type: Variable
\   Category: Equipment
\    Summary: Equipment prices
\
\ ------------------------------------------------------------------------------
\
\ Equipment prices are stored as 10 * the actual value, so we can support prices
\ with fractions of credits (0.1 Cr). This is used for the price of fuel only.
\
\ Different ships have different equipment prices (apart from fuel which is the
\ same price for all ships). Each ship type has an offset that is used when
\ accessing this table; the offset to the price table for our current ship is
\ held in the new_costs variable, and the offset values for all the different
\ ships we can buy are defined in the new_details table.
\
\ ******************************************************************************

.PRXS

 EQUW 1                 \ 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)

                        \ Offset 0 (PRXS+0): Boa, Cobra Mk III, Ghavial, Iguana

 EQUW 250               \ 1  Missile                     25.0 Cr
 EQUW 4000              \ 2  I.F.F. System              400.0 Cr
 EQUW 6000              \ 3  E.C.M. System              600.0 Cr
 EQUW 4000              \ 4  Extra Pulse Lasers         400.0 Cr
 EQUW 10000             \ 5  Extra Beam Lasers         1000.0 Cr
 EQUW 5250              \ 6  Fuel Scoops                525.0 Cr
 EQUW 3000              \ 7  Escape Pod                 300.0 Cr
 EQUW 5500              \ 8  Hyperspace Unit            550.0 Cr
 EQUW 15000             \ 9  Energy Unit               1500.0 Cr
 EQUW 15000             \ 10 Docking Computer          1500.0 Cr
 EQUW 50000             \ 11 Galactic Hyperspace       5000.0 Cr
 EQUW 30000             \ 12 Extra Military Lasers     3000.0 Cr
 EQUW 2500              \ 13 Extra Mining Lasers        250.0 Cr

                        \ Offset 1 (PRXS+26): Adder, Cobra Mk I, Gecko, Python

 EQUW 250               \ 1  Missile                     25.0 Cr
 EQUW 2000              \ 2  I.F.F. System              200.0 Cr
 EQUW 4000              \ 3  E.C.M. System              400.0 Cr
 EQUW 2000              \ 4  Extra Pulse Lasers         200.0 Cr
 EQUW 4500              \ 5  Extra Beam Lasers          450.0 Cr
 EQUW 3750              \ 6  Fuel Scoops                375.0 Cr
 EQUW 2000              \ 7  Escape Pod                 200.0 Cr
 EQUW 3750              \ 8  Hyperspace Unit            375.0 Cr
 EQUW 9000              \ 9  Energy Unit                900.0 Cr
 EQUW 8000              \ 10 Docking Computer           800.0 Cr
 EQUW 30000             \ 11 Galactic Hyperspace       3000.0 Cr
 EQUW 23000             \ 12 Extra Military Lasers     2300.0 Cr
 EQUW 2500              \ 13 Extra Mining Lasers        250.0 Cr

                        \ Offset 2 (PRXS+52): Asp Mk II, Fer-de-Lance

 EQUW 250               \ 1  Missile                     25.0 Cr
 EQUW 4000              \ 2  I.F.F. System              400.0 Cr
 EQUW 5000              \ 3  E.C.M. System              500.0 Cr
 EQUW 5000              \ 4  Extra Pulse Lasers         500.0 Cr
 EQUW 10000             \ 5  Extra Beam Lasers         1000.0 Cr
 EQUW 7000              \ 6  Fuel Scoops                700.0 Cr
 EQUW 6000              \ 7  Escape Pod                 600.0 Cr
 EQUW 4000              \ 8  Hyperspace Unit            400.0 Cr
 EQUW 25000             \ 9  Energy Unit               2500.0 Cr
 EQUW 10000             \ 10 Docking Computer          1000.0 Cr
 EQUW 40000             \ 11 Galactic Hyperspace       4000.0 Cr
 EQUW 50000             \ 12 Extra Military Lasers     5000.0 Cr
 EQUW 2500              \ 13 Extra Mining Lasers        250.0 Cr

                        \ Offset 3 (PRXS+78): Anaconda, Monitor

 EQUW 250               \ 1  Missile                     25.0 Cr
 EQUW 3000              \ 2  I.F.F. System              300.0 Cr
 EQUW 8000              \ 3  E.C.M. System              800.0 Cr
 EQUW 6000              \ 4  Extra Pulse Lasers         600.0 Cr
 EQUW 8000              \ 5  Extra Beam Lasers          800.0 Cr
 EQUW 6500              \ 6  Fuel Scoops                650.0 Cr
 EQUW 4500              \ 7  Escape Pod                 450.0 Cr
 EQUW 8000              \ 8  Hyperspace Unit            800.0 Cr
 EQUW 19000             \ 9  Energy Unit               1900.0 Cr
 EQUW 20000             \ 10 Docking Computer          2000.0 Cr
 EQUW 60000             \ 11 Galactic Hyperspace       6000.0 Cr
 EQUW 25000             \ 12 Extra Military Lasers     2500.0 Cr
 EQUW 2500              \ 13 Extra Mining Lasers        250.0 Cr

                        \ Offset 4 (PRXS+104): Chameleon, Moray, Ophidian

 EQUW 250               \ 1  Missile                     25.0 Cr
 EQUW 1500              \ 2  I.F.F. System              150.0 Cr
 EQUW 3000              \ 3  E.C.M. System              300.0 Cr
 EQUW 3500              \ 4  Extra Pulse Lasers         350.0 Cr
 EQUW 7000              \ 5  Extra Beam Lasers          700.0 Cr
 EQUW 4500              \ 6  Fuel Scoops                450.0 Cr
 EQUW 2500              \ 7  Escape Pod                 250.0 Cr
 EQUW 4500              \ 8  Hyperspace Unit            450.0 Cr
 EQUW 7000              \ 9  Energy Unit                700.0 Cr
 EQUW 7000              \ 10 Docking Computer           700.0 Cr
 EQUW 30000             \ 11 Galactic Hyperspace       3000.0 Cr
 EQUW 19000             \ 12 Extra Military Lasers     1900.0 Cr
 EQUW 2500              \ 13 Extra Mining Lasers        250.0 Cr

\ ******************************************************************************
\
\       Name: STATUS
\       Type: Subroutine
\   Category: Status
\    Summary: Show the Status Mode screen (red key f8)
\  Deep dive: Combat rank
\
\
\ Other entry points:
\
\   sell_equip          Show the Sell Equipment screen, i.e. show a "Sell(Y/N)?"
\                       prompt as we print each item of equipment
\
\ ******************************************************************************

.st4

                        \ We call this from st5 below with the high byte of the
                        \ kill tally in A, which is non-zero, and want to return
                        \ with the following in X, depending on our rating:
                        \
                        \   Competent = 6
                        \   Dangerous = 7
                        \   Deadly    = 8
                        \   Elite     = 9
                        \
                        \ The high bytes of the top tier ratings are as follows,
                        \ so this a relatively simple calculation:
                        \
                        \   Competent       = 1 to 2
                        \   Dangerous       = 2 to 9
                        \   Deadly          = 10 to 24
                        \   Elite           = 25 and up

 LDX #9                 \ Set X to 9 for an Elite rating

 CMP #25                \ If A >= 25, jump to st3 to print out our rating, as we
 BCS st3                \ are Elite

 DEX                    \ Decrement X to 8 for a Deadly rating

 CMP #10                \ If A >= 10, jump to st3 to print out our rating, as we
 BCS st3                \ are Deadly

 DEX                    \ Decrement X to 7 for a Dangerous rating

 CMP #2                 \ If A >= 2, jump to st3 to print out our rating, as we
 BCS st3                \ are Dangerous

 DEX                    \ Decrement X to 6 for a Competent rating

 BNE st3                \ Jump to st3 to print out our rating, as we are
                        \ Competent (this BNE is effectively a JMP as A will
                        \ never be zero)

.STATUS

 LDA #8                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 8 (Status
                        \ Mode screen)

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 LDA #7                 \ Move the text cursor to column 7
 STA XC

 LDA #126               \ Print recursive token 126, which prints the top
 JSR NLIN3              \ four lines of the Status Mode screen:
                        \
                        \         COMMANDER {commander name}
                        \
                        \
                        \   Present System      : {current system name}
                        \   Hyperspace System   : {selected system name}
                        \   Condition           :
                        \
                        \ and draw a horizontal line at pixel row 19 to box
                        \ in the title

 BIT dockedp            \ If bit 7 of dockedp is clear, then we are docked, so
 BPL stat_dock          \ jump to stat_dock to print "Docked" for our ship's
                        \ condition

 LDA #230               \ Otherwise we are in space, so start off by setting A
                        \ to token 70 ("GREEN")

 LDY JUNK               \ Set Y to the number of junk items in our local bubble
                        \ of universe (where junk is asteroids, canisters,
                        \ escape pods and so on)

 LDX FRIN+2,Y           \ The ship slots at FRIN are ordered with the first two
                        \ slots reserved for the planet and sun/space station,
                        \ and then any ships, so if the slot at FRIN+2+Y is not
                        \ empty (i.e. is non-zero), then that means the number
                        \ of non-asteroids in the vicinity is at least 1

 BEQ st6                \ So if X = 0, there are no ships in the vicinity, so
                        \ jump to st6 to print "Green" for our ship's condition

 LDY ENERGY             \ Otherwise we have ships in the vicinity, so we load
                        \ our energy levels into Y

 CPY #128               \ Set the C flag if Y >= 128, so C is set if we have
                        \ more than half of our energy banks charged

 ADC #1                 \ Add 1 + C to A, so if C is not set (i.e. we have low
                        \ energy levels) then A is set to token 231 ("RED"),
                        \ and if C is set (i.e. we have healthy energy levels)
                        \ then A is set to token 232 ("YELLOW")

.st6

 JSR plf                \ Print the text token in A (which contains our ship's
                        \ condition) followed by a newline

 JMP stat_legal         \ Jump to stat_legal to skip the following, as we are
                        \ not docked and have already printed the correct
                        \ in-flight status

.stat_dock

 LDA #205               \ Print extended token 205 ("DOCKED")
 JSR DETOK

 JSR TT67               \ Print a newline

.stat_legal

 LDA #125               \ Print recursive token 125, which prints the next
 JSR spc                \ three lines of the Status Mode screen:
                        \
                        \   Fuel: {fuel level} Light Years
                        \   Cash: {cash} Cr
                        \   Legal Status:
                        \
                        \ followed by a space

 LDA #19                \ Set A to token 133 ("CLEAN")

 LDY FIST               \ Fetch our legal status, and if it is 0, we are clean,
 BEQ st5                \ so jump to st5 to print "Clean"

 CPY #50                \ Set the C flag if Y >= 50, so C is set if we have
                        \ a legal status of 50+ (i.e. we are a fugitive)

 ADC #1                 \ Add 1 + C to A, so if C is not set (i.e. we have a
                        \ legal status between 1 and 49) then A is set to token
                        \ 134 ("OFFENDER"), and if C is set (i.e. we have a
                        \ legal status of 50+) then A is set to token 135
                        \ ("FUGITIVE")

.st5

 JSR plf                \ Print the text token in A (which contains our legal
                        \ status) followed by a newline

 LDA #16                \ Print recursive token 130 ("RATING:") followed by a
 JSR spc                \ space

 LDA TALLY+1            \ Fetch the high byte of the kill tally, and if it is
 BNE st4                \ not zero, then we have more than 256 kills, so jump
                        \ to st4 to work out whether we are Competent,
                        \ Dangerous, Deadly or Elite

                        \ Otherwise we have fewer than 256 kills, so we are one
                        \ of Harmless, Mostly Harmless, Poor, Average or Above
                        \ Average

 TAX                    \ Set X to 0 (as A is 0)

 LDA TALLY              \ Set A = lower byte of tally / 4
 LSR A
 LSR A

.st5L

                        \ We now loop through bits 2 to 7, shifting each of them
                        \ off the end of A until there are no set bits left, and
                        \ incrementing X for each shift, so at the end of the
                        \ process, X contains the position of the leftmost 1 in
                        \ A. Looking at the rank values in TALLY:
                        \
                        \   Harmless        = %00000000 to %00000011
                        \   Mostly Harmless = %00000100 to %00000111
                        \   Poor            = %00001000 to %00001111
                        \   Average         = %00010000 to %00011111
                        \   Above Average   = %00100000 to %11111111
                        \
                        \ we can see that the values returned by this process
                        \ are:
                        \
                        \   Harmless        = 1
                        \   Mostly Harmless = 2
                        \   Poor            = 3
                        \   Average         = 4
                        \   Above Average   = 5

 INX                    \ Increment X for each shift

 LSR A                  \ Shift A to the right

 BNE st5L               \ Keep looping around until A = 0, which means there are
                        \ no set bits left in A

.st3

 TXA                    \ A now contains our rating as a value of 1 to 9, so
                        \ transfer X to A, so we can print it out

 CLC                    \ Print recursive token 135 + A, which will be in the
 ADC #21                \ range 136 ("HARMLESS") to 144 ("---- E L I T E ----")
 JSR plf                \ followed by a newline

 LDA #18                \ Call status_equip with A set to recursive token 132
 JSR status_equip       \ to print the next bit of the Status Mode screen:
                        \
                        \   {current ship type}:
                        \
                        \ followed by a newline and an indent of 8 characters

.sell_equip

 LDA CRGO               \ If we don't have an I.F.F. system fitted (i.e. CRGO is
 BEQ P%+9               \ zero), skip the following three instructions

 LDA #107               \ We do have an I.F.F. system fitted, so print recursive
 LDX #6                 \ token 107 ("I.F.F.SYSTEM"). If this is the Status Mode
 JSR status_equip       \ or Inventory screen, print a newline and an indent of
                        \ 8 characters, or if this is the Sell Equipment screen,
                        \ show and process a sell prompt for the piece of
                        \ equipment at LASER+X = LASER+6 = CRGO before printing
                        \ a newline

 LDA BST                \ If we don't have fuel scoops fitted, skip the
 BEQ P%+9               \ following three instructions

 LDA #111               \ We do have fuel scoops fitted, so print recursive
 LDX #25                \ token 111 ("FUEL SCOOPS"). If this is the Status Mode
 JSR status_equip       \ or Inventory screen, print a newline and an indent of
                        \ 8 characters, or if this is the Sell Equipment screen,
                        \ show and process a sell prompt for the piece of
                        \ equipment at LASER+X = LASER+25 = BST before printing
                        \ a newline

 LDA ECM                \ If we don't have an E.C.M. fitted, skip the following
 BEQ P%+9               \ three instructions

 LDA #108               \ We do have an E.C.M. fitted, so print recursive token
 LDX #24                \ 108 ("E.C.M.SYSTEM"). If this is the Status Mode or
 JSR status_equip       \ Inventory screen, print a newline and an indent of 8
                        \ characters, or if this is the Sell Equipment screen,
                        \ show and process a sell prompt for the piece of
                        \ equipment at LASER+X = LASER+24 = ECM before printing
                        \ a newline

\LDA #113               \ These instructions are commented out in the original
\STA XX4                \ source

 LDX #26                \ Set X = 26 so we now process equipment from LASER+26
                        \ onwards (i.e. BOMB onwards), using X as a counter
                        \ going from LASER+26 (BOMB) to LASER+29 (GHYP)

.stqv

 STX CNT                \ Store the X counter in CNT so we can retrieve it below

\TAY                    \ These instructions are commented out in the original
\LDX FRIN,Y             \ source

 LDY LASER,X            \ Fetch the equipment flag from LASER+X, and if we do
 BEQ P%+9               \ not have that equipment fitted, skip the following
                        \ four instructions to move onto the next piece of
                        \ equipment

 TXA                    \ Set A = X + 87
 CLC                    \
 ADC #87                \ so A is now a token number between 113 ("HYPERSPACE
                        \ UNIT") and 116 ("GALACTIC HYPERSPACE ")

 JSR status_equip       \ Print the recursive token in A. If this is the Status
                        \ Mode or Inventory screen, print a newline and an
                        \ indent of 8 characters, or if this is the Sell
                        \ Equipment screen, show and process a sell prompt for
                        \ the piece of equipment at LASER+X before printing a
                        \ newline

\INC XX4                \ These instructions are commented out in the original
\LDA XX4                \ source
\CMP #117

 LDX CNT                \ Retrieve the X counter from CNT that we stored above

 INX                    \ Increment the loop counter

 CPX #30                \ Loop back to print the next piece of equipment until
 BCC stqv               \ we have done LASER+26 (BOMB) to LASER+29 (GHYP)

 LDX #0                 \ Now to print our ship's lasers, so set a counter in X
                        \ to count through the four views (0 = front, 1 = rear,
                        \ 2 = left, 3 = right)

.st

 STX CNT                \ Store the view number in CNT

 LDY LASER,X            \ Fetch the laser power for view X, and if we do not
 BEQ st1                \ have a laser fitted to that view, jump to st1 to move
                        \ on to the next one

 TXA                    \ Print recursive token 96 + X, which will print from 96
 ORA #96                \ ("FRONT") through to 99 ("RIGHT"), followed by a space
 JSR spc                \ (the ORA acts like an addition as 96 = %01100000)

 LDA #103               \ Set A to token 103 ("PULSE LASER")

 LDX CNT                \ Retrieve the view number from CNT that we stored above

 LDY LASER,X            \ Set Y = the laser power for view X

 CPY new_beam           \ If the laser power for view X is not that of a beam
 BNE P%+4               \ laser when fitted to our current ship type, skip the
                        \ next LDA instruction

 LDA #104               \ This sets A = 104 if the laser in view X is a beam
                        \ laser (token 104 is "BEAM LASER")

 CPY new_military       \ If the laser power for view X is not that of a
 BNE P%+4               \ military laser when fitted to our current ship type,
                        \ skip the next LDA instruction

 LDA #117               \ This sets A = 117 if the laser in view X is a military
                        \ laser (token 117 is "MILITARY  LASER")

 CPY new_mining         \ If the laser power for view X is not that of a mining
 BNE P%+4               \ laser when fitted to our current ship type, skip the
                        \ next LDA instruction

 LDA #118               \ This sets A = 118 if the laser in view X is a mining
                        \ laser (token 118 is "MINING  LASER")

 JSR status_equip       \ Print the recursive token in A. If this is the Status
                        \ Mode or Inventory screen, print a newline and an
                        \ indent of 8 characters, or if this is the Sell
                        \ Equipment screen, show and process a sell prompt for
                        \ the piece of equipment at LASER+X before printing a
                        \ newline

.st1

 LDX CNT                \ Increment the counter in X and CNT to point to the
 INX                    \ next view

 CPX #4                 \ If this isn't the last of the four views, jump back up
 BCC st                 \ to st to print out the next one

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: status_equip
\       Type: Subroutine
\   Category: Text
\    Summary: Print equipment name, adding a sell prompt if appropriate
\
\ ------------------------------------------------------------------------------
\
\ Print a text token containing the equipment name. Then:
\
\   * If this is the Status Mode or Inventory screen, print a newline and move
\     the text cursor to column 8
\
\   * If this is the Sell Equipment screen, show and process a "Sell(Y/N)?"
\     prompt on the end of the same line as the equipment name, and move the
\     text cursor to the start of the next line
\
\ Arguments:
\
\   A                   The text token to be printed
\
\   X                   If this is the Sell Equipment screen, this contains the
\                       offset from LASER where this piece of equipment's flag
\                       is stored (e.g. X = 25 means LASER+25, which is BST,
\                       the flag for the fuel scoops)
\
\ ******************************************************************************

.status_equip

 STX CNT                \ Store the tab indent in CNT, so we can use it later

 STA XX4                \ Store the text token in XX4, so we can use it later

 JSR TT27               \ Print the text token in A

 LDX QQ11               \ If the current view is the Status Mode screen or the
 CPX #8                 \ Inventory screen, jump to status_keep to print a tab
 BEQ status_keep        \ to column 8 (as X = 8) and return from the subroutine,
                        \ as we don't want to show a sell prompt

 LDA #21                \ Move the text cursor to column 21
 STA XC

 JSR vdu_80             \ Call vdu_80 to switch to Sentence Case, with the next
                        \ letter in capitals

 LDA #1                 \ Set QQ25 to 1, which sets the maximum number of items
 STA QQ25               \ we can sell in the following call to sell_yn

 JSR sell_yn            \ Call sell_yn to print a "Sell(Y/N)?" prompt and get a
                        \ number from the keyboard

 BEQ status_no          \ If no number was entered, jump to status_no to move to
                        \ the next line and return from the subroutine

 BCS status_no          \ If the number entered was too big, jump to status_no
                        \ to move to the next line and return from the
                        \ subroutine

 LDA XX4                \ If XX4 >= 107, then the token is a piece of equipment
 CMP #107               \ ("I.F.F.SYSTEM" onwards) rather a laser, so skip the
 BCS status_over        \ following instruction to reach status_over with
                        \ A >= 107 and the C flag set

 ADC #7                 \ The token in A is < 107, so it must be a pulse laser
                        \ (103) or beam laser (104), so add 7 to set A to 110
                        \ or 111 (as we know the C flag is clear), and fall
                        \ through into status_over with the C flag clear

.status_over

                        \ We get here with one of the following:
                        \
                        \   * A >= 107 and the C flag set, if this is not a
                        \     pulse or beam laser
                        \
                        \   * A = 110 or 111 with the C flag clear, if this is a
                        \     pulse or beam laser

 SBC #104               \ Subtract 104 - (1 - C) from the token number, so
                        \ either:
                        \
                        \   * A is now 1 for fuel, 2 for missiles, 3 for the
                        \     I.F.F. system, and so on
                        \
                        \   * A = 5 or 6 for pulse or beam lasers
                        \
                        \ In each case, A contains the equipment number from the
                        \ PRXS table, plus 1

 JSR prx-3              \ Call prx-3 to set (A X) to the price of the item with
                        \ number A - 1

 LSR A                  \ We now halve the price in (A X) and put the result
 TAY                    \ into (Y X), starting with the high byte in A

 TXA                    \ And then halving the low byte in X
 ROR A
 TAX

 JSR MCASH              \ Call MCASH to add (Y X) to the cash pot, so we get
                        \ half of the original price back when selling equipment

 INC new_hold           \ We just sold a piece of equipment, so increment the
                        \ amount of free space in the hold

 LDX CNT                \ Set X to the value we stored in CNT above, so it now
                        \ contains the equipment flag's offset from LASER

 LDA #0                 \ We just sold this piece of equipment, so set the flag
 STA LASER,X            \ to zero to indicate we no longer have the equipment
                        \ fitted

 JSR update_pod         \ Update the dashboard colours to reflect whether we
                        \ have an escape pod

.status_no

 LDX #1                 \ Set X = 1 so we move the text cursor to column 1 in
                        \ in the next instruction

.status_keep

 STX XC                 \ Move the text cursor to the column specified in X

 LDA #10                \ Print a line feed to move the text cursor down a line
 JMP TT27               \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TENS
\       Type: Variable
\   Category: Text
\    Summary: A constant used when printing large numbers in BPRNT
\  Deep dive: Printing decimal numbers
\
\ ------------------------------------------------------------------------------
\
\ Contains the four low bytes of the value 100,000,000,000 (100 billion).
\
\ The maximum number of digits that we can print with the BPRNT routine is 11,
\ so the biggest number we can print is 99,999,999,999. This maximum number
\ plus 1 is 100,000,000,000, which in hexadecimal is:
\
\   & 17 48 76 E8 00
\
\ The TENS variable contains the lowest four bytes in this number, with the
\ most significant byte first, i.e. 48 76 E8 00. This value is used in the
\ BPRNT routine when working out which decimal digits to print when printing a
\ number.
\
\ ******************************************************************************

.TENS

 EQUD &00E87648

\ ******************************************************************************
\
\       Name: pr2
\       Type: Subroutine
\   Category: Text
\    Summary: Print an 8-bit number, left-padded to 3 digits, and optional point
\
\ ------------------------------------------------------------------------------
\
\ Print the 8-bit number in X to 3 digits, left-padding with spaces for numbers
\ with fewer than 3 digits (so numbers < 100 are right-aligned). Optionally
\ include a decimal point.
\
\ Arguments:
\
\   X                   The number to print
\
\   C flag              If set, include a decimal point
\
\ Other entry points:
\
\   pr2+2               Print the 8-bit number in X to the number of digits in A
\
\   pr2-1               Print X without a decimal point
\
\ ******************************************************************************

 CLC                    \ Clear the C flag so the routine doesn't print a
                        \ decimal point if called via pr2-1

.pr2

 LDA #3                 \ Set A to the number of digits (3)

 LDY #0                 \ Zero the Y register, so we can fall through into TT11
                        \ to print the 16-bit number (Y X) to 3 digits, which
                        \ effectively prints X to 3 digits as the high byte is
                        \ zero

\ ******************************************************************************
\
\       Name: TT11
\       Type: Subroutine
\   Category: Text
\    Summary: Print a 16-bit number, left-padded to n digits, and optional point
\
\ ------------------------------------------------------------------------------
\
\ Print the 16-bit number in (Y X) to a specific number of digits, left-padding
\ with spaces for numbers with fewer digits (so lower numbers will be right-
\ aligned). Optionally include a decimal point.
\
\ Arguments:
\
\   X                   The low byte of the number to print
\
\   Y                   The high byte of the number to print
\
\   A                   The number of digits
\
\   C flag              If set, include a decimal point
\
\ ******************************************************************************

.TT11

 STA U                  \ We are going to use the BPRNT routine (below) to
                        \ print this number, so we store the number of digits
                        \ in U, as that's what BPRNT takes as an argument

 LDA #0                 \ BPRNT takes a 32-bit number in K to K+3, with the
 STA K                  \ most significant byte first (big-endian), so we set
 STA K+1                \ the two most significant bytes to zero (K and K+1)
 STY K+2                \ and store (Y X) in the least two significant bytes
 STX K+3                \ (K+2 and K+3), so we are going to print the 32-bit
                        \ number (0 0 Y X)

                        \ Finally we fall through into BPRNT to print out the
                        \ number in K to K+3, which now contains (Y X), to 3
                        \ digits (as U = 3), using the same C flag as when pr2
                        \ was called to control the decimal point

\ ******************************************************************************
\
\       Name: BPRNT
\       Type: Subroutine
\   Category: Text
\    Summary: Print a 32-bit number, left-padded to a specific number of digits,
\             with an optional decimal point
\  Deep dive: Printing decimal numbers
\
\ ------------------------------------------------------------------------------
\
\ Print the 32-bit number stored in K(0 1 2 3) to a specific number of digits,
\ left-padding with spaces for numbers with fewer digits (so lower numbers are
\ right-aligned). Optionally include a decimal point.
\
\ See the deep dive on "Printing decimal numbers" for details of the algorithm
\ used in this routine.
\
\ Arguments:
\
\   K(0 1 2 3)          The number to print, stored with the most significant
\                       byte in K and the least significant in K+3 (i.e. as a
\                       big-endian number, which is the opposite way to how the
\                       6502 assembler stores addresses, for example)
\
\   U                   The maximum number of digits to print, including the
\                       decimal point (spaces will be used on the left to pad
\                       out the result to this width, so the number is right-
\                       aligned to this width). U must be 11 or less
\
\   C flag              If set, include a decimal point followed by one
\                       fractional digit (i.e. show the number to 1 decimal
\                       place). In this case, the number in K(0 1 2 3) contains
\                       10 * the number we end up printing, so to print 123.4,
\                       we would pass 1234 in K(0 1 2 3) and would set the C
\                       flag to include the decimal point
\
\ ******************************************************************************

.BPRNT

 LDX #11                \ Set T to the maximum number of digits allowed (11
 STX T                  \ characters, which is the number of digits in 10
                        \ billion). We will use this as a flag when printing
                        \ characters in TT37 below

 PHP                    \ Make a copy of the status register (in particular
                        \ the C flag) so we can retrieve it later

 BCC TT30               \ If the C flag is clear, we do not want to print a
                        \ decimal point, so skip the next two instructions

 DEC T                  \ As we are going to show a decimal point, decrement
 DEC U                  \ both the number of characters and the number of
                        \ digits (as one of them is now a decimal point)

.TT30

 LDA #11                \ Set A to 11, the maximum number of digits allowed

 SEC                    \ Set the C flag so we can do subtraction without the
                        \ C flag affecting the result

 STA XX17               \ Store the maximum number of digits allowed (11) in
                        \ XX17

 SBC U                  \ Set U = 11 - U + 1, so U now contains the maximum
 STA U                  \ number of digits minus the number of digits we want
 INC U                  \ to display, plus 1 (so this is the number of digits
                        \ we should skip before starting to print the number
                        \ itself, and the plus 1 is there to ensure we print at
                        \ least one digit)

 LDY #0                 \ In the main loop below, we use Y to count the number
                        \ of times we subtract 10 billion to get the leftmost
                        \ digit, so set this to zero

 STY S                  \ In the main loop below, we use location S as an
                        \ 8-bit overflow for the 32-bit calculations, so
                        \ we need to set this to 0 before joining the loop

 JMP TT36               \ Jump to TT36 to start the process of printing this
                        \ number's digits

.TT35

                        \ This subroutine multiplies K(S 0 1 2 3) by 10 and
                        \ stores the result back in K(S 0 1 2 3), using the fact
                        \ that K * 10 = (K * 2) + (K * 2 * 2 * 2)

 ASL K+3                \ Set K(S 0 1 2 3) = K(S 0 1 2 3) * 2 by rotating left
 ROL K+2
 ROL K+1
 ROL K
 ROL S

 LDX #3                 \ Now we want to make a copy of the newly doubled K in
                        \ XX15, so we can use it for the first (K * 2) in the
                        \ equation above, so set up a counter in X for copying
                        \ four bytes, starting with the last byte in memory
                        \ (i.e. the least significant)

.tt35

 LDA K,X                \ Copy the X-th byte of K(0 1 2 3) to the X-th byte of
 STA XX15,X             \ XX15(0 1 2 3), so that XX15 will contain a copy of
                        \ K(0 1 2 3) once we've copied all four bytes

 DEX                    \ Decrement the loop counter

 BPL tt35               \ Loop back to copy the next byte until we have copied
                        \ all four

 LDA S                  \ Store the value of location S, our overflow byte, in
 STA XX15+4             \ XX15+4, so now XX15(4 0 1 2 3) contains a copy of
                        \ K(S 0 1 2 3), which is the value of (K * 2) that we
                        \ want to use in our calculation

 ASL K+3                \ Now to calculate the (K * 2 * 2 * 2) part. We still
 ROL K+2                \ have (K * 2) in K(S 0 1 2 3), so we just need to shift
 ROL K+1                \ it twice. This is the first one, so we do this:
 ROL K                  \
 ROL S                  \   K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 4

 ASL K+3                \ And then we do it again, so that means:
 ROL K+2                \
 ROL K+1                \   K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 8
 ROL K
 ROL S

 CLC                    \ Clear the C flag so we can do addition without the
                        \ C flag affecting the result

 LDX #3                 \ By now we've got (K * 2) in XX15(4 0 1 2 3) and
                        \ (K * 8) in K(S 0 1 2 3), so the final step is to add
                        \ these two 32-bit numbers together to get K * 10.
                        \ So we set a counter in X for four bytes, starting
                        \ with the last byte in memory (i.e. the least
                        \ significant)

.tt36

 LDA K,X                \ Fetch the X-th byte of K into A

 ADC XX15,X             \ Add the X-th byte of XX15 to A, with carry

 STA K,X                \ Store the result in the X-th byte of K

 DEX                    \ Decrement the loop counter

 BPL tt36               \ Loop back to add the next byte, moving from the least
                        \ significant byte to the most significant, until we
                        \ have added all four

 LDA XX15+4             \ Finally, fetch the overflow byte from XX15(4 0 1 2 3)

 ADC S                  \ And add it to the overflow byte from K(S 0 1 2 3),
                        \ with carry

 STA S                  \ And store the result in the overflow byte from
                        \ K(S 0 1 2 3), so now we have our desired result, i.e.
                        \
                        \   K(S 0 1 2 3) = K(S 0 1 2 3) * 10

 LDY #0                 \ In the main loop below, we use Y to count the number
                        \ of times we subtract 10 billion to get the leftmost
                        \ digit, so set this to zero so we can rejoin the main
                        \ loop for another subtraction process

.TT36

                        \ This is the main loop of our digit-printing routine.
                        \ In the following loop, we are going to count the
                        \ number of times that we can subtract 10 million and
                        \ store that count in Y, which we have already set to 0

 LDX #3                 \ Our first calculation concerns 32-bit numbers, so
                        \ set up a counter for a four-byte loop

 SEC                    \ Set the C flag so we can do subtraction without the
                        \ C flag affecting the result

.tt37

                        \ We now loop through each byte in turn to do this:
                        \
                        \   XX15(4 0 1 2 3) = K(S 0 1 2 3) - 100,000,000,000

 LDA K,X                \ Subtract the X-th byte of TENS (i.e. 10 billion) from
 SBC TENS,X             \ the X-th byte of K

 STA XX15,X             \ Store the result in the X-th byte of XX15

 DEX                    \ Decrement the loop counter

 BPL tt37               \ Loop back to subtract the next byte, moving from the
                        \ least significant byte to the most significant, until
                        \ we have subtracted all four

 LDA S                  \ Subtract the fifth byte of 10 billion (i.e. &17) from
 SBC #&17               \ the fifth (overflow) byte of K, which is S

 STA XX15+4             \ Store the result in the overflow byte of XX15

 BCC TT37               \ If subtracting 10 billion took us below zero, jump to
                        \ TT37 to print out this digit, which is now in Y

 LDX #3                 \ We now want to copy XX15(4 0 1 2 3) back into
                        \ K(S 0 1 2 3), so we can loop back up to do the next
                        \ subtraction, so set up a counter for a four-byte loop

.tt38

 LDA XX15,X             \ Copy the X-th byte of XX15(0 1 2 3) to the X-th byte
 STA K,X                \ of K(0 1 2 3), so that K(0 1 2 3) will contain a copy
                        \ of XX15(0 1 2 3) once we've copied all four bytes

 DEX                    \ Decrement the loop counter

 BPL tt38               \ Loop back to copy the next byte, until we have copied
                        \ all four

 LDA XX15+4             \ Store the value of location XX15+4, our overflow
 STA S                  \ byte in S, so now K(S 0 1 2 3) contains a copy of
                        \ XX15(4 0 1 2 3)

 INY                    \ We have now managed to subtract 10 billion from our
                        \ number, so increment Y, which is where we are keeping
                        \ a count of the number of subtractions so far

 JMP TT36               \ Jump back to TT36 to subtract the next 10 billion

.TT37

 TYA                    \ If we get here then Y contains the digit that we want
                        \ to print (as Y has now counted the total number of
                        \ subtractions of 10 billion), so transfer Y into A

 BNE TT32               \ If the digit is non-zero, jump to TT32 to print it

 LDA T                  \ Otherwise the digit is zero. If we are already
                        \ printing the number then we will want to print a 0,
                        \ but if we haven't started printing the number yet,
                        \ then we probably don't, as we don't want to print
                        \ leading zeroes unless this is the only digit before
                        \ the decimal point
                        \
                        \ To help with this, we are going to use T as a flag
                        \ that tells us whether we have already started
                        \ printing digits:
                        \
                        \   * If T <> 0 we haven't printed anything yet
                        \
                        \   * If T = 0 then we have started printing digits
                        \
                        \ We initially set T above to the maximum number of
                        \ characters allowed, less 1 if we are printing a
                        \ decimal point, so the first time we enter the digit
                        \ printing routine at TT37, it is definitely non-zero

 BEQ TT32               \ If T = 0, jump straight to the print routine at TT32,
                        \ as we have already started printing the number, so we
                        \ definitely want to print this digit too

 DEC U                  \ We initially set U to the number of digits we want to
 BPL TT34               \ skip before starting to print the number. If we get
                        \ here then we haven't printed any digits yet, so
                        \ decrement U to see if we have reached the point where
                        \ we should start printing the number, and if not, jump
                        \ to TT34 to set up things for the next digit

 LDA #' '               \ We haven't started printing any digits yet, but we
 BNE tt34               \ have reached the point where we should start printing
                        \ our number, so call TT26 (via tt34) to print a space
                        \ so that the number is left-padded with spaces (this
                        \ BNE is effectively a JMP as A will never be zero)

.TT32

 LDY #0                 \ We are printing an actual digit, so first set T to 0,
 STY T                  \ to denote that we have now started printing digits as
                        \ opposed to spaces

 CLC                    \ The digit value is in A, so add ASCII "0" to get the
 ADC #'0'               \ ASCII character number to print

.tt34

 JSR TT26               \ Call TT26 to print the character in A and fall through
                        \ into TT34 to get things ready for the next digit

.TT34

 DEC T                  \ Decrement T but keep T >= 0 (by incrementing it
 BPL P%+4               \ again if the above decrement made T negative)
 INC T

 DEC XX17               \ Decrement the total number of characters left to
                        \ print, which we stored in XX17

 BMI rT10               \ If the result is negative, we have printed all the
                        \ characters, so jump down to rT10 to return from the
                        \ subroutine

 BNE P%+10              \ If the result is positive (> 0) then we still have
                        \ characters left to print, so loop back to TT35 (via
                        \ the JMP TT35 instruction below) to print the next
                        \ digit

 PLP                    \ If we get here then we have printed the exact number
                        \ of digits that we wanted to, so restore the C flag
                        \ that we stored at the start of the routine

 BCC P%+7               \ If the C flag is clear, we don't want a decimal point,
                        \ so loop back to TT35 (via the JMP TT35 instruction
                        \ below) to print the next digit

 LDA #'.'               \ Otherwise the C flag is set, so print the decimal
 JSR TT26               \ point

 JMP TT35               \ Loop back to TT35 to print the next digit

.rT10

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DTW1
\       Type: Variable
\   Category: Text
\    Summary: A mask for applying the lower case part of Sentence Case to
\             extended text tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This variable is used to change characters to lower case as part of applying
\ Sentence Case to extended text tokens. It has two values:
\
\   * %00100000 = apply lower case to the second letter of a word onwards
\
\   * %00000000 = do not change case to lower case
\
\ The default value is %00100000 (apply lower case).
\
\ The flag is set to %00100000 (apply lower case) by jump token 2, {sentence
\ case}, which calls routine MT2 to change the value of DTW1.
\
\ The flag is set to %00000000 (do not change case to lower case) by jump token
\ 1, {all caps}, which calls routine MT1 to change the value of DTW1.
\
\ The letter to print is OR'd with DTW1 in DETOK2, which lower-cases the letter
\ by setting bit 5 (if DTW1 is %00100000). However, this OR is only done if bit
\ 7 of DTW2 is clear, i.e. we are printing a word, so this doesn't affect the
\ first letter of the word, which remains capitalised.
\
\ ******************************************************************************

.DTW1

 EQUB %00100000

\ ******************************************************************************
\
\       Name: DTW2
\       Type: Variable
\   Category: Text
\    Summary: A flag that indicates whether we are currently printing a word
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This variable is used to indicate whether we are currently printing a word. It
\ has two values:
\
\   * 0 = we are currently printing a word
\
\   * Non-zero = we are not currently printing a word
\
\ The default value is %11111111 (we are not currently printing a word).
\
\ The flag is set to %00000000 (we are currently printing a word) whenever a
\ non-terminator character is passed to DASC for printing.
\
\ The flag is set to %11111111 (we are not currently printing a word) whenever a
\ terminator character (full stop, colon, carriage return, line feed, space) is
\ passed to DASC for printing. It is also set to %11111111 by jump token 8,
\ {tab 6}, which calls routine MT8 to change the value of DTW2, and to %10000000
\ by TTX66 when we clear the screen.
\
\ ******************************************************************************

.DTW2

 EQUB %11111111

\ ******************************************************************************
\
\       Name: DTW3
\       Type: Variable
\   Category: Text
\    Summary: A flag for switching between standard and extended text tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This variable is used to indicate whether standard or extended text tokens
\ should be printed by calls to DETOK. It allows us to mix standard tokens in
\ with extended tokens. It has two values:
\
\   * %00000000 = print extended tokens (i.e. those in TKN1 and RUTOK)
\
\   * %11111111 = print standard tokens (i.e. those in QQ18)
\
\ The default value is %00000000 (extended tokens).
\
\ Standard tokens are set by jump token {6}, which calls routine MT6 to change
\ the value of DTW3 to %11111111.
\
\ Extended tokens are set by jump token {5}, which calls routine MT5 to change
\ the value of DTW3 to %00000000.
\
\ ******************************************************************************

.DTW3

 EQUB %00000000

\ ******************************************************************************
\
\       Name: DTW4
\       Type: Variable
\   Category: Text
\    Summary: Flags that govern how justified extended text tokens are printed
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This variable is used to control how justified text tokens are printed as part
\ of the extended text token system. There are two bits that affect justified
\ text:
\
\   * Bit 7: 1 = justify text
\            0 = do not justify text
\
\   * Bit 6: 1 = buffer the entire token before printing, including carriage
\                returns (used for in-flight messages only)
\            0 = print the contents of the buffer whenever a carriage return
\                appears in the token
\
\ The default value is %00000000 (do not justify text, print buffer on carriage
\ return).
\
\ The flag is set to %10000000 (justify text, print buffer on carriage return)
\ by jump token 14, {justify}, which calls routine MT14 to change the value of
\ DTW4.
\
\ The flag is set to %11000000 (justify text, buffer entire token) by routine
\ MESS, which prints in-flight messages.
\
\ The flag is set to %00000000 (do not justify text, print buffer on carriage
\ return) by jump token 15, {left align}, which calls routine MT1 to change the
\ value of DTW4.
\
\ ******************************************************************************

.DTW4

 EQUB 0

\ ******************************************************************************
\
\       Name: DTW5
\       Type: Variable
\   Category: Text
\    Summary: The size of the justified text buffer at BUF
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ When justified text is enabled by jump token 14, {justify}, during printing of
\ extended text tokens, text is fed into a buffer at BUF instead of being
\ printed straight away, so it can be padded out with spaces to justify the
\ text. DTW5 contains the size of the buffer, so BUF + DTW5 points to the first
\ free byte after the end of the buffer.
\
\ ******************************************************************************

.DTW5

 EQUB 0

\ ******************************************************************************
\
\       Name: DTW6
\       Type: Variable
\   Category: Text
\    Summary: A flag to denote whether printing in lower case is enabled for
\             extended text tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This variable is used to indicate whether lower case is currently enabled. It
\ has two values:
\
\   * %10000000 = lower case is enabled
\
\   * %00000000 = lower case is not enabled
\
\ The default value is %00000000 (lower case is not enabled).
\
\ The flag is set to %10000000 (lower case is enabled) by jump token 13 {lower
\ case}, which calls routine MT10 to change the value of DTW6.
\
\ The flag is set to %00000000 (lower case is not enabled) by jump token 1, {all
\ caps}, and jump token 2, {sentence case}, which call routines MT1 and MT2 to
\ change the value of DTW6.
\
\ ******************************************************************************

.DTW6

 EQUB %00000000

\ ******************************************************************************
\
\       Name: DTW8
\       Type: Variable
\   Category: Text
\    Summary: A mask for capitalising the next letter in an extended text token
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This variable is only used by one specific extended token, the {single cap}
\ jump token, which capitalises the next letter only. It has two values:
\
\   * %11011111 = capitalise the next letter
\
\   * %11111111 = do not change case
\
\ The default value is %11111111 (do not change case).
\
\ The flag is set to %11011111 (capitalise the next letter) by jump token 19,
\ {single cap}, which calls routine MT19 to change the value of DTW.
\
\ The flag is set to %11111111 (do not change case) at the start of DASC, after
\ the letter has been capitalised in DETOK2, so the effect is to capitalise one
\ letter only.
\
\ The letter to print is AND'd with DTW8 in DETOK2, which capitalises the letter
\ by clearing bit 5 (if DTW8 is %11011111). However, this AND is only done if at
\ least one of the following is true:
\
\   * Bit 7 of DTW2 is set (we are not currently printing a word)
\
\   * Bit 7 of DTW6 is set (lower case has been enabled by jump token 13, {lower
\     case}
\
\ In other words, we only capitalise the next letter if it's the first letter in
\ a word, or we are printing in lower case.
\
\ ******************************************************************************

.DTW8

 EQUB %11111111

\ ******************************************************************************
\
\       Name: FEED
\       Type: Subroutine
\   Category: Text
\    Summary: Print a newline
\
\ ******************************************************************************

.FEED

 LDA #12                \ Set A = 12, so when we skip MT16 and fall through into
                        \ TT26, we print character 12, which is a newline

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &41, or BIT &41A9, which does nothing apart
                        \ from affect the flags

                        \ Fall through into TT26 (skipping MT16) to print the
                        \ newline character

\ ******************************************************************************
\
\       Name: MT16
\       Type: Subroutine
\   Category: Text
\    Summary: Print the character in variable DTW7
\  Deep dive: Extended text tokens
\
\ ******************************************************************************

.MT16

 LDA #'A'               \ Set A to the contents of DTW7, as DTW7 points to the
                        \ second byte of this instruction, so updating DTW7 will
                        \ modify this instruction (the default value of DTW7 is
                        \ an "A")

 DTW7 = MT16 + 1        \ Point DTW7 to the second byte of the instruction above
                        \ so that modifying DTW7 changes the value loaded into A

                        \ Fall through into TT26 to print the character in A

\ ******************************************************************************
\
\       Name: TT26
\       Type: Subroutine
\   Category: Text
\    Summary: Print a character at the text cursor, with support for verified
\             text in extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The character to print
\
\ Returns:
\
\   X                   X is preserved
\
\   C flag              The C flag is cleared
\
\ Other entry points:
\
\   DASC                DASC does exactly the same as TT26 and prints a
\                       character at the text cursor, with support for verified
\                       text in extended tokens
\
\   rT9                 Contains an RTS
\
\ ******************************************************************************

.DASC

.TT26

 STX SC                 \ Store X in SC, so we can retrieve it below

 LDX #%11111111         \ Set DTW8 = %11111111, to disable the effect of {19} if
 STX DTW8               \ it was set (as {19} capitalises one character only)

 CMP #'.'               \ If the character in A is a word terminator:
 BEQ DA8                \
 CMP #':'               \   * Full stop
 BEQ DA8                \   * Colon
 CMP #10                \   * Line feed
 BEQ DA8                \   * Carriage return
 CMP #12                \   * Space
 BEQ DA8                \
 CMP #' '               \ then skip the following instruction
 BEQ DA8

 INX                    \ Increment X to 0, so DTW2 gets set to %00000000 below

.DA8

 STX DTW2               \ Store X in DTW2, so DTW2 is now:
                        \
                        \   * %00000000 if this character is a word terminator
                        \
                        \   * %11111111 if it isn't
                        \
                        \ so DTW2 indicates whether or not we are currently
                        \ printing a word

 LDX SC                 \ Retrieve the original value of X from SC

 BIT DTW4               \ If bit 7 of DTW4 is set then we are currently printing
 BMI P%+5               \ justified text, so skip the next instruction

 JMP CHPR               \ Bit 7 of DTW4 is clear, so jump down to CHPR to print
                        \ this character, as we are not printing justified text

                        \ If we get here then we are printing justified text, so
                        \ we need to buffer the text until we reach the end of
                        \ the paragraph, so we can then pad it out with spaces

 CMP #12                \ If the character in A is a carriage return, then we
 BEQ DA1                \ have reached the end of the paragraph, so jump down to
                        \ DA1 to print out the contents of the buffer,
                        \ justifying it as we go

                        \ If we get here then we need to buffer this character
                        \ in the line buffer at BUF

 LDX DTW5               \ DTW5 contains the current size of the buffer, so this
 STA BUF,X              \ stores the character in A at BUF + DTW5, the next free
                        \ space in the buffer

 LDX SC                 \ Retrieve the original value of X from SC so we can
                        \ preserve it through this subroutine call

 INC DTW5               \ Increment the size of the BUF buffer that is stored in
                        \ DTW5

 CLC                    \ Clear the C flag

 RTS                    \ Return from the subroutine

.DA1

                        \ If we get here then we are justifying text and we have
                        \ reached the end of the paragraph, so we need to print
                        \ out the contents of the buffer, justifying it as we go

 TXA                    \ Store X and Y on the stack
 PHA
 TYA
 PHA

.DA5

 LDX DTW5               \ Set X = DTW5, which contains the size of the buffer

 BEQ DA6+3              \ If X = 0 then the buffer is empty, so jump down to
                        \ DA6+3 to print a newline

 CPX #(LL+1)            \ If X < LL+1, i.e. X <= LL, then the buffer contains
 BCC DA6                \ fewer than LL characters, which is less than a line
                        \ length, so jump down to DA6 to print the contents of
                        \ BUF followed by a newline, as we don't justify the
                        \ last line of the paragraph

                        \ Otherwise X > LL, so the buffer does not fit into one
                        \ line, and we therefore need to justify the text, which
                        \ we do one line at a time

 LSR SC+1               \ Shift SC+1 to the right, which clears bit 7 of SC+1,
                        \ so we pass through the following comparison on the
                        \ first iteration of the loop and set SC+1 to %01000000

.DA11

 LDA SC+1               \ If bit 7 of SC+1 is set, skip the following two
 BMI P%+6               \ instructions

 LDA #%01000000         \ Set SC+1 = %01000000
 STA SC+1

 LDY #(LL-1)            \ Set Y = line length, so we can loop backwards from the
                        \ end of the first line in the buffer using Y as the
                        \ loop counter

.DAL1

 LDA BUF+LL             \ If the LL-th byte in BUF is a space, jump down to DA2
 CMP #' '               \ to print out the first line from the buffer, as it
 BEQ DA2                \ fits the line width exactly (i.e. it's justified)

                        \ We now want to find the last space character in the
                        \ first line in the buffer, so we loop through the line
                        \ using Y as a counter

.DAL2

 DEY                    \ Decrement the loop counter in Y

 BMI DA11               \ If Y <= 0, loop back to DA11, as we have now looped
 BEQ DA11               \ through the whole line

 LDA BUF,Y              \ If the Y-th byte in BUF is not a space, loop back up
 CMP #' '               \ to DAL2 to check the next character
 BNE DAL2

                        \ Y now points to a space character in the line buffer

 ASL SC+1               \ Shift SC+1 to the left

 BMI DAL2               \ If bit 7 of SC+1 is set, jump to DAL2 to find the next
                        \ space character

                        \ We now want to insert a space into the line buffer at
                        \ position Y, which we do by shifting every character
                        \ after position Y along by 1, and then inserting the
                        \ space

 STY SC                 \ Store Y in SC, so we want to insert the space at
                        \ position SC

 LDY DTW5               \ Fetch the buffer size from DTW5 into Y, to act as a
                        \ loop counter for moving the line buffer along by 1

.DAL6

 LDA BUF,Y              \ Copy the Y-th character from BUF into the Y+1-th
 STA BUF+1,Y            \ position

 DEY                    \ Decrement the loop counter in Y

 CPY SC                 \ Loop back to shift the next character along, until we
 BCS DAL6               \ have moved the SC-th character (i.e. Y < SC)

 INC DTW5               \ Increment the buffer size in DTW5

                        \ We've now shifted the line to the right by 1 from
                        \ position SC onwards, so SC and SC+1 both contain
                        \ spaces, and Y is now SC-1 as we did a DEY just before
                        \ the end of the loop - in other words, we have inserted
                        \ a space at position SC, and Y points to the character
                        \ before the newly inserted space

                        \ We now want to move the pointer Y left to find the
                        \ next space in the line buffer, before looping back to
                        \ check whether we are done, and if not, insert another
                        \ space

.DAL3

 CMP BUF,Y              \ If the character at position Y is not a space, jump to
 BNE DAL1               \ DAL1 to see whether we have now justified the line

 DEY                    \ Decrement the loop counter in Y

 BPL DAL3               \ Loop back to check the next character to the left,
                        \ until we have found a space

 BMI DA11               \ Jump back to DA11 (this BMI is effectively a JMP as
                        \ we already passed through a BPL to get here)

.DA2

                        \ This subroutine prints out a full line of characters
                        \ from the start of the line buffer in BUF, followed by
                        \ a newline. It then removes that line from the buffer,
                        \ shuffling the rest of the buffer contents down

 LDX #LL                \ Call DAS1 to print out the first LL characters from
 JSR DAS1               \ the line buffer in BUF

 LDA #12                \ Print a newline
 JSR CHPR

 LDA DTW5               \ Subtract #LL from the end-of-buffer pointer in DTW5
 SBC #LL                \
 STA DTW5               \ The subtraction works as CHPR clears the C flag

 TAX                    \ Copy the new value of DTW5 into X

 BEQ DA6+3              \ If DTW5 = 0 then jump down to DA6+3 to print a newline
                        \ as the buffer is now empty

                        \ If we get here then we have printed our line but there
                        \ is more in the buffer, so we now want to remove the
                        \ line we just printed from the start of BUF

 LDY #0                 \ Set Y = 0 to count through the characters in BUF

 INX                    \ Increment X, so it now contains the number of
                        \ characters in the buffer (as DTW5 is a zero-based
                        \ pointer and is therefore equal to the number of
                        \ characters minus 1)

.DAL4

 LDA BUF+LL+1,Y         \ Copy the Y-th character from BUF+LL to BUF
 STA BUF,Y

 INY                    \ Increment the character pointer

 DEX                    \ Decrement the character count

 BNE DAL4               \ Loop back to copy the next character until we have
                        \ shuffled down the whole buffer

 BEQ DA5                \ Jump back to DA5 (this BEQ is effectively a JMP as we
                        \ have already passed through the BNE above)

.DAS1

                        \ This subroutine prints out X characters from BUF,
                        \ returning with X = 0

 LDY #0                 \ Set Y = 0 to point to the first character in BUF

.DAL5

 LDA BUF,Y              \ Print the Y-th character in BUF using CHPR, which also
 JSR CHPR               \ clears the C flag for when we return from the
                        \ subroutine below

 INY                    \ Increment Y to point to the next character

 DEX                    \ Decrement the loop counter

 BNE DAL5               \ Loop back for the next character until we have printed
                        \ X characters from BUF

.rT9

 RTS                    \ Return from the subroutine

.DA6

 JSR DAS1               \ Call DAS1 to print X characters from BUF, returning
                        \ with X = 0

 STX DTW5               \ Set the buffer size in DTW5 to 0, as the buffer is now
                        \ empty

 PLA                    \ Restore Y and X from the stack
 TAY
 PLA
 TAX

 LDA #12                \ Set A = 12, so when we skip BELL and fall through into
                        \ CHPR, we print character 12, which is a newline

.DA7

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &07, or BIT &07A9, which does nothing apart
                        \ from affect the flags

                        \ Fall through into CHPR (skipping BELL) to print the
                        \ character and return with the C flag cleared

\ ******************************************************************************
\
\       Name: BELL
\       Type: Subroutine
\   Category: Sound
\    Summary: Make a standard system beep
\
\ ------------------------------------------------------------------------------
\
\ This is the standard system beep, as made by the ASCII 7 "BELL" control code.
\
\ ******************************************************************************

.BELL

 LDA #7                 \ Control code 7 makes a beep, so load this into A

                        \ Fall through into the TT26 print routine to
                        \ actually make the sound

\ ******************************************************************************
\
\       Name: CHPR
\       Type: Subroutine
\   Category: Text
\    Summary: Print a character at the text cursor by sending a write_xyc
\             command to the I/O processor
\  Deep dive: Drawing text
\
\ ------------------------------------------------------------------------------
\
\ Print a character at the text cursor (XC, YC), do a beep, print a newline,
\ or delete left (backspace).
\
\ WRCHV is set to point here by the loading process.
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\                         * 127 (delete the character to the left of the text
\                           cursor and move the cursor to the left)
\
\   XC                  Contains the text column to print at (the x-coordinate)
\
\   YC                  Contains the line number to print on (the y-coordinate)
\
\ Returns:
\
\   A                   A is preserved
\
\   X                   X is preserved
\
\   Y                   Y is preserved
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.CHPR

 STA K3                 \ Store the A, X and Y registers, so we can restore
 STY YSAV2              \ them at the end (so they don't get changed by this
 STX XSAV2              \ routine)

.RRNEW

 LDY QQ17               \ Load the QQ17 flag, which contains the text printing
                        \ flags

 INY                    \ If QQ17 = 255 then printing is disabled, so jump to
 BEQ RR4                \ RR4, which doesn't print anything, it just restores
                        \ the registers and returns from the subroutine

 TAY                    \ Set Y = the character to be printed

 BEQ RR4                \ If the character is zero, which is typically a string
                        \ terminator character, jump down to RR4 to restore the
                        \ registers and return from the subroutine

 BMI RR4                \ If A > 127 then there is nothing to print, so jump to
                        \ RR4 to restore the registers and return from the
                        \ subroutine

 CMP #7                 \ If this is a beep character (A = 7), jump to R5,
 BEQ R5                 \ which will emit the beep, restore the registers and
                        \ return from the subroutine

 CMP #32                \ If this is an ASCII character (A >= 32), jump to RR1
 BCS RR1                \ below, which will print the character, restore the
                        \ registers and return from the subroutine

 CMP #10                \ If this is control code 10 (line feed) then jump to
 BEQ RRX1               \ RRX1, which will move down a line, restore the
                        \ registers and return from the subroutine

 LDX #1                 \ If we get here, then this is control code 11-13, of
 STX XC                 \ which only 13 is used. This code prints a newline,
                        \ which we can achieve by moving the text cursor
                        \ to the start of the line (carriage return) and down
                        \ one line (line feed). These two lines do the first
                        \ bit by setting XC = 1, and we then fall through into
                        \ the line feed routine that's used by control code 10

 CMP #13                \ If this is control code 13 (carriage return) then jump
 BEQ RR4                \ RR4 to restore the registers and return from the
                        \ subroutine

.RRX1

 INC YC                 \ Print a line feed, simply by incrementing the row
                        \ number (y-coordinate) of the text cursor, which is
                        \ stored in YC

 BNE RR4                \ Jump to RR4 to restore the registers and return from
                        \ the subroutine (this BNE is effectively a JMP as Y
                        \ will never be zero)

.RR1

                        \ If we get here, then the character to print is an
                        \ ASCII character in the range 32-95. The quickest way
                        \ to display text on-screen is to poke the character
                        \ pixel by pixel, directly into screen memory, so
                        \ that's what the rest of this routine does
                        \
                        \ The first step, then, is to get hold of the bitmap
                        \ definition for the character we want to draw on the
                        \ screen (i.e. we need the pixel shape of this
                        \ character). The MOS ROM contains bitmap definitions
                        \ of the system's ASCII characters, starting from &C000
                        \ for space (ASCII 32) and ending with the  symbol
                        \ (ASCII 126)
                        \
                        \ There are definitions for 32 characters in each of the
                        \ three pages of MOS memory, as each definition takes up
                        \ 8 bytes (8 rows of 8 pixels) and 32 * 8 = 256 bytes =
                        \ 1 page. So:
                        \
                        \   ASCII 32-63  are defined in &C000-&C0FF (page 0)
                        \   ASCII 64-95  are defined in &C100-&C1FF (page 1)
                        \   ASCII 96-126 are defined in &C200-&C2F0 (page 2)
                        \
                        \ The following code reads the relevant character
                        \ bitmap from the above locations in ROM and pokes
                        \ those values into the correct position in screen
                        \ memory, thus printing the character on-screen
                        \
                        \ It's a long way from 10 PRINT "Hello world!":GOTO 10

                        \ Now we want to set X to point to the relevant page
                        \ number for this character - i.e. &C0, &C1 or &C2.

                        \ The following logic is easier to follow if we look
                        \ at the three character number ranges in binary:
                        \
                        \   Bit #  76543210
                        \
                        \   32  = %00100000     Page 0 of bitmap definitions
                        \   63  = %00111111
                        \
                        \   64  = %01000000     Page 1 of bitmap definitions
                        \   95  = %01011111
                        \
                        \   96  = %01100000     Page 2 of bitmap definitions
                        \   125 = %01111101
                        \
                        \ We'll refer to this below

 LDA YC                 \ Fetch YC, the y-coordinate (row) of the text cursor

 CMP #24                \ If the text cursor is on the screen (i.e. YC < 24, so
 BCC RR3                \ we are on rows 0-23), then jump to RR3 to print the
                        \ character

 PHA                    \ Store A on the stack so we can retrieve it below

 JSR TTX66              \ Otherwise we are off the bottom of the screen, so
                        \ clear the screen and draw a white border

 PLA                    \ Retrieve A from the stack... only to overwrite it with
                        \ the next instruction, so presumably we didn't need to
                        \ preserve it and this and the PHA above have no effect

 LDA K3                 \ Set A to the character to be printed

 JMP RRNEW              \ Jump back to RRNEW to print the character

.RR3

 LDA #&8E               \ Send command &8E to the I/O processor:
 JSR tube_write         \
                        \   write_xyc(x, y, char)
                        \
                        \ which will draw the text character in char at column x
                        \ and row y

 LDA XC                 \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * x = XC

 LDA YC                 \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * y = YC

 TYA                    \ Send the third parameter to the I/O processor:
 JSR tube_write         \
                        \   * char = the character in Y

 INC XC                 \ Once we print the character, we want to move the text
                        \ cursor to the right, so we do this by incrementing
                        \ XC. Note that this doesn't have anything to do
                        \ with the actual printing below, we're just updating
                        \ the cursor so it's in the right position following
                        \ the print

.RR4

 LDY YSAV2              \ We're done printing, so restore the values of the
 LDX XSAV2              \ A, X and Y registers that we saved above and clear
 LDA K3                 \ the C flag, so everything is back to how it was
 CLC

 RTS                    \ Return from the subroutine

.R5

 JSR BEEP               \ Call the BEEP subroutine to make a short, high beep

 JMP RR4                \ Jump to RR4 to restore the registers and return from
                        \ the subroutine using a tail call

\ ******************************************************************************
\
\       Name: DIALS (Part 1 of 4)
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update the dashboard: speed indicator
\  Deep dive: The dashboard indicators
\
\ ------------------------------------------------------------------------------
\
\ This routine updates the dashboard. First we draw all the indicators in the
\ right part of the dashboard, from top (speed) to bottom (energy banks), and
\ then we move on to the left part, again drawing from top (forward shield) to
\ bottom (altitude).
\
\ This first section starts us off with the speedometer in the top right.
\
\ ******************************************************************************

.DIALS

 LDA #&D0               \ Set SC(1 0) = &78D0, which is the screen address for
 STA SC                 \ the character block containing the left end of the
 LDA #&78               \ top indicator in the right part of the dashboard, the
 STA SC+1               \ one showing our speed

 JSR PZW                \ Call PZW to set A to the colour for dangerous values
                        \ and X to the colour for safe values

 STX K+1                \ Set K+1 (the colour we should show for low values) to
                        \ X (the colour to use for safe values)

 STA K                  \ Set K (the colour we should show for high values) to
                        \ A (the colour to use for dangerous values)

                        \ The above sets the following indicators to show red
                        \ for high values and yellow/white for low values

 LDA #14                \ Set T1 to 14, the threshold at which we change the
 STA T1                 \ indicator's colour

 LDA DELTA              \ Fetch our ship's speed into A, in the range 0-40

 JSR DIL-1              \ Draw the speed indicator using a range of 0-31, and
                        \ increment SC to point to the next indicator (the roll
                        \ indicator)

\ ******************************************************************************
\
\       Name: DIALS (Part 2 of 4)
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update the dashboard: pitch and roll indicators
\  Deep dive: The dashboard indicators
\
\ ******************************************************************************

 LDA #0                 \ Set R = P = 0 for the low bytes in the call to the ADD
 STA R                  \ routine below
 STA P

 LDA #8                 \ Set S = 8, which is the value of the centre of the
 STA S                  \ roll indicator

 LDA ALP1               \ Fetch the roll angle alpha as a value between 0 and
 LSR A                  \ 31, and divide by 4 to get a value of 0 to 7
 LSR A

 ORA ALP2               \ Apply the roll sign to the value, and flip the sign,
 EOR #%10000000         \ so it's now in the range -7 to +7, with a positive
                        \ roll angle alpha giving a negative value in A

 JSR ADD                \ We now add A to S to give us a value in the range 1 to
                        \ 15, which we can pass to DIL2 to draw the vertical
                        \ bar on the indicator at this position. We use the ADD
                        \ routine like this:
                        \
                        \ (A X) = (A 0) + (S 0)
                        \
                        \ and just take the high byte of the result. We use ADD
                        \ rather than a normal ADC because ADD separates out the
                        \ sign bit and does the arithmetic using absolute values
                        \ and separate sign bits, which we want here rather than
                        \ the two's complement that ADC uses

 JSR DIL2               \ Draw a vertical bar on the roll indicator at offset A
                        \ and increment SC to point to the next indicator (the
                        \ pitch indicator)

 LDA BETA               \ Fetch the pitch angle beta as a value between -8 and
                        \ +8

 LDX BET1               \ Fetch the magnitude of the pitch angle beta, and if it
 BEQ P%+5               \ is 0 (i.e. we are not pitching), skip the next two
                        \ instructions

 SEC                    \ The C flag is set by the call to DIL2 above, so this
                        \ instruction has no effect

 SBC #1                 \ The pitch angle beta is non-zero, so set A = A - 1.
                        \ This gives us a value of A from -7 to +7 because these
                        \ are magnitude-based numbers with sign bits, rather
                        \ than two's complement numbers

 JSR ADD                \ We now add A to S to give us a value in the range 1 to
                        \ 15, which we can pass to DIL2 to draw the vertical
                        \ bar on the indicator at this position (see the JSR ADD
                        \ above for more on this)

 JSR DIL2               \ Draw a vertical bar on the pitch indicator at offset A
                        \ and increment SC to point to the next indicator (the
                        \ four energy banks)

\ ******************************************************************************
\
\       Name: DIALS (Part 3 of 4)
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update the dashboard: four energy banks
\  Deep dive: The dashboard indicators
\
\ ------------------------------------------------------------------------------
\
\ This and the next section only run once every four iterations of the main
\ loop, so while the speed, pitch and roll indicators update every iteration,
\ the other indicators update less often.
\
\ ******************************************************************************

 LDA MCNT               \ Fetch the main loop counter and calculate MCNT mod 4,
 AND #3                 \ jumping to R5-1 if it is non-zero. R5-1 contains an
 BNE R5-1               \ RTS, so the following code only runs every 4
                        \ iterations of the main loop, otherwise we return from
                        \ the subroutine

 LDY #0                 \ Set Y = 0, for use in various places below

 JSR PZW                \ Call PZW to set A to the colour for dangerous values
                        \ and X to the colour for safe values

 STX K                  \ Set K (the colour we should show for high values) to X
                        \ (the colour to use for safe values)

 STA K+1                \ Set K+1 (the colour we should show for low values) to
                        \ A (the colour to use for dangerous values)

                        \ The above sets the following indicators to show red
                        \ for low values and yellow/white for high values, which
                        \ we use not only for the energy banks, but also for the
                        \ shield levels and current fuel

 LDX #3                 \ Set up a counter in X so we can zero the four bytes at
                        \ XX12, so we can then calculate each of the four energy
                        \ banks' values before drawing them later

 STX T1                 \ Set T1 to 3, the threshold at which we change the
                        \ indicator's colour

.DLL23

 STY XX12,X             \ Set the X-th byte of XX12 to 0

 DEX                    \ Decrement the counter

 BPL DLL23              \ Loop back for the next byte until the four bytes at
                        \ XX12 are all zeroed

 LDX #3                 \ Set up a counter in X to loop through the 4 energy
                        \ bank indicators, so we can calculate each of the four
                        \ energy banks' values and store them in XX12

 LDA ENERGY             \ Set A = Q = ENERGY / 4, so they are both now in the
 LSR A                  \ range 0-63 (so that's a maximum of 16 in each of the
 LSR A                  \ banks, and a maximum of 15 in the top bank)

 STA Q                  \ Set Q to A, so we can use Q to hold the remaining
                        \ energy as we work our way through each bank, from the
                        \ full ones at the bottom to the empty ones at the top

.DLL24

 SEC                    \ Set A = A - 16 to reduce the energy count by a full
 SBC #16                \ bank

 BCC DLL26              \ If the C flag is clear then A < 16, so this bank is
                        \ not full to the brim, and is therefore the last one
                        \ with any energy in it, so jump to DLL26

 STA Q                  \ This bank is full, so update Q with the energy of the
                        \ remaining banks

 LDA #16                \ Store this bank's level in XX12 as 16, as it is full,
 STA XX12,X             \ with XX12+3 for the bottom bank and XX12+0 for the top

 LDA Q                  \ Set A to the remaining energy level again

 DEX                    \ Decrement X to point to the next bank, i.e. the one
                        \ above the bank we just processed

 BPL DLL24              \ Loop back to DLL24 until we have either processed all
                        \ four banks, or jumped out early to DLL26 if the top
                        \ banks have no charge

 BMI DLL9               \ Jump to DLL9 as we have processed all four banks (this
                        \ BMI is effectively a JMP as A will never be positive)

.DLL26

 LDA Q                  \ If we get here then the bank we just checked is not
 STA XX12,X             \ fully charged, so store its value in XX12 (using Q,
                        \ which contains the energy of the remaining banks -
                        \ i.e. this one)

                        \ Now that we have the four energy bank values in XX12,
                        \ we can draw them, starting with the top bank in XX12
                        \ and looping down to the bottom bank in XX12+3, using Y
                        \ as a loop counter, which was set to 0 above

.DLL9

 LDA XX12,Y             \ Fetch the value of the Y-th indicator, starting from
                        \ the top

 STY P                  \ Store the indicator number in P for retrieval later

 JSR DIL                \ Draw the energy bank using a range of 0-15, and
                        \ increment SC to point to the next indicator (the
                        \ next energy bank down)

 LDY P                  \ Restore the indicator number into Y

 INY                    \ Increment the indicator number

 CPY #4                 \ Check to see if we have drawn the last energy bank

 BNE DLL9               \ Loop back to DLL9 if we have more banks to draw,
                        \ otherwise we are done

\ ******************************************************************************
\
\       Name: DIALS (Part 4 of 4)
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update the dashboard: shields, fuel, laser & cabin temp, altitude
\  Deep dive: The dashboard indicators
\
\ ******************************************************************************

 LDA #&78               \ Set SC(1 0) = &7810, which is the screen address for
 STA SC+1               \ the character block containing the left end of the
 LDA #&10               \ top indicator in the left part of the dashboard, the
 STA SC                 \ one showing the forward shield

 LDA FSH                \ Draw the forward shield indicator using a range of
 JSR DILX               \ 0-255, and increment SC to point to the next indicator
                        \ (the aft shield)

 LDA ASH                \ Draw the aft shield indicator using a range of 0-255,
 JSR DILX               \ and increment SC to point to the next indicator (the
                        \ fuel level)

 LDA QQ14               \ Draw the fuel level indicator using a range of 0-63,
 JSR DILX+2             \ and increment SC to point to the next indicator (the
                        \ cabin temperature)

 JSR PZW                \ Call PZW to set A to the colour for dangerous values
                        \ and X to the colour for safe values

 STX K+1                \ Set K+1 (the colour we should show for low values) to
                        \ X (the colour to use for safe values)

 STA K                  \ Set K (the colour we should show for high values) to
                        \ A (the colour to use for dangerous values)

                        \ The above sets the following indicators to show red
                        \ for high values and yellow/white for low values, which
                        \ we use for the cabin and laser temperature bars

 LDX #11                \ Set T1 to 11, the threshold at which we change the
 STX T1                 \ cabin and laser temperature indicators' colours

 LDA CABTMP             \ Draw the cabin temperature indicator using a range of
 JSR DILX               \ 0-255, and increment SC to point to the next indicator
                        \ (the laser temperature)

 LDA GNTMP              \ Draw the laser temperature indicator using a range of
 JSR DILX               \ 0-255, and increment SC to point to the next indicator
                        \ (the altitude)

 LDA #240               \ Set T1 to 240, the threshold at which we change the
 STA T1                 \ altitude indicator's colour. As the altitude has a
                        \ range of 0-255, pixel 16 will not be filled in, and
                        \ 240 would change the colour when moving between pixels
                        \ 15 and 16, so this effectively switches off the colour
                        \ change for the altitude indicator

 STA K+1                \ Set K+1 (the colour we should show for low values) to
                        \ 240, or &F0 (dashboard colour 2, yellow/white), so the
                        \ altitude indicator always shows in this colour

 LDA ALTIT              \ Draw the altitude indicator using a range of 0-255,
 JMP DILX               \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PZW
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Fetch the current dashboard colours, to support flashing
\
\ ------------------------------------------------------------------------------
\
\ Set A and X to the colours we should use for indicators showing dangerous and
\ safe values respectively. This enables us to implement flashing indicators,
\ which is one of the game's configurable options.
\
\ If flashing is enabled, the colour returned in A (dangerous values) will be
\ red for 8 iterations of the main loop, and yellow/white for the next 8, before
\ going back to red. If we always use PZW to decide which colours we should use
\ when updating indicators, flashing colours will be automatically taken care of
\ for us.
\
\ The values returned are &F0 for yellow/white and &0F for red. These are mode 5
\ bytes that contain 4 pixels, with the colour of each pixel given in two bits,
\ the high bit from the first nibble (bits 4-7) and the low bit from the second
\ nibble (bits 0-3). So in &F0 each pixel is %10, or colour 2 (yellow or white,
\ depending on the dashboard palette), while in &0F each pixel is %01, or colour
\ 1 (red).
\
\ Returns:
\
\   A                   The colour to use for indicators with dangerous values
\
\   X                   The colour to use for indicators with safe values
\
\ ******************************************************************************

.PZW

 LDX #&F0               \ Set X to dashboard colour 2 (yellow/white)

 LDA MCNT               \ A will be non-zero for 8 out of every 16 main loop
 AND #%00001000         \ counts, when bit 4 is set, so this is what we use to
                        \ flash the "danger" colour

 AND FLH                \ A will be zeroed if flashing colours are disabled

 BEQ P%+4               \ If A is zero, skip to the LDA instruction below

 TXA                    \ Otherwise flashing colours are enabled and it's the
                        \ main loop iteration where we flash them, so set A to
                        \ colour 2 (yellow/white) and use the BIT trick below to
                        \ return from the subroutine

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &0F, or BIT &0FA9, which does nothing apart
                        \ from affect the flags

 LDA #&0F               \ Set A to dashboard colour 1 (red)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DILX
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update a bar-based indicator on the dashboard by sending a
\             draw_bar command to the I/O processor
\  Deep dive: The dashboard indicators
\
\ ------------------------------------------------------------------------------
\
\ The range of values shown on the indicator depends on which entry point is
\ called. For the default entry point of DILX, the range is 0-255 (as the value
\ passed in A is one byte). The other entry points are shown below.
\
\ Arguments:
\
\   A                   The value to be shown on the indicator (so the larger
\                       the value, the longer the bar)
\
\   T1                  The threshold at which we change the indicator's colour
\                       from the low value colour to the high value colour. The
\                       threshold is in pixels, so it should have a value from
\                       0-16, as each bar indicator is 16 pixels wide
\
\   K                   The colour to use when A is a high value, as a 4-pixel
\                       mode 5 character row byte
\
\   K+1                 The colour to use when A is a low value, as a 4-pixel
\                       mode 5 character row byte
\
\   SC(1 0)             The screen address of the first character block in the
\                       indicator
\
\ Other entry points:
\
\   DILX+2              The range of the indicator is 0-64 (for the fuel
\                       indicator)
\
\   DIL-1               The range of the indicator is 0-32 (for the speed
\                       indicator)
\
\   DIL                 The range of the indicator is 0-16 (for the energy
\                       banks)
\
\ ******************************************************************************

.DILX

 LSR A                  \ If we call DILX, we set A = A / 16, so A is 0-15
 LSR A

 LSR A                  \ If we call DILX+2, we set A = A / 4, so A is 0-15

 LSR A                  \ If we call DIL-1, we set A = A / 2, so A is 0-15

.DIL

                        \ If we call DIL, we leave A alone, so A is 0-15

 PHA                    \ Store the indicator value on the stack

 LDA #&86               \ Send command &86 to the I/O processor:
 JSR tube_write         \
                        \   draw_bar(value, colour, screen_low, screen_high)
                        \
                        \ which will update the bar-based dashboard indicator at
                        \ the specified screen address to a given value and
                        \ colour

 PLA                    \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * value = A

 LDX #&FF               \ Set R = &FF, to use as a mask for drawing each row of
 STX R                  \ each character block of the bar, starting with a full
                        \ character's width of 4 pixels

 CMP T1                 \ If A >= T1 then we have passed the threshold where we
 BCS DL30               \ change bar colour, so jump to DL30 to set A to the
                        \ "high value" colour

 LDA K+1                \ Set A to K+1, the "low value" colour to use

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A5 &40, or BIT &40A5, which does nothing apart
                        \ from affect the flags

.DL30

 LDA K                  \ Set A to K, the "high value" colour to use

.DL31

 JSR tube_write         \ Send the second parameter to the I/O processor:
                        \
                        \   * colour = A

 LDA SC                 \ Send the third parameter to the I/O processor:
 JSR tube_write         \
                        \   * screen_low = SC

 LDA SC+1               \ Send the fourth parameter to the I/O processor:
 JSR tube_write         \
                        \   * sch = SC+1

 INC SC+1               \ Increment the high byte of SC to point to the next
                        \ character row on-screen (as each row takes up exactly
                        \ one page of 256 bytes) - so this sets up SC to point
                        \ to the next indicator, i.e. the one below the one we
                        \ just drew

.DL9

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DIL2
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update the roll or pitch indicator on the dashboard by sending a
\             draw_angle command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The offset of the vertical bar to show in the indicator,
\                       from 0 at the far left, to 8 in the middle, and 15 at
\                       the far right
\
\ Returns:
\
\   C flag              The C flag is set
\
\ ******************************************************************************

.DIL2

 PHA                    \ Store the new value of the indicator on the stack

 LDA #&87               \ Send command &87 to the I/O processor:
 JSR tube_write         \
                        \   draw_angle(value, screen_low, screen_high)
                        \
                        \ which will update the roll or pitch dashboard
                        \ indicator to the specified value

 PLA                    \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * value = A

 LDA SC                 \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * screen_low = SC

 LDA SC+1               \ Send the third parameter to the I/O processor:
 JSR tube_write         \
                        \   * screen_high = SC+1

 INC SC+1               \ Increment the high byte of SC to point to the next
                        \ character row on-screen (as each row takes up exactly
                        \ one page of 256 bytes) - so this sets up SC to point
                        \ to the next indicator, i.e. the one below the one we
                        \ just drew

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: HME2
\       Type: Subroutine
\   Category: Charts
\    Summary: Search the galaxy for a system
\
\ ******************************************************************************

.HME2

 LDA #14                \ Print extended token 14 ("{clear bottom of screen}
 JSR DETOK              \ PLANET NAME?{fetch line input from keyboard}"). The
                        \ last token calls MT26, which puts the entered search
                        \ term in INWK+5 and the term length in Y

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will erase the crosshairs currently there

 JSR TT81               \ Set the seeds in QQ15 (the selected system) to those
                        \ of system 0 in the current galaxy (i.e. copy the seeds
                        \ from QQ21 to QQ15)

 LDA #0                 \ We now loop through the galaxy's systems in order,
 STA XX20               \ until we find a match, so set XX20 to act as a system
                        \ counter, starting with system 0

.HME3

 JSR MT14               \ Switch to justified text when printing extended
                        \ tokens, so the call to cpl prints into the justified
                        \ text buffer at BUF instead of the screen, and DTW5
                        \ gets set to the length of the system name

 JSR cpl                \ Print the selected system name into the justified text
                        \ buffer

 LDX DTW5               \ Fetch DTW5 into X, so X is now equal to the length of
                        \ the selected system name

 LDA INWK+5,X           \ Fetch the X-th character from the entered search term

 CMP #13                \ If the X-th character is not a carriage return, then
 BNE HME6               \ the selected system name and the entered search term
                        \ are different lengths, so jump to HME6 to move on to
                        \ the next system

.HME4

 DEX                    \ Decrement X so it points to the last letter of the
                        \ selected system name (and, when we loop back here, it
                        \ points to the next letter to the left)

 LDA INWK+5,X           \ Set A to the X-th character of the entered search term

 ORA #%00100000         \ Set bit 5 of the character to make it lower case

 CMP BUF,X              \ If the character in A matches the X-th character of
 BEQ HME4               \ the selected system name in BUF, loop back to HME4 to
                        \ check the next letter to the left

 TXA                    \ The last comparison didn't match, so copy the letter
 BMI HME5               \ number into A, and if it's negative, that means we
                        \ managed to go past the first letters of each term
                        \ before we failed to get a match, so the terms are the
                        \ same, so jump to HME5 to process a successful search

.HME6

                        \ If we get here then the selected system name and the
                        \ entered search term did not match

 JSR TT20               \ We want to move on to the next system, so call TT20
                        \ to twist the three 16-bit seeds in QQ15

 INC XX20               \ Increment the system counter in XX20

 BNE HME3               \ If we haven't yet checked all 256 systems in the
                        \ current galaxy, loop back to HME3 to check the next
                        \ system

                        \ If we get here then the entered search term did not
                        \ match any systems in the current galaxy

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10), so we can put the crosshairs back where
                        \ they were before the search

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10)

 LDA #40                \ Call the NOISE routine with A = 40 to make a low,
 JSR NOISE              \ long beep to indicate a failed search

 LDA #215               \ Print extended token 215 ("{left align} UNKNOWN
 JMP DETOK              \ PLANET"), which will print on-screen as the left align
                        \ code disables justified text, and return from the
                        \ subroutine using a tail call

.HME5

                        \ If we get here then we have found a match for the
                        \ entered search

 LDA QQ15+3             \ The x-coordinate of the system described by the seeds
 STA QQ9                \ in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
                        \ as the x-coordinate of the search result

 LDA QQ15+1             \ The y-coordinate of the system described by the seeds
 STA QQ10               \ in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
                        \ as the y-coordinate of the search result

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10)

 JSR MT15               \ Switch to left-aligned text when printing extended
                        \ tokens so future tokens will print to the screen (as
                        \ this disables justified text)

 JMP T95                \ Jump to T95 to print the distance to the selected
                        \ system and return from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\ Save ELTB.bin
\
\ ******************************************************************************

 PRINT "ELITE B"
 PRINT "Assembled at ", ~CODE_B%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_B%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_B%

 PRINT "S.2.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
\SAVE "3-assembled-output/2.ELTB.bin", CODE_B%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE C FILE
\
\ ******************************************************************************

 CODE_C% = P%
 LOAD_C% = LOAD% +P% - CODE%

\ ******************************************************************************
\
\       Name: HATB
\       Type: Variable
\   Category: Ship hangar
\    Summary: Ship hangar group table
\
\ ------------------------------------------------------------------------------
\
\ This table contains groups of ships to show in the ship hangar. A group of
\ ships is shown half the time (the other half shows a solo ship), and each of
\ the four groups is equally likely.
\
\ The bytes for each ship in the group contain the following information:
\
\   Byte #0             Non-zero = Ship type to draw
\                       0        = don't draw anything
\
\   Byte #1             Bits 0-7 = Ship's x_hi
\                       Bit 0    = Ship's z_hi (1 if clear, or 2 if set)
\
\   Byte #2             Bits 0-7 = Ship's z_lo
\                       Bit 0    = Ship's x_sign
\
\ The ship's y-coordinate is calculated in the has1 routine from the size of
\ its targetable area. Ships of type 0 are not shown.
\
\ Note that ship numbers are for the ship hangar blueprints at XX21 in the
\ docked code, rather than the full set of ships in the flight code. They are:
\
\   1 = Cargo canister
\   2 = Shuttle
\   3 = Transporter
\   4 = Cobra Mk III
\   5 = Python
\   6 = Viper
\   7 = Krait
\   8 = Constrictor
\
\ ******************************************************************************

.HATB

                        \ Hangar group for X = 0
                        \
                        \ Shuttle (left) and Transporter (right)

 EQUB 2                 \ Ship type in the hangar = 2 = Shuttle
 EQUB %01010100         \ x_hi = %01010100 = 84, z_hi   = 1     -> x = -84
 EQUB %00111011         \ z_lo = %00111011 = 59, x_sign = 1        z = +315

 EQUB 3                 \ Ship type in the hangar = 3 = Transporter
 EQUB %10000010         \ x_hi = %10000010 = 130, z_hi   = 1    -> x = +130
 EQUB %10110000         \ z_lo = %10110000 = 176, x_sign = 0       z = +432

 EQUB 0                 \ No third ship
 EQUB 0
 EQUB 0

                        \ Hangar group for X = 9
                        \
                        \ Three cargo canisters (left, far right and forward,
                        \ right)

 EQUB 1                 \ Ship type in the hangar = 1 = Cargo canister
 EQUB %01010000         \ x_hi = %01010000 = 80, z_hi   = 1     -> x = -80
 EQUB %00010001         \ z_lo = %00010001 = 17, x_sign = 1        z = +273

 EQUB 1                 \ Ship type in the hangar = 1 = Cargo canister
 EQUB %11010001         \ x_hi = %11010001 = 209, z_hi = 2      -> x = +209
 EQUB %00101000         \ z_lo = %00101000 =  40, x_sign = 0       z = +552

 EQUB 1                 \ Ship type in the hangar = 1 = Cargo canister
 EQUB %01000000         \ x_hi = %01000000 = 64, z_hi   = 1     -> x = +64
 EQUB %00000110         \ z_lo = %00000110 = 6,  x_sign = 0        z = +262

                        \ Hangar group for X = 18
                        \
                        \ Transporter (right) and Cobra Mk III (left)

 EQUB 3                 \ Ship type in the hangar = 3 = Transporter
 EQUB %01100000         \ x_hi = %01100000 =  96, z_hi   = 1    -> x = +96
 EQUB %10010000         \ z_lo = %10010000 = 144, x_sign = 0       z = +400

 EQUB 4                 \ Ship type in the hangar = 4 = Cobra Mk III
 EQUB %00010000         \ x_hi = %00010000 =  16, z_hi   = 1    -> x = -16
 EQUB %11010001         \ z_lo = %11010001 = 209, x_sign = 1       z = +465

 EQUB 0                 \ No third ship
 EQUB 0
 EQUB 0

                        \ Hangar group for X = 27
                        \
                        \ Viper (right and forward) and Krait (left)

 EQUB 6                 \ Ship type in the hangar = 6 = Viper
 EQUB %01010001         \ x_hi = %01010001 =  81, z_hi  = 2     -> x = +81
 EQUB %11111000         \ z_lo = %11111000 = 248, x_sign = 0       z = +760

 EQUB 7                 \ Ship type in the hangar = 7 = Krait
 EQUB %01100000         \ x_hi = %01100000 = 96,  z_hi   = 1    -> x = -96
 EQUB %01110101         \ z_lo = %01110101 = 117, x_sign = 1       z = +373

 EQUB 0                 \ No third ship
 EQUB 0
 EQUB 0

\ ******************************************************************************
\
\       Name: HALL
\       Type: Subroutine
\   Category: Ship hangar
\    Summary: Draw the ships in the ship hangar, then draw the hangar
\
\ ------------------------------------------------------------------------------
\
\ Half the time this will draw one of the four pre-defined ship hangar groups in
\ HATB, and half the time this will draw a solitary Sidewinder, Mamba, Krait or
\ Adder on a random position. In all cases, the ships will be randomly spun
\ around on the ground so they can face in any direction, and larger ships are
\ drawn higher up off the ground than smaller ships.
\
\ ******************************************************************************

.HALL

 JSR UNWISE             \ Call UNWISE to switch the main line-drawing routine
                        \ between EOR and OR logic (in this case, switching it
                        \ to OR logic so that it overwrites anything that's
                        \ on-screen)

 LDA #0                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 0 (space
                        \ view)

 JSR DORND              \ Set A and X to random numbers

 BPL HA7                \ Jump to HA7 if A is positive (50% chance)

 AND #3                 \ Reduce A to a random number in the range 0-3

 STA T                  \ Set X = A * 8 + A
 ASL A                  \       = 9 * A
 ASL A                  \
 ASL A                  \ so X is a random number, either 0, 9, 18 or 27
 ADC T
 TAX

                        \ The following double loop calls the HAS1 routine three
                        \ times to display three ships on screen. For each call,
                        \ the values passed to HAS1 in XX15+2 to XX15 are taken
                        \ from the HATB table, depending on the value in X, as
                        \ follows:
                        \
                        \   * If X = 0,  pass bytes #0 to #2 of HATB to HAS1
                        \                then bytes #3 to #5
                        \                then bytes #6 to #8
                        \
                        \   * If X = 9,  pass bytes  #9 to #11 of HATB to HAS1
                        \                then bytes #12 to #14
                        \                then bytes #15 to #17
                        \
                        \   * If X = 18, pass bytes #18 to #20 of HATB to HAS1
                        \                then bytes #21 to #23
                        \                then bytes #24 to #26
                        \
                        \   * If X = 27, pass bytes #27 to #29 of HATB to HAS1
                        \                then bytes #30 to #32
                        \                then bytes #33 to #35
                        \
                        \ Note that the values are passed in reverse, so for the
                        \ first call, for example, where we pass bytes #0 to #2
                        \ of HATB to HAS1, we call HAS1 with:
                        \
                        \   XX15   = HATB+2
                        \   XX15+1 = HATB+1
                        \   XX15+2 = HATB

 LDY #3                 \ Set CNT2 = 3 to act as an outer loop counter going
 STY CNT2               \ from 3 to 1, so the HAL8 loop is run 3 times

.HAL8

 LDY #2                 \ Set Y = 2 to act as an inner loop counter going from
                        \ 2 to 0

.HAL9

 LDA HATB,X             \ Copy the X-th byte of HATB to the Y-th byte of XX15,
 STA XX15,Y             \ as described above

 INX                    \ Increment X to point to the next byte in HATB

 DEY                    \ Decrement Y to point to the previous byte in XX15

 BPL HAL9               \ Loop back to copy the next byte until we have copied
                        \ three of them (i.e. Y was 3 before the DEY)

 TXA                    \ Store X on the stack so we can retrieve it after the
 PHA                    \ call to HAS1 (as it contains the index of the next
                        \ byte in HATB

 JSR HAS1               \ Call HAS1 to draw this ship in the hangar

 PLA                    \ Restore the value of X, so X points to the next byte
 TAX                    \ in HATB after the three bytes we copied into XX15

 DEC CNT2               \ Decrement the outer loop counter in CNT2

 BNE HAL8               \ Loop back to HAL8 to do it 3 times, once for each ship
                        \ in the HATB table

 LDY #128               \ Set Y = 128 to send as byte #2 of the parameter block
                        \ to the OSWORD 248 command below, to tell the I/O
                        \ processor that there are multiple ships in the hangar

 BNE HA9                \ Jump to HA9 to display the ship hangar (this BNE is
                        \ effectively a JMP as Y is never zero)

.HA7

                        \ If we get here, A is a positive random number in the
                        \ range 0-127

 LSR A                  \ Set XX15+1 = A / 2 (random number 0-63)
 STA XX15+1

 JSR DORND              \ Set XX15 = random number 0-255
 STA XX15

 JSR DORND              \ Set XX15+2 = random number 0-7
 AND #7                 \
 STA XX15+2             \ which is either 0 (no ships in the hangar) or one of
                        \ the first 7 ship types in the ship hangar blueprints
                        \ table, i.e. a cargo canister, Shuttle, Transporter,
                        \ Cobra Mk III, Python, Viper or Krait

 JSR HAS1               \ Call HAS1 to draw this ship in the hangar, with the
                        \ following properties:
                        \
                        \   * Random x-coordinate from -63 to +63
                        \
                        \   * Randomly chosen cargo canister, Shuttle,
                        \     Transporter, Cobra Mk III, Python, Viper or Krait
                        \
                        \   * Random z-coordinate from +256 to +639

 LDY #0                 \ Set Y = 0 to use in the following instruction, to tell
                        \ the hangar-drawing routine that there is just one ship
                        \ in the hangar, so it knows not to draw between the
                        \ ships

.HA9

 STY YSAV               \ Store Y in YSAV to specify whether there are multiple
                        \ ships in the hangar

 JSR UNWISE             \ Call UNWISE to switch the main line-drawing routine
                        \ between EOR and OR logic (in this case, switching it
                        \ back to EOR logic so that we can erase anything we
                        \ draw on-screen)

                        \ Fall through into HANGER to draw the hangar background

\ ******************************************************************************
\
\       Name: HANGER
\       Type: Subroutine
\   Category: Ship hangar
\    Summary: Display the ship hangar by sending picture_h and picture_v
\             commands to the I/O processor
\
\ ******************************************************************************

.HANGER

                        \ We start by drawing the floor

 LDX #2                 \ We start with a loop using a counter in T that goes
                        \ from 2 to 12, one for each of the 11 horizontal lines
                        \ in the floor, so set the initial value in X

.HAL1

 STX XSAV               \ Store the loop counter in XSAV

 LDA #130               \ Set A = 130

 LDX XSAV               \ Retrieve the loop counter from XSAV

 STX Q                  \ Set Q = T

 JSR DVID4              \ Calculate the following:
                        \
                        \   (P R) = 256 * A / Q
                        \         = 256 * 130 / T
                        \
                        \ so P = 130 / T, and as the counter T goes from 2 to
                        \ 12, P goes 65, 43, 32 ... 13, 11, 10, with the
                        \ difference between two consecutive numbers getting
                        \ smaller as P gets smaller
                        \
                        \ We can use this value as a y-coordinate to draw a set
                        \ of horizontal lines, spaced out near the bottom of the
                        \ screen (high value of P, high y-coordinate, lower down
                        \ the screen) and bunching up towards the horizon (low
                        \ value of P, low y-coordinate, higher up the screen)

 LDA #&9A               \ Send command &9A to the I/O processor:
 JSR tube_write         \
                        \   picture_h(line_count, multiple_ships)
                        \
                        \ which will draw the specified number of horizontal
                        \ lines as the hangar floor, drawing lines between
                        \ multiple ships if required

 LDA P                  \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * line_count = P

 LDA YSAV               \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * multiple_ships = YSAV

 LDX XSAV               \ Fetch the loop counter from XSAV and increment it
 INX

 CPX #13                \ If the loop counter is less than 13 (i.e. 2 to 12)
 BCC HAL1               \ then loop back to HAL1 to draw the next line

                        \ The floor is done, so now we move on to the back wall

 LDA #16                \ We want to draw 15 vertical lines, one every 16 pixels
                        \ across the screen, with the first at x-coordinate 16,
                        \ so set this in A to act as the x-coordinate of each
                        \ line as we work our way through them from left to
                        \ right, incrementing by 16 for each new line

.HAL6

 STA XSAV               \ Store this value in XSAV, so we can retrieve it later

 LDA #&9B               \ Send command &9B to the I/O processor:
 JSR tube_write         \
                        \   picture_v(line_count)
                        \
                        \ which will draw the specified number of vertical
                        \ lines as the back wall of the hangar

 LDA XSAV               \ Send the parameter to the I/O processor:
 JSR tube_write         \
                        \   * line_count = XSAV

 LDA XSAV               \ Fetch the x-coordinate of the line we just drew from
 CLC                    \ XSAV into A, and add 16 so that A contains the
 ADC #16                \ x-coordinate of the next line to draw

 BNE HAL6               \ Loop back to HAL6 until we have run through the loop
                        \ 60 times, by which point we are most definitely done

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: HAS1
\       Type: Subroutine
\   Category: Ship hangar
\    Summary: Draw a ship in the ship hangar
\
\ ------------------------------------------------------------------------------
\
\ The ship's position within the hangar is determined by the arguments and the
\ size of the ship's targetable area, as follows:
\
\   * The x-coordinate is (x_sign x_hi 0) from the arguments, so the ship can be
\     left of centre or right of centre
\
\   * The y-coordinate is negative and is lower down the screen for smaller
\     ships, so smaller ships are drawn closer to the ground (because they are)
\
\   * The z-coordinate is positive, with both z_hi (which is 1 or 2) and z_lo
\     coming from the arguments
\
\ Arguments:
\
\   XX15                Bits 0-7 = Ship's z_lo
\                       Bit 0    = Ship's x_sign
\
\   XX15+1              Bits 0-7 = Ship's x_hi
\                       Bit 0    = Ship's z_hi (1 if clear, or 2 if set)
\
\   XX15+2              Non-zero = Ship type to draw
\                       0        = Don't draw anything
\
\ ******************************************************************************

.HAS1

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace and reset
                        \ the orientation vectors, with nosev pointing out of
                        \ the screen, so this puts the ship flat on the
                        \ horizontal deck (the y = 0 plane) with its nose
                        \ pointing towards us

 LDA XX15               \ Set z_lo = XX15
 STA INWK+6

 LSR A                  \ Set the sign bit of x_sign to bit 0 of A
 ROR INWK+2

 LDA XX15+1             \ Set x_hi = XX15+1
 STA INWK

 LSR A                  \ Set z_hi = 1 + bit 0 of XX15+1
 LDA #1
 ADC #0
 STA INWK+7

 LDA #%10000000         \ Set bit 7 of y_sign, so y is negative
 STA INWK+5

 STA RAT2               \ Set RAT2 = %10000000, so the yaw calls in HAL5 below
                        \ are negative

 LDA #&0B               \ Set the ship line heap pointer in INWK(34 33) to point
 STA INWK+34            \ to &0B00

 JSR DORND              \ We now perform a random number of small angle (3.6
 STA XSAV               \ degree) rotations to spin the ship on the deck while
                        \ keeping it flat on the deck (a bit like spinning a
                        \ bottle), so we set XSAV to a random number between 0
                        \ and 255 for the number of small yaw rotations to
                        \ perform, so the ship could be pointing in any
                        \ direction by the time we're done

.HAL5

 LDX #21                \ Rotate (sidev_x, nosev_x) by a small angle (yaw)
 LDY #9
 JSR MVS5

 LDX #23                \ Rotate (sidev_y, nosev_y) by a small angle (yaw)
 LDY #11
 JSR MVS5

 LDX #25                \ Rotate (sidev_z, nosev_z) by a small angle (yaw)
 LDY #13
 JSR MVS5

 DEC XSAV               \ Decrement the yaw counter in XSAV

 BNE HAL5               \ Loop back to yaw a little more until we have yawed
                        \ by the number of times in XSAV

 LDY XX15+2             \ Set Y = XX15+2, the ship type of the ship we need to
                        \ draw

 BEQ HA1                \ If Y = 0, return from the subroutine (as HA1 contains
                        \ an RTS)

                        \ We now work our way through the ship blueprints table
                        \ for the hangar, counting valid blueprints until we
                        \ have found the Y-th valid blueprint (we do this as the
                        \ hangar blueprint table at XX21 is not fully populated,
                        \ so the Y-th ship is not necessarily at position Y)

 LDX #4                 \ We can start looking from ship blueprint 3, because we
                        \ don't show ship 1 (missile) or ship 2 (space station)
                        \ in the hangar. Setting X to 4, which then gets
                        \ incremented to 6, will start us at XX21(5 4), which is
                        \ the address of ship blueprint 3 (escape pod)

.hloop

 INX                    \ Increment X by 2 to point to the next blueprint in the
 INX                    \ table

 LDA XX21-2,X           \ Set XX0(1 0) to the X-th address in the ship blueprint
 STA XX0                \ address lookup table at XX21, so XX0(1 0) now points
 LDA XX21-1,X           \ to the blueprint for the ship we need to draw
 STA XX0+1

 BEQ hloop              \ If the high byte of the blueprint address is 0, then
                        \ the blueprint for this ship is not available, so jump
                        \ back to hloop to try the next ship along in the table

 DEY                    \ We have found a valid blueprint, so decrement the ship
                        \ number that we are looking for in Y

 BNE hloop              \ If Y is not yet zero, we still haven't found the Y-th
                        \ valid blueprint, so loop back to hloop to try the next
                        \ ship along in the table

 LDY #1                 \ Set Q = ship byte #1
 LDA (XX0),Y
 STA Q

 INY                    \ Set R = ship byte #2
 LDA (XX0),Y            \
 STA R                  \ so (R Q) contains the ship's targetable area, which is
                        \ a square number

 JSR LL5                \ Set Q = SQRT(R Q)

 LDA #100               \ Set y_lo = (100 - Q) / 2
 SBC Q                  \
 LSR A                  \ so the bigger the ship's targetable area, the smaller
 STA INWK+3             \ the magnitude of the y-coordinate, so because we set
                        \ y_sign to be negative above, this means smaller ships
                        \ are drawn lower down, i.e. closer to the ground, while
                        \ larger ships are drawn higher up, as you would expect

 JSR TIDY               \ Call TIDY to tidy up the orientation vectors, to
                        \ prevent the ship from getting elongated and out of
                        \ shape due to the imprecise nature of trigonometry
                        \ in assembly language

 JMP LL9                \ Jump to LL9 to display the ship and return from the
                        \ subroutine using a tail call

.HA1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UNWISE
\       Type: Subroutine
\   Category: Ship hangar
\    Summary: Switch the main line-drawing routine between EOR and OR logic by
\             sending a draw_mode command to the I/O processor
\
\ ******************************************************************************

.UNWISE

 LDA #&94               \ Send command &94 to the I/O processor:
 JMP tube_write         \
                        \   draw_mode()
                        \
                        \ which will toggle the line drawing mode between EOR
                        \ and OR, and return from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: HFS1
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Draw the launch or hyperspace tunnel
\
\ ------------------------------------------------------------------------------
\
\ The animation gets drawn like this. First, we draw a circle of radius 8 at the
\ centre, and then double the radius, draw another circle, double the radius
\ again and draw a circle, and we keep doing this until the radius is bigger
\ than 160 (which goes beyond the edge of the screen, which is 256 pixels wide,
\ equivalent to a radius of 128). We then repeat this whole process for an
\ initial circle of radius 9, then radius 10, all the way up to radius 15.
\
\ This has the effect of making the tunnel appear to be racing towards us as we
\ hurtle out into hyperspace or through the space station's docking tunnel.
\
\ The hyperspace effect is done in a full mode 5 screen, which makes the rings
\ all coloured and zig-zaggy, while the launch screen is in the normal
\ monochrome mode 4 screen.
\
\ ******************************************************************************

.HFS1

 LDX #X                 \ Set K3 = #X (the x-coordinate of the centre of the
 STX K3                 \ screen)

 LDX #Y                 \ Set K4 = #Y (the y-coordinate of the centre of the
 STX K4                 \ screen)

 LDX #0                 \ Set X = 0

 STX XX4                \ Set XX4 = 0, which we will use as a counter for
                        \ drawing eight concentric rings

 STX K3+1               \ Set the high bytes of K3(1 0) and K4(1 0) to 0
 STX K4+1

.HFL5

 JSR HFL1               \ Call HFL1 below to draw a set of rings, with each one
                        \ twice the radius of the previous one, until they won't
                        \ fit on-screen

 INC XX4                \ Increment the counter and fetch it into X
 LDX XX4

 CPX #8                 \ If we haven't drawn 8 sets of rings yet, loop back to
 BNE HFL5               \ HFL5 to draw the next ring

 RTS                    \ Return from the subroutine

.HFL1

 LDA XX4                \ Set K to the ring number in XX4 (0-7) + 8, so K has
 AND #7                 \ a value of 8 to 15, which we will use as the starting
 CLC                    \ radius for our next set of rings
 ADC #8
 STA K

.HFL2

 LDA #1                 \ Set LSP = 1 to reset the ball line heap
 STA LSP

 JSR CIRCLE2            \ Call CIRCLE2 to draw a circle with the centre at
                        \ (K3(1 0), K4(1 0)) and radius K

 ASL K                  \ Double the radius in K

 BCS HF8                \ If the radius had a 1 in bit 7 before the above shift,
                        \ then doubling K will means the circle will no longer
                        \ fit on the screen (which is width 256), so jump to
                        \ HF8 to stop drawing circles

 LDA K                  \ If the radius in K <= 160, loop back to HFL2 to draw
 CMP #160               \ another one
 BCC HFL2

.HF8

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SQUA
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Clear bit 7 of A and calculate (A P) = A * A
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of unsigned 8-bit numbers, after first
\ clearing bit 7 of A:
\
\   (A P) = A * A
\
\ ******************************************************************************

.SQUA

 AND #%01111111         \ Clear bit 7 of A and fall through into SQUA2 to set
                        \ (A P) = A * A

\ ******************************************************************************
\
\       Name: SQUA2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A P) = A * A
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of unsigned 8-bit numbers:
\
\   (A P) = A * A
\
\ ******************************************************************************

.SQUA2

 STA P                  \ Copy A into P and X
 TAX

 BNE MU11               \ If X = 0 fall through into MU1 to return a 0,
                        \ otherwise jump to MU11 to return P * X

\ ******************************************************************************
\
\       Name: MU1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Copy X into P and A, and clear the C flag
\
\ ------------------------------------------------------------------------------
\
\ Used to return a 0 result quickly from MULTU below.
\
\ ******************************************************************************

.MU1

 CLC                    \ Clear the C flag

 STX P                  \ Copy X into P and A
 TXA

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MULTU
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A P) = P * Q
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of unsigned 8-bit numbers:
\
\   (A P) = P * Q
\
\ ******************************************************************************

.MULTU

 LDX Q                  \ Set X = Q

 BEQ MU1                \ If X = Q = 0, jump to MU1 to copy X into P and A,
                        \ clear the C flag and return from the subroutine using
                        \ a tail call

                        \ Otherwise fall through into MU11 to set (A P) = P * X

\ ******************************************************************************
\
\       Name: MU11
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A P) = P * X
\  Deep dive: Shift-and-add multiplication
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of two unsigned 8-bit numbers:
\
\   (A P) = P * X
\
\ This uses the same shift-and-add approach as MULT1, but it's simpler as we
\ are dealing with unsigned numbers in P and X. See the deep dive on
\ "Shift-and-add multiplication" for a discussion of how this algorithm works.
\
\ ******************************************************************************

.MU11

 DEX                    \ Set T = X - 1
 STX T                  \
                        \ We subtract 1 as the C flag will be set when we want
                        \ to do an addition in the loop below

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LDX #8                 \ Set up a counter in X to count the 8 bits in P

 LSR P                  \ Set P = P >> 1
                        \ and C flag = bit 0 of P

                        \ We are now going to work our way through the bits of
                        \ P, and do a shift-add for any bits that are set,
                        \ keeping the running total in A. We just did the first
                        \ shift right, so we now need to do the first add and
                        \ loop through the other bits in P

.MUL6

 BCC P%+4               \ If C (i.e. the next bit from P) is set, do the
 ADC T                  \ addition for this bit of P:
                        \
                        \   A = A + T + C
                        \     = A + X - 1 + 1
                        \     = A + X

 ROR A                  \ Shift A right to catch the next digit of our result,
                        \ which the next ROR sticks into the left end of P while
                        \ also extracting the next bit of P

 ROR P                  \ Add the overspill from shifting A to the right onto
                        \ the start of P, and shift P right to fetch the next
                        \ bit for the calculation into the C flag

 DEX                    \ Decrement the loop counter

 BNE MUL6               \ Loop back for the next bit until P has been rotated
                        \ all the way

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FMLTU2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate A = K * sin(A)
\  Deep dive: The sine, cosine and arctan tables
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   A = K * sin(A)
\
\ Because this routine uses the sine lookup table SNE, we can also call this
\ routine to calculate cosine multiplication. To calculate the following:
\
\   A = K * cos(B)
\
\ call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
\
\ ******************************************************************************

.FMLTU2

 AND #%00011111         \ Restrict A to bits 0-5 (so it's in the range 0-31)

 TAX                    \ Set Q = sin(A) * 256
 LDA SNE,X
 STA Q

 LDA K                  \ Set A to the radius in K

                        \ Fall through into FMLTU to do the following:
                        \
                        \   (A ?) = A * Q
                        \         = K * sin(A) * 256
                        \
                        \ which is equivalent to:
                        \
                        \   A = K * sin(A)

\ ******************************************************************************
\
\       Name: FMLTU
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate A = A * Q / 256
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of two unsigned 8-bit numbers, returning only
\ the high byte of the result:
\
\   (A ?) = A * Q
\
\ or, to put it another way:
\
\   A = A * Q / 256
\
\ Returns:
\
\   C flag              The C flag is set
\
\ ******************************************************************************

.FMLTU

 EOR #%11111111         \ Flip the bits in A, set the C flag and rotate right,
 SEC                    \ so the C flag now contains bit 0 of A inverted, and P
 ROR A                  \ contains A inverted and shifted right by one, with bit
 STA P                  \ 7 set to a 1. We can now use P as our source of bits
                        \ to shift right, just as in MU11, just with the logic
                        \ reversed

 LDA #0                 \ Set A = 0 so we can start building the answer in A

.MUL3

 BCS MU7                \ If C (i.e. the next bit from P) is set, do not do the
                        \ addition for this bit of P, and instead skip to MU7
                        \ to just do the shifts

 ADC Q                  \ Do the addition for this bit of P:
                        \
                        \   A = A + Q + C
                        \     = A + Q

 ROR A                  \ Shift A right to catch the next digit of our result.
                        \ If we were interested in the low byte of the result we
                        \ would want to save the bit that falls off the end, but
                        \ we aren't, so we can ignore it

 LSR P                  \ Shift P right to fetch the next bit for the
                        \ calculation into the C flag

 BNE MUL3               \ Loop back to MUL3 if P still contains some set bits
                        \ (so we loop through the bits of P until we get to the
                        \ 1 we inserted before the loop, and then we stop)

                        \ If we get here then the C flag is set as we just
                        \ rotated a 1 out of the right end of P

 RTS                    \ Return from the subroutine

.MU7

 LSR A                  \ Shift A right to catch the next digit of our result,
                        \ pushing a 0 into bit 7 as we aren't adding anything
                        \ here (we can't use a ROR here as the C flag is set, so
                        \ a ROR would push a 1 into bit 7)

 LSR P                  \ Fetch the next bit from P into the C flag

 BNE MUL3               \ Loop back to MUL3 if P still contains some set bits
                        \ (so we loop through the bits of P until we get to the
                        \ 1 we inserted before the loop, and then we stop)

                        \ If we get here then the C flag is set as we just
                        \ rotated a 1 out of the right end of P

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MULT1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A P) = Q * A
\  Deep dive: Shift-and-add multiplication
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of two 8-bit sign-magnitude numbers:
\
\   (A P) = Q * A
\
\ ******************************************************************************

.MULT1

 TAX                    \ Store A in X

 AND #%01111111         \ Set P = |A| >> 1
 LSR A                  \ and C flag = bit 0 of A
 STA P

 TXA                    \ Restore argument A

 EOR Q                  \ Set bit 7 of A and T if Q and A have different signs,
 AND #%10000000         \ clear bit 7 if they have the same signs, 0 all other
 STA T                  \ bits, i.e. T contains the sign bit of Q * A

 LDA Q                  \ Set A = |Q|
 AND #%01111111

 BEQ mu10               \ If |Q| = 0 jump to mu10 (with A set to 0)

 TAX                    \ Set T1 = |Q| - 1
 DEX                    \
 STX T1                 \ We subtract 1 as the C flag will be set when we want
                        \ to do an addition in the loop below

                        \ We are now going to work our way through the bits of
                        \ P, and do a shift-add for any bits that are set,
                        \ keeping the running total in A. We already set up
                        \ the first shift at the start of this routine, as
                        \ P = |A| >> 1 and C = bit 0 of A, so we now need to set
                        \ up a loop to sift through the other 7 bits in P

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LDX #7                 \ Set up a counter in X to count the 7 bits remaining
                        \ in P

.MUL4

 BCC P%+4               \ If C (i.e. the next bit from P) is set, do the
 ADC T1                 \ addition for this bit of P:
                        \
                        \   A = A + T1 + C
                        \     = A + |Q| - 1 + 1
                        \     = A + |Q|

 ROR A                  \ As mentioned above, this ROR shifts A right and
                        \ catches bit 0 in C - giving another digit for our
                        \ result - and the next ROR sticks that bit into the
                        \ left end of P while also extracting the next bit of P
                        \ for the next addition

 ROR P                  \ Add the overspill from shifting A to the right onto
                        \ the start of P, and shift P right to fetch the next
                        \ bit for the calculation

 DEX                    \ Decrement the loop counter

 BNE MUL4               \ Loop back for the next bit until P has been rotated
                        \ all the way

 LSR A                  \ Rotate (A P) once more to get the final result, as
 ROR P                  \ we only pushed 7 bits through the above process

 ORA T                  \ Set the sign bit of the result that we stored in T

 RTS                    \ Return from the subroutine

.mu10

 STA P                  \ If we get here, the result is 0 and A = 0, so set
                        \ P = 0 so (A P) = 0

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MULT12
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (S R) = Q * A
\
\ ------------------------------------------------------------------------------
\
\ Calculate:
\
\   (S R) = Q * A
\
\ ******************************************************************************

.MULT12

 JSR MULT1              \ Set (A P) = Q * A

 STA S                  \ Set (S R) = (A P)
 LDA P                  \           = Q * A
 STA R

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MAD
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A X) = Q * A + (S R)
\
\ ------------------------------------------------------------------------------
\
\ Calculate
\
\   (A X) = Q * A + (S R)
\
\ ******************************************************************************

.MAD

 JSR MULT1              \ Call MULT1 to set (A P) = Q * A

                        \ Fall through into ADD to do:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = Q * A + (S R)

\ ******************************************************************************
\
\       Name: ADD
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A X) = (A P) + (S R)
\  Deep dive: Adding sign-magnitude numbers
\
\ ------------------------------------------------------------------------------
\
\ Add two 16-bit sign-magnitude numbers together, calculating:
\
\   (A X) = (A P) + (S R)
\
\ ******************************************************************************

.ADD

 STA T1                 \ Store argument A in T1

 AND #%10000000         \ Extract the sign (bit 7) of A and store it in T
 STA T

 EOR S                  \ EOR bit 7 of A with S. If they have different bit 7s
 BMI MU8                \ (i.e. they have different signs) then bit 7 in the
                        \ EOR result will be 1, which means the EOR result is
                        \ negative. So the AND, EOR and BMI together mean "jump
                        \ to MU8 if A and S have different signs"

                        \ If we reach here, then A and S have the same sign, so
                        \ we can add them and set the sign to get the result

 LDA R                  \ Add the least significant bytes together into X:
 CLC                    \
 ADC P                  \   X = P + R
 TAX

 LDA S                  \ Add the most significant bytes together into A. We
 ADC T1                 \ stored the original argument A in T1 earlier, so we
                        \ can do this with:
                        \
                        \   A = A  + S + C
                        \     = T1 + S + C

 ORA T                  \ If argument A was negative (and therefore S was also
                        \ negative) then make sure result A is negative by
                        \ OR'ing the result with the sign bit from argument A
                        \ (which we stored in T)

 RTS                    \ Return from the subroutine

.MU8

                        \ If we reach here, then A and S have different signs,
                        \ so we can subtract their absolute values and set the
                        \ sign to get the result

 LDA S                  \ Clear the sign (bit 7) in S and store the result in
 AND #%01111111         \ U, so U now contains |S|
 STA U

 LDA P                  \ Subtract the least significant bytes into X:
 SEC                    \
 SBC R                  \   X = P - R
 TAX

 LDA T1                 \ Restore the A of the argument (A P) from T1 and
 AND #%01111111         \ clear the sign (bit 7), so A now contains |A|

 SBC U                  \ Set A = |A| - |S|

                        \ At this point we have |A P| - |S R| in (A X), so we
                        \ need to check whether the subtraction above was the
                        \ right way round (i.e. that we subtracted the smaller
                        \ absolute value from the larger absolute value)

 BCS MU9                \ If |A| >= |S|, our subtraction was the right way
                        \ round, so jump to MU9 to set the sign

                        \ If we get here, then |A| < |S|, so our subtraction
                        \ above was the wrong way round (we actually subtracted
                        \ the larger absolute value from the smaller absolute
                        \ value). So let's subtract the result we have in (A X)
                        \ from zero, so that the subtraction is the right way
                        \ round

 STA U                  \ Store A in U

 TXA                    \ Set X = 0 - X using two's complement (to negate a
 EOR #&FF               \ number in two's complement, you can invert the bits
 ADC #1                 \ and add one - and we know the C flag is clear as we
 TAX                    \ didn't take the BCS branch above, so the ADC will do
                        \ the correct addition)

 LDA #0                 \ Set A = 0 - A, which we can do this time using a
 SBC U                  \ subtraction with the C flag clear

 ORA #%10000000         \ We now set the sign bit of A, so that the EOR on the
                        \ next line will give the result the opposite sign to
                        \ argument A (as T contains the sign bit of argument
                        \ A). This is the same as giving the result the same
                        \ sign as argument S (as A and S have different signs),
                        \ which is what we want, as S has the larger absolute
                        \ value

.MU9

 EOR T                  \ If we get here from the BCS above, then |A| >= |S|,
                        \ so we want to give the result the same sign as
                        \ argument A, so if argument A was negative, we flip
                        \ the sign of the result with an EOR (to make it
                        \ negative)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TIS1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A ?) = (-X * A + (S R)) / 96
\  Deep dive: Shift-and-subtract division
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following expression between sign-magnitude numbers, ignoring
\ the low byte of the result:
\
\   (A ?) = (-X * A + (S R)) / 96
\
\ This uses the same shift-and-subtract algorithm as TIS2, just with the
\ quotient A hard-coded to 96.
\
\ Returns:
\
\   Q                   Gets set to the value of argument X
\
\ ******************************************************************************

.TIS1

 STX Q                  \ Set Q = X

 EOR #%10000000         \ Flip the sign bit in A

 JSR MAD                \ Set (A X) = Q * A + (S R)
                        \           = X * -A + (S R)

.DVID96

 TAX                    \ Set T to the sign bit of the result
 AND #%10000000
 STA T

 TXA                    \ Set A to the high byte of the result with the sign bit
 AND #%01111111         \ cleared, so (A ?) = |X * A + (S R)|

                        \ The following is identical to TIS2, except Q is
                        \ hard-coded to 96, so this does A = A / 96

 LDX #254               \ Set T1 to have bits 1-7 set, so we can rotate through
 STX T1                 \ 7 loop iterations, getting a 1 each time, and then
                        \ getting a 0 on the 8th iteration... and we can also
                        \ use T1 to catch our result bits into bit 0 each time

.DVL3

 ASL A                  \ Shift A to the left

 CMP #96                \ If A < 96 skip the following subtraction
 BCC DV4

 SBC #96                \ Set A = A - 96
                        \
                        \ Going into this subtraction we know the C flag is
                        \ set as we passed through the BCC above, and we also
                        \ know that A >= 96, so the C flag will still be set
                        \ once we are done

.DV4

 ROL T1                 \ Rotate the counter in T1 to the left, and catch the
                        \ result bit into bit 0 (which will be a 0 if we didn't
                        \ do the subtraction, or 1 if we did)

 BCS DVL3               \ If we still have set bits in T1, loop back to DVL3 to
                        \ do the next iteration of 7

 LDA T1                 \ Fetch the result from T1 into A

 ORA T                  \ Give A the sign of the result that we stored above

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DVID4
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (P R) = 256 * A / Q
\  Deep dive: Shift-and-subtract division
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following division and remainder:
\
\   P = A / Q
\
\   R = remainder as a fraction of Q, where 1.0 = 255
\
\ Another way of saying the above is this:
\
\   (P R) = 256 * A / Q
\
\ This uses the same shift-and-subtract algorithm as TIS2, but this time we
\ keep the remainder.
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.DVID4

 LDX #8                 \ Set a counter in X to count the 8 bits in A

 ASL A                  \ Shift A left and store in P (we will build the result
 STA P                  \ in P)

 LDA #0                 \ Set A = 0 for us to build a remainder

.DVL4

 ROL A                  \ Shift A to the left

 BCS DV8                \ If the C flag is set (i.e. bit 7 of A was set) then
                        \ skip straight to the subtraction

 CMP Q                  \ If A < Q skip the following subtraction
 BCC DV5

.DV8

 SBC Q                  \ A >= Q, so set A = A - Q

 SEC                    \ Set the C flag, so that P gets a 1 shifted into bit 0

.DV5

 ROL P                  \ Shift P to the left, pulling the C flag into bit 0

 DEX                    \ Decrement the loop counter

 BNE DVL4               \ Loop back for the next bit until we have done all 8
                        \ bits of P

 JMP LL28+4             \ Jump to LL28+4 to convert the remainder in A into an
                        \ integer representation of the fractional value A / Q,
                        \ in R, where 1.0 = 255. LL28+4 always returns with the
                        \ C flag cleared, and we return from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: PDESC
\       Type: Subroutine
\   Category: Text
\    Summary: Print the system's extended description or a mission 1 directive
\  Deep dive: Extended system descriptions
\             Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This prints a specific system's extended description. This is called the "pink
\ volcanoes string" in a comment in the original source, and the "goat soup"
\ recipe by Ian Bell on his website (where he also refers to the species string
\ as the "pink felines" string).
\
\ For some special systems, when you are docked at them, the procedurally
\ generated extended description is overridden and a text token from the RUTOK
\ table is shown instead. If mission 1 is in progress, then a number of systems
\ along the route of that mission's story will show custom mission-related
\ directives in place of that system's normal "goat soup" phrase.
\
\ Arguments:
\
\   ZZ                  The system number (0-255)
\
\ ******************************************************************************

.PDESC

 LDA QQ8                \ If either byte in QQ18(1 0) is non-zero, meaning that
 ORA QQ8+1              \ the distance from the current system to the selected
 BNE PD1                \ is non-zero, jump to PD1 to show the standard "goat
                        \ soup" description

                        \ If we get here, then the current system is the same as
                        \ the selected system and we are docked, so now to check
                        \ whether there is a special override token for this
                        \ system

 LDY #NRU%              \ Set Y as a loop counter as we work our way through the
                        \ system numbers in RUPLA, starting at NRU% (which is
                        \ the number of entries in RUPLA, 26) and working our
                        \ way down to 1

.PDL1

 LDA RUPLA-1,Y          \ Fetch the Y-th byte from RUPLA-1 into A (we use
                        \ RUPLA-1 because Y is looping from 26 to 1

 CMP ZZ                 \ If A doesn't match the system whose description we
 BNE PD2                \ are printing (in ZZ), jump to PD2 to keep looping
                        \ through the system numbers in RUPLA

                        \ If we get here we have found a match for this system
                        \ number in RUPLA

 LDA RUGAL-1,Y          \ Fetch the Y-th byte from RUGAL-1 into A

 AND #%01111111         \ Extract bits 0-6 of A

 CMP GCNT               \ If the result does not equal the current galaxy
 BNE PD2                \ number, jump to PD2 to keep looping through the system
                        \ numbers in RUPLA

 LDA RUGAL-1,Y          \ Fetch the Y-th byte from RUGAL-1 into A, once again

 BMI PD3                \ If bit 7 is set, jump to PD3 to print the extended
                        \ token in A from the second table in RUTOK

 LDA TP                 \ Fetch bit 0 of TP into the C flag, and skip to PD1 if
 LSR A                  \ it is clear (i.e. if mission 1 is not in progress) to
 BCC PD1                \ print the "goat soup" extended description

                        \ If we get here then mission 1 is in progress, so we
                        \ print out the corresponding token from RUTOK

 JSR MT14               \ Call MT14 to switch to justified text

 LDA #1                 \ Set A = 1 so that extended token 1 (an empty string)
                        \ gets printed below instead of token 176, followed by
                        \ the Y-th token in RUTOK

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &B0, or BIT &B0A9, which does nothing apart
                        \ from affect the flags

.PD3

 LDA #176               \ Print extended token 176 ("{lower case}{justify}
 JSR DETOK2             \ {single cap}")

 TYA                    \ Print the extended token in Y from the second table
 JSR DETOK3             \ in RUTOK

 LDA #177               \ Set A = 177 so when we jump to PD4 in the next
                        \ instruction, we print token 177 (".{cr}{left align}")

 BNE PD4                \ Jump to PD4 to print the extended token in A and
                        \ return from the subroutine using a tail call

.PD2

 DEY                    \ Decrement the byte counter in Y

 BNE PDL1               \ Loop back to check the next byte in RUPLA until we
                        \ either find a match for the system in ZZ, or we fall
                        \ through into the "goat soup" extended description
                        \ routine

.PD1

                        \ We now print the "goat soup" extended description

 LDX #3                 \ We now want to seed the random number generator with
                        \ the s1 and s2 16-bit seeds from the current system, so
                        \ we get the same extended description for each system
                        \ every time we call PDESC, so set a counter in X for
                        \ copying 4 bytes

{
.PDL1                   \ This label is a duplicate of the label above (which is
                        \ why we need to surround it with braces, as BeebAsm
                        \ doesn't allow us to redefine labels, unlike BBC BASIC)

 LDA QQ15+2,X           \ Copy QQ15+2 to QQ15+5 (s1 and s2) to RAND to RAND+3
 STA RAND,X

 DEX                    \ Decrement the loop counter

 BPL PDL1               \ Loop back to PDL1 until we have copied all

 LDA #5                 \ Set A = 5, so we print extended token 5 in the next
                        \ instruction ("{lower case}{justify}{single cap}[86-90]
                        \ IS [140-144].{cr}{left align}"
}

.PD4

 JMP DETOK              \ Print the extended token given in A, and return from
                        \ the subroutine using a tail call

\ ******************************************************************************
\
\       Name: BRIEF2
\       Type: Subroutine
\   Category: Missions
\    Summary: Start mission 2
\
\ ******************************************************************************

.BRIEF2

 LDA TP                 \ Set bit 2 of TP to indicate mission 2 is in progress
 ORA #%00000100         \ but plans have not yet been picked up
 STA TP

 LDA #11                \ Set A = 11 so the call to BRP prints extended token 11
                        \ (the initial contact at the start of mission 2, asking
                        \ us to head for Ceerdi for a mission briefing)

                        \ Fall through into BRP to print the extended token in A
                        \ and show the Status Mode screen

\ ******************************************************************************
\
\       Name: BRP
\       Type: Subroutine
\   Category: Missions
\    Summary: Print an extended token and show the Status Mode screen
\
\ ******************************************************************************

.BRP

 JSR DETOK              \ Print the extended token in A

 JMP BAY                \ Jump to BAY to go to the docking bay (i.e. show the
                        \ Status Mode screen) and return from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: BRIEF3
\       Type: Subroutine
\   Category: Missions
\    Summary: Receive the briefing and plans for mission 2
\
\ ******************************************************************************

.BRIEF3

 LDA TP                 \ Set bits 1 and 3 of TP to indicate that mission 1 is
 AND #%11110000         \ complete, and mission 2 is in progress and the plans
 ORA #%00001010         \ have been picked up
 STA TP

 LDA #222               \ Set A = 222 so the call to BRP prints extended token
                        \ 222 (the briefing for mission 2 where we pick up the
                        \ plans we need to take to Birera)

 BNE BRP                \ Jump to BRP to print the extended token in A and show
                        \ the Status Mode screen), returning from the subroutine
                        \ using a tail call (this BNE is effectively a JMP as A
                        \ is never zero)

\ ******************************************************************************
\
\       Name: DEBRIEF2
\       Type: Subroutine
\   Category: Missions
\    Summary: Finish mission 2
\
\ ******************************************************************************

.DEBRIEF2

 LDA TP                 \ Set bit 2 of TP to indicate mission 2 is complete (so
 ORA #%00000100         \ both bits 2 and 3 are now set)
 STA TP

 LDA ENGY               \ If we already have an energy unit fitted (i.e. ENGY is
 BNE rew_notgot         \ non-zero), jump to rew_notgot to skip the following
                        \ instruction

 DEC new_hold           \ We're about to be given a special navy energy unit,
                        \ which doesn't take up space in the hold, so decrement
                        \ new_hold to reclaim the space for our old energy unit

.rew_notgot

 LDA #2                 \ Set ENGY to 2 so our energy banks recharge at a faster
 STA ENGY               \ rate, as our mission reward is a special navy energy
                        \ unit that recharges at a rate of 3 units of energy on
                        \ each iteration of the main loop, compared to a rate of
                        \ 2 units of energy for the standard energy unit

 INC TALLY+1            \ Award 256 kill points for completing the mission

 LDA #223               \ Set A = 223 so the call to BRP prints extended token
                        \ 223 (the thank you message at the end of mission 2)

 BNE BRP                \ Jump to BRP to print the extended token in A and show
                        \ the Status Mode screen), returning from the subroutine
                        \ using a tail call (this BNE is effectively a JMP as A
                        \ is never zero)

\ ******************************************************************************
\
\       Name: DEBRIEF
\       Type: Subroutine
\   Category: Missions
\    Summary: Finish mission 1
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   BRPS                Print the extended token in A, show the Status Mode
\                       screen and return from the subroutine
\
\ ******************************************************************************

.DEBRIEF

 LSR TP                 \ Clear bit 0 of TP to indicate that mission 1 is no
 ASL TP                 \ longer in progress, as we have completed it

 INC TALLY+1            \ Award 256 kill points for completing the mission

 LDX #LO(50000)         \ Increase our cash reserves by the generous mission
 LDY #HI(50000)         \ reward of 5,000 CR
 JSR MCASH

 LDA #15                \ Set A = 15 so the call to BRP prints extended token 15
                        \ (the thank you message at the end of mission 1)

.BRPS

 BNE BRP                \ Jump to BRP to print the extended token in A and show
                        \ the Status Mode screen, returning from the subroutine
                        \ using a tail call (this BNE is effectively a JMP as A
                        \ is never zero)

\ ******************************************************************************
\
\       Name: BRIEF
\       Type: Subroutine
\   Category: Missions
\    Summary: Start mission 1 and show the mission briefing
\
\ ------------------------------------------------------------------------------
\
\ This routine does the following:
\
\   * Clear the screen
\   * Display "INCOMING MESSAGE" in the middle of the screen
\   * Wait for 2 seconds
\   * Clear the screen
\   * Show the Constrictor rolling and pitching in the middle of the screen
\   * Do this for 64 loop iterations
\   * Move the ship away from us and up until it's near the top of the screen
\   * Show the mission 1 briefing in extended token 10
\
\ The mission briefing ends with a "{display ship, wait for key press}" token,
\ which calls the PAUSE routine. This continues to display the rotating ship,
\ waiting until a key is pressed, and then removes the ship from the screen.
\
\ ******************************************************************************

.BRIEF

 LSR TP                 \ Set bit 0 of TP to indicate that mission 1 is now in
 SEC                    \ progress
 ROL TP

 JSR BRIS               \ Call BRIS to clear the screen, display "INCOMING
                        \ MESSAGE" and wait for 2 seconds

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 LDA #CON               \ Set the ship type in TYPE to the Constrictor
 STA TYPE

 JSR NWSHP              \ Add a new Constrictor to the local bubble (in this
                        \ case, the briefing screen)

 LDA #1                 \ Move the text cursor to column 1
 STA XC

 STA INWK+7             \ Set z_hi = 1, the distance at which we show the
                        \ rotating ship

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 1

 LDA #64                \ Set the main loop counter to 64, so the ship rotates
 STA MCNT               \ for 64 iterations through MVEIT

.BRL1

 LDX #%01111111         \ Set the ship's roll counter to a positive roll that
 STX INWK+29            \ doesn't dampen

 STX INWK+30            \ Set the ship's pitch counter to a positive pitch that
                        \ doesn't dampen

 JSR LL9                \ Draw the ship on screen

 JSR MVEIT              \ Call MVEIT to rotate the ship in space

 DEC MCNT               \ Decrease the counter in MCNT

 BNE BRL1               \ Loop back to keep moving the ship until we have done
                        \ all 64 iterations

.BRL2

 LSR INWK               \ Halve x_lo so the Constrictor moves towards the centre

 INC INWK+6             \ Increment z_lo so the Constrictor moves away from us

 BEQ BR2                \ If z_lo = 0 (i.e. it just went past 255), jump to BR2
                        \ to show the briefing

 INC INWK+6             \ Increment z_lo so the Constrictor moves a bit further
                        \ away from us

 BEQ BR2                \ If z_lo = 0 (i.e. it just went past 255), jump out of
                        \ the loop to BR2 to stop moving the ship up the screen
                        \ and show the briefing

 LDX INWK+3             \ Set X = y_lo + 1
 INX

 CPX #112               \ If X < 112 then skip the next instruction
 BCC P%+4

 LDX #112               \ X is bigger than 112, so set X = 112 so that X has a
                        \ maximum value of 112

 STX INWK+3             \ Set y_lo = X
                        \          = y_lo + 1
                        \
                        \ so the ship moves up the screen (as space coordinates
                        \ have the y-axis going up)

 JSR LL9                \ Draw the ship on screen

 JSR MVEIT              \ Call MVEIT to move and rotate the ship in space

 JMP BRL2               \ Loop back to keep moving the ship up the screen and
                        \ away from us

.BR2

 INC INWK+7             \ Increment z_hi, to keep the ship at the same distance
                        \ as we just incremented z_lo past 255

 LDA #10                \ Set A = 10 so the call to BRP prints extended token 10
                        \ (the briefing for mission 1 where we find out all
                        \ about the stolen Constrictor)

 BNE BRPS               \ Jump to BRP via BRPS to print the extended token in A
                        \ and show the Status Mode screen, returning from the
                        \ subroutine using a tail call (this BNE is effectively
                        \ a JMP as A is never zero)

\ ******************************************************************************
\
\       Name: BRIS
\       Type: Subroutine
\   Category: Missions
\    Summary: Clear the screen, display "INCOMING MESSAGE" and wait for 2
\             seconds
\
\ ******************************************************************************

.BRIS

 LDA #216               \ Print extended token 216 ("{clear screen}{tab 6}{move
 JSR DETOK              \ to row 10, white, lower case}{white}{all caps}INCOMING
                        \ MESSAGE"

 LDY #100               \ Delay for 100 vertical syncs (100/50 = 2 seconds) and
 JMP DELAY              \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PAUSE
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Display a rotating ship, waiting until a key is pressed, then
\             remove the ship from the screen
\
\ ******************************************************************************

.PAUSE

 JSR PAS1               \ Call PAS1 to display the rotating ship at space
                        \ coordinates (0, 112, 256) and scan the keyboard,
                        \ returning the internal key number in X (or 0 for no
                        \ key press)

 BNE PAUSE              \ If a key was already being held down when we entered
                        \ this routine, keep looping back up to PAUSE, until
                        \ the key is released

.PAL1

 JSR PAS1               \ Call PAS1 to display the rotating ship at space
                        \ coordinates (0, 112, 256) and scan the keyboard,
                        \ returning the internal key number in X (or 0 for no
                        \ key press)

 BEQ PAL1               \ Keep looping up to PAL1 until a key is pressed

 LDA #0                 \ Set the ship's AI flag to 0 (no AI) so it doesn't get
 STA INWK+31            \ any ideas of its own

 LDA #1                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 1

 JSR LL9                \ Draw the ship on screen to redisplay it

                        \ Fall through into MT23 to move to row 10, switch to
                        \ white text, and switch to lower case when printing
                        \ extended tokens

\ ******************************************************************************
\
\       Name: MT23
\       Type: Subroutine
\   Category: Text
\    Summary: Move to row 10, switch to white text, and switch to lower case
\             when printing extended tokens
\  Deep dive: Extended text tokens
\
\ ******************************************************************************

.MT23

 LDA #10                \ Set A = 10, so when we fall through into MT29, the
                        \ text cursor gets moved to row 10

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &06, or BIT &06A9, which does nothing apart
                        \ from affect the flags

                        \ Fall through into MT29 to move to the row in A, switch
                        \ to white text, and switch to lower case

\ ******************************************************************************
\
\       Name: MT29
\       Type: Subroutine
\   Category: Text
\    Summary: Move to row 6, switch to white text, and switch to lower case when
\             printing extended tokens
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following:
\
\   * YC = 6 (move to row 6)
\
\ Then it calls WHITETEXT to switch to white text, before jumping to MT13 to
\ switch to lower case when printing extended tokens.
\
\ ******************************************************************************

.MT29

 LDA #6                 \ Move the text cursor to row 6
 STA YC

 JMP MT13               \ Jump to MT13 to set bit 7 of DTW6 and bit 5 of DTW1,
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PAS1
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Display a rotating ship at space coordinates (0, 112, 256) and
\             scan the keyboard
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   If a key is being pressed, X contains the internal key
\                       number, otherwise it contains 0
\
\   A                   Contains the same as X
\
\ ******************************************************************************

.PAS1

 LDA #112               \ Set y_lo = 112
 STA INWK+3

 LDA #0                 \ Set x_lo = 0
 STA INWK

 STA INWK+6             \ Set z_lo = 0

 LDA #2                 \ Set z_hi = 1, so (z_hi z_lo) = 256
 STA INWK+7

 JSR LL9                \ Draw the ship on screen

 JSR MVEIT              \ Call MVEIT to move and rotate the ship in space

 JMP RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press),
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PAUSE2
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Wait until a key is pressed, ignoring any existing key press
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   The internal key number of the key that was pressed
\
\ ******************************************************************************

.PAUSE2

 JSR RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press)

 BNE PAUSE2             \ If a key was already being held down when we entered
                        \ this routine, keep looping back up to PAUSE2, until
                        \ the key is released

 JSR RDKEY              \ Any pre-existing key press is now gone, so we can
                        \ start scanning the keyboard again, returning the
                        \ internal key number in X (or 0 for no key press)

 BEQ PAUSE2             \ Keep looping up to PAUSE2 until a key is pressed

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT66
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Clear the screen and set the current view type
\
\ ------------------------------------------------------------------------------
\
\ Clear the top part of the screen, draw a white border, and set the current
\ view type in QQ11 to A.
\
\ Arguments:
\
\   A                   The type of the new current view (see QQ11 for a list of
\                       view types)
\
\ ******************************************************************************

.TT66

 STA QQ11               \ Set the current view type in QQ11 to A

                        \ Fall through into TTX66 to clear the screen and draw a
                        \ white border

\ ******************************************************************************
\
\       Name: TTX66
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Clear the top part of the screen and draw a white border by
\             sending a clr_scrn command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Clear the top part of the screen (the space view) and draw a white border
\ along the top and sides.
\
\ ******************************************************************************

.TTX66

 JSR MT2                \ Switch to Sentence Case when printing extended tokens

 LDA #%10000000         \ Set bit 7 of QQ17 to switch to Sentence Case
 STA QQ17

 STA DTW2               \ Set bit 7 of DTW2 to indicate we are not currently
                        \ printing a word

 ASL A                  \ Set A to 0, as 128 << 1 = %10000000 << 1 = 0

 STA DLY                \ Set the delay in DLY to 0, to indicate that we are
                        \ no longer showing an in-flight message, so any new
                        \ in-flight messages will be shown instantly

 STA de                 \ Clear de, the flag that appends " DESTROYED" to the
                        \ end of the next text token, so that it doesn't

 JSR write_0346         \ Tell the I/O processor to set its copy of LASCT to 0

 LDA #&83               \ Send command &83 to the I/O processor:
 JSR tube_write         \
                        \   clr_scrn()
                        \
                        \ to clear the top part of the screen

 LDX QQ22+1             \ Fetch into X the number that's shown on-screen during
                        \ the hyperspace countdown

 BEQ BOX                \ If the counter is zero then we are not counting down
                        \ to hyperspace, so jump to BOX to skip the next
                        \ instruction

 JSR ee3                \ Print the 8-bit number in X at text location (0, 1),
                        \ i.e. print the hyperspace countdown in the top-left
                        \ corner

.BOX

 LDY #1                 \ Move the text cursor to row 1
 STY YC

 LDA QQ11               \ If this is not a space view, jump to tt66 to skip
 BNE tt66               \ displaying the view name

 LDY #11                \ Move the text cursor to row 11
 STY XC

 LDA VIEW               \ Load the current view into A:
                        \
                        \   0 = front
                        \   1 = rear
                        \   2 = left
                        \   3 = right

 ORA #&60               \ OR with &60 so we get a value of &60 to &63 (96 to 99)

 JSR TT27               \ Print recursive token 96 to 99, which will be in the
                        \ range "FRONT" to "RIGHT"

 JSR TT162              \ Print a space

 LDA #175               \ Print recursive token 15 ("VIEW ")
 JSR TT27

.tt66

 LDX #0                 \ Set QQ17 = 0 to switch to ALL CAPS
 STX QQ17

 STX X1                 \ Set (X1, Y1) to (0, 0)
 STX Y1

 DEX                    \ Set X2 = 255
 STX X2

 JSR HLOIN              \ Draw a horizontal line from (X1, Y1) to (X2, Y1), so
                        \ that's (0, 0) to (255, 0), along the very top of the
                        \ screen

 LDA #2                 \ Set X1 = X2 = 2
 STA X1
 STA X2

 JSR BOS2               \ Call BOS2 below, which will call BOS1 twice, and then
                        \ fall through into BOS2 again, so we effectively do
                        \ BOS1 four times, decrementing X1 and X2 each time
                        \ before calling LOIN, so this whole loop-within-a-loop
                        \ mind-bender ends up drawing these four lines:
                        \
                        \   (1, 0)   to (1, 191)
                        \   (0, 0)   to (0, 191)
                        \   (255, 0) to (255, 191)
                        \   (254, 0) to (254, 191)
                        \
                        \ So that's a 2-pixel wide vertical border along the
                        \ left edge of the upper part of the screen, and a
                        \ 2-pixel wide vertical border along the right edge

.BOS2

 JSR BOS1               \ Call BOS1 below and then fall through into it, which
                        \ ends up running BOS1 twice. This is all part of the
                        \ loop-the-loop border-drawing mind-bender explained
                        \ above

.BOS1

 LDA #0                 \ Set Y1 = 0
 STA Y1

 LDA #2*Y-1             \ Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
 STA Y2                 \ y-coordinate of the mid-point of the space view, so
                        \ this sets Y2 to 191, the y-coordinate of the bottom
                        \ pixel row of the space view

 DEC X1                 \ Decrement X1 and X2
 DEC X2

 JMP LOIN               \ Draw a line from (X1, Y1) to (X2, Y2), and return from
                        \ the subroutine using a tail call

\ ******************************************************************************
\
\       Name: DELAY
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Wait for a specified time, in 1/50s of a second
\
\ ------------------------------------------------------------------------------
\
\ Wait for the number of vertical syncs given in Y, so this effectively waits
\ for Y/50 of a second (as the vertical sync occurs 50 times a second).
\
\ Arguments:
\
\   Y                   The number of vertical sync events to wait for
\
\ ******************************************************************************

.DELAY

 JSR WSCAN              \ Call WSCAN to wait for the vertical sync, so the whole
                        \ screen gets drawn

 DEY                    \ Decrement the counter in Y

 BNE DELAY              \ If Y isn't yet at zero, jump back to DELAY to wait
                        \ for another vertical sync

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CLYNS
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Clear the bottom three text rows of the mode 4 screen by sending a
\             clr_line command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   A is set to 0
\
\   Y                   Y is set to 0
\
\ ******************************************************************************

.CLYNS

 LDA #%11111111         \ Set DTW2 = %11111111 to denote that we are not
 STA DTW2               \ currently printing a word

 LDA #20                \ Move the text cursor to row 20, near the bottom of
 STA YC                 \ the screen

 JSR TT67               \ Print a newline, which will move the text cursor down
                        \ a line (to row 21) and back to column 1

 LDY #1                 \ Move the text cursor to column 1
 STY XC

 DEY                    \ Set Y = 0, so the subroutine returns with this value

 LDA #&84               \ Send command &84 to the I/O processor:
 JMP tube_write         \
                        \   clr_line()
                        \
                        \ which will clear the bottom three text rows of the top
                        \ part of the screen and return from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: WSCAN
\       Type: Subroutine
\   Category: Screen mode
\    Summary: Wait for the vertical sync by sending a sync_in command to the I/O
\             processor
\
\ ******************************************************************************

.WSCAN

 LDA #&85               \ Send command &86 to the I/O processor:
 JSR tube_write         \
                        \   =sync_in()
                        \
                        \ which will wait until the vertical sync before
                        \ returning control to the parasite

 JMP tube_read          \ Set A to the response from the I/O processor, which
                        \ will be sent when the vertical sync occurs (it doesn't
                        \ matter what the value is), and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\ Save ELTC.bin
\
\ ******************************************************************************

 PRINT "ELITE C"
 PRINT "Assembled at ", ~CODE_C%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_C%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_C%

 PRINT "S.2.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
\SAVE "3-assembled-output/2.ELTC.bin", CODE_C%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE D FILE
\
\ ******************************************************************************

 CODE_D% = P%
 LOAD_D% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: tnpr
\       Type: Subroutine
\   Category: Market
\    Summary: Work out if we have space for a specific amount of cargo
\
\ ------------------------------------------------------------------------------
\
\ Given a market item and an amount, work out whether there is room in the
\ cargo hold for this item.
\
\ For standard tonne canisters, the limit is given by size of the cargo hold of
\ our current ship.
\
\ For items measured in kg (gold, platinum), g (gem-stones) and alien items,
\ there is no limit.
\
\ Arguments:
\
\   A                   The number of units of this market item
\
\   QQ29                The type of market item (see QQ23 for a list of market
\                       item numbers)
\
\ Returns:
\
\   C flag              Returns the result:
\
\                         * Set if there is no room for this item
\
\                         * Clear if there is room for this item
\
\ Other entry points:
\
\   Tml                 Calculate the sum of the following, returning the C flag
\                       according to whether this all fits into the hold:
\
\                         * The total tonnage of the first X items of cargo
\
\                         * The value in A
\
\                         * Plus one more tonne if the C flag is set on entry
\
\                       This is called with X = 12, A = the number of alien
\                       items in the hold, and the C flag set, to see if there
\                       is room for one more tonne in the hold
\
\ ******************************************************************************

.tnpr

 LDX #12                \ If QQ29 > 12 then jump to kg below, as this cargo
 CPX QQ29               \ type is gold, platinum, gem-stones or alien items,
 BCC kg                 \ and they have different cargo limits to the standard
                        \ tonne canisters

 CLC                    \ Clear the C flag for the addition below

.Tml

                        \ Here we count the tonne canisters we have in the hold
                        \ and add to A to see if we have enough room for A more
                        \ tonnes of cargo, using X as the loop counter, starting
                        \ with X = 12

 ADC QQ20,X             \ Set A = A + the number of tonnes we have in the hold
                        \ of market item number X

 BCS n_over             \ If the addition overflowed, jump to n_over to return
                        \ from the subroutine with the C flag set, as the hold
                        \ is already full

 DEX                    \ Decrement the loop counter

 BPL Tml                \ Loop back to add in the next market item in the hold,
                        \ until we have added up all market items from 12
                        \ (minerals) down to 0 (food)

 CMP new_hold           \ If A < new_hold then the C flag will be clear (we have
                        \ room in the hold)
                        \
                        \ If A >= new_hold then the C flag will be set (we do
                        \ not have room in the hold)

.n_over

 RTS                    \ Return from the subroutine

.kg

                        \ Here we count the number of items of this type that
                        \ we already have in the hold, and add to A to see if
                        \ we have enough room for A more units

 LDY QQ29               \ Set Y to the item number we want to add

 ADC QQ20,Y             \ Set A = A + the number of units of this item that we
                        \ already have in the hold

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT20
\       Type: Subroutine
\   Category: Universe
\    Summary: Twist the selected system's seeds four times
\  Deep dive: Twisting the system seeds
\             Galaxy and system seeds
\
\ ------------------------------------------------------------------------------
\
\ Twist the three 16-bit seeds in QQ15 (selected system) four times, to
\ generate the next system.
\
\ ******************************************************************************

.TT20

 JSR P%+3               \ This line calls the line below as a subroutine, which
                        \ does two twists before returning here, and then we
                        \ fall through to the line below for another two
                        \ twists, so the net effect of these two consecutive
                        \ JSR calls is four twists, not counting the ones
                        \ inside your head as you try to follow this process

 JSR P%+3               \ This line calls TT54 as a subroutine to do a twist,
                        \ and then falls through into TT54 to do another twist
                        \ before returning from the subroutine

\ ******************************************************************************
\
\       Name: TT54
\       Type: Subroutine
\   Category: Universe
\    Summary: Twist the selected system's seeds
\  Deep dive: Twisting the system seeds
\             Galaxy and system seeds
\
\ ------------------------------------------------------------------------------
\
\ This routine twists the three 16-bit seeds in QQ15 once.
\
\ ******************************************************************************

.TT54

 LDA QQ15               \ X = tmp_lo = s0_lo + s1_lo
 CLC
 ADC QQ15+2
 TAX

 LDA QQ15+1             \ Y = tmp_hi = s1_hi + s1_hi + C
 ADC QQ15+3
 TAY

 LDA QQ15+2             \ s0_lo = s1_lo
 STA QQ15

 LDA QQ15+3             \ s0_hi = s1_hi
 STA QQ15+1

 LDA QQ15+5             \ s1_hi = s2_hi
 STA QQ15+3

 LDA QQ15+4             \ s1_lo = s2_lo
 STA QQ15+2

 CLC                    \ s2_lo = X + s1_lo
 TXA
 ADC QQ15+2
 STA QQ15+4

 TYA                    \ s2_hi = Y + s1_hi + C
 ADC QQ15+3
 STA QQ15+5

 RTS                    \ The twist is complete so return from the subroutine

\ ******************************************************************************
\
\       Name: TT146
\       Type: Subroutine
\   Category: Text
\    Summary: Print the distance to the selected system in light years
\
\ ------------------------------------------------------------------------------
\
\ If it is non-zero, print the distance to the selected system in light years.
\ If it is zero, just move the text cursor down a line.
\
\ Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
\ then a colon, then the distance to one decimal place, then token 35 ("LIGHT
\ YEARS"). If the distance is zero, move the cursor down one line.
\
\ ******************************************************************************

.TT146

 LDA QQ8                \ Take the two bytes of the 16-bit value in QQ8 and
 ORA QQ8+1              \ OR them together to check whether there are any
 BNE TT63               \ non-zero bits, and if so, jump to TT63 to print the
                        \ distance

 INC YC                 \ The distance is zero, so we just move the text cursor
 RTS                    \ in YC down by one line and return from the subroutine

.TT63

 LDA #191               \ Print recursive token 31 ("DISTANCE") followed by
 JSR TT68               \ a colon

 LDX QQ8                \ Load (Y X) from QQ8, which contains the 16-bit
 LDY QQ8+1              \ distance we want to show

 SEC                    \ Set the C flag so that the call to pr5 will include a
                        \ decimal point, and display the value as (Y X) / 10

 JSR pr5                \ Print (Y X) to 5 digits, including a decimal point

 LDA #195               \ Set A to the recursive token 35 (" LIGHT YEARS") and
                        \ fall through into TT60 to print the token followed
                        \ by a paragraph break

\ ******************************************************************************
\
\       Name: TT60
\       Type: Subroutine
\   Category: Text
\    Summary: Print a text token and a paragraph break
\
\ ------------------------------------------------------------------------------
\
\ Print a text token (i.e. a character, control code, two-letter token or
\ recursive token). Then print a paragraph break (a blank line between
\ paragraphs) by moving the cursor down a line, setting Sentence Case, and then
\ printing a newline.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.TT60

 JSR TT27               \ Print the text token in A and fall through into TTX69
                        \ to print the paragraph break

\ ******************************************************************************
\
\       Name: TTX69
\       Type: Subroutine
\   Category: Text
\    Summary: Print a paragraph break
\
\ ------------------------------------------------------------------------------
\
\ Print a paragraph break (a blank line between paragraphs) by moving the cursor
\ down a line, setting Sentence Case, and then printing a newline.
\
\ ******************************************************************************

.TTX69

 INC YC                 \ Move the text cursor down a line

                        \ Fall through into TT69 to set Sentence Case and print
                        \ a newline

\ ******************************************************************************
\
\       Name: TT69
\       Type: Subroutine
\   Category: Text
\    Summary: Set Sentence Case and print a newline
\
\ ******************************************************************************

.TT69

 LDA #%10000000         \ Set bit 7 of QQ17 to switch to Sentence Case
 STA QQ17

                        \ Fall through into TT67 to print a newline

\ ******************************************************************************
\
\       Name: TT67
\       Type: Subroutine
\   Category: Text
\    Summary: Print a newline
\
\ ******************************************************************************

.TT67

 LDA #12                \ Load a newline character into A

 JMP TT27               \ Print the text token in A and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT70
\       Type: Subroutine
\   Category: Text
\    Summary: Display "MAINLY " and jump to TT72
\
\ ------------------------------------------------------------------------------
\
\ This subroutine is called by TT25 when displaying a system's economy.
\
\ ******************************************************************************

.TT70

 LDA #173               \ Print recursive token 13 ("MAINLY ")
 JSR TT27

 JMP TT72               \ Jump to TT72 to continue printing system data as part
                        \ of routine TT25

\ ******************************************************************************
\
\       Name: spc
\       Type: Subroutine
\   Category: Text
\    Summary: Print a text token followed by a space
\
\ ------------------------------------------------------------------------------
\
\ Print a text token (i.e. a character, control code, two-letter token or
\ recursive token) followed by a space.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.spc

 JSR TT27               \ Print the text token in A

 JMP TT162              \ Print a space and return from the subroutine using a
                        \ tail call

\ ******************************************************************************
\
\       Name: TT25
\       Type: Subroutine
\   Category: Universe
\    Summary: Show the Data on System screen (red key f6) or Encyclopedia screen
\             (CTRL-f6)
\  Deep dive: Generating system data
\             Galaxy and system seeds
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   TT72                Used by TT70 to re-enter the routine after displaying
\                       "MAINLY" for the economy type
\
\ ******************************************************************************

.TT25

 JSR CTRL               \ Scan the keyboard to see if CTRL is currently pressed,
                        \ returning a negative value in A if it is

 BPL not_cyclop         \ If CTRL is not being pressed, jump to not_cyclop to
                        \ skip the next instruction

 LDA dockedp            \ If dockedp is non-zero, then we are not docked and
 BNE not_cyclop         \ can't show the encyclopedia, so jump to not_cyclop to
                        \ skip the following instruction

 JMP encyclopedia       \ CTRL-f6 is being pressed, so jump to encyclopedia to
                        \ show the Encyclopedia screen

.not_cyclop

 LDA #1                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 1

 LDA #9                 \ Move the text cursor to column 9
 STA XC

 LDA #163               \ Print recursive token 3 ("DATA ON {selected system
 JSR NLIN3              \ name}" and draw a horizontal line at pixel row 19
                        \ to box in the title

 JSR TTX69              \ Print a paragraph break and set Sentence Case

 JSR TT146              \ If the distance to this system is non-zero, print
                        \ "DISTANCE", then the distance, "LIGHT YEARS" and a
                        \ paragraph break, otherwise just move the cursor down
                        \ a line

 LDA #194               \ Print recursive token 34 ("ECONOMY") followed by
 JSR TT68               \ a colon

 LDA QQ3                \ The system economy is determined by the value in QQ3,
                        \ so fetch it into A. First we work out the system's
                        \ prosperity as follows:
                        \
                        \   QQ3 = 0 or 5 = %000 or %101 = Rich
                        \   QQ3 = 1 or 6 = %001 or %110 = Average
                        \   QQ3 = 2 or 7 = %010 or %111 = Poor
                        \   QQ3 = 3 or 4 = %011 or %100 = Mainly

 CLC                    \ If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
 ADC #1                 \ (3 or 4), then call TT70, which prints "MAINLY " and
 LSR A                  \ jumps down to TT72 to print the type of economy
 CMP #%00000010
 BEQ TT70

 LDA QQ3                \ If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
 BCC TT71               \ %010 (0, 1 or 2), then jump to TT71 with A set to the
                        \ original value of QQ3

 SBC #5                 \ Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
 CLC                    \ 5 to bring it down to 0, 1 or 2 (the C flag is already
                        \ set so the SBC will be correct)

.TT71

 ADC #170               \ A is now 0, 1 or 2, so print recursive token 10 + A.
 JSR TT27               \ This means that:
                        \
                        \   QQ3 = 0 or 5 prints token 10 ("RICH ")
                        \   QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
                        \   QQ3 = 2 or 7 prints token 12 ("POOR ")

.TT72

 LDA QQ3                \ Now to work out the type of economy, which is
 LSR A                  \ determined by bit 2 of QQ3, as follows:
 LSR A                  \
                        \   QQ3 bit 2 = 0 = Industrial
                        \   QQ3 bit 2 = 1 = Agricultural
                        \
                        \ So we fetch QQ3 into A and set A = bit 2 of QQ3 using
                        \ two right shifts (which will work as QQ3 is only a
                        \ 3-bit number)

 CLC                    \ Print recursive token 8 + A, followed by a paragraph
 ADC #168               \ break and Sentence Case, so:
 JSR TT60               \
                        \   QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
                        \   QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")

 LDA #162               \ Print recursive token 2 ("GOVERNMENT") followed by
 JSR TT68               \ a colon

 LDA QQ4                \ The system's government is determined by the value in
                        \ QQ4, so fetch it into A

 CLC                    \ Print recursive token 17 + A, followed by a paragraph
 ADC #177               \ break and Sentence Case, so:
 JSR TT60               \
                        \   QQ4 = 0 prints token 17 ("ANARCHY")
                        \   QQ4 = 1 prints token 18 ("FEUDAL")
                        \   QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
                        \   QQ4 = 3 prints token 20 ("DICTATORSHIP")
                        \   QQ4 = 4 prints token 21 ("COMMUNIST")
                        \   QQ4 = 5 prints token 22 ("CONFEDERACY")
                        \   QQ4 = 6 prints token 23 ("DEMOCRACY")
                        \   QQ4 = 7 prints token 24 ("CORPORATE STATE")

 LDA #196               \ Print recursive token 36 ("TECH.LEVEL") followed by a
 JSR TT68               \ colon

 LDX QQ5                \ Fetch the tech level from QQ5 and increment it, as it
 INX                    \ is stored in the range 0-14 but the displayed range
                        \ should be 1-15

 CLC                    \ Call pr2 to print the technology level as a 3-digit
 JSR pr2                \ number without a decimal point (by clearing the C
                        \ flag)

 JSR TTX69              \ Print a paragraph break and set Sentence Case

 LDA #192               \ Print recursive token 32 ("POPULATION") followed by a
 JSR TT68               \ colon

 SEC                    \ Call pr2 to print the population as a 3-digit number
 LDX QQ6                \ with a decimal point (by setting the C flag), so the
 JSR pr2                \ number printed will be population / 10

 LDA #198               \ Print recursive token 38 (" BILLION"), followed by a
 JSR TT60               \ paragraph break and Sentence Case

 LDA #'('               \ Print an opening bracket
 JSR TT27

 LDA QQ15+4             \ Now to calculate the species, so first check bit 7 of
 BMI TT75               \ s2_lo, and if it is set, jump to TT75 as this is an
                        \ alien species

 LDA #188               \ Bit 7 of s2_lo is clear, so print recursive token 28
 JSR TT27               \ ("HUMAN COLONIAL")

 JMP TT76               \ Jump to TT76 to print "S)" and a paragraph break, so
                        \ the whole species string is "(HUMAN COLONIALS)"

.TT75

 LDA QQ15+5             \ This is an alien species, and we start with the first
 LSR A                  \ adjective, so fetch bits 2-7 of s2_hi into A and push
 LSR A                  \ onto the stack so we can use this later
 PHA

 AND #%00000111         \ Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)

 CMP #3                 \ If A >= 3, jump to TT205 to skip the first adjective,
 BCS TT205

 ADC #227               \ Otherwise A = 0, 1 or 2, so print recursive token
 JSR spc                \ 67 + A, followed by a space, so:
                        \
                        \   A = 0 prints token 67 ("LARGE") and a space
                        \   A = 1 prints token 67 ("FIERCE") and a space
                        \   A = 2 prints token 67 ("SMALL") and a space

.TT205

 PLA                    \ Now for the second adjective, so restore A to bits
 LSR A                  \ 2-7 of s2_hi, and throw away bits 2-4 to leave
 LSR A                  \ A = bits 5-7 of s2_hi
 LSR A

 CMP #6                 \ If A >= 6, jump to TT206 to skip the second adjective
 BCS TT206

 ADC #230               \ Otherwise A = 0 to 5, so print recursive token
 JSR spc                \ 70 + A, followed by a space, so:
                        \
                        \   A = 0 prints token 70 ("GREEN") and a space
                        \   A = 1 prints token 71 ("RED") and a space
                        \   A = 2 prints token 72 ("YELLOW") and a space
                        \   A = 3 prints token 73 ("BLUE") and a space
                        \   A = 4 prints token 74 ("BLACK") and a space
                        \   A = 5 prints token 75 ("HARMLESS") and a space

.TT206

 LDA QQ15+3             \ Now for the third adjective, so EOR the high bytes of
 EOR QQ15+1             \ s0 and s1 and extract bits 0-2 of the result:
 AND #%00000111         \
 STA QQ19               \   A = (s0_hi EOR s1_hi) AND %111
                        \
                        \ storing the result in QQ19 so we can use it later

 CMP #6                 \ If A >= 6, jump to TT207 to skip the third adjective
 BCS TT207

 ADC #236               \ Otherwise A = 0 to 5, so print recursive token
 JSR spc                \ 76 + A, followed by a space, so:
                        \
                        \   A = 0 prints token 76 ("SLIMY") and a space
                        \   A = 1 prints token 77 ("BUG-EYED") and a space
                        \   A = 2 prints token 78 ("HORNED") and a space
                        \   A = 3 prints token 79 ("BONY") and a space
                        \   A = 4 prints token 80 ("FAT") and a space
                        \   A = 5 prints token 81 ("FURRY") and a space

.TT207

 LDA QQ15+5             \ Now for the actual species, so take bits 0-1 of
 AND #%00000011         \ s2_hi, add this to the value of A that we used for
 CLC                    \ the third adjective, and take bits 0-2 of the result
 ADC QQ19
 AND #%00000111

 ADC #242               \ A = 0 to 7, so print recursive token 82 + A, so:
 JSR TT27               \
                        \   A = 0 prints token 76 ("RODENT")
                        \   A = 1 prints token 76 ("FROG")
                        \   A = 2 prints token 76 ("LIZARD")
                        \   A = 3 prints token 76 ("LOBSTER")
                        \   A = 4 prints token 76 ("BIRD")
                        \   A = 5 prints token 76 ("HUMANOID")
                        \   A = 6 prints token 76 ("FELINE")
                        \   A = 7 prints token 76 ("INSECT")

.TT76

 LDA #'S'               \ Print an "S" to pluralise the species
 JSR TT27

 LDA #')'               \ And finally, print a closing bracket, followed by a
 JSR TT60               \ paragraph break and Sentence Case, to end the species
                        \ section

 LDA #193               \ Print recursive token 33 ("GROSS PRODUCTIVITY"),
 JSR TT68               \ followed by a colon

 LDX QQ7                \ Fetch the 16-bit productivity value from QQ7 into
 LDY QQ7+1              \ (Y X)

 JSR pr6                \ Print (Y X) to 5 digits with no decimal point

 JSR TT162              \ Print a space

 LDA #0                 \ Set QQ17 = 0 to switch to ALL CAPS
 STA QQ17

 LDA #'M'               \ Print "M"
 JSR TT27

 LDA #226               \ Print recursive token 66 (" CR"), followed by a
 JSR TT60               \ paragraph break and Sentence Case

 LDA #250               \ Print recursive token 90 ("AVERAGE RADIUS"), followed
 JSR TT68               \ by a colon

                        \ The average radius is calculated like this:
                        \
                        \   ((s2_hi AND %1111) + 11) * 256 + s1_hi
                        \
                        \ or, in terms of memory locations:
                        \
                        \   ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
                        \
                        \ Because the multiplication is by 256, this is the
                        \ same as saying a 16-bit number, with high byte:
                        \
                        \   (QQ15+5 AND %1111) + 11
                        \
                        \ and low byte:
                        \
                        \   QQ15+3
                        \
                        \ so we can set this up in (Y X) and call the pr5
                        \ routine to print it out

 LDA QQ15+5             \ Set A = QQ15+5
 LDX QQ15+3             \ Set X = QQ15+3

 AND #%00001111         \ Set Y = (A AND %1111) + 11
 CLC
 ADC #11
 TAY

 JSR pr5                \ Print (Y X) to 5 digits, not including a decimal
                        \ point, as the C flag will be clear (as the maximum
                        \ radius will always fit into 16 bits)

 JSR TT162              \ Print a space

 LDA #'k'               \ Print "km"
 JSR TT26
 LDA #'m'
 JSR TT26

 JSR TTX69              \ Print a paragraph break and set Sentence Case

                        \ By this point, ZZ contains the current system number
                        \ which PDESC requires. It gets put there in the TT102
                        \ routine, which calls TT111 to populate ZZ before
                        \ calling TT25 (this routine)

 JMP PDESC              \ Jump to PDESC to print the system's extended
                        \ description, returning from the subroutine using a
                        \ tail call

\ ******************************************************************************
\
\       Name: TT24
\       Type: Subroutine
\   Category: Universe
\    Summary: Calculate system data from the system seeds
\  Deep dive: Generating system data
\             Galaxy and system seeds
\
\ ------------------------------------------------------------------------------
\
\ Calculate system data from the seeds in QQ15 and store them in the relevant
\ locations. Specifically, this routine calculates the following from the three
\ 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
\
\   QQ3 = economy (0-7)
\   QQ4 = government (0-7)
\   QQ5 = technology level (0-14)
\   QQ6 = population * 10 (1-71)
\   QQ7 = productivity (96-62480)
\
\ The ranges of the various values are shown in brackets. Note that the radius
\ and type of inhabitant are calculated on-the-fly in the TT25 routine when
\ the system data gets displayed, so they aren't calculated here.
\
\ ******************************************************************************

.TT24

 LDA QQ15+1             \ Fetch s0_hi and extract bits 0-2 to determine the
 AND #%00000111         \ system's economy, and store in QQ3
 STA QQ3

 LDA QQ15+2             \ Fetch s1_lo and extract bits 3-5 to determine the
 LSR A                  \ system's government, and store in QQ4
 LSR A
 LSR A
 AND #%00000111
 STA QQ4

 LSR A                  \ If government isn't anarchy or feudal, skip to TT77,
 BNE TT77               \ as we need to fix the economy of anarchy and feudal
                        \ systems so they can't be rich

 LDA QQ3                \ Set bit 1 of the economy in QQ3 to fix the economy
 ORA #%00000010         \ for anarchy and feudal governments
 STA QQ3

.TT77

 LDA QQ3                \ Now to work out the tech level, which we do like this:
 EOR #%00000111         \
 CLC                    \   flipped_economy + (s1_hi AND %11) + (government / 2)
 STA QQ5                \
                        \ or, in terms of memory locations:
                        \
                        \   QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
                        \
                        \ We start by setting QQ5 = QQ3 EOR %111

 LDA QQ15+3             \ We then take the first 2 bits of s1_hi (QQ15+3) and
 AND #%00000011         \ add it into QQ5
 ADC QQ5
 STA QQ5

 LDA QQ4                \ And finally we add QQ4 / 2 and store the result in
 LSR A                  \ QQ5, using LSR then ADC to divide by 2, which rounds
 ADC QQ5                \ up the result for odd-numbered government types
 STA QQ5

 ASL A                  \ Now to work out the population, like so:
 ASL A                  \
 ADC QQ3                \   (tech level * 4) + economy + government + 1
 ADC QQ4                \
 ADC #1                 \ or, in terms of memory locations:
 STA QQ6                \
                        \   QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1

 LDA QQ3                \ Finally, we work out productivity, like this:
 EOR #%00000111         \
 ADC #3                 \  (flipped_economy + 3) * (government + 4)
 STA P                  \                        * population
 LDA QQ4                \                        * 8
 ADC #4                 \
 STA Q                  \ or, in terms of memory locations:
 JSR MULTU              \
                        \   QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
                        \
                        \ We do the first step by setting P to the first
                        \ expression in brackets and Q to the second, and
                        \ calling MULTU, so now (A P) = P * Q. The highest this
                        \ can be is 10 * 11 (as the maximum values of economy
                        \ and government are 7), so the high byte of the result
                        \ will always be 0, so we actually have:
                        \
                        \   P = P * Q
                        \     = (flipped_economy + 3) * (government + 4)

 LDA QQ6                \ We now take the result in P and multiply by the
 STA Q                  \ population to get the productivity, by setting Q to
 JSR MULTU              \ the population from QQ6 and calling MULTU again, so
                        \ now we have:
                        \
                        \   (A P) = P * population

 ASL P                  \ Next we multiply the result by 8, as a 16-bit number,
 ROL A                  \ so we shift both bytes to the left three times, using
 ASL P                  \ the C flag to carry bits from bit 7 of the low byte
 ROL A                  \ into bit 0 of the high byte
 ASL P
 ROL A

 STA QQ7+1              \ Finally, we store the productivity in two bytes, with
 LDA P                  \ the low byte in QQ7 and the high byte in QQ7+1
 STA QQ7

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT22
\       Type: Subroutine
\   Category: Charts
\    Summary: Show the Long-range Chart (red key f4)
\
\ ******************************************************************************

.TT22

 LDA #64                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32 (Long-
                        \ range Chart)

 LDA #7                 \ Move the text cursor to column 7
 STA XC

 JSR TT81               \ Set the seeds in QQ15 to those of system 0 in the
                        \ current galaxy (i.e. copy the seeds from QQ21 to QQ15)

 LDA #199               \ Print recursive token 39 ("GALACTIC CHART{galaxy
 JSR TT27               \ number right-aligned to width 3}")

 JSR NLIN               \ Draw a horizontal line at pixel row 23 to box in the
                        \ title and act as the top frame of the chart, and move
                        \ the text cursor down one line

 LDA #152               \ Draw a screen-wide horizontal line at pixel row 152
 JSR NLIN2              \ for the bottom edge of the chart, so the chart itself
                        \ is 128 pixels high, starting on row 24 and ending on
                        \ row 151

 JSR TT14               \ Call TT14 to draw a circle with crosshairs at the
                        \ current system's galactic coordinates

 LDX #0                 \ We're now going to plot each of the galaxy's systems,
                        \ so set up a counter in X for each system, starting at
                        \ 0 and looping through to 255

.TT83

 STX XSAV               \ Store the counter in XSAV

 LDX QQ15+3             \ Fetch the s1_hi seed into X, which gives us the
                        \ galactic x-coordinate of this system

 LDY QQ15+4             \ Fetch the s2_lo seed and set bits 4 and 6, storing the
 TYA                    \ result in ZZ to give a random number between 80 and
 ORA #%01010000         \ (but which will always be the same for this system).
 STA ZZ                 \ We use this value to determine the size of the point
                        \ for this system on the chart by passing it as the
                        \ distance argument to the PIXEL routine below

 LDA QQ15+1             \ Fetch the s0_hi seed into A, which gives us the
                        \ galactic y-coordinate of this system

 LSR A                  \ We halve the y-coordinate because the galaxy in
                        \ in Elite is rectangular rather than square, and is
                        \ twice as wide (x-axis) as it is high (y-axis), so the
                        \ chart is 256 pixels wide and 128 high

 CLC                    \ Add 24 to the halved y-coordinate and store in XX15+1
 ADC #24                \ (as the top of the chart is on pixel row 24, just
 STA XX15+1             \ below the line we drew on row 23 above)

 JSR PIXEL              \ Call PIXEL to draw a point at (X, A), with the size of
                        \ the point dependent on the distance specified in ZZ
                        \ (so a high value of ZZ will produce a 1-pixel point,
                        \ a medium value will produce a 2-pixel dash, and a
                        \ small value will produce a 4-pixel square)

 JSR TT20               \ We want to move on to the next system, so call TT20
                        \ to twist the three 16-bit seeds in QQ15

 LDX XSAV               \ Restore the loop counter from XSAV

 INX                    \ Increment the counter

 BNE TT83               \ If X > 0 then we haven't done all 256 systems yet, so
                        \ loop back up to TT83

 LDA QQ9                \ Set QQ19 to the selected system's x-coordinate
 STA QQ19

 LDA QQ10               \ Set QQ19+1 to the selected system's y-coordinate,
 LSR A                  \ halved to fit it into the chart
 STA QQ19+1

 LDA #4                 \ Set QQ19+2 to size 4 for the crosshairs size
 STA QQ19+2

                        \ Fall through into TT15 to draw crosshairs of size 4 at
                        \ the selected system's coordinates

\ ******************************************************************************
\
\       Name: TT15
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Draw a set of crosshairs
\
\ ------------------------------------------------------------------------------
\
\ For all views except the Short-range Chart, the centre is drawn 24 pixels to
\ the right of the y-coordinate given.
\
\ Arguments:
\
\   QQ19                The pixel x-coordinate of the centre of the crosshairs
\
\   QQ19+1              The pixel y-coordinate of the centre of the crosshairs
\
\   QQ19+2              The size of the crosshairs
\
\ ******************************************************************************

.TT15

 LDA #24                \ Set A to 24, which we will use as the minimum
                        \ screen indent for the crosshairs (i.e. the minimum
                        \ distance from the top-left corner of the screen)

 LDX QQ11               \ If the current view is not the Short-range Chart,
 BPL P%+4               \ which is the only view with bit 7 set, then skip the
                        \ following instruction

 LDA #0                 \ This is the Short-range Chart, so set A to 0, so the
                        \ crosshairs can go right up against the screen edges

 STA QQ19+5             \ Set QQ19+5 to A, which now contains the correct indent
                        \ for this view

 LDA QQ19               \ Set A = crosshairs x-coordinate - crosshairs size
 SEC                    \ to get the x-coordinate of the left edge of the
 SBC QQ19+2             \ crosshairs

 BCS TT84               \ If the above subtraction didn't underflow, then A is
                        \ positive, so skip the next instruction

 LDA #0                 \ The subtraction underflowed, so set A to 0 so the
                        \ crosshairs don't spill out of the left of the screen

.TT84

                        \ In the following, the authors have used XX15 for
                        \ temporary storage. XX15 shares location with X1, Y1,
                        \ X2 and Y2, so in the following, you can consider
                        \ the variables like this:
                        \
                        \   XX15   is the same as X1
                        \   XX15+1 is the same as Y1
                        \   XX15+2 is the same as X2
                        \   XX15+3 is the same as Y2
                        \
                        \ Presumably this routine was written at a different
                        \ time to the line-drawing routine, before the two
                        \ workspaces were merged to save space

 STA XX15               \ Set XX15 (X1) = A (the x-coordinate of the left edge
                        \ of the crosshairs)

 LDA QQ19               \ Set A = crosshairs x-coordinate + crosshairs size
 CLC                    \ to get the x-coordinate of the right edge of the
 ADC QQ19+2             \ crosshairs

 BCC P%+4               \ If the above addition didn't overflow, then A is
                        \ correct, so skip the next instruction

 LDA #255               \ The addition overflowed, so set A to 255 so the
                        \ crosshairs don't spill out of the right of the screen
                        \ (as 255 is the x-coordinate of the rightmost pixel
                        \ on-screen)

 STA XX15+2             \ Set XX15+2 (X2) = A (the x-coordinate of the right
                        \ edge of the crosshairs)

 LDA QQ19+1             \ Set XX15+1 (Y1) = crosshairs y-coordinate + indent
 CLC                    \ to get the y-coordinate of the centre of the
 ADC QQ19+5             \ crosshairs
 STA XX15+1

 JSR HLOIN              \ Draw a horizontal line from (X1, Y1) to (X2, Y1),
                        \ which will draw from the left edge of the crosshairs
                        \ to the right edge, through the centre of the
                        \ crosshairs

 LDA QQ19+1             \ Set A = crosshairs y-coordinate - crosshairs size
 SEC                    \ to get the y-coordinate of the top edge of the
 SBC QQ19+2             \ crosshairs

 BCS TT86               \ If the above subtraction didn't underflow, then A is
                        \ correct, so skip the next instruction

 LDA #0                 \ The subtraction underflowed, so set A to 0 so the
                        \ crosshairs don't spill out of the top of the screen

.TT86

 CLC                    \ Set XX15+1 (Y1) = A + indent to get the y-coordinate
 ADC QQ19+5             \ of the top edge of the indented crosshairs
 STA XX15+1

 LDA QQ19+1             \ Set A = crosshairs y-coordinate + crosshairs size
 CLC                    \ + indent to get the y-coordinate of the bottom edge
 ADC QQ19+2             \ of the indented crosshairs
 ADC QQ19+5

 CMP #152               \ If A < 152 then skip the following, as the crosshairs
 BCC TT87               \ won't spill out of the bottom of the screen

 LDX QQ11               \ A >= 152, so we need to check whether this will fit in
                        \ this view, so fetch the view number

 BMI TT87               \ If this is the Short-range Chart then the y-coordinate
                        \ is fine, so skip to TT87

 LDA #151               \ Otherwise this is the Long-range Chart, so we need to
                        \ clip the crosshairs at a maximum y-coordinate of 151

.TT87

 STA XX15+3             \ Set XX15+3 (Y2) = A (the y-coordinate of the bottom
                        \ edge of the crosshairs)

 LDA QQ19               \ Set XX15 (X1) = the x-coordinate of the centre of the
 STA XX15               \ crosshairs

 STA XX15+2             \ Set XX15+2 (X2) = the x-coordinate of the centre of
                        \ the crosshairs

 JMP LL30               \ Draw a vertical line (X1, Y1) to (X2, Y2), which will
                        \ draw from the top edge of the crosshairs to the bottom
                        \ edge, through the centre of the crosshairs, returning
                        \ from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT14
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Draw a circle with crosshairs on a chart
\
\ ------------------------------------------------------------------------------
\
\ Draw a circle with crosshairs at the current system's galactic coordinates.
\
\ ******************************************************************************

.TT126

 LDA #104               \ Set QQ19 = 104, for the x-coordinate of the centre of
 STA QQ19               \ the fixed circle on the Short-range Chart

 LDA #90                \ Set QQ19+1 = 90, for the y-coordinate of the centre of
 STA QQ19+1             \ the fixed circle on the Short-range Chart

 LDA #16                \ Set QQ19+2 = 16, the size of the crosshairs on the
 STA QQ19+2             \ Short-range Chart

 JSR TT15               \ Draw the set of crosshairs defined in QQ19, at the
                        \ exact coordinates as this is the Short-range Chart

 LDA QQ14               \ Set K to the fuel level from QQ14, so this can act as
 STA K                  \ the circle's radius (70 being a full tank)

 JMP TT128              \ Jump to TT128 to draw a circle with the centre at the
                        \ same coordinates as the crosshairs, (QQ19, QQ19+1),
                        \ and radius K that reflects the current fuel levels,
                        \ returning from the subroutine using a tail call

.TT14

 LDA QQ11               \ If the current view is the Short-range Chart, which
 BMI TT126              \ is the only view with bit 7 set, then jump up to TT126
                        \ to draw the crosshairs and circle for that view

                        \ Otherwise this is the Long-range Chart, so we draw the
                        \ crosshairs and circle for that view instead

 LDA QQ14               \ Set K to the fuel level from QQ14 divided by 4, so
 LSR A                  \ this can act as the circle's radius (70 being a full
 LSR A                  \ tank, which divides down to a radius of 17)
 STA K

 LDA QQ0                \ Set QQ19 to the x-coordinate of the current system,
 STA QQ19               \ which will be the centre of the circle and crosshairs
                        \ we draw

 LDA QQ1                \ Set QQ19+1 to the y-coordinate of the current system,
 LSR A                  \ halved because the galactic chart is half as high as
 STA QQ19+1             \ it is wide, which will again be the centre of the
                        \ circle and crosshairs we draw

 LDA #7                 \ Set QQ19+2 = 7, the size of the crosshairs on the
 STA QQ19+2             \ Long-range Chart

 JSR TT15               \ Draw the set of crosshairs defined in QQ19, which will
                        \ be drawn 24 pixels to the right of QQ19+1

 LDA QQ19+1             \ Add 24 to the y-coordinate of the crosshairs in QQ19+1
 CLC                    \ so that the centre of the circle matches the centre
 ADC #24                \ of the crosshairs
 STA QQ19+1

                        \ Fall through into TT128 to draw a circle with the
                        \ centre at the same coordinates as the crosshairs,
                        \ (QQ19, QQ19+1), and radius K that reflects the
                        \ current fuel levels

\ ******************************************************************************
\
\       Name: TT128
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Draw a circle on a chart
\  Deep dive: Drawing circles
\
\ ------------------------------------------------------------------------------
\
\ Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
\
\ Arguments:
\
\   QQ19                The x-coordinate of the centre of the circle
\
\   QQ19+1              The y-coordinate of the centre of the circle
\
\   K                   The radius of the circle
\
\ ******************************************************************************

.TT128

 LDA QQ19               \ Set K3 = the x-coordinate of the centre
 STA K3

 LDA QQ19+1             \ Set K4 = the y-coordinate of the centre
 STA K4

 LDX #0                 \ Set the high bytes of K3(1 0) and K4(1 0) to 0
 STX K4+1
 STX K3+1

 INX                    \ Set LSP = 1 to reset the ball line heap
 STX LSP

 INX                    \ Set STP = 2, the step size for the circle
 STX STP

 JMP CIRCLE2            \ Jump to CIRCLE2 to draw a circle with the centre at
                        \ (K3(1 0), K4(1 0)) and radius K, returning from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT219
\       Type: Subroutine
\   Category: Market
\    Summary: Show the Buy Cargo screen (red key f1) or Special Cargo screen
\             (CTRL-f1)
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   BAY2                Jump into the main loop at FRCE, setting the key
\                       "pressed" to red key f9 (so we show the Inventory
\                       screen)
\
\ ******************************************************************************

.TT219

 LDA #2                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 2

 JSR CTRL               \ Scan the keyboard to see if CTRL is currently pressed,
                        \ returning a negative value in A if it is

 BPL buy_ctrl           \ If CTRL is not being pressed, jump to buy_ctrl to skip
                        \ the next instruction

 JMP cour_buy           \ CTRL-f1 is being pressed, so jump to cour_buy to show
                        \ the Special Cargo screen, returning from the
                        \ subroutine using a tail call
.buy_ctrl

 JSR TT163              \ Print the column headers for the prices table

 LDA #%10000000         \ Set bit 7 of QQ17 to switch to Sentence Case, with the
 STA QQ17               \ next letter in capitals

 JSR FLKB               \ Flush the keyboard buffer

 LDA #0                 \ We're going to loop through all the available market
 STA QQ29               \ items, so we set up a counter in QQ29 to denote the
                        \ current item and start it at 0

.TT220

 JSR TT151              \ Call TT151 to print the item name, market price and
                        \ availability of the current item, and set QQ24 to the
                        \ item's price / 4, QQ25 to the quantity available and
                        \ QQ19+1 to byte #1 from the market prices table for
                        \ this item

 LDA QQ25               \ If there are some of the current item available, jump
 BNE TT224              \ to TT224 below to see if we want to buy any

 JMP TT222              \ Otherwise there are none available, so jump down to
                        \ TT222 to skip this item

.TQ4

 LDY #176               \ Set Y to the recursive token 16 ("QUANTITY")

.Tc

 JSR TT162              \ Print a space

 TYA                    \ Print the recursive token in Y followed by a question
 JSR prq                \ mark

.TTX224

 JSR dn2                \ Call dn2 to make a short, high beep and delay for 1
                        \ second

.TT224

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

 LDA #204               \ Print recursive token 44 ("QUANTITY OF ")
 JSR TT27

 LDA QQ29               \ Print recursive token 48 + QQ29, which will be in the
 CLC                    \ range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
 ADC #208               \ prints the current item's name
 JSR TT27

 LDA #'/'               \ Print "/"
 JSR TT27

 JSR TT152              \ Print the unit ("t", "kg" or "g") for the current item
                        \ (as the call to TT151 above set QQ19+1 with the
                        \ appropriate value)

 LDA #'?'               \ Print "?"
 JSR TT27

 JSR TT67               \ Print a newline

 JSR gnum               \ Call gnum to get a number from the keyboard, which
                        \ will be the quantity of this item we want to purchase,
                        \ returning the number entered in A and R

 BCS TQ4                \ If gnum set the C flag, the number entered is greater
                        \ than the quantity available, so jump up to TQ4 to
                        \ display a "Quantity?" error, beep, clear the number
                        \ and try again

 STA P                  \ Otherwise we have a valid purchase quantity entered,
                        \ so store the amount we want to purchase in P

 JSR tnpr               \ Call tnpr to work out whether there is room in the
                        \ cargo hold for this item

 LDY #206               \ Set Y to recursive token 46 (" CARGO{sentence case}")
                        \ to pass to the Tc routine if we call it

 BCS Tc                 \ If the C flag is set, then there is no room in the
                        \ cargo hold, jump up to Tc to print a "Cargo?" error,
                        \ beep, clear the number and try again

 LDA QQ24               \ There is room in the cargo hold, so now to check
 STA Q                  \ whether we have enough cash, so fetch the item's
                        \ price / 4, which was returned in QQ24 by the call
                        \ to TT151 above and store it in Q

 JSR GCASH              \ Call GCASH to calculate:
                        \
                        \   (Y X) = P * Q * 4
                        \
                        \ which will be the total price of this transaction
                        \ (as P contains the purchase quantity and Q contains
                        \ the item's price / 4)

 JSR LCASH              \ Subtract (Y X) cash from the cash pot in CASH

 LDY #197               \ If the C flag is clear, we didn't have enough cash,
 BCC Tc                 \ so set Y to the recursive token 37 ("CASH") and jump
                        \ up to Tc to print a "Cash?" error, beep, clear the
                        \ number and try again

 LDY QQ29               \ Fetch the current market item number from QQ29 into Y

 LDA R                  \ Set A to the number of items we just purchased (this
                        \ was set by gnum above)

 PHA                    \ Store the quantity just purchased on the stack

 CLC                    \ Add the number purchased to the Y-th byte of QQ20,
 ADC QQ20,Y             \ which contains the number of items of this type in
 STA QQ20,Y             \ our hold (so this transfers the bought items into our
                        \ cargo hold)

 LDA AVL,Y              \ Subtract the number of items from the Y-th byte of
 SEC                    \ AVL, which contains the number of items of this type
 SBC R                  \ that are available on the market
 STA AVL,Y

 PLA                    \ Restore the quantity just purchased

 BEQ TT222              \ If we didn't buy anything, jump to TT222 to skip the
                        \ following instruction

 JSR dn                 \ Call dn to print the amount of cash left in the cash
                        \ pot, then make a short, high beep to confirm the
                        \ purchase, and delay for 1 second

.TT222

 LDA QQ29               \ Move the text cursor to row QQ29 + 5 (where QQ29 is
 CLC                    \ the item number, starting from 0)
 ADC #5
 STA YC

 LDA #0                 \ Move the text cursor to column 0
 STA XC

 INC QQ29               \ Increment QQ29 to point to the next item

 LDA QQ29               \ If QQ29 >= 17 then jump to BAY2 as we have done the
 CMP #17                \ last item
 BCS BAY2

 JMP TT220              \ Otherwise loop back to TT220 to print the next market
                        \ item

.BAY2

 LDA #f9                \ Jump into the main loop at FRCE, setting the key
 JMP FRCE               \ "pressed" to red key f9 (so we show the Inventory
                        \ screen)

\ ******************************************************************************
\
\       Name: sell_yn
\       Type: Subroutine
\   Category: Text
\    Summary: Print a "Sell(Y/N)?" prompt and get a number from the keyboard
\
\ ------------------------------------------------------------------------------
\
\ The arguments and results for this routine are the same as for gnum.
\
\ Arguments:
\
\   QQ25                The maximum number allowed
\
\ Returns:
\
\   A                   The number entered
\
\   R                   Also contains the number entered
\
\   C flag              Set if the number is too large (> QQ25), clear otherwise
\
\ ******************************************************************************

.sell_yn

 LDA #205               \ Print recursive token 45 ("SELL")
 JSR TT27

 LDA #206               \ Print extended token 206 ("{all caps}(Y/N)?")
 JSR DETOK

                        \ Fall through into gnum to get a number from the
                        \ keyboard

\ ******************************************************************************
\
\       Name: gnum
\       Type: Subroutine
\   Category: Market
\    Summary: Get a number from the keyboard
\
\ ------------------------------------------------------------------------------
\
\ Get a number from the keyboard, up to the maximum number in QQ25, for the
\ buying and selling of cargo and equipment.
\
\ Pressing "Y" will return the maximum number (i.e. buy/sell all items), while
\ pressing "N" will abort the sale and return a 0.
\
\ Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
\ that includes pressing Space or Return), while pressing a key with an ASCII
\ code greater than ASCII "9" will jump to the Inventory screen (so that
\ includes all letters and most punctuation).
\
\ Arguments:
\
\   QQ25                The maximum number allowed
\
\ Returns:
\
\   A                   The number entered
\
\   R                   Also contains the number entered
\
\   C flag              Set if the number is too large (> QQ25), clear otherwise
\
\ ******************************************************************************

.gnum

 LDX #0                 \ We will build the number entered in R, so initialise
 STX R                  \ it with 0

 LDX #12                \ We will check for up to 12 key presses, so set a
 STX T1                 \ counter in T1

.TT223

 JSR TT217              \ Scan the keyboard until a key is pressed, and return
                        \ the key's ASCII code in A (and X)

 LDX R                  \ If R is non-zero then skip to NWDAV2, as we are
 BNE NWDAV2             \ already building a number

 CMP #'y'               \ If "Y" was pressed, jump to NWDAV1 to return the
 BEQ NWDAV1             \ maximum number allowed (i.e. buy/sell the whole stock)

 CMP #'n'               \ If "N" was pressed, jump to NWDAV3 to return from the
 BEQ NWDAV3             \ subroutine with a result of 0 (i.e. abort transaction)

.NWDAV2

 STA Q                  \ Store the key pressed in Q

 SEC                    \ Subtract ASCII "0" from the key pressed, to leave the
 SBC #'0'               \ numeric value of the key in A (if it was a number key)

 BCC OUT                \ If A < 0, jump to OUT to return from the subroutine
                        \ with a result of 0, as the key pressed was not a
                        \ number or letter and is less than ASCII "0"

 CMP #10                \ If A >= 10, jump to BAY2 to display the Inventory
 BCS BAY2               \ screen, as the key pressed was a letter or other
                        \ non-digit and is greater than ASCII "9"

 STA S                  \ Store the numeric value of the key pressed in S

 LDA R                  \ Fetch the result so far into A

 CMP #26                \ If A >= 26, where A is the number entered so far, then
 BCS OUT                \ adding a further digit will make it bigger than 256,
                        \ so jump to OUT to return from the subroutine with the
                        \ result in R (i.e. ignore the last key press)

 ASL A                  \ Set A = (A * 2) + (A * 8) = A * 10
 STA T
 ASL A
 ASL A
 ADC T

 ADC S                  \ Add the pressed digit to A and store in R, so R now
 STA R                  \ contains its previous value with the new key press
                        \ tacked onto the end

 CMP QQ25               \ If the result in R = the maximum allowed in QQ25, jump
 BEQ TT226              \ to TT226 to print the key press and keep looping (the
                        \ BEQ is needed because the BCS below would jump to OUT
                        \ if R >= QQ25, which we don't want)

 BCS OUT                \ If the result in R > QQ25, jump to OUT to return from
                        \ the subroutine with the result in R

.TT226

 LDA Q                  \ Print the character in Q (i.e. the key that was
 JSR TT26               \ pressed, as we stored the ASCII value in Q earlier)

 DEC T1                 \ Decrement the loop counter

 BNE TT223              \ Loop back to TT223 until we have checked for 12 digits

.OUT

 LDA R                  \ Set A to the result we have been building in R

 RTS                    \ Return from the subroutine

.NWDAV1

                        \ If we get here then "Y" was pressed, so we return the
                        \ maximum number allowed, which is in QQ25

 JSR TT26               \ Print the character for the key that was pressed

 LDA QQ25               \ Set R = QQ25, so we return the maximum value allowed
 STA R

 RTS                    \ Return from the subroutine

.NWDAV3

                        \ If we get here then "N" was pressed, so we return 0

 JSR TT26               \ Print the character for the key that was pressed

 LDA #0                 \ Set R = 0, so we return 0
 STA R

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sell_jump
\       Type: Subroutine
\   Category: Equipment
\    Summary: Show the Sell Equipment screen (CTRL-f2)
\
\ ******************************************************************************

.sell_jump

 INC XC                 \ Move the text cursor down one line

 LDA #207               \ Print recursive token 47 ("EQUIP") and draw a
 JSR NLIN3              \ horizontal line at pixel row 19 to box in the title

 JSR TT69               \ Call TT69 to set Sentence Case and print a newline

 JSR TT67               \ Print a newline

 JSR sell_equip         \ Call sell_equip to show the Sell Equipment screen,
                        \ which will run through all the equipment apart from
                        \ the escape pod

 LDA ESCP               \ If we do not have an escape pod fitted, in which case
 BEQ sell_escape        \ ESCP will be 0, jump to sell_escape

 LDA #112               \ We do have an E.C.M. fitted, so print recursive token
 LDX #30                \ 112 ("ESCAPE POD"), and as this is the Sell Equipment
 JSR status_equip       \ screen, show and process a sell prompt for the piece
                        \ of equipment at LASER+X = LASER+30 = ESCP before
                        \ printing a newline

.sell_escape

 JMP BAY                \ Go to the docking bay (i.e. show the Status Mode
                        \ screen) and return from the subroutine with a tail
                        \ call

\ ******************************************************************************
\
\       Name: NWDAV4
\       Type: Subroutine
\   Category: Market
\    Summary: Print an "ITEM?" error, make a beep and rejoin the TT210 routine
\
\ ******************************************************************************

.NWDAV4

 JSR TT67               \ Print a newline

 LDA #176               \ Print recursive token 127 ("ITEM") followed by a
 JSR prq                \ question mark

 JSR dn2                \ Call dn2 to make a short, high beep and delay for 1
                        \ second

 LDY QQ29               \ Fetch the item number we are selling from QQ29

 JMP NWDAVxx            \ Jump back into the TT210 routine that called NWDAV4

\ ******************************************************************************
\
\       Name: TT208
\       Type: Subroutine
\   Category: Market
\    Summary: Show the Sell Cargo screen (red key f2) or Sell Equipment screen
\             (CTRL-f2)
\
\ ******************************************************************************

.TT208

 LDA #4                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 4 (Sell
                        \ Cargo screen)

 LDA #10                \ Move the text cursor to column 10
 STA XC

 JSR FLKB               \ Flush the keyboard buffer

 LDA #205               \ Print recursive token 45 ("SELL")
 JSR TT27

 JSR CTRL               \ Scan the keyboard to see if CTRL is currently pressed,
                        \ returning a negative value in A if it is

 BMI sell_jump          \ If CTRL is being pressed, jump to sell_jump to show
                        \ the Sell Equipment screen (CTRL-f2)

 LDA #206               \ Print recursive token 46 (" CARGO{sentence case}")
 JSR NLIN3              \ draw a horizontal line at pixel row 19 to box in the
                        \ title

 JSR TT67               \ Print a newline

                        \ Fall through into TT210 to show the Inventory screen
                        \ with the option to sell

\ ******************************************************************************
\
\       Name: TT210
\       Type: Subroutine
\   Category: Inventory
\    Summary: Show a list of current cargo in our hold, optionally to sell
\
\ ------------------------------------------------------------------------------
\
\ Show a list of current cargo in our hold, either with the ability to sell (the
\ Sell Cargo screen) or without (the Inventory screen), depending on the current
\ view.
\
\ Arguments:
\
\   QQ11                The current view:
\
\                           * 4 = Sell Cargo
\
\                           * 8 = Inventory
\
\ Other entry points:
\
\   NWDAVxx             Used to rejoin this routine from the call to NWDAV4
\
\ ******************************************************************************

.TT210

 LDY #0                 \ We're going to loop through all the available market
                        \ items and check whether we have any in the hold (and,
                        \ if we are in the Sell Cargo screen, whether we want
                        \ to sell any items), so we set up a counter in Y to
                        \ denote the current item and start it at 0

.TT211

 STY QQ29               \ Store the current item number in QQ29

.NWDAVxx

 LDX QQ20,Y             \ Fetch into X the amount of the current item that we
 BEQ TT212              \ have in our cargo hold, which is stored in QQ20+Y,
                        \ and if there are no items of this type in the hold,
                        \ jump down to TT212 to skip to the next item

 TYA                    \ Set Y = Y * 4, so this will act as an index into the
 ASL A                  \ market prices table at QQ23 for this item (as there
 ASL A                  \ are four bytes per item in the table)
 TAY

 LDA QQ23+1,Y           \ Fetch byte #1 from the market prices table for the
 STA QQ19+1             \ current item and store it in QQ19+1, for use by the
                        \ call to TT152 below

 TXA                    \ Store the amount of item in the hold (in X) on the
 PHA                    \ stack

 JSR TT69               \ Call TT69 to set Sentence Case and print a newline

 CLC                    \ Print recursive token 48 + QQ29, which will be in the
 LDA QQ29               \ range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
 ADC #208               \ prints the current item's name
 JSR TT27

 LDA #14                \ Move the text cursor to column 14, for the item's
 STA XC                 \ quantity

 PLA                    \ Restore the amount of item in the hold into X
 TAX

 STA QQ25               \ Store the amount of this item in the hold in QQ25

 CLC                    \ Print the 8-bit number in X to 3 digits, without a
 JSR pr2                \ decimal point

 JSR TT152              \ Print the unit ("t", "kg" or "g") for the market item
                        \ whose byte #1 from the market prices table is in
                        \ QQ19+1 (which we set up above)

 LDA QQ11               \ If the current view type in QQ11 is not 4 (Sell Cargo
 CMP #4                 \ screen), jump to TT212 to skip the option to sell
 BNE TT212              \ items

 JSR sell_yn            \ Call sell_yn to print a "Sell(Y/N)?" prompt and get a
                        \ number from the keyboard, which will be the number of
                        \ the item we want to sell, returning the number entered
                        \ in A and R, and setting the C flag if the number is
                        \ bigger than the available amount of this item in QQ25

 BEQ TT212              \ If no number was entered, jump to TT212 to move on to
                        \ the next item

 BCS NWDAV4             \ If the number entered was too big, jump to NWDAV4 to
                        \ print an "ITEM?" error, make a beep and rejoin the
                        \ routine at NWDAVxx above

 LDA QQ29               \ We are selling this item, so fetch the item number
                        \ from QQ29

 LDX #255               \ Set QQ17 = 255 to disable printing
 STX QQ17

 JSR TT151              \ Call TT151 to set QQ24 to the item's price / 4 (the
                        \ routine doesn't print the item details, as we just
                        \ disabled printing)

 LDY QQ29               \ Subtract R (the number of items we just asked to buy)
 LDA QQ20,Y             \ from the available amount of this item in QQ20, as we
 SEC                    \ just bought them
 SBC R
 STA QQ20,Y

 LDA R                  \ Set P to the amount of this item we just bought
 STA P

 LDA QQ24               \ Set Q to the item's price / 4
 STA Q

 JSR MULTU              \ Call MULTU to calculate (A P) = P * Q

 JSR price_xy           \ Call price_xy to set (Y X) = (A P) = P * Q

 JSR MCASH              \ Add 4 * (Y X) cash to the cash pot in CASH, i.e.
 JSR MCASH              \
 JSR MCASH              \   (Y X) = P * Q * 4
 JSR MCASH              \
                        \ which will be the total price we make from this sale
                        \ (as P contains the quantity we're selling and Q
                        \ contains the item's price / 4)

 LDA #0                 \ We've made the sale, so set the amount

 STA QQ17               \ Set QQ17 = 0, which enables printing again

.TT212

 LDY QQ29               \ Fetch the item number from QQ29 into Y, and increment
 INY                    \ Y to point to the next item

 CPY #17                \ Loop back to TT211 to print the next item in the hold
 BCC TT211              \ until Y = 17 (at which point we have done the last
                        \ item)

 LDA QQ11               \ If the current view type in QQ11 is not 4 (Sell Cargo
 CMP #4                 \ screen), skip the next two instructions and just
 BNE P%+8               \ return from the subroutine

 JSR dn2                \ This is the Sell Cargo screen, so call dn2 to make a
                        \ short, high beep and delay for 1 second

 JMP BAY2               \ And then jump to BAY2 to display the Inventory
                        \ screen, as we have finished selling cargo

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT213
\       Type: Subroutine
\   Category: Inventory
\    Summary: Show the Inventory screen (red key f9)
\
\ ******************************************************************************

.TT213

 LDA #8                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 8 (Inventory
                        \ screen)

 LDA #11                \ Move the text cursor to column 11 to print the screen
 STA XC                 \ title

 LDA #164               \ Print recursive token 4 ("INVENTORY{crlf}") followed
 JSR TT60               \ by a paragraph break and Sentence Case

 JSR NLIN4              \ Draw a horizontal line at pixel row 19 to box in the
                        \ title. The authors could have used a call to NLIN3
                        \ instead and saved the above call to TT60, but you
                        \ just can't optimise everything

 JSR fwl                \ Call fwl to print the fuel and cash levels on two
                        \ separate lines

 LDA #14                \ Print recursive token 128 ("SPACE") followed by a
 JSR TT68               \ colon

 LDX new_hold           \ Set X to the amount of free space in our current
 DEX                    \ ship's hold, minus 1 as new_hold contains the amount
                        \ of free space plus 1

 CLC                    \ Call pr2 to print the amount of free space as a
 JSR pr2                \ 3-digit number without a decimal point (by clearing
                        \ the C flag)

 JSR TT160              \ Print "t" (for tonne) and a space

 JMP TT210              \ Jump to TT210 to print the contents of our cargo bay
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT16
\       Type: Subroutine
\   Category: Charts
\    Summary: Move the crosshairs on a chart
\
\ ------------------------------------------------------------------------------
\
\ Move the chart crosshairs by the amount in X and Y.
\
\ Arguments:
\
\   X                   The amount to move the crosshairs in the x-axis
\
\   Y                   The amount to move the crosshairs in the y-axis
\
\ ******************************************************************************

.TT16

 TXA                    \ Push the change in X onto the stack (let's call this
 PHA                    \ the x-delta)

 DEY                    \ Negate the change in Y and push it onto the stack
 TYA                    \ (let's call this the y-delta)
 EOR #&FF
 PHA

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will erase the crosshairs currently there

 PLA                    \ Store the y-delta in QQ19+3 and fetch the current
 STA QQ19+3             \ y-coordinate of the crosshairs from QQ10 into A, ready
 LDA QQ10               \ for the call to TT123

 JSR TT123              \ Call TT123 to move the selected system's galactic
                        \ y-coordinate by the y-delta, putting the new value in
                        \ QQ19+4

 LDA QQ19+4             \ Store the updated y-coordinate in QQ10 (the current
 STA QQ10               \ y-coordinate of the crosshairs)

 STA QQ19+1             \ This instruction has no effect, as QQ19+1 is
                        \ overwritten below, both in TT103 and TT105

 PLA                    \ Store the x-delta in QQ19+3 and fetch the current
 STA QQ19+3             \ x-coordinate of the crosshairs from QQ10 into A, ready
 LDA QQ9                \ for the call to TT123

 JSR TT123              \ Call TT123 to move the selected system's galactic
                        \ x-coordinate by the x-delta, putting the new value in
                        \ QQ19+4

 LDA QQ19+4             \ Store the updated x-coordinate in QQ9 (the current
 STA QQ9                \ x-coordinate of the crosshairs)

 STA QQ19               \ This instruction has no effect, as QQ19 is overwritten
                        \ below, both in TT103 and TT105

                        \ Now we've updated the coordinates of the crosshairs,
                        \ fall through into TT103 to redraw them at their new
                        \ location

\ ******************************************************************************
\
\       Name: TT103
\       Type: Subroutine
\   Category: Charts
\    Summary: Draw a small set of crosshairs on a chart
\
\ ------------------------------------------------------------------------------
\
\ Draw a small set of crosshairs on a galactic chart at the coordinates in
\ (QQ9, QQ10).
\
\ ******************************************************************************

.TT103

 LDA QQ11               \ Fetch the current view type into A

 BMI TT105              \ If this is the Short-range Chart screen, jump to TT105

 LDA QQ9                \ Store the crosshairs x-coordinate in QQ19
 STA QQ19

 LDA QQ10               \ Halve the crosshairs y-coordinate and store it in QQ19
 LSR A                  \ (we halve it because the Long-range Chart is half as
 STA QQ19+1             \ high as it is wide)

 LDA #4                 \ Set QQ19+2 to 4 denote crosshairs of size 4
 STA QQ19+2

 JMP TT15               \ Jump to TT15 to draw crosshairs of size 4 at the
                        \ crosshairs coordinates, returning from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: TT123
\       Type: Subroutine
\   Category: Charts
\    Summary: Move galactic coordinates by a signed delta
\
\ ------------------------------------------------------------------------------
\
\ Move an 8-bit galactic coordinate by a certain distance in either direction
\ (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
\ overflow. The coordinate is in a single axis, so it's either an x-coordinate
\ or a y-coordinate.
\
\ Arguments:
\
\   A                   The galactic coordinate to update
\
\   QQ19+3              The delta (can be positive or negative)
\
\ Returns:
\
\   QQ19+4              The updated coordinate after moving by the delta (this
\                       will be the same as A if moving by the delta overflows)
\
\ Other entry points:
\
\   TT180               Contains an RTS
\
\ ******************************************************************************

.TT123

 STA QQ19+4             \ Store the original coordinate in temporary storage at
                        \ QQ19+4

 CLC                    \ Set A = A + QQ19+3, so A now contains the original
 ADC QQ19+3             \ coordinate, moved by the delta

 LDX QQ19+3             \ If the delta is negative, jump to TT124
 BMI TT124

 BCC TT125              \ If the C flag is clear, then the above addition didn't
                        \ overflow, so jump to TT125 to return the updated value

 RTS                    \ Otherwise the C flag is set and the above addition
                        \ overflowed, so do not update the return value

.TT124

 BCC TT180              \ If the C flag is clear, then because the delta is
                        \ negative, this indicates the addition (which is
                        \ effectively a subtraction) underflowed, so jump to
                        \ TT180 to return from the subroutine without updating
                        \ the return value

.TT125

 STA QQ19+4             \ Store the updated coordinate in QQ19+4

.TT180

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT105
\       Type: Subroutine
\   Category: Charts
\    Summary: Draw crosshairs on the Short-range Chart, with clipping
\
\ ------------------------------------------------------------------------------
\
\ Check whether the crosshairs are close enough to the current system to appear
\ on the Short-range Chart, and if so, draw them.
\
\ ******************************************************************************

.TT105

 LDA QQ9                \ Set A = QQ9 - QQ0, the horizontal distance between the
 SEC                    \ crosshairs (QQ9) and the current system (QQ0)
 SBC QQ0

 CMP #38                \ If the horizontal distance in A < 38, then the
 BCC TT179              \ crosshairs are close enough to the current system to
                        \ appear in the Short-range Chart, so jump to TT179 to
                        \ check the vertical distance

 CMP #230               \ If the horizontal distance in A < -26, then the
 BCC TT180              \ crosshairs are too far from the current system to
                        \ appear in the Short-range Chart, so jump to TT180 to
                        \ return from the subroutine (as TT180 contains an RTS)

.TT179

 ASL A                  \ Set QQ19 = 104 + A * 4
 ASL A                  \
 CLC                    \ 104 is the x-coordinate of the centre of the chart,
 ADC #104               \ so this sets QQ19 to the screen pixel x-coordinate
 STA QQ19               \ of the crosshairs

 LDA QQ10               \ Set A = QQ10 - QQ1, the vertical distance between the
 SEC                    \ crosshairs (QQ10) and the current system (QQ1)
 SBC QQ1

 CMP #38                \ If the vertical distance in A is < 38, then the
 BCC P%+6               \ crosshairs are close enough to the current system to
                        \ appear in the Short-range Chart, so skip the next two
                        \ instructions

 CMP #220               \ If the horizontal distance in A is < -36, then the
 BCC TT180              \ crosshairs are too far from the current system to
                        \ appear in the Short-range Chart, so jump to TT180 to
                        \ return from the subroutine (as TT180 contains an RTS)

 ASL A                  \ Set QQ19+1 = 90 + A * 2
 CLC                    \
 ADC #90                \ 90 is the y-coordinate of the centre of the chart,
 STA QQ19+1             \ so this sets QQ19+1 to the screen pixel x-coordinate
                        \ of the crosshairs

 LDA #8                 \ Set QQ19+2 to 8 denote crosshairs of size 8
 STA QQ19+2

 JMP TT15               \ Jump to TT15 to draw crosshairs of size 8 at the
                        \ crosshairs coordinates, returning from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: TT23
\       Type: Subroutine
\   Category: Charts
\    Summary: Show the Short-range Chart (red key f5)
\
\ ******************************************************************************

.TT23

 LDA #128               \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 128 (Short-
                        \ range Chart)

 LDA #7                 \ Move the text cursor to column 7
 STA XC

 LDA #190               \ Print recursive token 30 ("SHORT RANGE CHART") and
 JSR NLIN3              \ draw a horizontal line at pixel row 19 to box in the
                        \ title

 JSR TT14               \ Call TT14 to draw a circle with crosshairs at the
                        \ current system's galactic coordinates

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ i.e. at the selected system

 JSR TT81               \ Set the seeds in QQ15 to those of system 0 in the
                        \ current galaxy (i.e. copy the seeds from QQ21 to QQ15)

 LDA #0                 \ Set A = 0, which we'll use below to zero out the INWK
                        \ workspace

 STA XX20               \ We're about to start working our way through each of
                        \ the galaxy's systems, so set up a counter in XX20 for
                        \ each system, starting at 0 and looping through to 255

 LDX #24                \ First, though, we need to zero out the 25 bytes at
                        \ INWK so we can use them to work out which systems have
                        \ room for a label, so set a counter in X for 25 bytes

.EE3

 STA INWK,X             \ Set the X-th byte of INWK to zero

 DEX                    \ Decrement the counter

 BPL EE3                \ Loop back to EE3 for the next byte until we've zeroed
                        \ all 25 bytes

                        \ We now loop through every single system in the galaxy
                        \ and check the distance from the current system whose
                        \ coordinates are in (QQ0, QQ1). We get the galactic
                        \ coordinates of each system from the system's seeds,
                        \ like this:
                        \
                        \   x = s1_hi (which is stored in QQ15+3)
                        \   y = s0_hi (which is stored in QQ15+1)
                        \
                        \ so the following loops through each system in the
                        \ galaxy in turn and calculates the distance between
                        \ (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one

.TT182

 LDA QQ15+3             \ Set A = s1_hi - QQ0, the horizontal distance between
 SEC                    \ (s1_hi, s0_hi) and (QQ0, QQ1)
 SBC QQ0

 STA XX12               \ Store the horizontal distance in XX12, so we can
                        \ retrieve it later

 BCS TT184              \ If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
                        \ result is positive, so jump to TT184 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |s1_hi - QQ0|)

.TT184

 CMP #20                \ If the horizontal distance in A is >= 20, then this
 BCS TT187              \ system is too far away from the current system to
                        \ appear in the Short-range Chart, so jump to TT187 to
                        \ move on to the next system

 LDA QQ15+1             \ Set A = s0_hi - QQ1, the vertical distance between
 SEC                    \ (s1_hi, s0_hi) and (QQ0, QQ1)
 SBC QQ1

 STA K4                 \ Store the vertical distance in K4, so we can retrieve
                        \ it later

 BCS TT186              \ If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
                        \ result is positive, so jump to TT186 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |s0_hi - QQ1|)

.TT186

 CMP #38                \ If the vertical distance in A is >= 38, then this
 BCS TT187              \ system is too far away from the current system to
                        \ appear in the Short-range Chart, so jump to TT187 to
                        \ move on to the next system

                        \ This system should be shown on the Short-range Chart,
                        \ so now we need to work out where the label should go,
                        \ and set up the various variables we need to draw the
                        \ system's filled circle on the chart

 LDA XX12               \ Retrieve the horizontal distance from XX12, so A now
                        \ contains the horizontal distance between this system
                        \ and the current system
                        \
                        \ Let's call this the x-delta, as it's the horizontal
                        \ difference between the current system at the centre of
                        \ the chart, and this system (so A is negative if it's
                        \ to the left of the chart's centre, or positive if it's
                        \ to the right)

 ASL A                  \ Set XX12 = 104 + x-delta * 4
 ASL A                  \
 ADC #104               \ 104 is the x-coordinate of the centre of the chart,
 STA XX12               \ so this sets XX12 to the centre 104 +/- 76, the pixel
                        \ x-coordinate of this system

 LSR A                  \ Move the text cursor to column x-delta / 2 + 1
 LSR A                  \ which will be in the range 1-10
 LSR A
 STA XC
 INC XC

 LDA K4                 \ Retrieve the vertical distance from XX12, so A now
                        \ contains the vertical distance between this system
                        \ and the current system
                        \
                        \ Let's call this the y-delta, as it's the vertical
                        \ difference between the current system at the centre of
                        \ the chart, and this system (so A is negative if it's
                        \ above the chart's centre, or positive if it's below)

 ASL A                  \ Set K4 = 90 + y-delta * 2
 ADC #90                \
 STA K4                 \ 90 is the y-coordinate of the centre of the chart,
                        \ so this sets K4 to the centre 90 +/- 74, the pixel
                        \ y-coordinate of this system

 LSR A                  \ Set Y = K4 / 8, so Y contains the number of the text
 LSR A                  \ row that contains this system
 LSR A
 TAY

                        \ Now to see if there is room for this system's label.
                        \ Ideally we would print the system name on the same
                        \ text row as the system, but we only want to print one
                        \ label per row, to prevent overlap, so now we check
                        \ this system's row, and if that's already occupied,
                        \ the row above, and if that's already occupied, the
                        \ row below... and if that's already occupied, we give
                        \ up and don't print a label for this system

 LDX INWK,Y             \ If the value in INWK+Y is 0 (i.e. the text row
 BEQ EE4                \ containing this system does not already have another
                        \ system's label on it), jump to EE4 to store this
                        \ system's label on this row

 INY                    \ If the value in INWK+Y+1 is 0 (i.e. the text row below
 LDX INWK,Y             \ the one containing this system does not already have
 BEQ EE4                \ another system's label on it), jump to EE4 to store
                        \ this system's label on this row

 DEY                    \ If the value in INWK+Y-1 is 0 (i.e. the text row above
 DEY                    \ the one containing this system does not already have
 LDX INWK,Y             \ another system's label on it), fall through into to
 BNE ee1                \ EE4 to store this system's label on this row,
                        \ otherwise jump to ee1 to skip printing a label for
                        \ this system (as there simply isn't room)

.EE4

 STY YC                 \ Now to print the label, so move the text cursor to row
                        \ Y (which contains the row where we can print this
                        \ system's label)

 CPY #3                 \ If Y < 3, then the system would clash with the chart
 BCC TT187              \ title, so jump to TT187 to skip showing the system

 LDA #&FF               \ Store &FF in INWK+Y, to denote that this row is now
 STA INWK,Y             \ occupied so we don't try to print another system's
                        \ label on this row

 LDA #%10000000         \ Set bit 7 of QQ17 to switch to Sentence Case
 STA QQ17

 JSR cpl                \ Call cpl to print out the system name for the seeds
                        \ in QQ15 (which now contains the seeds for the current
                        \ system)

.ee1

 LDA #0                 \ Now to plot the star, so set the high bytes of K, K3
 STA K3+1               \ and K4 to 0
 STA K4+1
 STA K+1

 LDA XX12               \ Set the low byte of K3 to XX12, the pixel x-coordinate
 STA K3                 \ of this system

 LDA QQ15+5             \ Fetch s2_hi for this system from QQ15+5, extract bit 0
 AND #1                 \ and add 2 to get the size of the star, which we store
 ADC #2                 \ in K. This will be either 2, 3 or 4, depending on the
 STA K                  \ value of bit 0, and whether the C flag is set (which
                        \ will vary depending on what happens in the above call
                        \ to cpl). Incidentally, the planet's average radius
                        \ also uses s2_hi, bits 0-3 to be precise, but that
                        \ doesn't mean the two sizes affect each other

                        \ We now have the following:
                        \
                        \   K(1 0)  = radius of star (2, 3 or 4)
                        \
                        \   K3(1 0) = pixel x-coordinate of system
                        \
                        \   K4(1 0) = pixel y-coordinate of system
                        \
                        \ which we can now pass to the SUN routine to draw a
                        \ small "sun" on the Short-range Chart for this system

 JSR FLFLLS             \ Call FLFLLS to reset the LSO block

 JSR SUN                \ Call SUN to plot a sun with radius K at pixel
                        \ coordinate (K3, K4)

 JSR FLFLLS             \ Call FLFLLS to reset the LSO block

.TT187

 JSR TT20               \ We want to move on to the next system, so call TT20
                        \ to twist the three 16-bit seeds in QQ15

 INC XX20               \ Increment the counter

 BEQ TT111-1            \ If X = 0 then we have done all 256 systems, so return
                        \ from the subroutine (as TT111-1 contains an RTS)

 JMP TT182              \ Otherwise jump back up to TT182 to process the next
                        \ system

\ ******************************************************************************
\
\       Name: TT81
\       Type: Subroutine
\   Category: Universe
\    Summary: Set the selected system's seeds to those of system 0
\
\ ------------------------------------------------------------------------------
\
\ Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
\ seeds for the selected system (QQ15) - in other words, set the selected
\ system's seeds to those of system 0.
\
\ ******************************************************************************

.TT81

 LDX #5                 \ Set up a counter in X to copy six bytes (for three
                        \ 16-bit numbers)

 LDA QQ21,X             \ Copy the X-th byte in QQ21 to the X-th byte in QQ15
 STA QQ15,X

 DEX                    \ Decrement the counter

 BPL TT81+2             \ Loop back up to the LDA instruction if we still have
                        \ more bytes to copy

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT111
\       Type: Subroutine
\   Category: Universe
\    Summary: Set the current system to the nearest system to a point
\
\ ------------------------------------------------------------------------------
\
\ Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
\ to this point in the galaxy, and set this as the currently selected system.
\
\ Arguments:
\
\   QQ9                 The x-coordinate near which we want to find a system
\
\   QQ10                The y-coordinate near which we want to find a system
\
\ Returns:
\
\   QQ8(1 0)            The distance from the current system to the nearest
\                       system to the original coordinates
\
\   QQ9                 The x-coordinate of the nearest system to the original
\                       coordinates
\
\   QQ10                The y-coordinate of the nearest system to the original
\                       coordinates
\
\   QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
\                       original coordinates
\
\   ZZ                  The system number of the nearest system
\
\ Other entry points:
\
\   TT111-1             Contains an RTS
\
\ ******************************************************************************

.TT111

 JSR TT81               \ Set the seeds in QQ15 to those of system 0 in the
                        \ current galaxy (i.e. copy the seeds from QQ21 to QQ15)

                        \ We now loop through every single system in the galaxy
                        \ and check the distance from (QQ9, QQ10). We get the
                        \ galactic coordinates of each system from the system's
                        \ seeds, like this:
                        \
                        \   x = s1_hi (which is stored in QQ15+3)
                        \   y = s0_hi (which is stored in QQ15+1)
                        \
                        \ so the following loops through each system in the
                        \ galaxy in turn and calculates the distance between
                        \ (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one

 LDY #127               \ Set Y = T = 127 to hold the shortest distance we've
 STY T                  \ found so far, which we initially set to half the
                        \ distance across the galaxy, or 127, as our coordinate
                        \ system ranges from (0,0) to (255, 255)

 LDA #0                 \ Set A = U = 0 to act as a counter for each system in
 STA U                  \ the current galaxy, which we start at system 0 and
                        \ loop through to 255, the last system

.TT130

 LDA QQ15+3             \ Set A = s1_hi - QQ9, the horizontal distance between
 SEC                    \ (s1_hi, s0_hi) and (QQ9, QQ10)
 SBC QQ9

 BCS TT132              \ If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
                        \ result is positive, so jump to TT132 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |s1_hi - QQ9|)

.TT132

 LSR A                  \ Set S = A / 2
 STA S                  \       = |s1_hi - QQ9| / 2

 LDA QQ15+1             \ Set A = s0_hi - QQ10, the vertical distance between
 SEC                    \ (s1_hi, s0_hi) and (QQ9, QQ10)
 SBC QQ10

 BCS TT134              \ If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
                        \ result is positive, so jump to TT134 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |s0_hi - QQ10|)

.TT134

 LSR A                  \ Set A = S + A / 2
 CLC                    \       = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
 ADC S                  \
                        \ So A now contains the sum of the horizontal and
                        \ vertical distances, both divided by 2 so the result
                        \ fits into one byte, and although this doesn't contain
                        \ the actual distance between the systems, it's a good
                        \ enough approximation to use for comparing distances

 CMP T                  \ If A >= T, then this system's distance is bigger than
 BCS TT135              \ our "minimum distance so far" stored in T, so it's no
                        \ closer than the systems we have already found, so
                        \ skip to TT135 to move on to the next system

 STA T                  \ This system is the closest to (QQ9, QQ10) so far, so
                        \ update T with the new "distance" approximation

 LDX #5                 \ As this system is the closest we have found yet, we
                        \ want to store the system's seeds in case it ends up
                        \ being the closest of all, so we set up a counter in X
                        \ to copy six bytes (for three 16-bit numbers)

.TT136

 LDA QQ15,X             \ Copy the X-th byte in QQ15 to the X-th byte in QQ19,
 STA QQ19,X             \ where QQ15 contains the seeds for the system we just
                        \ found to be the closest so far, and QQ19 is temporary
                        \ storage

 DEX                    \ Decrement the counter

 BPL TT136              \ Loop back to TT136 if we still have more bytes to
                        \ copy

 LDA U                  \ Store the system number U in ZZ, so when we are done
 STA ZZ                 \ looping through all the candidates, the winner's
                        \ number will be in ZZ

.TT135

 JSR TT20               \ We want to move on to the next system, so call TT20
                        \ to twist the three 16-bit seeds in QQ15

 INC U                  \ Increment the system counter in U

 BNE TT130              \ If U > 0 then we haven't done all 256 systems yet, so
                        \ loop back up to TT130

                        \ We have now finished checking all the systems in the
                        \ galaxy, and the seeds for the closest system are in
                        \ QQ19, so now we want to copy these seeds to QQ15,
                        \ to set the selected system to this closest system

 LDX #5                 \ So we set up a counter in X to copy six bytes (for
                        \ three 16-bit numbers)

.TT137

 LDA QQ19,X             \ Copy the X-th byte in QQ19 to the X-th byte in QQ15
 STA QQ15,X

 DEX                    \ Decrement the counter

 BPL TT137              \ Loop back to TT137 if we still have more bytes to
                        \ copy

 LDA QQ15+1             \ The y-coordinate of the system described by the seeds
 STA QQ10               \ in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
                        \ as this is where we store the selected system's
                        \ y-coordinate

 LDA QQ15+3             \ The x-coordinate of the system described by the seeds
 STA QQ9                \ in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
                        \ as this is where we store the selected system's
                        \ x-coordinate

                        \ We have now found the closest system to (QQ9, QQ10)
                        \ and have set it as the selected system, so now we
                        \ need to work out the distance between the selected
                        \ system and the current system

 SEC                    \ Set A = QQ9 - QQ0, the horizontal distance between
 SBC QQ0                \ the selected system's x-coordinate (QQ9) and the
                        \ current system's x-coordinate (QQ0)

 BCS TT139              \ If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
                        \ result is positive, so jump to TT139 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |QQ9 - QQ0|)

                        \ A now contains the difference between the two
                        \ systems' x-coordinates, with the sign removed. We
                        \ will refer to this as the x-delta ("delta" means
                        \ change or difference in maths)

.TT139

 JSR SQUA2              \ Set (A P) = A * A
                        \           = |QQ9 - QQ0| ^ 2
                        \           = x_delta ^ 2

 STA K+1                \ Store (A P) in K(1 0)
 LDA P
 STA K

 LDA QQ10               \ Set A = QQ10 - QQ1, the vertical distance between the
 SEC                    \ selected system's y-coordinate (QQ10) and the current
 SBC QQ1                \ system's y-coordinate (QQ1)

 BCS TT141              \ If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
                        \ result is positive, so jump to TT141 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |QQ10 - QQ1|)

.TT141

 LSR A                  \ Set A = A / 2

                        \ A now contains the difference between the two
                        \ systems' y-coordinates, with the sign removed, and
                        \ halved. We halve the value because the galaxy in
                        \ in Elite is rectangular rather than square, and is
                        \ twice as wide (x-axis) as it is high (y-axis), so to
                        \ get a distance that matches the shape of the
                        \ long-range galaxy chart, we need to halve the
                        \ distance between the vertical y-coordinates. We will
                        \ refer to this as the y-delta

 JSR SQUA2              \ Set (A P) = A * A
                        \           = (|QQ10 - QQ1| / 2) ^ 2
                        \           = y_delta ^ 2

                        \ By this point we have the following results:
                        \
                        \   K(1 0) = x_delta ^ 2
                        \    (A P) = y_delta ^ 2
                        \
                        \ so to find the distance between the two points, we
                        \ can use Pythagoras - so first we need to add the two
                        \ results together, and then take the square root

 PHA                    \ Store the high byte of the y-axis value on the stack,
                        \ so we can use A for another purpose

 LDA P                  \ Set Q = P + K, which adds the low bytes of the two
 CLC                    \ calculated values
 ADC K
 STA Q

 PLA                    \ Restore the high byte of the y-axis value from the
                        \ stack into A again

 ADC K+1                \ Set R = A + K+1, which adds the high bytes of the two
 STA R                  \ calculated values, so we now have:
                        \
                        \   (R Q) = K(1 0) + (A P)
                        \         = (x_delta ^ 2) + (y_delta ^ 2)

 JSR LL5                \ Set Q = SQRT(R Q), so Q now contains the distance
                        \ between the two systems, in terms of coordinates

                        \ We now store the distance to the selected system * 4
                        \ in the two-byte location QQ8, by taking (0 Q) and
                        \ shifting it left twice, storing it in QQ8(1 0)

 LDA Q                  \ First we shift the low byte left by setting
 ASL A                  \ A = Q * 2, with bit 7 of A going into the C flag

 LDX #0                 \ Now we set the high byte in QQ8+1 to 0 and rotate
 STX QQ8+1              \ the C flag into bit 0 of QQ8+1
 ROL QQ8+1

 ASL A                  \ And then we repeat the shift left of (QQ8+1 A)
 ROL QQ8+1

 STA QQ8                \ And store A in the low byte, QQ8, so QQ8(1 0) now
                        \ contains Q * 4. Given that the width of the galaxy is
                        \ 256 in coordinate terms, the width of the galaxy
                        \ would be 1024 in the units we store in QQ8

 JMP TT24               \ Call TT24 to calculate system data from the seeds in
                        \ QQ15 and store them in the relevant locations, so our
                        \ new selected system is fully set up, and return from
                        \ the subroutine using a tail call

\ ******************************************************************************
\
\       Name: jmp
\       Type: Subroutine
\   Category: Universe
\    Summary: Set the current system to the selected system
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   (QQ0, QQ1)          The galactic coordinates of the new system
\
\ Other entry points:
\
\   hy5                 Contains an RTS
\
\ ******************************************************************************

.jmp

 LDA QQ9                \ Set the current system's galactic x-coordinate to the
 STA QQ0                \ x-coordinate of the selected system

 LDA QQ10               \ Set the current system's galactic y-coordinate to the
 STA QQ1                \ y-coordinate of the selected system

.hy5

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: pr6
\       Type: Subroutine
\   Category: Text
\    Summary: Print 16-bit number, left-padded to 5 digits, no point
\
\ ------------------------------------------------------------------------------
\
\ Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
\ numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
\ with no decimal point.
\
\ Arguments:
\
\   X                   The low byte of the number to print
\
\   Y                   The high byte of the number to print
\
\ ******************************************************************************

.pr6

 CLC                    \ Do not display a decimal point when printing

                        \ Fall through into pr5 to print X to 5 digits

\ ******************************************************************************
\
\       Name: pr5
\       Type: Subroutine
\   Category: Text
\    Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
\
\ ------------------------------------------------------------------------------
\
\ Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
\ numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
\ Optionally include a decimal point.
\
\ Arguments:
\
\   X                   The low byte of the number to print
\
\   Y                   The high byte of the number to print
\
\   C flag              If set, include a decimal point
\
\ ******************************************************************************

.pr5

 LDA #5                 \ Set the number of digits to print to 5

 JMP TT11               \ Call TT11 to print (Y X) to 5 digits and return from
                        \ the subroutine using a tail call

\ ******************************************************************************
\
\       Name: prq
\       Type: Subroutine
\   Category: Text
\    Summary: Print a text token followed by a question mark
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.prq

 JSR TT27               \ Print the text token in A

 LDA #'?'               \ Print a question mark and return from the
 JMP TT27               \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT151
\       Type: Subroutine
\   Category: Market
\    Summary: Print the name, price and availability of a market item
\  Deep dive: Market item prices and availability
\             Galaxy and system seeds
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of the market item to print, 0-16 (see QQ23
\                       for details of item numbers)
\
\ Returns:
\
\   QQ19+1              Byte #1 from the market prices table for this item
\
\   QQ24                The item's price / 4
\
\   QQ25                The item's availability
\
\ ******************************************************************************

.TT151

 PHA                    \ Store the item number on the stack and in QQ19+4
 STA QQ19+4

 ASL A                  \ Store the item number * 4 in QQ19, so this will act as
 ASL A                  \ an index into the market prices table at QQ23 for this
 STA QQ19               \ item (as there are four bytes per item in the table)

 LDA #1                 \ Move the text cursor to column 1, for the item's name
 STA XC

 PLA                    \ Restore the item number

 ADC #208               \ Print recursive token 48 + A, which will be in the
 JSR TT27               \ range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
                        \ prints the item's name

 LDA #14                \ Move the text cursor to column 14, for the price
 STA XC

 LDX QQ19               \ Fetch byte #1 from the market prices table (units and
 LDA QQ23+1,X           \ economic_factor) for this item and store in QQ19+1
 STA QQ19+1

 LDA QQ26               \ Fetch the random number for this system visit and
 AND QQ23+3,X           \ AND with byte #3 from the market prices table (mask)
                        \ to give:
                        \
                        \   A = random AND mask

 CLC                    \ Add byte #0 from the market prices table (base_price),
 ADC QQ23,X             \ so we now have:
 STA QQ24               \
                        \   A = base_price + (random AND mask)

 JSR TT152              \ Call TT152 to print the item's unit ("t", "kg" or
                        \ "g"), padded to a width of two characters

 JSR var                \ Call var to set QQ19+3 = economy * |economic_factor|
                        \ (and set the availability of alien items to 0)

 LDA QQ19+1             \ Fetch the byte #1 that we stored above and jump to
 BMI TT155              \ TT155 if it is negative (i.e. if the economic_factor
                        \ is negative)

 LDA QQ24               \ Set A = QQ24 + QQ19+3
 ADC QQ19+3             \
                        \       = base_price + (random AND mask)
                        \         + (economy * |economic_factor|)
                        \
                        \ which is the result we want, as the economic_factor
                        \ is positive

 JMP TT156              \ Jump to TT156 to multiply the result by 4

.TT155

 LDA QQ24               \ Set A = QQ24 - QQ19+3
 SEC                    \
 SBC QQ19+3             \       = base_price + (random AND mask)
                        \         - (economy * |economic_factor|)
                        \
                        \ which is the result we want, as economic_factor
                        \ is negative

.TT156

 STA QQ24               \ Store the result in QQ24 and P
 STA P

 LDA #0                 \ Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
 JSR GC2                \ which is the same as (Y X) = P * 4 because A = 0

 SEC                    \ We now have our final price, * 10, so we can call pr5
 JSR pr5                \ to print (Y X) to 5 digits, including a decimal
                        \ point, as the C flag is set

 LDY QQ19+4             \ We now move on to availability, so fetch the market
                        \ item number that we stored in QQ19+4 at the start

 LDA #5                 \ Set A to 5 so we can print the availability to 5
                        \ digits (right-padded with spaces)

 LDX AVL,Y              \ Set X to the item's availability, which is given in
                        \ the AVL table

 STX QQ25               \ Store the availability in QQ25

 CLC                    \ Clear the C flag

 BEQ TT172              \ If none are available, jump to TT172 to print a tab
                        \ and a "-"

 JSR pr2+2              \ Otherwise print the 8-bit number in X to 5 digits,
                        \ right-aligned with spaces. This works because we set
                        \ A to 5 above, and we jump into the pr2 routine just
                        \ after the first instruction, which would normally
                        \ set the number of digits to 3

 JMP TT152              \ Print the unit ("t", "kg" or "g") for the market item,
                        \ with a following space if required to make it two
                        \ characters long, and return from the subroutine using
                        \ a tail call

.TT172

 LDA XC                 \ Move the text cursor in XC to the right by 4 columns,
 ADC #4                 \ so the cursor is where the last digit would be if we
 STA XC                 \ were printing a 5-digit availability number

 LDA #'-'               \ Print a "-" character by jumping to TT162+2, which
 BNE TT162+2            \ contains JMP TT27 (this BNE is effectively a JMP as A
                        \ will never be zero), and return from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: TT152
\       Type: Subroutine
\   Category: Market
\    Summary: Print the unit ("t", "kg" or "g") for a market item
\
\ ------------------------------------------------------------------------------
\
\ Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
\ market prices table is in QQ19+1, right-padded with spaces to a width of two
\ characters (so that's "t ", "kg" or "g ").
\
\ ******************************************************************************

.TT152

 LDA QQ19+1             \ Fetch the economic_factor from QQ19+1

 AND #96                \ If bits 5 and 6 are both clear, jump to TT160 to
 BEQ TT160              \ print "t" for tonne, followed by a space, and return
                        \ from the subroutine using a tail call

 CMP #32                \ If bit 5 is set, jump to TT161 to print "kg" for
 BEQ TT161              \ kilograms, and return from the subroutine using a tail
                        \ call

 JSR TT16a              \ Otherwise call TT16a to print "g" for grams, and fall
                        \ through into TT162 to print a space and return from
                        \ the subroutine

\ ******************************************************************************
\
\       Name: TT162
\       Type: Subroutine
\   Category: Text
\    Summary: Print a space
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   TT162+2             Jump to TT27 to print the text token in A
\
\ ******************************************************************************

.TT162

 LDA #' '               \ Load a space character into A

 JMP TT27               \ Print the text token in A and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT160
\       Type: Subroutine
\   Category: Market
\    Summary: Print "t" (for tonne) and a space
\
\ ******************************************************************************

.TT160

 LDA #'t'               \ Load a "t" character into A

 JSR TT26               \ Print the character, using TT216 so that it doesn't
                        \ change the character case

 BCC TT162              \ Jump to TT162 to print a space and return from the
                        \ subroutine using a tail call (this BCC is effectively
                        \ a JMP as the C flag is cleared by TT26)

\ ******************************************************************************
\
\       Name: TT161
\       Type: Subroutine
\   Category: Market
\    Summary: Print "kg" (for kilograms)
\
\ ******************************************************************************

.TT161

 LDA #'k'               \ Load a "k" character into A

 JSR TT26               \ Print the character, using TT216 so that it doesn't
                        \ change the character case, and fall through into
                        \ TT16a to print a "g" character

\ ******************************************************************************
\
\       Name: TT16a
\       Type: Subroutine
\   Category: Market
\    Summary: Print "g" (for grams)
\
\ ******************************************************************************

.TT16a

 LDA #'g'               \ Load a "g" character into A

 JMP TT26               \ Print the character, using TT216 so that it doesn't
                        \ change the character case, and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT163
\       Type: Subroutine
\   Category: Market
\    Summary: Print the headers for the table of market prices
\
\ ------------------------------------------------------------------------------
\
\ Print the column headers for the prices table in the Buy Cargo and Market
\ Price screens.
\
\ ******************************************************************************

.TT163

 LDA #17                \ Move the text cursor in XC to column 17
 STA XC

 LDA #255               \ Print recursive token 95 token ("UNIT  QUANTITY
 BNE TT162+2            \ {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
                        \ jumping to TT162+2, which contains JMP TT27 (this BNE
                        \ is effectively a JMP as A will never be zero), and
                        \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT167
\       Type: Subroutine
\   Category: Market
\    Summary: Show the Market Price screen (red key f7)
\
\ ******************************************************************************

.TT167

 LDA #16                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 16 (Market
                        \ Price screen)

 LDA #5                 \ Move the text cursor to column 5
 STA XC

 LDA #167               \ Print recursive token 7 ("{current system name} MARKET
 JSR NLIN3              \ PRICES") and draw a horizontal line at pixel row 19
                        \ to box in the title

 LDA #3                 \ Move the text cursor to row 3
 STA YC

 JSR TT163              \ Print the column headers for the prices table

 LDA #0                 \ We're going to loop through all the available market
 STA QQ29               \ items, so we set up a counter in QQ29 to denote the
                        \ current item and start it at 0

.TT168

 LDX #%10000000         \ Set bit 7 of QQ17 to switch to Sentence Case, with the
 STX QQ17               \ next letter in capitals

 JSR TT151              \ Call TT151 to print the item name, market price and
                        \ availability of the current item, and set QQ24 to the
                        \ item's price / 4, QQ25 to the quantity available and
                        \ QQ19+1 to byte #1 from the market prices table for
                        \ this item

 INC YC                 \ Move the text cursor down one row

 INC QQ29               \ Increment QQ29 to point to the next item

 LDA QQ29               \ If QQ29 >= 17 then jump to TT168 as we have done the
 CMP #17                \ last item
 BCC TT168

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: var
\       Type: Subroutine
\   Category: Market
\    Summary: Calculate QQ19+3 = economy * |economic_factor|
\
\ ------------------------------------------------------------------------------
\
\ Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
\ table for an item. Also sets the availability of alien items to 0.
\
\ This routine forms part of the calculations for market item prices (TT151)
\ and availability (GVL).
\
\ Arguments:
\
\   QQ19+1              Byte #1 of the market prices table for this market item
\                       (which contains the economic_factor in bits 0-5, and the
\                       sign of the economic_factor in bit 7)
\
\ ******************************************************************************

.var

 LDA QQ19+1             \ Extract bits 0-5 from QQ19+1 into A, to get the
 AND #31                \ economic_factor without its sign, in other words:
                        \
                        \   A = |economic_factor|

 LDY QQ28               \ Set Y to the economy byte of the current system

 STA QQ19+2             \ Store A in QQ19+2

 CLC                    \ Clear the C flag so we can do additions below

 LDA #0                 \ Set AVL+16 (availability of alien items) to 0,
 STA AVL+16             \ setting A to 0 in the process

.TT153

                        \ We now do the multiplication by doing a series of
                        \ additions in a loop, building the result in A. Each
                        \ loop adds QQ19+2 (|economic_factor|) to A, and it
                        \ loops the number of times given by the economy byte;
                        \ in other words, because A starts at 0, this sets:
                        \
                        \   A = economy * |economic_factor|

 DEY                    \ Decrement the economy in Y, exiting the loop when it
 BMI TT154              \ becomes negative

 ADC QQ19+2             \ Add QQ19+2 to A

 JMP TT153              \ Loop back to TT153 to do another addition

.TT154

 STA QQ19+3             \ Store the result in QQ19+3

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: hyp1
\       Type: Subroutine
\   Category: Universe
\    Summary: Process a jump to the system closest to (QQ9, QQ10)
\
\ ------------------------------------------------------------------------------
\
\ Do a hyperspace jump to the system closest to galactic coordinates
\ (QQ9, QQ10), and set up the current system's state to those of the new system.
\
\ Returns:
\
\   (QQ0, QQ1)          The galactic coordinates of the new system
\
\   QQ2 to QQ2+6        The seeds of the new system
\
\   EV                  Set to 0
\
\   QQ28                The new system's economy
\
\   tek                 The new system's tech level
\
\   gov                 The new system's government
\
\ Other entry points:
\
\   hyp1+3              Jump straight to the system at (QQ9, QQ10) without
\                       first calculating which system is closest. We do this
\                       if we already know that (QQ9, QQ10) points to a system
\
\ ******************************************************************************

.hyp1

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 JSR jmp                \ Set the current system to the selected system

 LDX #5                 \ We now want to copy the seeds for the selected system
                        \ in QQ15 into QQ2, where we store the seeds for the
                        \ current system, so set up a counter in X for copying
                        \ 6 bytes (for three 16-bit seeds)

.TT112

 LDA QQ15,X             \ Copy the X-th byte in QQ15 to the X-th byte in QQ2, to
 STA QQ2,X              \ update the selected system to the new one. Note that
                        \ this approach has a minor bug associated with it: if
                        \ your hyperspace counter hits 0 just as you're docking,
                        \ then you will magically appear in the station in your
                        \ hyperspace destination, without having to go to the
                        \ effort of actually flying there. This bug was fixed in
                        \ later versions by saving the destination seeds in a
                        \ separate location called safehouse, and using those
                        \ instead... but that isn't the case in this version

 DEX                    \ Decrement the counter

 BPL TT112              \ Loop back to TT112 if we still have more bytes to
                        \ copy

 INX                    \ Set X = 0 (as we ended the above loop with X = &FF)

 STX EV                 \ Set EV, the extra vessels spawning counter, to 0, as
                        \ we are entering a new system with no extra vessels
                        \ spawned

 LDA QQ3                \ Set the current system's economy in QQ28 to the
 STA QQ28               \ selected system's economy from QQ3

 LDA QQ5                \ Set the current system's tech level in tek to the
 STA tek                \ selected system's economy from QQ5

 LDA QQ4                \ Set the current system's government in gov to the
 STA gov                \ selected system's government from QQ4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LCASH
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Subtract an amount of cash from the cash pot
\
\ ------------------------------------------------------------------------------
\
\ Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
\ cash in the pot. As CASH is a four-byte number, this calculates:
\
\   CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
\
\ Returns:
\
\   C flag              If set, there was enough cash to do the subtraction
\
\                       If clear, there was not enough cash to do the
\                       subtraction
\
\ ******************************************************************************

.LCASH

 STX T1                 \ Subtract the least significant bytes:
 LDA CASH+3             \
 SEC                    \   CASH+3 = CASH+3 - X
 SBC T1
 STA CASH+3

 STY T1                 \ Then the second most significant bytes:
 LDA CASH+2             \
 SBC T1                 \   CASH+2 = CASH+2 - Y
 STA CASH+2

 LDA CASH+1             \ Then the third most significant bytes (which are 0):
 SBC #0                 \
 STA CASH+1             \   CASH+1 = CASH+1 - 0

 LDA CASH               \ And finally the most significant bytes (which are 0):
 SBC #0                 \
 STA CASH               \   CASH = CASH - 0

 BCS TT113              \ If the C flag is set then the subtraction didn't
                        \ underflow, so the value in CASH is correct and we can
                        \ jump to TT113 to return from the subroutine with the
                        \ C flag set to indicate success (as TT113 contains an
                        \ RTS)

                        \ Otherwise we didn't have enough cash in CASH to
                        \ subtract (Y X) from it, so fall through into
                        \ MCASH to reverse the sum and restore the original
                        \ value in CASH, and returning with the C flag clear

\ ******************************************************************************
\
\       Name: MCASH
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Add an amount of cash to the cash pot
\
\ ------------------------------------------------------------------------------
\
\ Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
\ calculates:
\
\   CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
\
\ Other entry points:
\
\   TT113               Contains an RTS
\
\ ******************************************************************************

.MCASH

 TXA                    \ Add the least significant bytes:
 CLC                    \
 ADC CASH+3             \   CASH+3 = CASH+3 + X
 STA CASH+3

 TYA                    \ Then the second most significant bytes:
 ADC CASH+2             \
 STA CASH+2             \   CASH+2 = CASH+2 + Y

 LDA CASH+1             \ Then the third most significant bytes (which are 0):
 ADC #0                 \
 STA CASH+1             \   CASH+1 = CASH+1 + 0

 LDA CASH               \ And finally the most significant bytes (which are 0):
 ADC #0                 \
 STA CASH               \   CASH = CASH + 0

 CLC                    \ Clear the C flag, so if the above was done following
                        \ a failed LCASH call, the C flag correctly indicates
                        \ failure

.TT113

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GCASH
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (Y X) = P * Q * 4
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following multiplication of unsigned 8-bit numbers:
\
\   (Y X) = P * Q * 4
\
\ ******************************************************************************

.GCASH

 JSR MULTU              \ Call MULTU to calculate (A P) = P * Q

\ ******************************************************************************
\
\       Name: GC2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (Y X) = (A P) * 4
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following multiplication of unsigned 16-bit numbers:
\
\   (Y X) = (A P) * 4
\
\ Other entry points:
\
\   price_xy            Set (Y X) = (A P)
\
\ ******************************************************************************

.GC2

 ASL P                  \ Set (A P) = (A P) * 4
 ROL A
 ASL P
 ROL A

.price_xy

 TAY                    \ Set (Y X) = (A P)
 LDX P

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: update_pod
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Ensure the correct palette is shown for the dashboard/hyperspace
\             tunnel, by sending a write_pod command to the I/O processor
\
\ ******************************************************************************

.update_pod

 LDA #&8F               \ Send command &8F to the I/O processor:
 JSR tube_write         \
                        \   write_pod(escp, hfx)
                        \
                        \ which will update the values of ESCP and HFX in the
                        \ I/O processor, so the palette gets set correctly for
                        \ the dashboard (ESCP) and hyperspace tunnel (HFX)

 LDA ESCP               \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * escp = ESCP

 LDA HFX                \ Send the second parameter to the I/O processor:
 JMP tube_write         \
                        \   * hfx = HFX
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: EQSHP
\       Type: Subroutine
\   Category: Equipment
\    Summary: Show the Equip Ship screen (red key f3) or Buy Ship screen
\             (CTRL-f3)
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   err                 Beep, pause and go to the docking bay (i.e. show the
\                       Status Mode screen)
\
\   pres                Given an item number A with the item name in recursive
\                       token Y, show an error to say that the item is already
\                       present, refund the cost of the item, and then beep and
\                       exit to the docking bay (i.e. show the Status Mode
\                       screen)
\
\   pres+3              Show the error to say that an item is already present,
\                       and process a refund, but do not free up a space in the
\                       hold
\
\ ******************************************************************************

.EQSHP

 LDA #32                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32 (Equip
                        \ Ship screen)

 JSR FLKB               \ Flush the keyboard buffer

 LDA #12                \ Move the text cursor to column 12
 STA XC

 LDA #207               \ Print recursive token 47 ("EQUIP") followed by a space
 JSR spc

 LDA #185               \ Print recursive token 25 ("SHIP") and draw a
 JSR NLIN3              \ horizontal line at pixel row 19 to box in the title

 LDA #%10000000         \ Set bit 7 of QQ17 to switch to Sentence Case, with the
 STA QQ17               \ next letter in capitals

 INC YC                 \ Move the text cursor down one line

 JSR CTRL               \ Scan the keyboard to see if CTRL is currently pressed,
                        \ returning a negative value in A if it is

 BPL n_eqship           \ If CTRL is not being pressed, jump down to n_eqship to
                        \ keep processing the Equip Ship screen

 JMP n_buyship          \ CTRL is being pressed, which means CTRL-f3 is being
                        \ pressed, so jump to n_buyship to show the Buy Ship
                        \ screen instead

.bay

 JMP BAY                \ Go to the docking bay (i.e. show the Status Mode
                        \ screen)

.n_eqship

 LDA tek                \ Fetch the tech level of the current system from tek
 CLC                    \ and add 2 (the tech level is stored as 0-14, so A is
 ADC #2                 \ now set to between 2 and 16)

 CMP #12                \ If A >= 12 then set A = 14, so A is now set to between
 BCC P%+4               \ 2 and 14
 LDA #14

 STA Q                  \ Set QQ25 = A (so QQ25 is in the range 2-14 and
 STA QQ25               \ represents number of the most advanced item available
 INC Q                  \ in this system, which we can pass to gnum below when
                        \ asking which item we want to buy)
                        \
                        \ Set Q = A + 1 (so Q is in the range 3-15 and contains
                        \ QQ25 + 1, i.e. the highest item number on sale + 1)

 LDA new_range          \ Set A = new_range - QQ14, where QQ14 contains the
 SEC                    \ current fuel in light years * 10, so this leaves the
 SBC QQ14               \ amount of fuel we need to fill 'er up (in light years
                        \ * 10)

 ASL A                  \ The price of fuel is always 2 Cr per light year, so we
 STA PRXS               \ double A and store it in PRXS, as the first price in
                        \ the price list (which is reserved for fuel), and
                        \ because the table contains prices as price * 10, it's
                        \ in the right format (so tank containing 7.0 light
                        \ years of fuel would be 14.0 Cr, or a PRXS value of
                        \ 140)

 LDA #0                 \ As the maximum amount of fuel in Elite-A can be more
 ROL A                  \ than 25.5 light years, we need to use PRXS(1 0) to
 STA PRXS+1             \ store the fuel level, so this catches bit 7 from the
                        \ left shift of the low byte above (which the ASL will
                        \ have put into the C flag), and sets bit 0 of the high
                        \ byte in PRXS+1 accordingly

 LDX #1                 \ We are now going to work our way through the equipment
                        \ price list at PRXS, printing out the equipment that is
                        \ available at this station, so set a counter in X,
                        \ starting at 1, to hold the number of the current item
                        \ plus 1 (so the item number in X loops through 1-13)

.EQL1

 STX XX13               \ Store the current item number + 1 in XX13

 JSR TT67               \ Print a newline

 LDX XX13               \ Print the current item number + 1 to 3 digits, left-
 CLC                    \ padding with spaces, and with no decimal point, so the
 JSR pr2                \ items are numbered from 1

 JSR TT162              \ Print a space

 LDA XX13               \ Print recursive token 104 + XX13, which will be in the
 CLC                    \ range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
 ADC #104               \ so this prints the current item's name
 JSR TT27

 LDA XX13               \ Call prx-3 to set (Y X) to the price of the item with
 JSR prx-3              \ number XX13 - 1 (as XX13 contains the item number + 1)

 SEC                    \ Set the C flag so we will print a decimal point when
                        \ we print the price

 LDA #25                \ Move the text cursor to column 25
 STA XC

 LDA #6                 \ Print the number in (Y X) to 6 digits, left-padding
 JSR TT11               \ with spaces and including a decimal point, which will
                        \ be the correct price for this item as (Y X) contains
                        \ the price * 10, so the trailing zero will go after the
                        \ decimal point (i.e. 5250 will be printed as 525.0)

 LDX XX13               \ Increment the current item number in XX13
 INX

 CPX Q                  \ If X < Q, loop back up to print the next item on the
 BCC EQL1               \ list of equipment available at this station

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

 LDA #127               \ Print recursive token 127 ("ITEM") followed by a
 JSR prq                \ question mark

 JSR gnum               \ Call gnum to get a number from the keyboard, which
                        \ will be the number of the item we want to purchase,
                        \ returning the number entered in A and R, and setting
                        \ the C flag if the number is bigger than the highest
                        \ item number in QQ25

 BEQ bay                \ If no number was entered, jump up to bay to go to the
                        \ docking bay (i.e. show the Status Mode screen)

 BCS bay                \ If the number entered was too big, jump up to bay to
                        \ go to the docking bay (i.e. show the Status Mode
                        \ screen)

 SBC #0                 \ Set A to the number entered - 1 (because the C flag is
                        \ clear), which will be the actual item number we want
                        \ to buy

 LDX #2                 \ Move the text cursor to column 2
 STX XC

 INC YC                 \ Move the text cursor down one line

 PHA                    \ Store A on the stack so we can restore it after the
                        \ following code

 CMP #2                 \ If A < 2, then we are buying fuel or missiles, so jump
 BCC equip_space        \ down to equip_space to skip the checks for whether we
                        \ have enough free space in the hold (as fuel and
                        \ missiles don't take up hold space)

 LDA QQ20+16            \ Fetch the number of alien items in the hold into A, so
                        \ the following call to Tml will include these in the
                        \ total

 SEC                    \ Call Tml with X = 12 and the C flag set, to work out
 LDX #12                \ if there is space for one more tonne in the hold
 JSR Tml

 BCC equip_isspace      \ If the C flag is clear then there is indeed room for
                        \ another tonne, so jump to equip_isspace so we can buy
                        \ the new piece of equipment

 LDA #14                \ Otherwise there isn't room in the hold for any more
                        \ equipment, so set A to the value for recursive token
                        \ 14 ("UNIT")

 JMP query_beep         \ Print the recursive token given in A followed by a
                        \ question mark, then make a beep, pause and go to the
                        \ docking bay (i.e. show the Status Mode screen)

.equip_isspace

 DEC new_hold           \ We are now going to buy the piece of equipment, so
                        \ decrement the free space in the hold, as equipment
                        \ takes up hold space in Elite-A

 PLA                    \ Set A to the value from the top of the stack (so it
 PHA                    \ contains the number of the item we want to buy)

.equip_space

 JSR eq                 \ Call eq to subtract the price of the item we want to
                        \ buy (which is in A) from our cash pot, but only if we
                        \ have enough cash in the pot. If we don't have enough
                        \ cash, exit to the docking bay (i.e. show the Status
                        \ Mode screen)

 PLA                    \ Restore A from the stack

 BNE et0                \ If A is not 0 (i.e. the item we've just bought is not
                        \ fuel), skip to et0

 LDX new_range          \ Set the current fuel level in QQ14 to our current
 STX QQ14               \ ship's maximum hyperspace range from new_range, so the
                        \ tank is now full

 JSR DIALS              \ Call DIALS to update the dashboard with the new fuel
                        \ level

 LDA #0                 \ Set A to 0 as the call to DIALS will have overwritten
                        \ the original value, and we still need it set
                        \ correctly so we can continue through the conditional
                        \ statements for all the other equipment

.et0

 CMP #1                 \ If A is not 1 (i.e. the item we've just bought is not
 BNE et1                \ a missile), skip to et1

 LDX NOMSL              \ Fetch the current number of missiles from NOMSL into X

 INX                    \ Increment X to the new number of missiles

 LDY #124               \ Set Y to recursive token 124 ("ALL")

 CPX new_missiles       \ If buying this missile would give us more than the
 BCS pres+3             \ maximum number of missiles that our current ship can
                        \ hold (which is stored in new_missiles), jump to pres+3
                        \ to show the error "All Present", do not free up any
                        \ space in the hold (as missiles do not take up hold
                        \ space), beep and exit to the docking bay (i.e. show
                        \ the Status Mode screen)

 STX NOMSL              \ Otherwise update the number of missiles in NOMSL

 JSR msblob             \ Reset the dashboard's missile indicators so none of
                        \ them are targeted

.et1

 LDY #107               \ Set Y to recursive token 107 ("I.F.F.SYSTEM")

 CMP #2                 \ If A is not 2 (i.e. the item we've just bought is not
 BNE et2                \ an I.F.F. system), skip to et2

 LDX CRGO               \ If we already have an I.F.F. system fitted (i.e. CRGO
 BNE pres               \ is non-zero), jump to pres to show the error "I.F.F.
                        \ System Present", beep and exit to the docking bay
                        \ (i.e. show the Status Mode screen)

 DEC CRGO               \ Otherwise we just scored ourselves an I.F.F. system,
                        \ so set CRGO to &FF (as CRGO was 0 before the DEC
                        \ instruction)

.et2

 CMP #3                 \ If A is not 3 (i.e. the item we've just bought is not
 BNE et3                \ an E.C.M. system), skip to et3

 INY                    \ Increment Y to recursive token 108 ("E.C.M.SYSTEM")

 LDX ECM                \ If we already have an E.C.M. fitted (i.e. ECM is
 BNE pres               \ non-zero), jump to pres to show the error "E.C.M.
                        \ System Present", beep and exit to the docking bay
                        \ (i.e. show the Status Mode screen)

 DEC ECM                \ Otherwise we just took delivery of a brand new E.C.M.
                        \ system, so set ECM to &FF (as ECM was 0 before the DEC
                        \ instruction)

.et3

 CMP #4                 \ If A is not 4 (i.e. the item we've just bought is not
 BNE et4                \ an extra pulse laser), skip to et4

 LDY new_pulse          \ Set Y to the power level of pulse lasers when fitted
                        \ to our current ship type

 BNE equip_leap         \ Jump to equip_merge (via equip_leap) to install the
                        \ new laser (this BNE is effectively a JMP as Y is never
                        \ zero)

.et4

 CMP #5                 \ If A is not 5 (i.e. the item we've just bought is not
 BNE et5                \ an extra beam laser), skip to et5

 LDY new_beam           \ Set Y to the power level of beam lasers when fitted to
                        \ our current ship type

.equip_leap

 BNE equip_frog         \ Jump to equip_merge (via equip_frog) to install the
                        \ new laser (this BNE is effectively a JMP as Y is never
                        \ zero)

.et5

 LDY #111               \ Set Y to recursive token 107 ("FUEL SCOOPS")

 CMP #6                 \ If A is not 6 (i.e. the item we've just bought is not
 BNE et6                \ a fuel scoop), skip to et6

 LDX BST                \ If we already have fuel scoops fitted (i.e. BST is
 BEQ ed9                \ zero), jump to ed9, otherwise fall through into pres
                        \ to show the error "Fuel Scoops Present", beep and
                        \ exit to the docking bay (i.e. show the Status Mode
                        \ screen)

.pres

                        \ If we get here we need to show an error to say that
                        \ the item whose name is in recursive token Y is already
                        \ present, and then process a refund for the cost of
                        \ item number A

 INC new_hold           \ We can't buy the requested equipment, so increment the
                        \ free space in the hold, as we decremented it earlier
                        \ in anticipation of making a deal, but the deal has
                        \ fallen through

 STY K                  \ Store the item's name in K

 JSR prx                \ Call prx to set (Y X) to the price of equipment item
                        \ number A

 JSR MCASH              \ Add (Y X) cash to the cash pot in CASH, as the station
                        \ already took the money for this item in the JSR eq
                        \ instruction above, but we can't fit the item, so need
                        \ our money back

 LDA K                  \ Print the recursive token in K (the item's name)
 JSR spc                \ followed by a space

 LDA #31                \ Print recursive token 145 ("PRESENT")
 JSR TT27

.err

 JSR dn2                \ Call dn2 to make a short, high beep and delay for 1
                        \ second

 JMP BAY                \ Jump to BAY to go to the docking bay (i.e. show the
                        \ Status Mode screen)

.ed9

 DEC BST                \ We just bought a shiny new fuel scoop, so set BST to
                        \ &FF (as BST was 0 before the jump to ed9 above)

.et6

 INY                    \ Increment Y to recursive token 112 ("E.C.M.SYSTEM")

 CMP #7                 \ If A is not 7 (i.e. the item we've just bought is not
 BNE et7                \ an escape pod), skip to et7

 LDX ESCP               \ If we already have an escape pod fitted (i.e. ESCP is
 BNE pres               \ non-zero), jump to pres to show the error "Escape Pod
                        \ Present", beep and exit to the docking bay (i.e. show
                        \ the Status Mode screen)

 DEC ESCP               \ Otherwise we just bought an escape pod, so set ESCP
                        \ to &FF (as ESCP was 0 before the DEC instruction)

 JSR update_pod         \ Update the dashboard colours to reflect that we now
                        \ have an escape pod

.et7

 INY                    \ Increment Y to recursive token 113 ("HYPERSPACE UNIT")

 CMP #8                 \ If A is not 8 (i.e. the item we've just bought is not
 BNE et8                \ a hyperspace unit), skip to et8

 LDX BOMB               \ If we already have a hyperspace unit fitted (i.e. BOMB
 BNE pres               \ is non-zero), jump to pres to show the error
                        \ "Hyperspace Unit Present", beep and exit to the
                        \ docking bay (i.e. show the Status Mode screen)

 DEC BOMB               \ Otherwise we just bought an energy bomb, so set BOMB
                        \ to &FF (as BOMB was 0 before the DEC instruction)

.et8

 INY                    \ Increment Y to recursive token 114 ("ENERGY UNIT")

 CMP #9                 \ If A is not 9 (i.e. the item we've just bought is not
 BNE etA                \ an energy unit), skip to etA

 LDX ENGY               \ If we already have an energy unit fitted (i.e. ENGY is
 BNE pres               \ non-zero), jump to pres to show the error "Energy Unit
                        \ Present", beep and exit to the docking bay (i.e. show
                        \ the Status Mode screen)

 LDX new_energy         \ Otherwise we just picked up an energy unit, so set
 STX ENGY               \ ENGY to new_energy, which is the value of our current
                        \ ship's ship energy refresh rate with an energy unit
                        \ fitted

.etA

 INY                    \ Increment Y to recursive token 115 ("DOCKING
                        \ COMPUTERS")

 CMP #10                \ If A is not 10 (i.e. the item we've just bought is not
 BNE etB                \ a docking computer), skip to etB

 LDX DKCMP              \ If we already have a docking computer fitted (i.e.
 BNE pres               \ DKCMP is non-zero), jump to pres to show the error
                        \ "Docking Computer Present", beep and exit to the
                        \ docking bay (i.e. show the Status Mode screen)

 DEC DKCMP              \ Otherwise we just got hold of a docking computer, so
                        \ set DKCMP to &FF (as DKCMP was 0 before the DEC
                        \ instruction)

.etB

 INY                    \ Increment Y to recursive token 116 ("GALACTIC
                        \ HYPERSPACE ")

 CMP #11                \ If A is not 11 (i.e. the item we've just bought is not
 BNE et9                \ a galactic hyperdrive), skip to et9

 LDX GHYP               \ Set X to the value of GHYP, which determines
                        \ whether we have a galactic hyperdrive fitted

.equip_gfrog

 BNE pres               \ If we already have a galactic hyperdrive fitted (i.e.
                        \ GHYP is non-zero), jump to pres to show the error
                        \ "Galactic Hyperspace Present", beep and exit to the
                        \ docking bay (i.e. show the Status Mode screen)

 DEC GHYP               \ Otherwise we just splashed out on a galactic
                        \ hyperdrive, so set GHYP to &FF (as GHYP was 0 before
                        \ the DEC instruction)

.et9

 INY                    \ Increment Y to recursive token 117 ("MILITARY  LASER")

 CMP #12                \ If A is not 12 (i.e. the item we've just bought is not
 BNE et10               \ a military laser), skip to et10

 LDY new_military       \ Set Y to the power level of military lasers when
                        \ fitted to our current ship type

.equip_frog

 BNE equip_merge        \ Jump to equip_merge to install the new laser (this BNE
                        \ is effectively a JMP as Y is never zero)

.et10

 INY                    \ Increment Y to recursive token 118 ("MINING  LASER")

 CMP #13                \ If A is not 13 (i.e. the item we've just bought is not
 BNE et11               \ a mining laser), skip to et11

 LDY new_mining         \ Set Y to the power level of mining lasers when fitted
                        \ to our current ship type

.equip_merge

                        \ Now to install a new laser with the laser power in Y
                        \ and the item number in A

 PHA                    \ Store the item number in A on the stack

 TYA                    \ Store the laser power in Y on the stack
 PHA

 JSR qv                 \ Print a menu listing the four views, with a "View ?"
                        \ prompt, and ask for a view number, which is returned
                        \ in X (which now contains 0-3)

 PLA                    \ Retrieve the laser power of the new laser from the
                        \ stack into A

 LDY LASER,X            \ If there is no laser mounted in the chosen view (i.e.
 BEQ l_3113             \ LASER+X, which contains the laser power for view X, is
                        \ zero), jump to l_3113 to fit the new laser

                        \ We already have a laser fitted to this view, so

 PLA                    \ Retrieve the item number from the stack into A

 LDY #187               \ Set Y to token 27 (" LASER") so the following jump to
                        \ pres will show the error "Laser Present", beep and
                        \ exit to the docking bay (i.e. show the Status Mode
                        \ screen)

 BNE equip_gfrog        \ Jump to pres via equip_gfrog (this BNE is effectively
                        \ a JMP as Y is never zero)

.l_3113

 STA LASER,X            \ Fit the new laser by storing the laser power in A into
                        \ LASER+X

 PLA                    \ Retrieve the item number from the stack into A

.et11

 JSR dn                 \ We are done buying equipment, so print the amount of
                        \ cash left in the cash pot, then make a short, high
                        \ beep to confirm the purchase, and delay for 1 second

 JMP EQSHP              \ Jump back up to EQSHP to show the Equip Ship screen
                        \ again and see if we can't track down another bargain

\ ******************************************************************************
\
\       Name: dn
\       Type: Subroutine
\   Category: Text
\    Summary: Print the amount of cash and beep
\
\ ------------------------------------------------------------------------------
\
\ Print the amount of money in the cash pot, then make a short, high beep and
\ delay for 1 second.
\
\ ******************************************************************************

.dn

 JSR TT162              \ Print a space

 LDA #119               \ Print recursive token 119 ("CASH:{cash} CR{crlf}")
 JSR spc                \ followed by a space

                        \ Fall through into dn2 to make a beep and delay for
                        \ 1 second before returning from the subroutine

\ ******************************************************************************
\
\       Name: dn2
\       Type: Subroutine
\   Category: Text
\    Summary: Make a short, high beep and delay for 1 second
\
\ ******************************************************************************

.dn2

 JSR BEEP               \ Call the BEEP subroutine to make a short, high beep

 LDY #50                \ Delay for 50 vertical syncs (50/50 = 1 second) and
 JMP DELAY              \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: eq
\       Type: Subroutine
\   Category: Equipment
\    Summary: Subtract the price of equipment from the cash pot
\
\ ------------------------------------------------------------------------------
\
\ If we have enough cash, subtract the price of a specified piece of equipment
\ from our cash pot and return from the subroutine. If we don't have enough
\ cash, exit to the docking bay (i.e. show the Status Mode screen).
\
\ Arguments:
\
\   A                   The item number of the piece of equipment (0-11) as
\                       shown in the table at PRXS
\
\ Other entry points:
\
\   query_beep          Print the recursive token given in A followed by a
\                       question mark, then make a beep, pause and go to the
\                       docking bay (i.e. show the Status Mode screen)
\
\ ******************************************************************************

.eq

 JSR prx                \ Call prx to set (Y X) to the price of equipment item
                        \ number A

 JSR LCASH              \ Subtract (Y X) cash from the cash pot, but only if
                        \ we have enough cash

 BCS c                  \ If the C flag is set then we did have enough cash for
                        \ the transaction, so jump to c to return from the
                        \ subroutine (as c contains an RTS)

 LDA #197               \ Otherwise we don't have enough cash to buy this piece
                        \ of equipment, so set A to the value for recursive
                        \ token 37 ("CASH")

.query_beep

 JSR prq                \ Print the recursive token in A followed by a question
                        \ mark

 JMP err                \ Jump to err to beep, pause and go to the docking bay
                        \ (i.e. show the Status Mode screen)

\ ******************************************************************************
\
\       Name: prx
\       Type: Subroutine
\   Category: Equipment
\    Summary: Return the price of a piece of equipment
\
\ ------------------------------------------------------------------------------
\
\ This routine returns the price of equipment as listed in the table at PRXS.
\
\ Arguments:
\
\   A                   The item number of the piece of equipment (0-13) as
\                       shown in the table at PRXS
\
\ Returns:
\
\   (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
\
\   (A X)               Contains the same as (Y X)
\
\ Other entry points:
\
\   prx-3               Return the price of the item with number A - 1
\
\   c                   Contains an RTS
\
\ ******************************************************************************

 SEC                    \ Decrement A (for when this routine is called via
 SBC #1                 \ prx-3)

.prx

 ASL A                  \ Set A = A * 2, so it can act as an index into the
                        \ PRXS table, which has two bytes per entry

 BEQ n_fcost            \ If A = 0, skip the following, as we are fetching the
                        \ price of fuel, and fuel is always the same price,
                        \ regardless of ship type

 ADC new_costs          \ In Elite-A the PRXS table has multiple sections, for
                        \ the different types of ship we can buy, and the offset
                        \ to the price table for our current ship is held in
                        \ new_costs, so this points the index in A to the
                        \ correct section of the PRXS table for our current ship

.n_fcost

 TAY                    \ Copy A into Y, so it can be used as an index

 LDX PRXS,Y             \ Fetch the low byte of the price into X

 LDA PRXS+1,Y           \ Fetch the high byte of the price into A and transfer
 TAY                    \ it to X, so the price is now in (Y X)

.c

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: qv
\       Type: Subroutine
\   Category: Equipment
\    Summary: Print a menu of the four space views, for buying lasers
\
\ ------------------------------------------------------------------------------
\
\ Print a menu in the bottom-middle of the screen, at row 16, column 12, that
\ lists the four available space views, like this:
\
\                 0 Front
\                 1 Rear
\                 2 Left
\                 3 Right
\
\ Also print a "View ?" prompt and ask for a view number. The menu is shown
\ when we choose to buy a new laser in the Equip Ship screen.
\
\ Returns:
\
\   X                   The chosen view number (0-3)
\
\ ******************************************************************************

.qv

 LDA tek                \ If the current system's tech level is less than 8,
 CMP #8                 \ skip the next two instructions, otherwise we clear the
 BCC P%+7               \ screen to prevent the view menu from clashing with the
                        \ longer equipment menu available in higher tech systems

 LDA #32                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32 (Equip
                        \ Ship screen)

 LDY #16                \ Move the text cursor to row 16, and at the same time
 STY YC                 \ set YC to a counter going from 16 to 19 in the loop
                        \ below

.qv1

 LDX #12                \ Move the text cursor to column 12
 STX XC

 LDA YC                 \ Fetch the counter value from YC into A

 CLC                    \ Print ASCII character "0" - 16 + A, so as A goes from
 ADC #'0'-16            \ 16 to 19, this prints "0" through "3" followed by a
 JSR spc                \ space

 LDA YC                 \ Print recursive text token 80 + YC, so as YC goes from
 CLC                    \ 16 to 19, this prints "FRONT", "REAR", "LEFT" and
 ADC #80                \ "RIGHT"
 JSR TT27

 INC YC                 \ Move the text cursor down a row, and increment the
                        \ counter in YC at the same time

 LDA new_mounts         \ Set A = new_mounts + 16, so A now contains a value of
 ORA #16                \ 17, 18 or 20, depending on the number of laser mounts
                        \ that our current ship supports (in other words, it's
                        \ one more than the corresponding value in the YC
                        \ counter, which is going from 16 to 19, not 17 to 20)

 CMP YC                 \ If the loop counter in YC hasn't yet reached the
 BNE qv1                \ value in A, then loop back up to qv1 to print the next
                        \ view in the menu, so this loops us back until we have
                        \ printed all of the laser mounts defined by the value
                        \ of new_mounts

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

.qv2

 LDA #175               \ Print recursive text token 15 ("VIEW ") followed by
 JSR prq                \ a question mark

 JSR TT217              \ Scan the keyboard until a key is pressed, and return
                        \ the key's ASCII code in A (and X)

 SEC                    \ Subtract ASCII "0" from the key pressed, to leave the
 SBC #'0'               \ numeric value of the key in A (if it was a number key)

 CMP new_mounts         \ If A < new_mounts, then our current ship supports this
 BCC qv3                \ view number, so jump down to qv3 as we are done

 JSR CLYNS              \ Otherwise we didn't get a valid view number, so clear
                        \ the bottom three text rows of the upper screen, and
                        \ move the text cursor to column 1 on row 21

 JMP qv2                \ Jump back to qv2 to try again

.qv3

 TAX                    \ We have a valid view number, so transfer it to X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: hm
\       Type: Subroutine
\   Category: Charts
\    Summary: Select the closest system and redraw the chart crosshairs
\
\ ------------------------------------------------------------------------------
\
\ Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
\ system, redraw the crosshairs on the chart accordingly (if they are being
\ shown), and, if this is not a space view, clear the bottom three text rows of
\ the screen.
\
\ ******************************************************************************

.hm

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will erase the crosshairs currently there

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will draw the crosshairs at our current home
                        \ system

 JMP CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

                        \ Return from the subroutine using a tail call

\ ******************************************************************************
\
\ Save ELTD.bin
\
\ ******************************************************************************

 PRINT "ELITE D"
 PRINT "Assembled at ", ~CODE_D%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_D%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_D%

 PRINT "S.2.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
\SAVE "3-assembled-output/2.ELTD.bin", CODE_D%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE E FILE
\
\ ******************************************************************************

 CODE_E% = P%
 LOAD_E% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: cpl
\       Type: Subroutine
\   Category: Text
\    Summary: Print the selected system name
\  Deep dive: Generating system names
\             Galaxy and system seeds
\
\ ------------------------------------------------------------------------------
\
\ Print control code 3 (the selected system name, i.e. the one in the crosshairs
\ in the Short-range Chart).
\
\ ******************************************************************************

.cpl

 LDX #5                 \ First we need to back up the seeds in QQ15, so set up
                        \ a counter in X to cover three 16-bit seeds (i.e.
                        \ 6 bytes)

.TT53

 LDA QQ15,X             \ Copy byte X from QQ15 to QQ19
 STA QQ19,X

 DEX                    \ Decrement the loop counter

 BPL TT53               \ Loop back for the next byte to back up

 LDY #3                 \ Step 1: Now that the seeds are backed up, we can
                        \ start the name-generation process. We will either
                        \ need to loop three or four times, so for now set
                        \ up a counter in Y to loop four times

 BIT QQ15               \ Check bit 6 of s0_lo, which is stored in QQ15

 BVS P%+3               \ If bit 6 is set then skip over the next instruction

 DEY                    \ Bit 6 is clear, so we only want to loop three times,
                        \ so decrement the loop counter in Y

 STY T                  \ Store the loop counter in T

.TT55

 LDA QQ15+5             \ Step 2: Load s2_hi, which is stored in QQ15+5, and
 AND #%00011111         \ extract bits 0-4 by AND'ing with %11111

 BEQ P%+7               \ If all those bits are zero, then skip the following
                        \ two instructions to go to step 3

 ORA #%10000000         \ We now have a number in the range 1-31, which we can
                        \ easily convert into a two-letter token, but first we
                        \ need to add 128 (or set bit 7) to get a range of
                        \ 129-159

 JSR TT27               \ Print the two-letter token in A

 JSR TT54               \ Step 3: twist the seeds in QQ15

 DEC T                  \ Decrement the loop counter

 BPL TT55               \ Loop back for the next two letters

 LDX #5                 \ We have printed the system name, so we can now
                        \ restore the seeds we backed up earlier. Set up a
                        \ counter in X to cover three 16-bit seeds (i.e. 6
                        \ bytes)

.TT56

 LDA QQ19,X             \ Copy byte X from QQ19 to QQ15
 STA QQ15,X

 DEX                    \ Decrement the loop counter

 BPL TT56               \ Loop back for the next byte to restore

 RTS                    \ Once all the seeds are restored, return from the
                        \ subroutine

\ ******************************************************************************
\
\       Name: cmn
\       Type: Subroutine
\   Category: Text
\    Summary: Print the commander's name
\
\ ------------------------------------------------------------------------------
\
\ Print control code 4 (the commander's name).
\
\ Other entry points:
\
\   cmn-1               Contains an RTS
\
\ ******************************************************************************

.cmn

 JSR MT19               \ Call MT19 to capitalise the next letter (i.e. set
                        \ Sentence Case for this word only)

 LDY #0                 \ Set up a counter in Y, starting from 0

.QUL4

 LDA NA%,Y              \ The commander's name is stored at NA%, so load the
                        \ Y-th character from NA%

 CMP #13                \ If we have reached the end of the name, return from
 BEQ ypl-1              \ the subroutine (ypl-1 points to the RTS below)

 JSR TT26               \ Print the character we just loaded

 INY                    \ Increment the loop counter

 BNE QUL4               \ Loop back for the next character

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ypl
\       Type: Subroutine
\   Category: Text
\    Summary: Print the current system name
\
\ ------------------------------------------------------------------------------
\
\ Print control code 2 (the current system name).
\
\ Other entry points:
\
\   ypl-1               Contains an RTS
\
\ ******************************************************************************

.ypl

 JSR TT62               \ Call TT62 below to swap the three 16-bit seeds in
                        \ QQ2 and QQ15 (before the swap, QQ2 contains the seeds
                        \ for the current system, while QQ15 contains the seeds
                        \ for the selected system)

 JSR cpl                \ Call cpl to print out the system name for the seeds
                        \ in QQ15 (which now contains the seeds for the current
                        \ system)

                        \ Now we fall through into the TT62 subroutine, which
                        \ will swap QQ2 and QQ15 once again, so everything goes
                        \ back into the right place, and the RTS at the end of
                        \ TT62 will return from the subroutine

.TT62

 LDX #5                 \ Set up a counter in X for the three 16-bit seeds we
                        \ want to swap (i.e. 6 bytes)

.TT78

 LDA QQ15,X             \ Swap byte X between QQ2 and QQ15
 LDY QQ2,X
 STA QQ2,X
 STY QQ15,X

 DEX                    \ Decrement the loop counter

 BPL TT78               \ Loop back for the next byte to swap

 RTS                    \ Once all bytes are swapped, return from the
                        \ subroutine

\ ******************************************************************************
\
\       Name: tal
\       Type: Subroutine
\   Category: Text
\    Summary: Print the current galaxy number
\
\ ------------------------------------------------------------------------------
\
\ Print control code 1 (the current galaxy number, right-aligned to width 3).
\
\ ******************************************************************************

.tal

 CLC                    \ We don't want to print the galaxy number with a
                        \ decimal point, so clear the C flag for pr2 to take as
                        \ an argument

 LDX GCNT               \ Load the current galaxy number from GCNT into X

 INX                    \ Add 1 to the galaxy number, as the galaxy numbers
                        \ are 0-7 internally, but we want to display them as
                        \ galaxy 1 through 8

 JMP pr2                \ Jump to pr2, which prints the number in X to a width
                        \ of 3 figures, left-padding with spaces to a width of
                        \ 3, and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: fwl
\       Type: Subroutine
\   Category: Text
\    Summary: Print fuel and cash levels
\
\ ------------------------------------------------------------------------------
\
\ Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
\ control code 0).
\
\ ******************************************************************************

.fwl

 LDA #105               \ Print recursive token 105 ("FUEL") followed by a
 JSR TT68               \ colon

 LDX QQ14               \ Load the current fuel level from QQ14

 SEC                    \ We want to print the fuel level with a decimal point,
                        \ so set the C flag for pr2 to take as an argument

 JSR pr2                \ Call pr2, which prints the number in X to a width of
                        \ 3 figures (i.e. in the format x.x, which will always
                        \ be exactly 3 characters as the maximum fuel is 7.0)

 LDA #195               \ Print recursive token 35 ("LIGHT YEARS") followed by
 JSR plf                \ a newline

.PCASH

 LDA #119               \ Print recursive token 119 ("CASH:" then control code
 BNE TT27               \ 0, which prints cash levels, then " CR" and newline)

\ ******************************************************************************
\
\       Name: csh
\       Type: Subroutine
\   Category: Text
\    Summary: Print the current amount of cash
\
\ ------------------------------------------------------------------------------
\
\ Print control code 0 (the current amount of cash, right-aligned to width 9,
\ followed by " CR" and a newline).
\
\ ******************************************************************************

.csh

 LDX #3                 \ We are going to use the BPRNT routine to print out
                        \ the current amount of cash, which is stored as a
                        \ 32-bit number at location CASH. BPRNT prints out
                        \ the 32-bit number stored in K, so before we call
                        \ BPRNT, we need to copy the four bytes from CASH into
                        \ K, so first we set up a counter in X for the 4 bytes

.pc1

 LDA CASH,X             \ Copy byte X from CASH to K
 STA K,X

 DEX                    \ Decrement the loop counter

 BPL pc1                \ Loop back for the next byte to copy

 LDA #9                 \ We want to print the cash amount using up to 9 digits
 STA U                  \ (including the decimal point), so store this in U
                        \ for BRPNT to take as an argument

 SEC                    \ We want to print the cash amount with a decimal point,
                        \ so set the C flag for BRPNT to take as an argument

 JSR BPRNT              \ Print the amount of cash to 9 digits with a decimal
                        \ point

 LDA #226               \ Print recursive token 66 (" CR") followed by a
                        \ newline by falling through into plf

\ ******************************************************************************
\
\       Name: plf
\       Type: Subroutine
\   Category: Text
\    Summary: Print a text token followed by a newline
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.plf

 JSR TT27               \ Print the text token in A

 JMP TT67               \ Jump to TT67 to print a newline and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT68
\       Type: Subroutine
\   Category: Text
\    Summary: Print a text token followed by a colon
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.TT68

 JSR TT27               \ Print the text token in A and fall through into TT73
                        \ to print a colon

\ ******************************************************************************
\
\       Name: TT73
\       Type: Subroutine
\   Category: Text
\    Summary: Print a colon
\
\ ******************************************************************************

.TT73

 LDA #':'               \ Set A to ASCII ":" and fall through into TT27 to
                        \ actually print the colon

\ ******************************************************************************
\
\       Name: TT27
\       Type: Subroutine
\   Category: Text
\    Summary: Print a text token
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ Print a text token (i.e. a character, control code, two-letter token or
\ recursive token).
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ Other entry points:
\
\   vdu_80              Switch standard tokens to Sentence Case
\
\ ******************************************************************************

.TT27

 TAX                    \ Copy the token number from A to X. We can then keep
                        \ decrementing X and testing it against zero, while
                        \ keeping the original token number intact in A; this
                        \ effectively implements a switch statement on the
                        \ value of the token

 BEQ csh                \ If token = 0, this is control code 0 (current amount
                        \ of cash and newline), so jump to csh to print the
                        \ amount of cash and return from the subroutine using
                        \ a tail call

 BMI TT43               \ If token > 127, this is either a two-letter token
                        \ (128-159) or a recursive token (160-255), so jump
                        \ to TT43 to process tokens

 DEX                    \ If token = 1, this is control code 1 (current galaxy
 BEQ tal                \ number), so jump to tal to print the galaxy number and
                        \ return from the subroutine using a tail call

 DEX                    \ If token = 2, this is control code 2 (current system
 BEQ ypl                \ name), so jump to ypl to print the current system name
                        \ and return from the subroutine using a tail call

 DEX                    \ If token > 3, skip the following instruction
 BNE P%+5

 JMP cpl                \ This token is control code 3 (selected system name)
                        \ so jump to cpl to print the selected system name
                        \ and return from the subroutine using a tail call

 DEX                    \ If token = 4, this is control code 4 (commander
 BEQ cmn                \ name), so jump to cmm to print the commander name
                        \ and return from the subroutine using a tail call

 DEX                    \ If token = 5, this is control code 5 (fuel, newline,
 BEQ fwl                \ cash, newline), so jump to fwl to print the fuel level
                        \ and return from the subroutine using a tail call

 DEX                    \ If token = 6, this is control code 6 (switch to
 BEQ vdu_80             \ Sentence Case), so jump to vdu_80 to do just that

 DEX                    \ If token <> 8, jump to l_31d2 to skip the following
 DEX                    \ four instructions
 BNE l_31d2

                        \ If we get here, then token = 8 (switch to ALL CAPS)
                        \ and X = 0, which we now use to set the value of QQ17
                        \ below

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A2 &80, or BIT &80A2, which does nothing apart
                        \ from affect the flags

.vdu_80

 LDX #%10000000         \ Set bit 7 of X, so when we set QQ17 below, we switch
                        \ standard tokens to Sentence Case

 STX QQ17               \ This token is control code 8 (switch to ALL CAPS), so
 RTS                    \ set QQ17 to 0 to switch to ALL CAPS and return from
                        \ the subroutine as we are done

.l_31d2

 DEX                    \ If token = 9, this is control code 9 (tab to column
 BEQ crlf               \ 21 and print a colon), so jump to crlf

 CMP #96                \ By this point, token is either 7, or in 10-127.
 BCS ex                 \ Check token number in A and if token >= 96, then the
                        \ token is in 96-127, which is a recursive token, so
                        \ jump to ex, which prints recursive tokens in this
                        \ range (i.e. where the recursive token number is
                        \ correct and doesn't need correcting)

 CMP #14                \ If token < 14, skip the following two instructions
 BCC P%+6

 CMP #32                \ If token < 32, then this means token is in 14-31, so
 BCC qw                 \ this is a recursive token that needs 114 adding to it
                        \ to get the recursive token number, so jump to qw
                        \ which will do this

                        \ By this point, token is either 7 (beep) or in 10-13
                        \ (line feeds and carriage returns), or in 32-95
                        \ (ASCII letters, numbers and punctuation)

 LDX QQ17               \ Fetch QQ17, which controls letter case, into X

 BEQ TT74               \ If QQ17 = 0, then ALL CAPS is set, so jump to TT74
                        \ to print this character as is (i.e. as a capital)

 BMI TT41               \ If QQ17 has bit 7 set, then we are using Sentence
                        \ Case, so jump to TT41, which will print the
                        \ character in upper or lower case, depending on
                        \ whether this is the first letter in a word

 BIT QQ17               \ If we get here, QQ17 is not 0 and bit 7 is clear, so
 BVS TT46               \ either it is bit 6 that is set, or some other flag in
                        \ QQ17 is set (bits 0-5). So check whether bit 6 is set.
                        \ If it is, then ALL CAPS has been set (as bit 7 is
                        \ clear) but bit 6 is still indicating that the next
                        \ character should be printed in lower case, so we need
                        \ to fix this. We do this with a jump to TT46, which
                        \ will print this character in upper case and clear bit
                        \ 6, so the flags are consistent with ALL CAPS going
                        \ forward

                        \ If we get here, some other flag is set in QQ17 (one
                        \ of bits 0-5 is set), which shouldn't happen in this
                        \ version of Elite. If this were the case, then we
                        \ would fall through into TT42 to print in lower case,
                        \ which is how printing all words in lower case could
                        \ be supported (by setting QQ17 to 1, say)

\ ******************************************************************************
\
\       Name: TT42
\       Type: Subroutine
\   Category: Text
\    Summary: Print a letter in lower case
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\ Other entry points:
\
\   TT44                Jumps to TT26 to print the character in A (used to
\                       enable us to use a branch instruction to jump to TT26)
\
\ ******************************************************************************

.TT42

 CMP #'A'               \ If A < ASCII "A", then this is punctuation, so jump
 BCC TT44               \ to TT26 (via TT44) to print the character as is, as
                        \ we don't care about the character's case

 CMP #'Z'+1             \ If A >= (ASCII "Z" + 1), then this is also
 BCS TT44               \ punctuation, so jump to TT26 (via TT44) to print the
                        \ character as is, as we don't care about the
                        \ character's case

 ADC #32                \ Add 32 to the character, to convert it from upper to
                        \ lower case

.TT44

 JMP TT26               \ Print the character in A

\ ******************************************************************************
\
\       Name: TT41
\       Type: Subroutine
\   Category: Text
\    Summary: Print a letter according to Sentence Case
\
\ ------------------------------------------------------------------------------
\
\ The rules for printing in Sentence Case are as follows:
\
\   * If QQ17 bit 6 is set, print lower case (via TT45)
\
\   * If QQ17 bit 6 is clear, then:
\
\       * If character is punctuation, just print it
\
\       * If character is a letter, set QQ17 bit 6 and print letter as a capital
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\   X                   Contains the current value of QQ17
\
\   QQ17                Bit 7 is set
\
\ ******************************************************************************

.TT41

                        \ If we get here, then QQ17 has bit 7 set, so we are in
                        \ Sentence Case

 BIT QQ17               \ If QQ17 also has bit 6 set, jump to TT45 to print
 BVS TT45               \ this character in lower case

                        \ If we get here, then QQ17 has bit 6 clear and bit 7
                        \ set, so we are in Sentence Case and we need to print
                        \ the next letter in upper case

 CMP #'A'               \ If A < ASCII "A", then this is punctuation, so jump
 BCC TT74               \ to TT26 (via TT44) to print the character as is, as
                        \ we don't care about the character's case

 PHA                    \ Otherwise this is a letter, so store the token number

 TXA                    \ Set bit 6 in QQ17 (X contains the current QQ17)
 ORA #%1000000          \ so the next letter after this one is printed in lower
 STA QQ17               \ case

 PLA                    \ Restore the token number into A

 BNE TT44               \ Jump to TT26 (via TT44) to print the character in A
                        \ (this BNE is effectively a JMP as A will never be
                        \ zero)

\ ******************************************************************************
\
\       Name: qw
\       Type: Subroutine
\   Category: Text
\    Summary: Print a recursive token in the range 128-145
\
\ ------------------------------------------------------------------------------
\
\ Print a recursive token where the token number is in 128-145 (so the value
\ passed to TT27 is in the range 14-31).
\
\ Arguments:
\
\   A                   A value from 128-145, which refers to a recursive token
\                       in the range 14-31
\
\ ******************************************************************************

.qw

 ADC #114               \ This is a recursive token in the range 0-95, so add
 BNE ex                 \ 114 to the argument to get the token number 128-145
                        \ and jump to ex to print it

\ ******************************************************************************
\
\       Name: crlf
\       Type: Subroutine
\   Category: Text
\    Summary: Tab to column 21 and print a colon
\
\ ------------------------------------------------------------------------------
\
\ Print control code 9 (tab to column 21 and print a colon). The subroutine
\ name is pretty misleading, as it doesn't have anything to do with carriage
\ returns or line feeds.
\
\ ******************************************************************************

.crlf

 LDA #21                \ Set the X-column in XC to 21
 STA XC

 BNE TT73               \ Jump to TT73, which prints a colon (this BNE is
                        \ effectively a JMP as A will never be zero)

\ ******************************************************************************
\
\       Name: TT45
\       Type: Subroutine
\   Category: Text
\    Summary: Print a letter in lower case
\
\ ------------------------------------------------------------------------------
\
\ This routine prints a letter in lower case. Specifically:
\
\   * If QQ17 = 255, abort printing this character as printing is disabled
\
\   * If this is a letter then print in lower case
\
\   * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\   X                   Contains the current value of QQ17
\
\   QQ17                Bits 6 and 7 are set
\
\ ******************************************************************************

.TT45

                        \ If we get here, then QQ17 has bit 6 and 7 set, so we
                        \ are in Sentence Case and we need to print the next
                        \ letter in lower case

 CPX #255               \ If QQ17 = 255 then printing is disabled, so return
 BEQ TT48               \ from the subroutine (as TT48 contains an RTS)

 CMP #'A'               \ If A >= ASCII "A", then jump to TT42, which will
 BCS TT42               \ print the letter in lowercase

                        \ Otherwise this is not a letter, it's punctuation, so
                        \ this is effectively a word break. We therefore fall
                        \ through to TT46 to print the character and set QQ17
                        \ to ensure the next word starts with a capital letter

\ ******************************************************************************
\
\       Name: TT46
\       Type: Subroutine
\   Category: Text
\    Summary: Print a character and switch to capitals
\
\ ------------------------------------------------------------------------------
\
\ Print a character and clear bit 6 in QQ17, so that the next letter that gets
\ printed after this will start with a capital letter.
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\   X                   Contains the current value of QQ17
\
\   QQ17                Bits 6 and 7 are set
\
\ ******************************************************************************

.TT46

 PHA                    \ Store the token number

 TXA                    \ Clear bit 6 in QQ17 (X contains the current QQ17) so
 AND #%10111111         \ the next letter after this one is printed in upper
 STA QQ17               \ case

 PLA                    \ Restore the token number into A

                        \ Now fall through into TT74 to print the character

\ ******************************************************************************
\
\       Name: TT74
\       Type: Subroutine
\   Category: Text
\    Summary: Print a character
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The character to be printed
\
\ ******************************************************************************

.TT74

 JMP TT26               \ Print the character in A

\ ******************************************************************************
\
\       Name: TT43
\       Type: Subroutine
\   Category: Text
\    Summary: Print a two-letter token or recursive token 0-95
\
\ ------------------------------------------------------------------------------
\
\ Print a two-letter token, or a recursive token where the token number is in
\ 0-95 (so the value passed to TT27 is in the range 160-255).
\
\ Arguments:
\
\   A                   One of the following:
\
\                         * 128-159 (two-letter token)
\
\                         * 160-255 (the argument to TT27 that refers to a
\                           recursive token in the range 0-95)
\
\ ******************************************************************************

.TT43

 CMP #160               \ If token >= 160, then this is a recursive token, so
 BCS TT47               \ jump to TT47 below to process it

 AND #127               \ This is a two-letter token with number 128-159. The
 ASL A                  \ set of two-letter tokens is stored in a lookup table
                        \ at QQ16, with each token taking up two bytes, so to
                        \ convert this into the token's position in the table,
                        \ we subtract 128 (or just clear bit 7) and multiply
                        \ by 2 (or shift left)

 TAY                    \ Transfer the token's position into Y so we can look
                        \ up the token using absolute indexed mode

 LDA QQ16,Y             \ Get the first letter of the token and print it
 JSR TT27

 LDA QQ16+1,Y           \ Get the second letter of the token

 CMP #'?'               \ If the second letter of the token is a question mark
 BEQ TT48               \ then this is a one-letter token, so just return from
                        \ the subroutine without printing (as TT48 contains an
                        \ RTS)

 JMP TT27               \ Print the second letter and return from the
                        \ subroutine

.TT47

 SBC #160               \ This is a recursive token in the range 160-255, so
                        \ subtract 160 from the argument to get the token
                        \ number 0-95 and fall through into ex to print it

\ ******************************************************************************
\
\       Name: ex
\       Type: Subroutine
\   Category: Text
\    Summary: Print a recursive token
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ This routine works its way through the recursive text tokens that are stored
\ in tokenised form in the table at QQ18, and when it finds token number A,
\ it prints it. Tokens are null-terminated in memory and fill three pages,
\ but there is no lookup table as that would consume too much memory, so the
\ only way to find the correct token is to start at the beginning and look
\ through the table byte by byte, counting tokens as we go until we are in the
\ right place. This approach might not be terribly speed efficient, but it is
\ certainly memory-efficient.
\
\ Arguments:
\
\   A                   The recursive token to be printed, in the range 0-148
\
\ Other entry points:
\
\   TT48                Contains an RTS
\
\ ******************************************************************************

.ex

 TAX                    \ Copy the token number into X

 LDA #LO(QQ18)          \ Set V(1 0) to point to the recursive token table at
 STA V                  \ location QQ18
 LDA #HI(QQ18)
 STA V+1

 LDY #0                 \ Set a counter Y to point to the character offset
                        \ as we scan through the table

 TXA                    \ Copy the token number back into A, so both A and X
                        \ now contain the token number we want to print

 BEQ TT50               \ If the token number we want is 0, then we have
                        \ already found the token we are looking for, so jump
                        \ to TT50, otherwise start working our way through the
                        \ null-terminated token table until we find the X-th
                        \ token

.TT51

 LDA (V),Y              \ Fetch the Y-th character from the token table page
                        \ we are currently scanning

 BEQ TT49               \ If the character is null, we've reached the end of
                        \ this token, so jump to TT49

 INY                    \ Increment character pointer and loop back around for
 BNE TT51               \ the next character in this token, assuming Y hasn't
                        \ yet wrapped around to 0

 INC V+1                \ If it has wrapped round to 0, we have just crossed
 BNE TT51               \ into a new page, so increment V+1 so that V points
                        \ to the start of the new page

.TT49

 INY                    \ Increment the character pointer

 BNE TT59               \ If Y hasn't just wrapped around to 0, skip the next
                        \ instruction

 INC V+1                \ We have just crossed into a new page, so increment
                        \ V+1 so that V points to the start of the new page

.TT59

 DEX                    \ We have just reached a new token, so decrement the
                        \ token number we are looking for

 BNE TT51               \ Assuming we haven't yet reached the token number in
                        \ X, look back up to keep fetching characters

.TT50

                        \ We have now reached the correct token in the token
                        \ table, with Y pointing to the start of the token as
                        \ an offset within the page pointed to by V, so let's
                        \ print the recursive token. Because recursive tokens
                        \ can contain other recursive tokens, we need to store
                        \ our current state on the stack, so we can retrieve
                        \ it after printing each character in this token

 TYA                    \ Store the offset in Y on the stack
 PHA

 LDA V+1                \ Store the high byte of V (the page containing the
 PHA                    \ token we have found) on the stack, so the stack now
                        \ contains the address of the start of this token

 LDA (V),Y              \ Load the character at offset Y in the token table,
                        \ which is the next character of this token that we
                        \ want to print

 EOR #RE                \ Tokens are stored in memory having been EOR'd with the
                        \ value of RE - which is 35 for all versions of Elite
                        \ except for NES, where RE is 62 - so we repeat the
                        \ EOR to get the actual character to print

 JSR TT27               \ Print the text token in A, which could be a letter,
                        \ number, control code, two-letter token or another
                        \ recursive token

 PLA                    \ Restore the high byte of V (the page containing the
 STA V+1                \ token we have found) into V+1

 PLA                    \ Restore the offset into Y
 TAY

 INY                    \ Increment Y to point to the next character in the
                        \ token we are printing

 BNE P%+4               \ If Y is zero then we have just crossed into a new
 INC V+1                \ page, so increment V+1 so that V points to the start
                        \ of the new page

 LDA (V),Y              \ Load the next character we want to print into A

 BNE TT50               \ If this is not the null character at the end of the
                        \ token, jump back up to TT50 to print the next
                        \ character, otherwise we are done printing

.TT48

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: WPSHPS
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Clear the scanner, reset the ball line and sun line heaps
\
\ ------------------------------------------------------------------------------
\
\ Remove all ships from the scanner, reset the sun line heap at LSO, and reset
\ the ball line heap at LSX2 and LSY2.
\
\ ******************************************************************************

.WPSHPS

 LDX #0                 \ Set up a counter in X to work our way through all the
                        \ ship slots in FRIN

.WSL1

 LDA FRIN,X             \ Fetch the ship type in slot X

 BEQ WS2                \ If the slot contains 0 then it is empty and we have
                        \ checked all the slots (as they are always shuffled
                        \ down in the main loop to close up and gaps), so jump
                        \ to WS2 as we are done

 BMI WS1                \ If the slot contains a ship type with bit 7 set, then
                        \ it contains the planet or the sun, so jump down to WS1
                        \ to skip this slot, as the planet and sun don't appear
                        \ on the scanner

 STA TYPE               \ Store the ship type in TYPE

 JSR GINF               \ Call GINF to get the address of the data block for
                        \ ship slot X and store it in INF

 LDY #31                \ We now want to copy the first 32 bytes from the ship's
                        \ data block into INWK, so set a counter in Y

.WSL2

 LDA (INF),Y            \ Copy the Y-th byte from the data block pointed to by
 STA INWK,Y             \ INF into the Y-th byte of INWK workspace

 DEY                    \ Decrement the counter to point at the next byte

 BPL WSL2               \ Loop back to WSL2 until we have copied all 32 bytes

 STX XSAV               \ Store the ship slot number in XSAV while we call SCAN

 JSR SCAN               \ Call SCAN to plot this ship on the scanner, which will
                        \ remove it as it's plotted with EOR logic

 LDX XSAV               \ Restore the ship slot number from XSAV into X

 LDY #31                \ Clear bits 3, 4 and 6 in the ship's byte #31, which
 LDA (INF),Y            \ stops drawing the ship on-screen (bit 3), hides it
 AND #%10100111         \ from the scanner (bit 4) and stops any lasers firing
 STA (INF),Y            \ (bit 6)

.WS1

 INX                    \ Increment X to point to the next ship slot

 BNE WSL1               \ Loop back up to process the next slot (this BNE is
                        \ effectively a JMP as X will never be zero)

.WS2

 LDX #&FF               \ Set LSX2 = LSY2 = &FF to clear the ball line heap
 STX LSX2
 STX LSY2

                        \ Fall through into FLFLLS to reset the LSO block

\ ******************************************************************************
\
\       Name: FLFLLS
\       Type: Subroutine
\   Category: Drawing suns
\    Summary: Reset the sun line heap
\
\ ------------------------------------------------------------------------------
\
\ Reset the sun line heap at LSO by zero-filling it and setting the first byte
\ to &FF.
\
\ Returns:
\
\   A                   A is set to 0
\
\ ******************************************************************************

.FLFLLS

 LDY #2*Y-1             \ #Y is the y-coordinate of the centre of the space
                        \ view, so this sets Y as a counter for the number of
                        \ lines in the space view (i.e. 191), which is also the
                        \ number of lines in the LSO block

 LDA #0                 \ Set A to 0 so we can zero-fill the LSO block

.SAL6

 STA LSO,Y              \ Set the Y-th byte of the LSO block to 0

 DEY                    \ Decrement the counter

 BNE SAL6               \ Loop back until we have filled all the way to LSO+1

 DEY                    \ Decrement Y to value of &FF (as we exit the above loop
                        \ with Y = 0)

 STY LSX                \ Set the first byte of the LSO block, which has its own
                        \ label LSX, to &FF, to indicate that the sun line heap
                        \ is empty

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MSBAR
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Draw a specific indicator in the dashboard's missile bar by
\             sending a put_missle command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the missile indicator to update (counting
\                       from right to left and starting at 0 rather than 1, so
\                       indicator NOMSL - 1 is the leftmost indicator)
\
\   Y                   The colour of the missile indicator:
\
\                         * &00 = black (no missile)
\
\                         * &0E = red (armed and locked)
\
\                         * &E0 = yellow/white (armed)
\
\                         * &EE = green/cyan (disarmed)
\
\ Returns:
\
\   X                   X is preserved
\
\   Y                   Y is set to 0
\
\ ******************************************************************************

.MSBAR

 LDA #&88               \ Send command &86 to the I/O processor:
 JSR tube_write         \
                        \   put_missle(number, colour)
                        \
                        \ which will update missile indicator with the specified
                        \ number, changing it to the specified colour

 TXA                    \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * number = X

 TYA                    \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * colour = Y

 LDY #0                 \ Set Y = 0 to ensure we return the same value as the
                        \ SCAN routine in the non-Tube version

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SUN (Part 1 of 4)
\       Type: Subroutine
\   Category: Drawing suns
\    Summary: Draw the sun: Set up all the variables needed to draw the sun
\  Deep dive: Drawing the sun
\
\ ------------------------------------------------------------------------------
\
\ Draw a new sun with radius K at pixel coordinate (K3, K4), removing the old
\ sun if there is one. This routine is used to draw the sun, as well as the
\ star systems on the Short-range Chart.
\
\ The first part sets up all the variables needed to draw the new sun.
\
\ Arguments:
\
\   K                   The new sun's radius
\
\   K3(1 0)             Pixel x-coordinate of the centre of the new sun
\
\   K4(1 0)             Pixel y-coordinate of the centre of the new sun
\
\   SUNX(1 0)           The x-coordinate of the vertical centre axis of the old
\                       sun (the one currently on-screen)
\
\ ******************************************************************************

 JMP WPLS               \ Jump to WPLS to remove the old sun from the screen. We
                        \ only get here via the BCS just after the SUN entry
                        \ point below, when there is no new sun to draw

.PLF3

                        \ This is called from below to negate X and set A to
                        \ &FF, for when the new sun's centre is off the bottom
                        \ of the screen (so we don't need to draw its bottom
                        \ half)
                        \
                        \ This happens when the y-coordinate of the centre of
                        \ the sun is bigger than the y-coordinate of the bottom
                        \ of the space view

 TXA                    \ Negate X using two's complement, so X = ~X + 1
 EOR #%11111111
 CLC
 ADC #1
 TAX

.PLF17

                        \ This is called from below to set A to &FF, for when
                        \ the new sun's centre is right on the bottom of the
                        \ screen (so we don't need to draw its bottom half)

 LDA #&FF               \ Set A = &FF

 BNE PLF5               \ Jump to PLF5 (this BNE is effectively a JMP as A is
                        \ never zero)

.SUN

 LDA #1                 \ Set LSX = 1 to indicate the sun line heap is about to
 STA LSX                \ be filled up

 JSR CHKON              \ Call CHKON to check whether any part of the new sun's
                        \ circle appears on-screen, and if it does, set P(2 1)
                        \ to the maximum y-coordinate of the new sun on-screen

 BCS PLF3-3             \ If CHKON set the C flag then the new sun's circle does
                        \ not appear on-screen, so jump to WPLS (via the JMP at
                        \ the top of this routine) to remove the sun from the
                        \ screen, returning from the subroutine using a tail
                        \ call

 LDA #0                 \ Set A = 0

 LDX K                  \ Set X = K = radius of the new sun

 CPX #96                \ If X >= 96, set the C flag and rotate it into bit 0
 ROL A                  \ of A, otherwise rotate a 0 into bit 0

 CPX #40                \ If X >= 40, set the C flag and rotate it into bit 0
 ROL A                  \ of A, otherwise rotate a 0 into bit 0

 CPX #16                \ If X >= 16, set the C flag and rotate it into bit 0
 ROL A                  \ of A, otherwise rotate a 0 into bit 0

                        \ By now, A contains the following:
                        \
                        \   * If radius is 96-255 then A = %111 = 7
                        \
                        \   * If radius is 40-95  then A = %11  = 3
                        \
                        \   * If radius is 16-39  then A = %1   = 1
                        \
                        \   * If radius is 0-15   then A = %0   = 0
                        \
                        \ The value of A determines the size of the new sun's
                        \ ragged fringes - the bigger the sun, the bigger the
                        \ fringes

.PLF18

 STA CNT                \ Store the fringe size in CNT

                        \ We now calculate the highest pixel y-coordinate of the
                        \ new sun, given that P(2 1) contains the 16-bit maximum
                        \ y-coordinate of the new sun on-screen

 LDA #2*Y-1             \ #Y is the y-coordinate of the centre of the space
                        \ view, so this sets Y to the y-coordinate of the bottom
                        \ of the space view

 LDX P+2                \ If P+2 is non-zero, the maximum y-coordinate is off
 BNE PLF2               \ the bottom of the screen, so skip to PLF2 with A set
                        \ to the y-coordinate of the bottom of the space view

 CMP P+1                \ If A < P+1, the maximum y-coordinate is underneath the
 BCC PLF2               \ dashboard, so skip to PLF2 with A set to the
                        \ y-coordinate of the bottom of the space view

 LDA P+1                \ Set A = P+1, the low byte of the maximum y-coordinate
                        \ of the sun on-screen

 BNE PLF2               \ If A is non-zero, skip to PLF2 as it contains the
                        \ value we are after

 LDA #1                 \ Otherwise set A = 1, the top line of the screen

.PLF2

 STA TGT                \ Set TGT to A, the maximum y-coordinate of the sun on
                        \ screen

                        \ We now calculate the number of lines we need to draw
                        \ and the direction in which we need to draw them, both
                        \ from the centre of the new sun

 LDA #2*Y-1             \ Set (A X) = y-coordinate of bottom of screen - K4(1 0)
 SEC                    \
 SBC K4                 \ Starting with the low bytes
 TAX

 LDA #0                 \ And then doing the high bytes, so (A X) now contains
 SBC K4+1               \ the number of lines between the centre of the sun and
                        \ the bottom of the screen. If it is positive then the
                        \ centre of the sun is above the bottom of the screen,
                        \ if it is negative then the centre of the sun is below
                        \ the bottom of the screen

 BMI PLF3               \ If A < 0, then this means the new sun's centre is off
                        \ the bottom of the screen, so jump up to PLF3 to negate
                        \ the height in X (so it becomes positive), set A to &FF
                        \ and jump down to PLF5

 BNE PLF4               \ If A > 0, then the new sun's centre is at least a full
                        \ screen above the bottom of the space view, so jump
                        \ down to PLF4 to set X = radius and A = 0

 INX                    \ Set the flags depending on the value of X
 DEX

 BEQ PLF17              \ If X = 0 (we already know A = 0 by this point) then
                        \ jump up to PLF17 to set A to &FF before jumping down
                        \ to PLF5

 CPX K                  \ If X < the radius in K, jump down to PLF5, so if
 BCC PLF5               \ X >= the radius in K, we set X = radius and A = 0

.PLF4

 LDX K                  \ Set X to the radius

 LDA #0                 \ Set A = 0

.PLF5

 STX V                  \ Store the height in V

 STA V+1                \ Store the direction in V+1

 LDA K                  \ Set (A P) = K * K
 JSR SQUA2

 STA K2+1               \ Set K2(1 0) = (A P) = K * K
 LDA P
 STA K2

                        \ By the time we get here, the variables should be set
                        \ up as shown in the header for part 3 below

\ ******************************************************************************
\
\       Name: SUN (Part 2 of 4)
\       Type: Subroutine
\   Category: Drawing suns
\    Summary: Draw the sun: Start from the bottom of the screen and erase the
\             old sun line by line
\  Deep dive: Drawing the sun
\
\ ------------------------------------------------------------------------------
\
\ This part erases the old sun, starting at the bottom of the screen and working
\ upwards until we reach the bottom of the new sun.
\
\ ******************************************************************************

 LDY #2*Y-1             \ Set Y = y-coordinate of the bottom of the screen,
                        \ which we use as a counter in the following routine to
                        \ redraw the old sun

 LDA SUNX               \ Set YY(1 0) = SUNX(1 0), the x-coordinate of the
 STA YY                 \ vertical centre axis of the old sun that's currently
 LDA SUNX+1             \ on-screen
 STA YY+1

.PLFL2

 CPY TGT                \ If Y = TGT, we have reached the line where we will
 BEQ PLFL               \ start drawing the new sun, so there is no need to
                        \ keep erasing the old one, so jump down to PLFL

 LDA LSO,Y              \ Fetch the Y-th point from the sun line heap, which
                        \ gives us the half-width of the old sun's line on this
                        \ line of the screen

 BEQ PLF13              \ If A = 0, skip the following call to HLOIN2 as there
                        \ is no sun line on this line of the screen

 JSR HLOIN2             \ Call HLOIN2 to draw a horizontal line on pixel line Y,
                        \ with centre point YY(1 0) and half-width A, and remove
                        \ the line from the sun line heap once done

.PLF13

 DEY                    \ Decrement the loop counter

 BNE PLFL2              \ Loop back for the next line in the line heap until
                        \ we have either gone through the entire heap, or
                        \ reached the bottom row of the new sun

\ ******************************************************************************
\
\       Name: SUN (Part 3 of 4)
\       Type: Subroutine
\   Category: Drawing suns
\    Summary: Draw the sun: Continue to move up the screen, drawing the new sun
\             line by line
\  Deep dive: Drawing the sun
\
\ ------------------------------------------------------------------------------
\
\ This part draws the new sun. By the time we get to this point, the following
\ variables should have been set up by parts 1 and 2:
\
\   V                   As we draw lines for the new sun, V contains the
\                       vertical distance between the line we're drawing and the
\                       centre of the new sun. As we draw lines and move up the
\                       screen, we either decrement (bottom half) or increment
\                       (top half) this value. See the deep dive on "Drawing the
\                       sun" to see a diagram that shows V in action
\
\   V+1                 This determines which half of the new sun we are drawing
\                       as we work our way up the screen, line by line:
\
\                         * 0 means we are drawing the bottom half, so the lines
\                           get wider as we work our way up towards the centre,
\                           at which point we will move into the top half, and
\                           V+1 will switch to &FF
\
\                         * &FF means we are drawing the top half, so the lines
\                           get smaller as we work our way up, away from the
\                           centre
\
\   TGT                 The maximum y-coordinate of the new sun on-screen (i.e.
\                       the screen y-coordinate of the bottom row of the new
\                       sun)
\
\   CNT                 The fringe size of the new sun
\
\   K2(1 0)             The new sun's radius squared, i.e. K^2
\
\   Y                   The y-coordinate of the bottom row of the new sun
\
\ ******************************************************************************

.PLFL

 LDA V                  \ Set (T P) = V * V
 JSR SQUA2              \           = V^2
 STA T

 LDA K2                 \ Set (R Q) = K^2 - V^2
 SEC                    \
 SBC P                  \ First calculating the low bytes
 STA Q

 LDA K2+1               \ And then doing the high bytes
 SBC T
 STA R

 STY Y1                 \ Store Y in Y1, so we can restore it after the call to
                        \ LL5

 JSR LL5                \ Set Q = SQRT(R Q)
                        \       = SQRT(K^2 - V^2)
                        \
                        \ So Q contains the half-width of the new sun's line at
                        \ height V from the sun's centre - in other words, it
                        \ contains the half-width of the sun's line on the
                        \ current pixel row Y

 LDY Y1                 \ Restore Y from Y1

 JSR DORND              \ Set A and X to random numbers

 AND CNT                \ Reduce A to a random number in the range 0 to CNT,
                        \ where CNT is the fringe size of the new sun

 CLC                    \ Set A = A + Q
 ADC Q                  \
                        \ So A now contains the half-width of the sun on row
                        \ V, plus a random variation based on the fringe size

 BCC PLF44              \ If the above addition did not overflow, skip the
                        \ following instruction

 LDA #255               \ The above overflowed, so set the value of A to 255

                        \ So A contains the half-width of the new sun on pixel
                        \ line Y, changed by a random amount within the size of
                        \ the sun's fringe

.PLF44

 LDX LSO,Y              \ Set X to the line heap value for the old sun's line
                        \ at row Y

 STA LSO,Y              \ Store the half-width of the new row Y line in the line
                        \ heap

 BEQ PLF11              \ If X = 0 then there was no sun line on pixel row Y, so
                        \ jump to PLF11

 LDA SUNX               \ Set YY(1 0) = SUNX(1 0), the x-coordinate of the
 STA YY                 \ vertical centre axis of the old sun that's currently
 LDA SUNX+1             \ on-screen
 STA YY+1

 TXA                    \ Transfer the line heap value for the old sun's line
                        \ from X into A

 JSR EDGES              \ Call EDGES to calculate X1 and X2 for the horizontal
                        \ line centred on YY(1 0) and with half-width A, i.e.
                        \ the line for the old sun

 LDA X1                 \ Store X1 and X2, the ends of the line for the old sun,
 STA XX                 \ in XX and XX+1
 LDA X2
 STA XX+1

 LDA K3                 \ Set YY(1 0) = K3(1 0), the x-coordinate of the centre
 STA YY                 \ of the new sun
 LDA K3+1
 STA YY+1

 LDA LSO,Y              \ Fetch the half-width of the new row Y line from the
                        \ line heap (which we stored above)

 JSR EDGES              \ Call EDGES to calculate X1 and X2 for the horizontal
                        \ line centred on YY(1 0) and with half-width A, i.e.
                        \ the line for the new sun

 BCS PLF23              \ If the C flag is set, the new line doesn't fit on the
                        \ screen, so jump to PLF23 to just draw the old line
                        \ without drawing the new one

                        \ At this point the old line is from XX to XX+1 and the
                        \ new line is from X1 to X2, and both fit on-screen. We
                        \ now want to remove the old line and draw the new one.
                        \ We could do this by simply drawing the old one then
                        \ drawing the new one, but instead Elite does this by
                        \ drawing first from X1 to XX and then from X2 to XX+1,
                        \ which you can see in action by looking at all the
                        \ permutations below of the four points on the line and
                        \ imagining what happens if you draw from X1 to XX and
                        \ X2 to XX+1 using EOR logic. The six possible
                        \ permutations are as follows, along with the result of
                        \ drawing X1 to XX and then X2 to XX+1:
                        \
                        \   X1    X2    XX____XX+1      ->      +__+  +  +
                        \
                        \   X1    XX____X2____XX+1      ->      +__+__+  +
                        \
                        \   X1    XX____XX+1  X2        ->      +__+__+__+
                        \
                        \   XX____X1____XX+1  X2        ->      +  +__+__+
                        \
                        \   XX____XX+1  X1    X2        ->      +  +  +__+
                        \
                        \   XX____X1____X2____XX+1      ->      +  +__+  +
                        \
                        \ They all end up with a line between X1 and X2, which
                        \ is what we want. There's probably a mathematical proof
                        \ of why this works somewhere, but the above is probably
                        \ easier to follow.
                        \
                        \ We can draw from X1 to XX and X2 to XX+1 by swapping
                        \ XX and X2 and drawing from X1 to X2, and then drawing
                        \ from XX to XX+1, so let's do this now

 LDA X2                 \ Swap XX and X2
 LDX XX
 STX X2
 STA XX

 JSR HLOIN              \ Draw a horizontal line from (X1, Y1) to (X2, Y1)

.PLF23

                        \ If we jump here from the BCS above when there is no
                        \ new line this will just draw the old line

 LDA XX                 \ Set X1 = XX
 STA X1

 LDA XX+1               \ Set X2 = XX+1
 STA X2

.PLF16

 JSR HLOIN              \ Draw a horizontal line from (X1, Y1) to (X2, Y1)

.PLF6

 DEY                    \ Decrement the line number in Y to move to the line
                        \ above

 BEQ PLF8               \ If we have reached the top of the screen, jump to PLF8
                        \ as we are done drawing (the top line of the screen is
                        \ the border, so we don't draw there)

 LDA V+1                \ If V+1 is non-zero then we are doing the top half of
 BNE PLF10              \ the new sun, so jump down to PLF10 to increment V and
                        \ decrease the width of the line we draw

 DEC V                  \ Decrement V, the height of the sun that we use to work
                        \ out the width, so this makes the line get wider, as we
                        \ move up towards the sun's centre

 BNE PLFL               \ If V is non-zero, jump back up to PLFL to do the next
                        \ screen line up

 DEC V+1                \ Otherwise V is 0 and we have reached the centre of the
                        \ sun, so decrement V+1 to -1 so we start incrementing V
                        \ each time, thus doing the top half of the new sun

.PLFLS

 JMP PLFL               \ Jump back up to PLFL to do the next screen line up

.PLF11

                        \ If we get here then there is no old sun line on this
                        \ line, so we can just draw the new sun's line

 LDX K3                 \ Set YY(1 0) = K3(1 0), the x-coordinate of the centre
 STX YY                 \ of the new sun's line
 LDX K3+1
 STX YY+1

 JSR EDGES              \ Call EDGES to calculate X1 and X2 for the horizontal
                        \ line centred on YY(1 0) and with half-width A, i.e.
                        \ the line for the new sun

 BCC PLF16              \ If the line is on-screen, jump up to PLF16 to draw the
                        \ line and loop round for the next line up

 LDA #0                 \ The line is not on-screen, so set the line heap for
 STA LSO,Y              \ line Y to 0, which means there is no sun line here

 BEQ PLF6               \ Jump up to PLF6 to loop round for the next line up
                        \ (this BEQ is effectively a JMP as A is always zero)

.PLF10

 LDX V                  \ Increment V, the height of the sun that we use to work
 INX                    \ out the width, so this makes the line get narrower, as
 STX V                  \ we move up and away from the sun's centre

 CPX K                  \ If V <= the radius of the sun, we still have lines to
 BCC PLFLS              \ draw, so jump up to PLFL (via PLFLS) to do the next
 BEQ PLFLS              \ screen line up

\ ******************************************************************************
\
\       Name: SUN (Part 4 of 4)
\       Type: Subroutine
\   Category: Drawing suns
\    Summary: Draw the sun: Continue to the top of the screen, erasing the old
\             sun line by line
\  Deep dive: Drawing the sun
\
\ ------------------------------------------------------------------------------
\
\ This part erases any remaining traces of the old sun, now that we have drawn
\ all the way to the top of the new sun.
\
\ Other entry points:
\
\   RTS2                Contains an RTS
\
\ ******************************************************************************

 LDA SUNX               \ Set YY(1 0) = SUNX(1 0), the x-coordinate of the
 STA YY                 \ vertical centre axis of the old sun that's currently
 LDA SUNX+1             \ on-screen
 STA YY+1

.PLFL3

 LDA LSO,Y              \ Fetch the Y-th point from the sun line heap, which
                        \ gives us the half-width of the old sun's line on this
                        \ line of the screen

 BEQ PLF9               \ If A = 0, skip the following call to HLOIN2 as there
                        \ is no sun line on this line of the screen

 JSR HLOIN2             \ Call HLOIN2 to draw a horizontal line on pixel line Y,
                        \ with centre point YY(1 0) and half-width A, and remove
                        \ the line from the sun line heap once done

.PLF9

 DEY                    \ Decrement the line number in Y to move to the line
                        \ above

 BNE PLFL3              \ Jump up to PLFL3 to redraw the next line up, until we
                        \ have reached the top of the screen

.PLF8

                        \ If we get here, we have successfully made it from the
                        \ bottom line of the screen to the top, and the old sun
                        \ has been replaced by the new one

 CLC                    \ Clear the C flag to indicate success in drawing the
                        \ sun

 LDA K3                 \ Set SUNX(1 0) = K3(1 0)
 STA SUNX
 LDA K3+1
 STA SUNX+1

.RTS2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CIRCLE2
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Draw a circle (for the planet or chart)
\  Deep dive: Drawing circles
\
\ ------------------------------------------------------------------------------
\
\ Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
\ planet and the chart circles.
\
\ Arguments:
\
\   STP                 The step size for the circle
\
\   K                   The circle's radius
\
\   K3(1 0)             Pixel x-coordinate of the centre of the circle
\
\   K4(1 0)             Pixel y-coordinate of the centre of the circle
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.CIRCLE2

 LDX #&FF               \ Set FLAG = &FF to reset the ball line heap in the call
 STX FLAG               \ to the BLINE routine below

 INX                    \ Set CNT = 0, our counter that goes up to 64, counting
 STX CNT                \ segments in our circle

.PLL3

 LDA CNT                \ Set A = CNT

 JSR FMLTU2             \ Call FMLTU2 to calculate:
                        \
                        \   A = K * sin(A)
                        \     = K * sin(CNT)

 LDX #0                 \ Set T = 0, so we have the following:
 STX T                  \
                        \   (T A) = K * sin(CNT)
                        \
                        \ which is the x-coordinate of the circle for this count

 LDX CNT                \ If CNT < 33 then jump to PL37, as this is the right
 CPX #33                \ half of the circle and the sign of the x-coordinate is
 BCC PL37               \ correct

 EOR #%11111111         \ This is the left half of the circle, so we want to
 ADC #0                 \ flip the sign of the x-coordinate in (T A) using two's
 TAX                    \ complement, so we start with the low byte and store it
                        \ in X (the ADC adds 1 as we know the C flag is set)

 LDA #&FF               \ And then we flip the high byte in T
 ADC #0
 STA T

 TXA                    \ Finally, we restore the low byte from X, so we have
                        \ now negated the x-coordinate in (T A)

 CLC                    \ Clear the C flag so we can do some more addition below

.PL37

 ADC K3                 \ We now calculate the following:
 STA K6                 \
                        \   K6(1 0) = (T A) + K3(1 0)
                        \
                        \ to add the coordinates of the centre to our circle
                        \ point, starting with the low bytes

 LDA K3+1               \ And then doing the high bytes, so we now have:
 ADC T                  \
 STA K6+1               \   K6(1 0) = K * sin(CNT) + K3(1 0)
                        \
                        \ which is the result we want for the x-coordinate

 LDA CNT                \ Set A = CNT + 16
 CLC
 ADC #16

 JSR FMLTU2             \ Call FMLTU2 to calculate:
                        \
                        \   A = K * sin(A)
                        \     = K * sin(CNT + 16)
                        \     = K * cos(CNT)

 TAX                    \ Set X = A
                        \       = K * cos(CNT)

 LDA #0                 \ Set T = 0, so we have the following:
 STA T                  \
                        \   (T X) = K * cos(CNT)
                        \
                        \ which is the y-coordinate of the circle for this count

 LDA CNT                \ Set A = (CNT + 15) mod 64
 ADC #15
 AND #63

 CMP #33                \ If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
 BCC PL38               \ PL38, as this is the bottom half of the circle and the
                        \ sign of the y-coordinate is correct

 TXA                    \ This is the top half of the circle, so we want to
 EOR #%11111111         \ flip the sign of the y-coordinate in (T X) using two's
 ADC #0                 \ complement, so we start with the low byte in X (the
 TAX                    \ ADC adds 1 as we know the C flag is set)

 LDA #&FF               \ And then we flip the high byte in T, so we have
 ADC #0                 \ now negated the y-coordinate in (T X)
 STA T

 CLC                    \ Clear the C flag so we can do some more addition below

.PL38

 JSR BLINE              \ Call BLINE to draw this segment, which also increases
                        \ CNT by STP, the step size

 CMP #65                \ If CNT >= 65 then skip the next instruction
 BCS P%+5

 JMP PLL3               \ Jump back for the next segment

 CLC                    \ Clear the C flag to indicate success

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: EDGES
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Draw a horizontal line given a centre and a half-width
\
\ ------------------------------------------------------------------------------
\
\ Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
\ centre x-coordinate YY(1 0), and length A in either direction from the centre
\ (so a total line length of 2 * A). In other words, this line:
\
\   X1             YY(1 0)             X2
\   +-----------------+-----------------+
\         <- A ->           <- A ->
\
\ The resulting line gets clipped to the edges of the screen, if needed. If the
\ calculation doesn't overflow, we return with the C flag clear, otherwise the C
\ flag gets set to indicate failure and the Y-th LSO entry gets set to 0.
\
\ Arguments:
\
\   A                   The half-length of the line
\
\   YY(1 0)             The centre x-coordinate
\
\ Returns:
\
\   C flag              Clear if the line fits on-screen, set if it doesn't
\
\   X1, X2              The x-coordinates of the clipped line
\
\   LSO+Y               If the line doesn't fit, LSO+Y is set to 0
\
\   Y                   Y is preserved
\
\ Other entry points:
\
\   PL44                Clear the C flag and return from the subroutine
\
\ ******************************************************************************

.EDGES

 STA T                  \ Set T to the line's half-length in argument A

 CLC                    \ We now calculate:
 ADC YY                 \
 STA X2                 \  (A X2) = YY(1 0) + A
                        \
                        \ to set X2 to the x-coordinate of the right end of the
                        \ line, starting with the low bytes

 LDA YY+1               \ And then adding the high bytes
 ADC #0

 BMI ED1                \ If the addition is negative then the calculation has
                        \ overflowed, so jump to ED1 to return a failure

 BEQ P%+6               \ If the high byte A from the result is 0, skip the
                        \ next two instructions, as the result already fits on
                        \ the screen

 LDA #254               \ The high byte is positive and non-zero, so we went
 STA X2                 \ past the right edge of the screen, so clip X2 to the
                        \ x-coordinate of the right edge of the screen

 LDA YY                 \ We now calculate:
 SEC                    \
 SBC T                  \   (A X1) = YY(1 0) - argument A
 STA X1                 \
                        \ to set X1 to the x-coordinate of the left end of the
                        \ line, starting with the low bytes

 LDA YY+1               \ And then subtracting the high bytes
 SBC #0

 BNE ED3                \ If the high byte subtraction is non-zero, then skip
                        \ to ED3

 CLC                    \ Otherwise the high byte of the subtraction was zero,
                        \ so the line fits on-screen and we clear the C flag to
                        \ indicate success

 RTS                    \ Return from the subroutine

.ED3

 BPL ED1                \ If the addition is positive then the calculation has
                        \ underflowed, so jump to ED1 to return a failure

 LDA #2                 \ The high byte is negative and non-zero, so we went
 STA X1                 \ past the left edge of the screen, so clip X1 to the
                        \ x-coordinate of the left edge of the screen

.PL44

 CLC                    \ The line does fit on-screen, so clear the C flag to
                        \ indicate success

 RTS                    \ Return from the subroutine

.ED1

 LDA #0                 \ Set the Y-th byte of the LSO block to 0
 STA LSO,Y

\ ******************************************************************************
\
\       Name: PL21
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Return from a planet/sun-drawing routine with a failure flag
\
\ ------------------------------------------------------------------------------
\
\ Set the C flag and return from the subroutine. This is used to return from a
\ planet- or sun-drawing routine with the C flag indicating an overflow in the
\ calculation.
\
\ ******************************************************************************

.PL21

 SEC                    \ Set the C flag to indicate an overflow

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CHKON
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Check whether any part of a circle appears on the extended screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   K                   The circle's radius
\
\   K3(1 0)             Pixel x-coordinate of the centre of the circle
\
\   K4(1 0)             Pixel y-coordinate of the centre of the circle
\
\ Returns:
\
\   C flag              Clear if any part of the circle appears on-screen, set
\                       if none of the circle appears on-screen
\
\   (A X)               Minimum y-coordinate of the circle on-screen (i.e. the
\                       y-coordinate of the top edge of the circle)
\
\   P(2 1)              Maximum y-coordinate of the circle on-screen (i.e. the
\                       y-coordinate of the bottom edge of the circle)
\
\ ******************************************************************************

.CHKON

 LDA K3                 \ Set A = K3 + K
 CLC
 ADC K

 LDA K3+1               \ Set A = K3+1 + 0 + any carry from above, so this
 ADC #0                 \ effectively sets A to the high byte of K3(1 0) + K:
                        \
                        \   (A ?) = K3(1 0) + K
                        \
                        \ so A is the high byte of the x-coordinate of the right
                        \ edge of the circle

 BMI PL21               \ If A is negative then the right edge of the circle is
                        \ to the left of the screen, so jump to PL21 to set the
                        \ C flag and return from the subroutine, as the whole
                        \ circle is off-screen to the left

 LDA K3                 \ Set A = K3 - K
 SEC
 SBC K

 LDA K3+1               \ Set A = K3+1 - 0 - any carry from above, so this
 SBC #0                 \ effectively sets A to the high byte of K3(1 0) - K:
                        \
                        \   (A ?) = K3(1 0) - K
                        \
                        \ so A is the high byte of the x-coordinate of the left
                        \ edge of the circle

 BMI PL31               \ If A is negative then the left edge of the circle is
                        \ to the left of the screen, and we already know the
                        \ right edge is either on-screen or off-screen to the
                        \ right, so skip to PL31 to move on to the y-coordinate
                        \ checks, as at least part of the circle is on-screen in
                        \ terms of the x-axis

 BNE PL21               \ If A is non-zero, then the left edge of the circle is
                        \ to the right of the screen, so jump to PL21 to set the
                        \ C flag and return from the subroutine, as the whole
                        \ circle is off-screen to the right

.PL31

 LDA K4                 \ Set P+1 = K4 + K
 CLC
 ADC K
 STA P+1

 LDA K4+1               \ Set A = K4+1 + 0 + any carry from above, so this
 ADC #0                 \ does the following:
                        \
                        \   (A P+1) = K4(1 0) + K
                        \
                        \ so A is the high byte of the y-coordinate of the
                        \ bottom edge of the circle

 BMI PL21               \ If A is negative then the bottom edge of the circle is
                        \ above the top of the screen, so jump to PL21 to set
                        \ the C flag and return from the subroutine, as the
                        \ whole circle is off-screen to the top

 STA P+2                \ Store the high byte in P+2, so now we have:
                        \
                        \   P(2 1) = K4(1 0) + K
                        \
                        \ i.e. the maximum y-coordinate of the circle on-screen
                        \ (which we return)

 LDA K4                 \ Set X = K4 - K
 SEC
 SBC K
 TAX

 LDA K4+1               \ Set A = K4+1 - 0 - any carry from above, so this
 SBC #0                 \ does the following:
                        \
                        \   (A X) = K4(1 0) - K
                        \
                        \ so A is the high byte of the y-coordinate of the top
                        \ edge of the circle

 BMI PL44               \ If A is negative then the top edge of the circle is
                        \ above the top of the screen, and we already know the
                        \ bottom edge is either on-screen or below the bottom
                        \ of the screen, so skip to PL44 to clear the C flag and
                        \ return from the subroutine using a tail call, as part
                        \ of the circle definitely appears on-screen

 BNE PL21               \ If A is non-zero, then the top edge of the circle is
                        \ below the bottom of the screen, so jump to PL21 to set
                        \ the C flag and return from the subroutine, as the
                        \ whole circle is off-screen to the bottom

 CPX #2*Y-1             \ If we get here then A is zero, which means the top
                        \ edge of the circle is within the screen boundary, so
                        \ now we need to check whether it is in the space view
                        \ (in which case it is on-screen) or the dashboard (in
                        \ which case the top of the circle is hidden by the
                        \ dashboard, so the circle isn't on-screen). We do this
                        \ by checking the low byte of the result in X against
                        \ 2 * #Y - 1, and returning the C flag from this
                        \ comparison. The constant #Y is the y-coordinate of the
                        \ mid-point of the space view, so 2 * #Y - 1 is 191, the
                        \ y-coordinate of the bottom pixel row of the space
                        \ view. So this does the following:
                        \
                        \   * The C flag is set if coordinate (A X) is below the
                        \     bottom row of the space view, i.e. the top edge of
                        \     the circle is hidden by the dashboard
                        \
                        \   * The C flag is clear if coordinate (A X) is above
                        \     the bottom row of the space view, i.e. the top
                        \     edge of the circle is on-screen

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT17
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan the keyboard for cursor key or joystick movement
\
\ ------------------------------------------------------------------------------
\
\ Scan the keyboard and joystick for cursor key or stick movement, and return
\ the result as deltas (changes) in x- and y-coordinates as follows:
\
\   * For joystick, X and Y are integers between -2 and +2 depending on how far
\     the stick has moved
\
\   * For keyboard, X and Y are integers between -1 and +1 depending on which
\     keys are pressed
\
\ Returns:
\
\   A                   The key pressed, if the arrow keys were used
\
\   X                   Change in the x-coordinate according to the cursor keys
\                       being pressed or joystick movement, as an integer (see
\                       above)
\
\   Y                   Change in the y-coordinate according to the cursor keys
\                       being pressed or joystick movement, as an integer (see
\                       above)
\
\ Other entry points:
\
\   chk_dirn            Do not scan the keyboard, instead just set the movement
\                       variables based on the current state of the key logger
\
\ ******************************************************************************

.TT17

 JSR DOKEY              \ Scan the keyboard for flight controls and pause keys,
                        \ (or the equivalent on joystick) and update the key
                        \ logger, setting KL to the key pressed

.chk_dirn

 LDA JSTK               \ If the joystick is not configured, jump down to TJ1,
 BEQ TJ1                \ otherwise we move the cursor with the joystick

 LDA JSTX               \ Fetch the joystick roll, ranging from 1 to 255 with
                        \ 128 as the centre point

 EOR #&FF               \ Flip the sign so A = -JSTX, because the joystick roll
                        \ works in the opposite way to moving a cursor on-screen
                        \ in terms of left and right

 JSR TJS1               \ Call TJS1 just below to set A to a value between -2
                        \ and +2 depending on the joystick roll value (moving
                        \ the stick sideways)

 TYA                    \ Copy Y to A

 TAX                    \ Copy A to X, so X contains the joystick roll value

 LDA JSTY               \ Fetch the joystick pitch, ranging from 1 to 255 with
                        \ 128 as the centre point, and fall through into TJS1 to
                        \ set Y to the joystick pitch value (moving the stick up
                        \ and down)

.TJS1

 TAY                    \ Store A in Y

 LDA #0                 \ Set the result, A = 0

 CPY #16                \ If Y >= 16 set the C flag, so A = A - 1
 SBC #0

 CPY #64                \ If Y >= 64 set the C flag, so A = A - 1
 SBC #0

 CPY #192               \ If Y >= 192 set the C flag, so A = A + 1
 ADC #0

 CPY #224               \ If Y >= 224 set the C flag, so A = A + 1
 ADC #0

 TAY                    \ Copy the value of A into Y

 LDA KL                 \ Set A to the value of KL (the key pressed)

 RTS                    \ Return from the subroutine

.TJ1

 LDA KL                 \ Set A to the value of KL (the key pressed)

 LDX #0                 \ Set the initial values for the results, X = Y = 0,
 LDY #0                 \ which we now increase or decrease appropriately

 CMP #&19               \ If left arrow was pressed, set X = X - 1
 BNE P%+3
 DEX

 CMP #&79               \ If right arrow was pressed, set X = X + 1
 BNE P%+3
 INX

 CMP #&39               \ If up arrow was pressed, set Y = Y + 1
 BNE P%+3
 INY

 CMP #&29               \ If down arrow was pressed, set Y = Y - 1
 BNE P%+3
 DEY

 STX T                  \ Set T to the value of X, which contains the joystick
                        \ roll value

 LDX #0                 \ Scan the keyboard to see if the SHIFT key is currently
 JSR DKS4               \ being pressed, returning the result in A and X

 BPL TJe                \ If SHIFT is not being pressed, skip to TJe

 ASL T                  \ SHIFT is being held down, so quadruple the value of T
 ASL T                  \ (i.e. SHIFT moves the cursor at four times the speed
                        \ when using the joystick)

 TYA                    \ Fetch the joystick pitch value from Y into A

 ASL A                  \ SHIFT is being held down, so quadruple the value of A
 ASL A                  \ (i.e. SHIFT moves the cursor at four times the speed
                        \ when using the joystick)

 TAY                    \ Transfer the amended value of A back into Y

.TJe

 LDX T                  \ Fetch the amended value of T back into X

 LDA KL                 \ Set A to the value of KL (the key pressed)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ping
\       Type: Subroutine
\   Category: Universe
\    Summary: Set the selected system to the current system
\
\ ******************************************************************************

.ping

 LDX #1                 \ We want to copy the X- and Y-coordinates of the
                        \ current system in (QQ0, QQ1) to the selected system's
                        \ coordinates in (QQ9, QQ10), so set up a counter to
                        \ copy two bytes

.pl1

 LDA QQ0,X              \ Load byte X from the current system in QQ0/QQ1

 STA QQ9,X              \ Store byte X in the selected system in QQ9/QQ10

 DEX                    \ Decrement the loop counter

 BPL pl1                \ Loop back for the next byte to copy

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\ Save ELTE.bin
\
\ ******************************************************************************

 PRINT "ELITE E"
 PRINT "Assembled at ", ~CODE_E%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_E%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_E%

 PRINT "S.2.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
\SAVE "3-assembled-output/2.ELTE.bin", CODE_E%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE F FILE
\
\ ******************************************************************************

 CODE_F% = P%
 LOAD_F% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: SFX
\       Type: Variable
\   Category: Sound
\    Summary: Sound data
\
\ ------------------------------------------------------------------------------
\
\ Sound data. To make a sound, the NOS1 routine copies the four relevant sound
\ bytes to XX16, and NO3 then makes the sound. The sound numbers are shown in
\ the table, and are always multiples of 8. Generally, sounds are made by
\ calling the NOISE routine with the sound number in A.
\
\ These bytes are passed to OSWORD 7, and are the equivalents to the parameters
\ passed to the SOUND keyword in BASIC. The parameters therefore have these
\ meanings:
\
\   channel/flush, amplitude (or envelope number if 1-4), pitch, duration
\
\ For the channel/flush parameter, the top nibble of the low byte is the flush
\ control (where a flush control of 0 queues the sound, and a flush control of
\ 1 makes the sound instantly), while the bottom nibble of the low byte is the
\ channel number . When written in hexadecimal, the first figure gives the flush
\ control, while the second is the channel (so &13 indicates flush control = 1
\ and channel = 3).
\
\ So when we call NOISE with A = 40 to make a long, low beep, then this is
\ effectively what the NOISE routine does:
\
\   SOUND &13, &F4, &0C, &08
\
\ which makes a sound with flush control 1 on channel 3, and with amplitude &F4
\ (-12), pitch &0C (2) and duration &08 (8). Meanwhile, to make the hyperspace
\ sound, the NOISE routine does this:
\
\   SOUND &10, &02, &60, &10
\
\ which makes a sound with flush control 1 on channel 0, using envelope 2,
\ and with pitch &60 (96) and duration &10 (16). The four sound envelopes (1-4)
\ are set up by the loading process.
\
\ ******************************************************************************

.SFX

 EQUB &12,&01,&00,&10   \ 0  - Lasers fired by us
 EQUB &12,&02,&2C,&08   \ 8  - We're being hit by lasers
 EQUB &11,&03,&F0,&18   \ 16 - We died 1 / We made a hit or kill 2
 EQUB &10,&F1,&07,&1A   \ 24 - We died 2 / We made a hit or kill 1
 EQUB &03,&F1,&BC,&01   \ 32 - Short, high beep
 EQUB &13,&F4,&0C,&08   \ 40 - Long, low beep
 EQUB &10,&F1,&06,&0C   \ 48 - Missile launched / Ship launched from station
 EQUB &10,&02,&60,&10   \ 56 - Hyperspace drive engaged
 EQUB &13,&04,&C2,&FF   \ 64 - E.C.M. on
 EQUB &13,&00,&00,&00   \ 72 - E.C.M. off

\ ******************************************************************************
\
\       Name: RESET
\       Type: Subroutine
\   Category: Start and end
\    Summary: Reset most variables
\
\ ------------------------------------------------------------------------------
\
\ Reset our ship and various controls, recharge shields and energy, and then
\ fall through into RES2 to reset the stardust and the ship workspace at INWK.
\
\ In this subroutine, this means zero-filling the following locations:
\
\   * Pages &9, &A, &B, &C and &D
\
\   * BETA to BETA+8, which covers the following:
\
\     * BETA, BET1 - Set pitch to 0
\
\     * XC, YC - Set text cursor to (0, 0)
\
\     * QQ22 - Set hyperspace counters to 0
\
\     * ECMA - Turn E.C.M. off
\
\     * ALP1, ALP2 - Set roll signs to 0
\
\ It also sets QQ12 to &FF, to indicate we are docked, recharges the shields and
\ energy banks, and then falls through into RES2.
\
\ ******************************************************************************

.RESET

 JSR ZERO               \ Zero-fill pages &9, &A, &B, &C and &D, which clears
                        \ the ship data blocks, the ship line heap, the ship
                        \ slots for the local bubble of universe, and various
                        \ flight and ship status variables

 LDX #8                 \ Set up a counter for zeroing BETA through BETA+8

.SAL3

 STA BETA,X             \ Zero the X-th byte after BETA

 DEX                    \ Decrement the loop counter

 BPL SAL3               \ Loop back for the next byte to zero

 TXA                    \ X is now negative - i.e. &FF - so this sets A and QQ12
 STA QQ12               \ to &FF to indicate we are docked

 LDX #2                 \ We're now going to recharge both shields and the
                        \ energy bank, which live in the three bytes at FSH,
                        \ ASH (FSH+1) and ENERGY (FSH+2), so set a loop counter
                        \ in X for 3 bytes

.REL5

 STA FSH,X              \ Set the X-th byte of FSH to &FF to charge up that
                        \ shield/bank

 DEX                    \ Decrement the loop counter

 BPL REL5               \ Loop back to REL5 until we have recharged both shields
                        \ and the energy bank

                        \ Fall through into RES2 to reset the stardust and ship
                        \ workspace at INWK

\ ******************************************************************************
\
\       Name: RES2
\       Type: Subroutine
\   Category: Start and end
\    Summary: Reset a number of flight variables and workspaces
\
\ ------------------------------------------------------------------------------
\
\ This is called after we launch from a space station, arrive in a new system
\ after hyperspace, launch an escape pod, or die a cold, lonely death in the
\ depths of space.
\
\ Returns:
\
\   Y                   Y is set to &FF
\
\ ******************************************************************************

.RES2

 LDA #NOST              \ Reset NOSTM, the number of stardust particles, to the
 STA NOSTM              \ maximum allowed (18)

 LDX #&FF               \ Reset LSX2 and LSY2, the ball line heaps used by the
 STX LSX2               \ BLINE routine for drawing circles, to &FF, to set the
 STX LSY2               \ heap to empty

 STX MSTG               \ Reset MSTG, the missile target, to &FF (no target)

 LDA #128               \ Set the current pitch and roll rates to the mid-point,
 STA JSTX               \ 128
 STA JSTY

 STA ALP2               \ Reset ALP2 (roll sign) and BET2 (pitch sign)
 STA BET2               \ to negative, i.e. pitch and roll negative

 ASL A                  \ This sets A to 0

 STA ALP2+1             \ Reset ALP2+1 (flipped roll sign) and BET2+1 (flipped
 STA BET2+1             \ pitch sign) to positive, i.e. pitch and roll negative

 STA MCNT               \ Reset MCNT (the main loop counter) to 0

 STA QQ22+1             \ Set the on-screen hyperspace counter to 0

 LDA #3                 \ Reset DELTA (speed) to 3
 STA DELTA

 STA ALPHA              \ Reset ALPHA (roll angle alpha) to 3

 STA ALP1               \ Reset ALP1 (magnitude of roll angle alpha) to 3

 LDA SSPR               \ Fetch the "space station present" flag, and if we are
 BEQ P%+5               \ not inside the safe zone, skip the next instruction

 JSR SPBLB              \ Light up the space station bulb on the dashboard

 LDA ECMA               \ Fetch the E.C.M. status flag, and if E.C.M. is off,
 BEQ yu                 \ skip the next instruction

 JSR ECMOF              \ Turn off the E.C.M. sound

.yu

 JSR WPSHPS             \ Wipe all ships from the scanner

 JSR ZERO               \ Zero-fill pages &9, &A, &B, &C and &D, which clears
                        \ the ship data blocks, the ship line heap, the ship
                        \ slots for the local bubble of universe, and various
                        \ flight and ship status variables

 LDA #LO(LS%)           \ We have reset the ship line heap, so we now point
 STA SLSP               \ SLSP to LS% (the byte below the ship blueprints at D%)
 LDA #HI(LS%)           \ to indicate that the heap is empty
 STA SLSP+1

 JSR DIALS              \ Update the dashboard

 JSR U%                 \ Call U% to clear the key logger

                        \ Finally, fall through into ZINF to reset the INWK
                        \ ship workspace

\ ******************************************************************************
\
\       Name: ZINF
\       Type: Subroutine
\   Category: Universe
\    Summary: Reset the INWK workspace and orientation vectors
\  Deep dive: Orientation vectors
\
\ ------------------------------------------------------------------------------
\
\ Zero-fill the INWK ship workspace and reset the orientation vectors, with
\ nosev pointing out of the screen, towards us.
\
\ Returns:
\
\   Y                   Y is set to &FF
\
\ ******************************************************************************

.ZINF

 LDY #NI%-1             \ There are NI% bytes in the INWK workspace, so set a
                        \ counter in Y so we can loop through them

 LDA #0                 \ Set A to 0 so we can zero-fill the workspace

.ZI1

 STA INWK,Y             \ Zero the Y-th byte of the INWK workspace

 DEY                    \ Decrement the loop counter

 BPL ZI1                \ Loop back for the next byte, ending when we have
                        \ zero-filled the last byte at INWK, which leaves Y
                        \ with a value of &FF

                        \ Finally, we reset the orientation vectors as follows:
                        \
                        \   sidev = (1,  0,  0)
                        \   roofv = (0,  1,  0)
                        \   nosev = (0,  0, -1)
                        \
                        \ 96 * 256 (&6000) represents 1 in the orientation
                        \ vectors, while -96 * 256 (&E000) represents -1. We
                        \ already set the vectors to zero above, so we just
                        \ need to set up the high bytes of the diagonal values
                        \ and we're done. The negative nosev makes the ship
                        \ point towards us, as the z-axis points into the screen

 LDA #96                \ Set A to represent a 1 (in vector terms)

 STA INWK+18            \ Set byte #18 = roofv_y_hi = 96 = 1

 STA INWK+22            \ Set byte #22 = sidev_x_hi = 96 = 1

 ORA #128               \ Flip the sign of A to represent a -1

 STA INWK+14            \ Set byte #14 = nosev_z_hi = -96 = -1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: msblob
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Display the dashboard's missile indicators in green
\
\ ------------------------------------------------------------------------------
\
\ Display the dashboard's missile indicators, with all the missiles reset to
\ green/cyan (i.e. not armed or locked).
\
\ Returns:
\
\   X                   X is set to &FF
\
\   Y                   Y is set to 0
\
\ ******************************************************************************

.msblob

 LDX #3                 \ Set up a loop counter in X to count through all four
                        \ missile indicators (in Elite-A the missile indicators
                        \ are numbered 0-3 rather than 1-4)

.ss

 LDY #0                 \ If X >= NOMSL, then jump down to miss_miss with Y = 0
 CPX NOMSL              \ to draw the missile indicator at position X in black
 BCS miss_miss

 LDY #&EE               \ Set the colour of the missile indicator to green/cyan

.miss_miss

 JSR MSBAR              \ Draw the missile indicator at position X in colour Y,
                        \ and return with Y = 0

 DEX                    \ Decrement the counter to point to the next missile

 BPL ss                 \ Loop back to ss if we still have missiles to draw,
                        \ ending when X = &FF

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: me2
\       Type: Subroutine
\   Category: Text
\    Summary: Remove an in-flight message from the space view
\
\ ******************************************************************************

.me2

 LDA MCH                \ Fetch the token number of the current message into A

 JSR MESS               \ Call MESS to print the token, which will remove it
                        \ from the screen as printing uses EOR logic

 LDA #0                 \ Set the delay in DLY to 0, so any new in-flight
 STA DLY                \ messages will be shown instantly

 JMP me3                \ Jump back into the main spawning loop at me3

\ ******************************************************************************
\
\       Name: Main game loop (Part 2 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Update the main loop counters
\  Deep dive: Program flow of the main game loop
\             Ship data blocks
\             Fixing ship positions
\
\ ------------------------------------------------------------------------------
\
\ This section covers the following:
\
\   * Update the main loop counters
\
\ Other entry points:
\
\   TT100               The entry point for the start of the main game loop,
\                       which calls the main flight loop and the moves into the
\                       spawning routine
\
\   me3                 Used by me2 to jump back into the main game loop after
\                       printing an in-flight message
\
\ ******************************************************************************

.TT100

 DEC DLY                \ Decrement the delay counter in DLY, so any in-flight
                        \ messages get removed once the counter reaches zero

 BEQ me2                \ If DLY is now 0, jump to me2 to remove any in-flight
                        \ message from the space view, and once done, return to
                        \ me3 below, skipping the following two instructions

 BPL me3                \ If DLY is positive, jump to me3 to skip the next
                        \ instruction

 INC DLY                \ If we get here, DLY is negative, so we have gone too
                        \ and need to increment DLY back to 0

.me3

 DEC MCNT               \ Decrement the main loop counter in MCNT

\ ******************************************************************************
\
\       Name: Main game loop (Part 5 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Cool down lasers, make calls to update the dashboard
\  Deep dive: Program flow of the main game loop
\             The dashboard indicators
\
\ ------------------------------------------------------------------------------
\
\ This is the first half of the minimal game loop, which we iterate when we are
\ docked. This section covers the following:
\
\   * Cool down lasers
\
\   * Make calls to update the dashboard
\
\ Other entry points:
\
\   MLOOP               The entry point for the main game loop. This entry point
\                       comes after the call to the main flight loop and
\                       spawning routines, so it marks the start of the main
\                       game loop for when we are docked (as we don't need to
\                       call the main flight loop or spawning routines if we
\                       aren't in space)
\
\ ******************************************************************************

.MLOOP

 LDX #&FF               \ Set the stack pointer to &01FF, which is the standard
 TXS                    \ location for the 6502 stack, so this instruction
                        \ effectively resets the stack

 LDY #2                 \ Wait for 2/50 of a second (0.04 seconds), to slow the
 JSR DELAY              \ main loop down a bit

 JSR TT17               \ Scan the keyboard for the cursor keys or joystick,
                        \ returning the cursor's delta values in X and Y and
                        \ the key pressed in A

\ ******************************************************************************
\
\       Name: Main game loop (Part 6 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Process non-flight key presses (red function keys, docked keys)
\  Deep dive: Program flow of the main game loop
\
\ ------------------------------------------------------------------------------
\
\ This is the second half of the minimal game loop, which we iterate when we are
\ docked. This section covers the following:
\
\   * Process more key presses (red function keys, docked keys etc.)
\
\ It also supports joining the main loop with a key already "pressed", so we can
\ jump into the main game loop to perform a specific action. In practice, this
\ is used when we enter the docking bay in BAY to display Status Mode (red key
\ f8), and when we finish buying or selling cargo in BAY2 to jump to the
\ Inventory (red key f9).
\
\ Other entry points:
\
\   FRCE                The entry point for the main game loop if we want to
\                       jump straight to a specific screen, by pretending to
\                       "press" a key, in which case A contains the internal key
\                       number of the key we want to "press"
\
\ ******************************************************************************

.FRCE

 JSR TT102              \ Call TT102 to process the key pressed in A

 LDA QQ12               \ Fetch the docked flag from QQ12 into A

 BNE MLOOP              \ If we are docked, loop back up to MLOOP just above
                        \ to restart the main loop, but skipping all the flight
                        \ and spawning code in the top part of the main loop

 JMP TT100              \ Otherwise jump to TT100 to restart the main loop from
                        \ the start

\ ******************************************************************************
\
\       Name: DORND
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Generate random numbers
\  Deep dive: Generating random numbers
\             Fixing ship positions
\
\ ------------------------------------------------------------------------------
\
\ Set A and X to random numbers (though note that X is set to the random number
\ that was returned in A the last time DORND was called).
\
\ The C and V flags are also set randomly.
\
\ If we want to generate a repeatable sequence of random numbers, when
\ generating explosion clouds, for example, then we call DORND2 to ensure that
\ the value of the C flag on entry doesn't affect the outcome, as otherwise we
\ might not get the same sequence of numbers if the C flag changes.
\
\ ******************************************************************************

.DORND

 LDA RAND               \ Calculate the next two values f2 and f3 in the feeder
 ROL A                  \ sequence:
 TAX                    \
 ADC RAND+2             \   * f2 = (f1 << 1) mod 256 + C flag on entry
 STA RAND               \   * f3 = f0 + f2 + (1 if bit 7 of f1 is set)
 STX RAND+2             \   * C flag is set according to the f3 calculation

 LDA RAND+1             \ Calculate the next value m2 in the main sequence:
 TAX                    \
 ADC RAND+3             \   * A = m2 = m0 + m1 + C flag from feeder calculation
 STA RAND+1             \   * X = m1
 STX RAND+3             \   * C and V flags set according to the m2 calculation

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: brkd
\       Type: Variable
\   Category: Utility routines
\    Summary: The brkd counter for error handling
\
\ ------------------------------------------------------------------------------
\
\ This counter starts at zero, and is decremented whenever the BRKV handler at
\ BRBR prints an error message. It is incremented every time an error message
\ is printed out as part of the TITLE routine.
\
\ ******************************************************************************

.brkd

 EQUB 0

\ ******************************************************************************
\
\       Name: INBAY
\       Type: Subroutine
\   Category: Loader
\    Summary: Restart the game upon death
\
\ ******************************************************************************

.INBAY

 LDA #0                 \ Set save_lock to 0 to indicate there are no unsaved
 STA save_lock          \ changes in the commander file

 STA dockedp            \ Set dockedp to 0 to indicate that we are docked

 JSR BRKBK              \ Call BRKBK to set BRKV to point to the BRBR routine

 JSR RES2               \ Reset a number of flight variables and workspaces

 JMP BR1                \ Jump to BR1 to restart the game

\ ******************************************************************************
\
\       Name: boot_in
\       Type: Subroutine
\   Category: Loader
\    Summary: The entry point for the game
\
\ ------------------------------------------------------------------------------
\
\ This routine is at the execution address for the parasite code (&2E93), so
\ it is called when the parasite code in file 2.T is loaded and run.
\
\ ******************************************************************************

.boot_in

 LDA #0                 \ Set save_lock to 0 to indicate there are no unsaved
 STA save_lock          \ changes in the commander file

 STA SSPR               \ Set the "space station present" flag to 0, as we are
                        \ no longer in the space station's safe zone

 STA ECMA               \ Set ECMA to 0 to indicate that no E.C.M. is currently
                        \ running

 STA dockedp            \ Set dockedp to 0 to indicate that we are docked

 JMP BEGIN              \ Jump to BEGIN to initialise the configuration
                        \ variables and start the game

\ ******************************************************************************
\
\       Name: BRBR
\       Type: Subroutine
\   Category: Utility routines
\    Summary: The standard BRKV handler for the game
\
\ ------------------------------------------------------------------------------
\
\ This routine is used to display error messages, before restarting the game.
\ When called, it makes a beep and prints the system error message in the block
\ pointed to by (&FD &FE), which is where the MOS will put any system errors. It
\ then waits for a key press and restarts the game.
\
\ BRKV is set to this routine in the loader, when the docked code is loaded, and
\ at the end of the SVE routine after the disc access menu has been processed.
\ In other words, this is the standard BRKV handler for the game, and it's
\ swapped out to MEBRK for disc access operations only.
\
\ When it is the BRKV handler, the routine can be triggered using a BRK
\ instruction. The main differences between this routine and the MEBRK handler
\ that is used during disc access operations are that this routine restarts the
\ game rather than returning to the disc access menu, and this handler
\ decrements the brkd counter.
\
\ ******************************************************************************

.BRBR

 DEC brkd               \ Decrement the brkd counter

 BNE BR1                \ If the brkd counter is non-zero, jump to BR1 to
                        \ restart the game

 JSR RES2               \ Reset a number of flight variables and workspaces
                        \ and fall through into the entry code for the game
                        \ to restart from the title screen

\ ******************************************************************************
\
\       Name: BEGIN
\       Type: Subroutine
\   Category: Loader
\    Summary: Initialise the configuration variables and start the game
\
\ ******************************************************************************

.BEGIN

 JSR BRKBK              \ Call BRKBK to set BRKV to point to the BRBR routine

 LDX #(CATF-COMC)       \ We start by zeroing all the configuration variables
                        \ between COMC and CATF, to set them to their default
                        \ values, so set a counter in X for CATF - COMC bytes

 LDA #0                 \ Set A = 0 so we can zero the variables

.BEL1

 STA COMC,X             \ Zero the X-th configuration variable

 DEX                    \ Decrement the loop counter

 BPL BEL1               \ Loop back to BEL1 to zero the next byte, until we have
                        \ zeroed them all

 LDA #127               \ Set BSTK = 127 (positive) to disable the Delta 14B
 STA BSTK               \ joystick

                        \ Fall through into TT170 to start the game

\ ******************************************************************************
\
\       Name: BR1 (Part 1 of 2)
\       Type: Subroutine
\   Category: Start and end
\    Summary: Show the "Load New Commander (Y/N)?" screen and start the game
\
\ ------------------------------------------------------------------------------
\
\ BRKV is set to point to BR1 by the loading process.
\
\ ******************************************************************************

.BR1

 LDX #10                \ Install ship number 10 (Cobra Mk III) into blueprint
 LDY #CYL               \ position #CYL (11) so it can be shown on the first
 JSR install_ship       \ title screen

 LDX #19                \ Install ship number 19 (Krait) into blueprint position
 LDY #KRA               \ #KRA (19) so it can be shown on the second title
 JSR install_ship       \ screen

 LDX #&FF               \ Set the stack pointer to &01FF, which is the standard
 TXS                    \ location for the 6502 stack, so this instruction
                        \ effectively resets the stack

 LDX #3                 \ Set XC = 3 (set text cursor to column 3)
 STX XC

 JSR FX200              \ Disable the ESCAPE key and clear memory if the BREAK
                        \ key is pressed (*FX 200,3)

 LDX #CYL               \ Call TITLE to show a rotating Cobra Mk III (#CYL) and
 LDA #6                 \ token 6 ("LOAD NEW {single cap}COMMANDER {all caps}
 JSR TITLE              \ (Y/N)?{sentence case}{cr}{cr}"), returning with the
                        \ internal number of the key pressed in A

 CMP #&44               \ Did we press "Y"? If not, jump to QU5, otherwise
 BNE QU5                \ continue on to load a new commander

 JSR DFAULT             \ Call DFAULT to reset the current commander data block
                        \ to the last saved commander

 JSR SVE                \ Call SVE to load a new commander into the last saved
                        \ commander data block

.QU5

 JSR DFAULT             \ Call DFAULT to reset the current commander data block
                        \ to the last saved commander

\ ******************************************************************************
\
\       Name: BR1 (Part 2 of 2)
\       Type: Subroutine
\   Category: Start and end
\    Summary: Show the "Press Fire or Space, Commander" screen and start the
\             game
\
\ ------------------------------------------------------------------------------
\
\ BRKV is set to point to BR1 by the loading process.
\
\ ******************************************************************************

 JSR msblob             \ Reset the dashboard's missile indicators so none of
                        \ them are targeted

 LDA #7                 \ Call TITLE to show a rotating Krait (#KRA) and token
 LDX #KRA               \ 7 ("PRESS SPACE OR FIRE,{single cap}COMMANDER.{cr}
 JSR TITLE              \ {cr}"), returning with the internal number of the key
                        \ pressed in A

 JSR ping               \ Set the target system coordinates (QQ9, QQ10) to the
                        \ current system coordinates (QQ0, QQ1) we just loaded

 JSR hyp1               \ Arrive in the system closest to (QQ9, QQ10)

                        \ Fall through into the docking bay routine below

\ ******************************************************************************
\
\       Name: BAY
\       Type: Subroutine
\   Category: Status
\    Summary: Go to the docking bay (i.e. show the Status Mode screen)
\
\ ------------------------------------------------------------------------------
\
\ We end up here after the start-up process (load commander etc.), as well as
\ after a successful save, an escape pod launch, a successful docking, the end
\ of a cargo sell, and various errors (such as not having enough cash, entering
\ too many items when buying, trying to fit an item to your ship when you
\ already have it, running out of cargo space, and so on).
\
\ ******************************************************************************

.BAY

 LDA #&FF               \ Set QQ12 = &FF (the docked flag) to indicate that we
 STA QQ12               \ are docked

 LDA #f8                \ Jump into the main loop at FRCE, setting the key
 JMP FRCE               \ that's "pressed" to red key f8 (so we show the Status
                        \ Mode screen)

\ ******************************************************************************
\
\       Name: DFAULT
\       Type: Subroutine
\   Category: Start and end
\    Summary: Reset the current commander data block to the last saved commander
\
\ ******************************************************************************

.DFAULT

 LDX #NT%+8             \ The size of the last saved commander data block is NT%
                        \ bytes, and it is preceded by the 8 bytes of the
                        \ commander name (seven characters plus a carriage
                        \ return). The commander data block at NAME is followed
                        \ by the commander data block, so we need to copy the
                        \ name and data from the "last saved" buffer at NA% to
                        \ the current commander workspace at NAME. So we set up
                        \ a counter in X for the NT% + 8 bytes that we want to
                        \ copy

.QUL1

 LDA NA%-1,X            \ Copy the X-th byte of NA%-1 to the X-th byte of
 STA NAME-1,X           \ NAME-1 (the -1 is because X is counting down from
                        \ NT% + 8 to 1)

 DEX                    \ Decrement the loop counter

 BNE QUL1               \ Loop back for the next byte of the commander data
                        \ block

 STX QQ11               \ X is 0 by the end of the above loop, so this sets QQ11
                        \ to 0, which means we will be showing a view without a
                        \ boxed title at the top (i.e. we're going to use the
                        \ screen layout of a space view in the following)

                        \ If the commander check below fails, we keep jumping
                        \ back to here to crash the game with an infinite loop

 JSR update_pod         \ Update the dashboard colours to reflect whether we now
                        \ have an escape pod

 JSR CHECK              \ Call the CHECK subroutine to calculate the checksum
                        \ for the current commander block at NA%+8 and put it
                        \ in A

 CMP CHK                \ Test the calculated checksum against CHK

IF _REMOVE_CHECKSUMS

 NOP                    \ If we have disabled checksums, then ignore the result
 NOP                    \ of the comparison and fall through into the next part

ELSE

 BNE P%-6               \ If the calculated checksum does not match CHK, then
                        \ loop back to repeat the check - in other words, we
                        \ enter an infinite loop here, as the checksum routine
                        \ will keep returning the same incorrect value

ENDIF

 JMP n_load             \ Jump to n_load to load the blueprint for the current
                        \ ship type, returning from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: TITLE
\       Type: Subroutine
\   Category: Start and end
\    Summary: Display a title screen with a rotating ship and prompt
\
\ ------------------------------------------------------------------------------
\
\ Display the title screen, with a rotating ship and a text token at the bottom
\ of the screen.
\
\ Arguments:
\
\   A                   The number of the recursive token to show below the
\                       rotating ship (see variable QQ18 for details of
\                       recursive tokens)
\
\   X                   The type of the ship to show (see variable XX21 for a
\                       list of ship types)
\
\ Returns:
\
\   X                   If a key is being pressed, X contains the internal key
\                       number, otherwise it contains 0
\
\ ******************************************************************************

.TITLE

 PHA                    \ Store the token number on the stack for later

 STX TYPE               \ Store the ship type in location TYPE

 JSR RESET              \ Reset our ship so we can use it for the rotating
                        \ title ship

 LDA #1                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 1

 DEC QQ11               \ Decrement QQ11 to 0, so from here on we are using a
                        \ space view

 LDA #96                \ Set nosev_z hi = 96 (96 is the value of unity in the
 STA INWK+14            \ rotation vector)

 LDA #219               \ Set A = 219 as the distance that the ship starts at

 STA INWK+7             \ Set z_hi, the high byte of the ship's z-coordinate,
                        \ to 96, which is the distance at which the rotating
                        \ ship starts out before coming towards us

 LDX #127               \ Set roll counter = 127, so don't dampen the roll
 STX INWK+29

 STX INWK+30            \ Set pitch counter = 127, so don't dampen the pitch

 INX                    \ Set QQ17 to 128 (so bit 7 is set) to switch to
 STX QQ17               \ Sentence Case, with the next letter printing in upper
                        \ case

 LDA TYPE               \ Set up a new ship, using the ship type in TYPE
 JSR NWSHP

 LDY #6                 \ Move the text cursor to column 6
 STY XC

 LDA #30                \ Print recursive token 144 ("---- E L I T E ----")
 JSR plf                \ followed by a newline

 LDY #6                 \ Move the text cursor to column 6 again
 STY XC

 INC YC                 \ Move the text cursor down a row

 LDA PATG               \ If PATG = 0, skip the following two lines, which
 BEQ awe                \ print the author credits (PATG can be toggled by
                        \ pausing the game and pressing "X")

 LDA #13                \ Print extended token 13 ("BY D.BRABEN & I.BELL")
 JSR DETOK

 INC YC                 \ Move the text cursor down two rows
 INC YC

 LDA #3                 \ Move the text cursor to column 3
 STA XC

 LDA #114               \ Print extended token 114 (" MODIFIED BY A.J.C.DUGGAN")
 JSR DETOK

.awe

 LDA brkd               \ If brkd = 0, jump to BRBR2 to skip the following, as
 BEQ BRBR2              \ we do not have a system error message to display

 INC brkd               \ Increment the brkd counter

 LDA #7                 \ Move the text cursor to column 7
 STA XC

 LDA #10                \ Move the text cursor to row 10
 STA YC

                        \ The following loop prints out the null-terminated
                        \ message pointed to by (&FD &FE), which is the MOS
                        \ error message pointer - so this prints the error
                        \ message on the next line

 LDY #0                 \ Set Y = 0 to act as a character counter

 JSR OSWRCH             \ Print the character in A (which contains a line feed
                        \ on the first loop iteration), and then any non-zero
                        \ characters we fetch from the error message

 INY                    \ Increment the loop counter

 LDA (&FD),Y            \ Fetch the Y-th byte of the block pointed to by
                        \ (&FD &FE), so that's the Y-th character of the message
                        \ pointed to by the MOS error message pointer

 BNE P%-6               \ If the fetched character is non-zero, loop back to the
                        \ JSR OSWRCH above to print it, and keep looping until
                        \ we fetch a zero (which marks the end of the message)

.BRBR2

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows.
                        \ It also returns with Y = 0

 STY DELTA              \ Set DELTA = 0 (i.e. ship speed = 0)

 STY JSTK               \ Set JSTK = 0 (i.e. keyboard, not joystick)

 PLA                    \ Restore the recursive token number we stored on the
                        \ stack at the start of this subroutine

 JSR DETOK              \ Print the extended token in A

 LDA #12                \ Set A to extended token 12

 LDX #7                 \ Move the text cursor to column 7
 STX XC

 JSR DETOK              \ Print extended token 12 ("({single cap}C) ACORNSOFT
                        \ 1984")

.TLL2

 LDA INWK+7             \ If z_hi (the ship's distance) is 1, jump to TL1 to
 CMP #1                 \ skip the following decrement
 BEQ TL1

 DEC INWK+7             \ Decrement the ship's distance, to bring the ship
                        \ a bit closer to us

.TL1

 JSR MVEIT              \ Move the ship in space according to the orientation
                        \ vectors and the new value in z_hi

 LDA #128               \ Set z_lo = 128, so the closest the ship gets to us is
 STA INWK+6             \ z_hi = 1, z_lo = 128, or 256 + 128 = 384

 ASL A                  \ Set A = 0

 STA INWK               \ Set x_lo = 0, so the ship remains in the screen centre

 STA INWK+3             \ Set y_lo = 0, so the ship remains in the screen centre

 JSR LL9                \ Call LL9 to display the ship

 DEC MCNT               \ Decrement the main loop counter

 JSR scan_fire          \ Call scan_fire to check whether the joystick's fire
                        \ button is being pressed, which clears bit 4 in A if
                        \ the fire button is being pressed, and sets it if it
                        \ is not being pressed

 BEQ TL2                \ If the joystick fire button is pressed, jump to TL2

 JSR RDKEY              \ Scan the keyboard for a key press

 BEQ TLL2               \ If no key was pressed, loop back up to move/rotate
                        \ the ship and check again for a key press

 RTS                    \ Return from the subroutine

.TL2

 DEC JSTK               \ Joystick fire button was pressed, so set JSTK to &FF
                        \ (it was set to 0 above), to disable keyboard and
                        \ enable joysticks

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CHECK
\       Type: Subroutine
\   Category: Save and load
\    Summary: Calculate the checksum for the last saved commander data block
\  Deep dive: Commander save files
\
\ ------------------------------------------------------------------------------
\
\ The checksum for the last saved commander data block is saved as part of the
\ commander file, in two places (CHK AND CHK2), to protect against file
\ tampering. This routine calculates the checksum and returns it in A.
\
\ This algorithm is also implemented in elite-checksum.py.
\
\ Returns:
\
\   A                   The checksum for the last saved commander data block
\
\ ******************************************************************************

.CHECK

 LDX #NT%-2             \ Set X to the size of the commander data block, less
                        \ 2 (to omit the checksum bytes and the save count)

 SEC                    \ Set the C flag to increase the checksum value by 1,
                        \ so the Elite-A checksum is subtly different to the
                        \ standard version's checksum

 TXA                    \ Seed the checksum calculation by setting A to the
                        \ size of the commander data block, less 2

                        \ We now loop through the commander data block,
                        \ starting at the end and looping down to the start
                        \ (so at the start of this loop, the X-th byte is the
                        \ last byte of the commander data block, i.e. the save
                        \ count)

.QUL2

 ADC NA%+7,X            \ Add the X-1-th byte of the data block to A, plus the
                        \ C flag

 EOR NA%+8,X            \ EOR A with the X-th byte of the data block

 DEX                    \ Decrement the loop counter

 BNE QUL2               \ Loop back for the next byte in the calculation, until
                        \ we have added byte #0 and EOR'd with byte #1 of the
                        \ data block

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TRNME
\       Type: Subroutine
\   Category: Save and load
\    Summary: Copy the last saved commander's name from INWK to NA%
\
\ ******************************************************************************

.TRNME

 LDX #7                 \ The commander's name can contain a maximum of 7
                        \ characters, and is terminated by a carriage return,
                        \ so set up a counter in X to copy 8 characters

.GTL1

 LDA INWK+5,X           \ Copy the X-th byte of INWK+5 to the X-th byte of NA%
 STA NA%,X

 DEX                    \ Decrement the loop counter

 BPL GTL1               \ Loop back until we have copied all 8 bytes

                        \ Fall through into TR1 to copy the name back from NA%
                        \ to INWK. This isn't necessary as the name is already
                        \ there, but it does save one byte, as we don't need an
                        \ RTS here

\ ******************************************************************************
\
\       Name: TR1
\       Type: Subroutine
\   Category: Save and load
\    Summary: Copy the last saved commander's name from NA% to INWK
\
\ ******************************************************************************

.TR1

 LDX #7                 \ The commander's name can contain a maximum of 7
                        \ characters, and is terminated by a carriage return,
                        \ so set up a counter in X to copy 8 characters

.GTL2

 LDA NA%,X              \ Copy the X-th byte of NA% to the X-th byte of INWK+5
 STA INWK+5,X

 DEX                    \ Decrement the loop counter

 BPL GTL2               \ Loop back until we have copied all 8 bytes

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GTNMEW
\       Type: Subroutine
\   Category: Save and load
\    Summary: Fetch the name of a commander file to save or load
\
\ ------------------------------------------------------------------------------
\
\ Get the commander's name for loading or saving a commander file. The name is
\ stored in the INWK workspace and is terminated by a return character (13).
\
\ If ESCAPE is pressed or a blank name is entered, then the name stored is set
\ to the name from the last saved commander block.
\
\ Returns:
\
\   INWK                The full filename, including drive and directory, in
\                       the form ":0.E.JAMESON", for example, terminated by a
\                       return character (13)
\
\ ******************************************************************************

.GTNMEW

 LDY #8                 \ Wait for 8/50 of a second (0.16 seconds)
 JSR DELAY

.GTNME

 LDX #4                 \ First we want to copy the drive and directory part of
                        \ the commander file from S1% (which equals NA%-5), so
                        \ set a counter in x for 5 bytes, as the string is of
                        \ the form ":0.E."

.GTL3

 LDA NA%-5,X            \ Copy the X-th byte from NA%-5 to INWK
 STA INWK,X

 DEX                    \ Decrement the loop counter

 BPL GTL3               \ Loop back until the whole drive and directory string
                        \ has been copied to INWK to INWK+4

 LDA #7                 \ The call to MT26 below uses the OSWORD block at RLINE
 STA RLINE+2            \ to fetch the line, and RLINE+2 defines the maximum
                        \ line length allowed, so this changes the maximum
                        \ length to 7 (as that's the longest commander name
                        \ allowed)

 LDA #8                 \ Print extended token 8 ("{single cap}COMMANDER'S
 JSR DETOK              \ NAME? ")

 JSR MT26               \ Call MT26 to fetch a line of text from the keyboard
                        \ to INWK+5, with the text length in Y, so INWK now
                        \ contains the full pathname of the file, as in
                        \ ":0.E.JAMESON", for example

 LDA #9                 \ Reset the maximum length in RLINE+2 to the original
 STA RLINE+2            \ value of 9

 TYA                    \ The OSWORD call returns the length of the commander's
                        \ name in Y, so transfer this to A

 BEQ TR1                \ If A = 0, no name was entered, so jump to TR1 to copy
                        \ the last saved commander's name from NA% to INWK
                        \ and return from the subroutine there

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MT26
\       Type: Subroutine
\   Category: Text
\    Summary: Fetch a line of text from the keyboard
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ If ESCAPE is pressed or a blank name is entered, then an empty string is
\ returned.
\
\ Returns:
\
\   Y                   The size of the entered text, or 0 if none was entered
\                       or if ESCAPE was pressed
\
\   INWK+5              The entered text, terminated by a carriage return
\
\   C flag              Set if ESCAPE was pressed
\
\ ******************************************************************************

.MT26

 LDA #&8A               \ Send command &8A to the I/O processor:
 JSR tube_write         \
                        \   =write_fe4e(value)
                        \
                        \ which sets the 6522 System VIA interrupt enable
                        \ register IER (SHEILA &4E) to the specified value and
                        \ returns the value in A when done

 LDA #%10000001         \ Send the parameter to the I/O processor:
 JSR tube_write         \
                        \   * value = %10000001
                        \
                        \ to clear bit 1 of IER (i.e. enable the CA2 interrupt,
                        \ which comes from the keyboard)

 JSR tube_read          \ Set A to the response from the I/O processor

 JSR FLKB               \ Call FLKB to flush the keyboard buffer

 LDX #LO(RLINE)         \ Set (Y X) to point to the RLINE parameter block
 LDY #HI(RLINE)

 LDA #0                 \ Call OSWORD with A = 0 to read a line from the current
 JSR OSWORD             \ input stream (i.e. the keyboard)

 BCC P%+4               \ The C flag will be set if we pressed ESCAPE when
                        \ entering the name, otherwise it will be clear, so
                        \ skip the next instruction if ESCAPE is not pressed

 LDY #0                 \ ESCAPE was pressed, so set Y = 0 (as the OSWORD call
                        \ returns the length of the entered string in Y)

 LDA #&8A               \ Send command &8A to the I/O processor:
 JSR tube_write         \
                        \   =write_fe4e(value)
                        \
                        \ which sets the 6522 System VIA interrupt enable
                        \ register IER (SHEILA &4E) to the specified value and
                        \ returns the value in A when done

 LDA #%00000001         \ Send the parameter to the I/O processor:
 JSR tube_write         \
                        \   * value = %00000001
                        \
                        \ to set bit 1 of IER (i.e. disable the CA2 interrupt,
                        \ which comes from the keyboard)

 JSR tube_read          \ Set A to the response from the I/O processor, so we
                        \ know the register has been set

 JMP FEED               \ Jump to FEED to print a newline, returning from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: RLINE
\       Type: Variable
\   Category: Text
\    Summary: The OSWORD configuration block used to fetch a line of text from
\             the keyboard
\
\ ******************************************************************************

.RLINE

 EQUW INWK+5            \ The address to store the input, so the text entered
                        \ will be stored in INWK+5 as it is typed

 EQUB 9                 \ Maximum line length = 9, as that's the maximum size
                        \ for a commander's name including a directory name

 EQUB '!'               \ Allow ASCII characters from "!" through to "{" in
 EQUB '{'               \ the input

\ ******************************************************************************
\
\       Name: ZERO
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Reset the local bubble of universe and ship status
\
\ ------------------------------------------------------------------------------
\
\ This resets the following workspaces to zero:
\
\   * WP workspace variables from FRIN to de, which include the ship slots for
\     the local bubble of universe, and various flight and ship status variables
\     (only a portion of the LSX/LSO sun line heap is cleared)
\
\ ******************************************************************************

.ZERO

 LDX #(de-FRIN)         \ We're going to zero the UP workspace variables from
                        \ FRIN to de, so set a counter in X for the correct
                        \ number of bytes

 LDA #0                 \ Set A = 0 so we can zero the variables

.ZEL2

 STA FRIN,X             \ Zero the X-th byte of FRIN to de

 DEX                    \ Decrement the loop counter

 BPL ZEL2               \ Loop back to zero the next variable until we have done
                        \ them all

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ZEBC
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Zero-fill pages &B and &C
\
\ ******************************************************************************

.ZEBC

 LDX #&C                \ Call ZES1 with X = &C to zero-fill page &C
 JSR ZES1

 DEX                    \ Decrement X to &B

                        \ Fall through into ZES1 to zero-fill page &B

\ ******************************************************************************
\
\       Name: ZES1
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Zero-fill the page whose number is in X
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The page we want to zero-fill
\
\ ******************************************************************************

.ZES1

 LDY #0                 \ If we set Y = SC = 0 and fall through into ZES2
 STY SC                 \ below, then we will zero-fill 255 bytes starting from
                        \ SC - in other words, we will zero-fill the whole of
                        \ page X

\ ******************************************************************************
\
\       Name: ZES2
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Zero-fill a specific page
\
\ ------------------------------------------------------------------------------
\
\ Zero-fill from address (X SC) + Y to (X SC) + &FF.
\
\ Arguments:
\
\   Y                   The offset from (X SC) where we start zeroing, counting
\                       up to &FF
\
\   SC                  The low byte (i.e. the offset into the page) of the
\                       starting point of the zero-fill
\
\ Returns:
\
\   Z flag              Z flag is set
\
\ ******************************************************************************

.ZES2

 LDA #0                 \ Load A with the byte we want to fill the memory block
                        \ with - i.e. zero

 STX SC+1               \ We want to zero-fill page X, so store this in the
                        \ high byte of SC, so the 16-bit address in SC and
                        \ SC+1 is now pointing to the SC-th byte of page X

.ZEL1

 STA (SC),Y             \ Zero the Y-th byte of the block pointed to by SC,
                        \ so that's effectively the Y-th byte before SC

 INY                    \ Increment the loop counter

 BNE ZEL1               \ Loop back to zero the next byte

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CTLI
\       Type: Variable
\   Category: Save and load
\    Summary: The OS command string for cataloguing a disc
\
\ ******************************************************************************

.CTLI

 EQUS ".:0"             \ The "0" part of the string is overwritten with the
 EQUB 13                \ actual drive number by the CATS routine

\ ******************************************************************************
\
\       Name: DELI
\       Type: Variable
\   Category: Save and load
\    Summary: The OS command string for deleting a file
\
\ ******************************************************************************

.DELI

 EQUS "DEL.:0.E.1234567"    \ Short for "*DELETE :0.E.1234567"
 EQUB 13

\ ******************************************************************************
\
\       Name: CATS
\       Type: Subroutine
\   Category: Save and load
\    Summary: Ask for a disc drive number and print a catalogue of that drive
\
\ ------------------------------------------------------------------------------
\
\ This routine asks for a disc drive number, and if it is a valid number (0-3)
\ it displays a catalogue of the disc in that drive. It also updates the OS
\ command at CTLI so that when that command is run, it catalogues the correct
\ drive.
\
\ Returns:
\
\   C flag              Clear if a valid drive number was entered (0-3), set
\                       otherwise
\
\ ******************************************************************************

.CATS

 JSR GTDRV              \ Get an ASCII disc drive number from the keyboard in A,
                        \ setting the C flag if an invalid drive number was
                        \ entered

 BCS DELT-1             \ If the C flag is set, then an invalid drive number was
                        \ entered, so return from the subroutine (as DELT-1
                        \ contains an RTS)

 STA CTLI+2             \ Store the drive number in the third byte of the
                        \ command string at CTLI, so it overwrites the "0" in
                        \ ".0" with the drive number to catalogue

 STA DTW7               \ Store the drive number in DTW7, so printing extended
                        \ token 4 will show the correct drive number (as token 4
                        \ contains the {drive number} jump code, which calls
                        \ MT16 to print the character in DTW7)

 LDA #4                 \ Print extended token 4, which clears the screen and
 JSR DETOK              \ prints the boxed-out title "DRIVE {drive number}
                        \ CATALOGUE"

 LDA #&8E               \ Send command &8E to the I/O processor:
 JSR tube_write         \
                        \   write_xyc(x, y, char)
                        \
                        \ which will draw the text character in char at column x
                        \ and row y, though in this case we're sending a null
                        \ character (char = 0), so this doesn't print anything
                        \ but just moves the text cursor in the I/O processor
                        \ to column XC and row YC

 LDA XC                 \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * x = XC

 LDA YC                 \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * y = YC

 LDA #0                 \ Send the third parameter to the I/O processor:
 JSR tube_write         \
                        \   * char = 0

 STA XC                 \ Move the text cursor to column 1

 LDX #LO(CTLI)          \ Set (Y X) to point to the OS command at CTLI, which
 LDY #HI(CTLI)          \ contains a dot and the drive number, which is the
                        \ DFS command for cataloguing that drive (*. being short
                        \ for *CAT)

 JSR OSCLI              \ Call OSCLI to execute the OS command at (Y X), which
                        \ catalogues the disc

 CLC                    \ Clear the C flag

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DELT
\       Type: Subroutine
\   Category: Save and load
\    Summary: Catalogue a disc, ask for a filename to delete, and delete the
\             file
\
\ ------------------------------------------------------------------------------
\
\ This routine asks for a disc drive number, and if it is a valid number (0-3)
\ it displays a catalogue of the disc in that drive. It then asks for a filename
\ to delete, updates the OS command at DELI so that when that command is run, it
\ deletes the correct file, and then it does the deletion.
\
\ Other entry points:
\
\   DELT-1              Contains an RTS
\
\ ******************************************************************************

.DELT

 JSR CATS               \ Call CATS to ask for a drive number (or a directory
                        \ name on the Master Compact) and catalogue that disc
                        \ or directory

 BCS SVE                \ If the C flag is set then an invalid drive number was
                        \ entered as part of the catalogue process, so jump to
                        \ SVE to display the disc access menu

 LDA CTLI+2             \ The call to CATS above put the drive number into
 STA DELI+5             \ CTLI+2, so copy the drive number into DELI+5 so that
                        \ the drive number in the "DEL.:0.E.1234567" string
                        \ gets updated (i.e. the number after the colon)

 LDA #9                 \ Print extended token 9 ("{clear bottom of screen}FILE
 JSR DETOK              \ TO DELETE?")

 JSR MT26               \ Call MT26 to fetch a line of text from the keyboard
                        \ to INWK+5, with the text length in Y

 TYA                    \ If no text was entered (Y = 0) then jump to SVE to
 BEQ SVE                \ display the disc access menu

                        \ We now copy the entered filename from INWK to DELI, so
                        \ that it overwrites the filename part of the string,
                        \ i.e. the "E.1234567" part of "DEL.:0.E.1234567"

 LDX #9                 \ Set up a counter in X to count from 9 to 1, so that we
                        \ copy the string starting at INWK+4+1 (i.e. INWK+5) to
                        \ DELI+5+1 (i.e. DELI+6 onwards, or "E.1234567")

.DELL1

 LDA INWK+4,X           \ Copy the X-th byte of INWK+4 to the X-th byte of
 STA DELI+6,X           \ DELI+6

 DEX                    \ Decrement the loop counter

 BNE DELL1              \ Loop back to DELL1 to copy the next character until we
                        \ have copied the whole filename

 LDX #LO(DELI)          \ Set (Y X) to point to the OS command at DELI, which
 LDY #HI(DELI)          \ contains the DFS command for deleting this file

 JSR OSCLI              \ Call OSCLI to execute the OS command at (Y X), which
                        \ catalogues the disc

 JMP SVE                \ Jump to SVE to display the disc access menu and return
                        \ from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: MEBRK
\       Type: Subroutine
\   Category: Save and load
\    Summary: The BRKV handler for disc access operations
\
\ ------------------------------------------------------------------------------
\
\ This routine is used to display error messages from the disc filing system
\ while disc access operations are being performed. When called, it makes a beep
\ and prints the system error message in the block pointed to by (&FD &FE),
\ which is where the disc filing system will put any disc errors (such as "File
\ not found", "Disc error" and so on). It then waits for a key press and returns
\ to the disc access menu.
\
\ BRKV is set to this routine at the start of the SVE routine, just before the
\ disc access menu is shown, and it reverts to BRBR at the end of the SVE
\ routine after the disc access menu has been processed. In other words, BRBR is
\ the standard BRKV handler for the game, and it's swapped out to MEBRK for disc
\ access operations only.
\
\ When it is the BRKV handler, the routine can be triggered using a BRK
\ instruction. The main difference between this routine and the standard BRKV
\ handler in BRBR is that this routine returns to the disc access menu rather
\ than restarting the game, and it doesn't decrement the brkd counter.
\
\ ******************************************************************************

.MEBRK

 LDX #&FF               \ The #&FF part of this instruction is modified by the
 TXS                    \ SVE routine so that it sets the stack pointer back to
                        \ the value it had before we set BRKV to point to MEBRK
                        \ in the SVE routine. Modifying this instruction means
                        \ we don't need to use the stack variable, which saves
                        \ us both a byte in this instruction, as well the byte
                        \ of the stack variable

 LDY #0                 \ Set Y to 0 to use as a loop counter below

 LDA #7                 \ Set A = 7 to generate a beep before we print the error
                        \ message

.MEBRKL

 JSR OSWRCH             \ Print the character in A (which contains a beep on the
                        \ first loop iteration), and then any non-zero
                        \ characters we fetch from the error message

 INY                    \ Increment the loop counter

 LDA (&FD),Y            \ Fetch the Y-th byte of the block pointed to by
                        \ (&FD &FE), so that's the Y-th character of the message
                        \ pointed to by the MOS error message pointer

 BNE MEBRKL             \ If the fetched character is non-zero, loop back to the
                        \ JSR OSWRCH above to print the it, and keep looping
                        \ until we fetch a zero (which marks the end of the
                        \ message)

 BEQ retry              \ Jump to retry to wait for a key press and display the
                        \ disc access menu (this BEQ is effectively a JMP, as we
                        \ didn't take the BNE branch above)

\ ******************************************************************************
\
\       Name: CAT
\       Type: Subroutine
\   Category: Save and load
\    Summary: Catalogue a disc, wait for a key press and display the disc access
\             menu
\
\ ******************************************************************************

.CAT

 JSR CATS               \ Call CATS to ask for a drive number, catalogue that
                        \ disc and update the catalogue command at CTLI

                        \ Fall through into retry to wait for a key press and
                        \ display the disc access menu

\ ******************************************************************************
\
\       Name: retry
\       Type: Subroutine
\   Category: Save and load
\    Summary: Scan the keyboard until a key is pressed and display the disc
\             access menu
\
\ ******************************************************************************

.retry

 JSR t                  \ Scan the keyboard until a key is pressed, returning
                        \ the ASCII code in A and X

                        \ Fall through into SVE to display the disc access menu

\ ******************************************************************************
\
\       Name: SVE
\       Type: Subroutine
\   Category: Save and load
\    Summary: Save the commander file
\  Deep dive: Commander save files
\             The competition code
\
\ ******************************************************************************

.SVE

 JSR ZEBC               \ Call ZEBC to zero-fill pages &B and &C

 TSX                    \ Transfer the stack pointer to X and store it in
 STX MEBRK+1            \ MEBRK+1, which modifies the LDX #&FF instruction at
                        \ the start of MEBRK so that it sets X to the value of
                        \ the stack pointer

 LDA #LO(MEBRK)         \ Set BRKV to point to the MEBRK routine, which is the
 STA BRKV               \ BRKV handler for disc access operations, and replaces
 LDA #HI(MEBRK)         \ the standard BRKV handler in BRBR while disc access
 STA BRKV+1             \ operations are happening

 LDA #1                 \ Print extended token 1, the disc access menu, which
 JSR DETOK              \ presents these options:
                        \
                        \   1. Load New Commander
                        \   2. Save Commander {commander name}
                        \   3. Catalogue
                        \   4. Delete A File
                        \   5. Exit

 JSR t                  \ Scan the keyboard until a key is pressed, returning
                        \ the ASCII code in A and X

 CMP #'1'               \ If A < ASCII "1", jump to SVEX to exit as the key
 BCC SVEX               \ press doesn't match a menu option

 CMP #'4'               \ If "4" was pressed, jump to DELT to process option 4
 BEQ DELT               \ (delete a file)

 BCS SVEX               \ If A >= ASCII "4", jump to SVEX to exit as the key
                        \ press is either option 5 (exit), or it doesn't match a
                        \ menu option (as we already checked for "4" above)

 CMP #'2'               \ If A >= ASCII "2" (i.e. save or catalogue), skip to
 BCS SV1                \ SV1

                        \ If we get here then option 1 (load) was chosen

 LDA #0                 \ If save_lock = &FF, then there are unsaved changes, so
 JSR confirm            \ ask for confirmation before proceeding with the load,
 BNE SVEX               \ jumping to SVEX to exit if confirmation is not given

 JSR GTNMEW             \ Call GTNMEW to fetch the name of the commander file
                        \ to load (including drive number and directory) into
                        \ INWK

 JSR LOD                \ Call LOD to load the commander file

 JSR TRNME              \ Transfer the commander filename from INWK to NA%

 SEC                    \ Set the C flag to indicate we loaded a new commander
 BCS SVEX+1             \ file, and return from the subroutine (as SVEX+1
                        \ contains an RTS)

.SV1

 BNE CAT                \ We get here following the CMP #'2' above, so this
                        \ jumps to CAT if option 2 was not chosen - in other
                        \ words, if option 3 (catalogue) was chosen

                        \ If we get here then option 2 (save) was chosen

 LDA #&FF               \ If save_lock = 0, then there are no unsaved changes,
 JSR confirm            \ so ask for confirmation before proceeding with the
 BNE SVEX               \ save, jumping to SVEX to exit if confirmation is not
                        \ given

 JSR GTNMEW             \ Call GTNMEW to fetch the name of the commander file
                        \ to save (including drive number and directory) into
                        \ INWK

 JSR TRNME              \ Transfer the commander filename from INWK to NA%

 LDX #NT%               \ We now want to copy the current commander data block
                        \ from location TP to the last saved commander block at
                        \ NA%+8, so set a counter in X to copy the NT% bytes in
                        \ the commander data block
                        \
                        \ We also want to copy the data block to another
                        \ location &0B00, which is normally used for the ship
                        \ lines heap

.SVL1

 LDA TP,X               \ Copy the X-th byte of TP to the X-th byte of &0B00
 STA &0B00,X            \ and NA%+8
 STA NA%+8,X

 DEX                    \ Decrement the loop counter

 BPL SVL1               \ Loop back until we have copied all the bytes in the
                        \ commander data block

 JSR CHECK              \ Call CHECK to calculate the checksum for the last
                        \ saved commander and return it in A

 STA CHK                \ Store the checksum in CHK, which is at the end of the
                        \ last saved commander block

 STA &0B00+NT%          \ Store the checksum in the last byte of the save file
                        \ at &0B00 (the equivalent of CHK in the last saved
                        \ block)

 EOR #&A9               \ Store the checksum EOR &A9 in CHK2, the penultimate
 STA CHK2               \ byte of the last saved commander block

 STA &0AFF+NT%          \ Store the checksum EOR &A9 in the penultimate byte of
                        \ the save file at &0B00 (the equivalent of CHK2 in the
                        \ last saved block)

 LDY #&B                \ Set up an OSFILE block at &0C00, containing:
 STY &0C0B              \
 INY                    \ Start address for save = &00000B00 in &0C0A to &0C0D
 STY &0C0F              \
                        \ End address for save = &00000C00 in &0C0E to &0C11
                        \
                        \ Y is left containing &C which we use below

 LDA #0                 \ Call QUS1 with A = 0, Y = &C to save the commander
 JSR QUS1               \ file with the filename we copied to INWK at the start
                        \ of this routine

.SVEX

 CLC                    \ Clear the C flag to indicate we didn't just load a new
                        \ commander file

 JMP BRKBK              \ Jump to BRKBK to set BRKV back to the standard BRKV
                        \ handler for the game, and return from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: confirm
\       Type: Subroutine
\   Category: Save and load
\    Summary: Print "ARE YOU SURE?" and wait for a response
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   If save_lock matches this value, then we do not ask for
\                       confirmation and instead assume the answer was "Y"
\
\ Returns:
\
\   Z flag              If "Y" is pressed, then BEQ will branch (Z flag is set),
\                       otherwise BNE will branch (Z flag is clear)
\
\ ******************************************************************************

.confirm

 CMP save_lock          \ If A = save_lock, jump to confirmed to return from the
 BEQ confirmed          \ subroutine without asking for confirmation, but
                        \ assuming a positive response

 LDA #3                 \ Print extended token 3 ("ARE YOU SURE?")
 JSR DETOK

 JSR t                  \ Scan the keyboard until a key is pressed, returning
                        \ the ASCII code in A and X

 JSR CHPR               \ Print the character in A

 ORA #%00100000         \ Set bit 5 in the value of the key pressed, which
                        \ converts it to lower case

 PHA                    \ Store A on the stack so we can retrieve it after the
                        \ call to FEED

 JSR TT67               \ Print a newline

 JSR FEED               \ Print a newline

 PLA                    \ Restore A from the stack

 CMP #'y'               \ Set the C flag if A >= ASCII y' (i.e. if "Y" was
                        \ pressed and not "N"), otherwise clear it

.confirmed

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: QUS1
\       Type: Subroutine
\   Category: Save and load
\    Summary: Save or load the commander file
\  Deep dive: Commander save files
\
\ ------------------------------------------------------------------------------
\
\ The filename should be stored at INWK, terminated with a carriage return (13).
\ The routine should be called with Y set to &C.
\
\ Arguments:
\
\   A                   File operation to be performed. Can be one of the
\                       following:
\
\                         * 0 (save file)
\
\                         * &FF (load file)
\
\   Y                   Points to the page number containing the OSFILE block,
\                       which must be &C because that's where the pointer to the
\                       filename in INWK is stored below (by the STX &0C00
\                       instruction)
\
\ ******************************************************************************

.QUS1

 PHA                    \ Store A on the stack so we can restore it after the
                        \ call to GTDRV

 JSR GTDRV              \ Get an ASCII disc drive number from the keyboard in A,
                        \ setting the C flag if an invalid drive number was
                        \ entered

 STA INWK+1             \ Store the ASCII drive number in INWK+1, which is the
                        \ drive character of the filename string ":0.E."

 PLA                    \ Restore A from the stack

 BCS QUR                \ If the C flag is set, then an invalid drive number was
                        \ entered, so jump to QUR to return from the subroutine

 STA save_lock          \ Set save_lock to 0 (when we save a file) or &FF (when
                        \ we load a file) to indicate:
                        \
                        \   * 0 = last file operation was a save
                        \
                        \   * &FF = last file operation was a load

 LDX #INWK              \ Store a pointer to INWK at the start of the block at
 STX &0C00              \ &0C00, storing #INWK in the low byte because INWK is
                        \ in zero page

 LDX #0                 \ Set (Y X) = &0C00
 LDY #&C

 JSR OSFILE             \ Call OSFILE to do the file operation specified in
                        \ &0C00 (i.e. save or load a file depending on the value
                        \ of A)

 CLC                    \ Clear the C flag

.QUR

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GTDRV
\       Type: Subroutine
\   Category: Save and load
\    Summary: Get an ASCII disc drive number from the keyboard
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The ASCII value of the entered drive number ("0" to "3")
\
\   C flag              Clear if a valid drive number was entered (0-3), set
\                       otherwise
\
\ ******************************************************************************

.GTDRV

 LDA #2                 \ Print extended token 2 ("{cr}WHICH DRIVE?")
 JSR DETOK

 JSR t                  \ Scan the keyboard until a key is pressed, returning
                        \ the ASCII code in A and X

 ORA #%00010000         \ Set bit 4 of A, perhaps to avoid printing any control
                        \ characters in the next instruction

 JSR CHPR               \ Print the character in A

 PHA                    \ Store A on the stack so we can retrieve it after the
                        \ call to FEED

 JSR FEED               \ Print a newline

 PLA                    \ Restore A from the stack

 CMP #'0'               \ If A < ASCII "0", then it is not a valid drive number,
 BCC LOR                \ so jump to LOR to set the C flag and return from the
                        \ subroutine

 CMP #'4'               \ If A >= ASCII "4", then it is not a valid drive
                        \ number, and this CMP sets the C flag, otherwise it is
                        \ a valid drive number in the range 0-3, so clear it

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LOD
\       Type: Subroutine
\   Category: Save and load
\    Summary: Load a commander file
\
\ ------------------------------------------------------------------------------
\
\ The filename should be stored at INWK, terminated with a carriage return (13).
\
\ ******************************************************************************

.LOD

 JSR ZEBC               \ Call ZEBC to zero-fill pages &B and &C

 LDY #&B                \ Set up an OSFILE block at &0C00, containing:
 STY &0C03              \
 INC &0C0B              \ Load address = &00000B00 in &0C02 to &0C05
                        \
                        \ Length of file = &00000100 in &0C0A to &0C0D

 LDA #&FF               \ Call QUS1 with A = &FF, Y = &C to load the commander
 JSR QUS1               \ file to address &0B00

 BCS LOR                \ If the C flag is set then an invalid drive number was
                        \ entered during the call to QUS1 and the file wasn't
                        \ loaded, so jump to LOR to return from the subroutine

 LDA &0B00              \ If the first byte of the loaded file has bit 7 set,
 BMI ELT2F              \ jump to ELT2F, as this is an invalid commander file
                        \
                        \ ELT2F contains a BRK instruction, which will force an
                        \ interrupt to call the address in BRKV, which will
                        \ print out the system error at ELT2F

 LDX #NT%               \ We have successfully loaded the commander file at
                        \ &0B00, so now we want to copy it to the last saved
                        \ commander data block at NA%+8, so we set up a counter
                        \ in X to copy NT% bytes

.LOL1

 LDA &0B00,X            \ Copy the X-th byte of &0B00 to the X-th byte of NA%+8
 STA NA%+8,X

 DEX                    \ Decrement the loop counter

 BPL LOL1               \ Loop back until we have copied all NT% bytes

.LOR

 SEC                    \ Set the C flag

 RTS                    \ Return from the subroutine

.ELT2F

 BRK                    \ The error that is printed if we try to load an
 EQUB &49               \ invalid commander file with bit 7 of byte #0 set
 EQUS "Bad ELITE III "  \ (&49 is the error number)
 EQUS "file"
 BRK

\ ******************************************************************************
\
\       Name: FX200
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Set the behaviour of the ESCAPE and BREAK keys
\
\ ------------------------------------------------------------------------------
\
\ This is the equivalent of a *FX 200 command, which controls the behaviour of
\ the ESCAPE and BREAK keys.
\
\ Arguments:
\
\   X                   Controls the behaviour as follows:
\
\                         * 0 = Enable ESCAPE key
\                               Normal BREAK key action
\
\                         * 1 = Disable ESCAPE key
\                               Normal BREAK key action
\
\                         * 2 = Enable ESCAPE key
\                               Clear memory if the BREAK key is pressed
\
\                         * 3 = Disable ESCAPE key
\                               Clear memory if the BREAK key is pressed
\
\ ******************************************************************************

.FX200

 LDY #0                 \ Call OSBYTE 200 with Y = 0, so the new value is set to
 LDA #200               \ X, and return from the subroutine using a tail call
 JMP OSBYTE

\ ******************************************************************************
\
\       Name: NORM
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Normalise the three-coordinate vector in XX15
\  Deep dive: Tidying orthonormal vectors
\             Orientation vectors
\
\ ------------------------------------------------------------------------------
\
\ We do this by dividing each of the three coordinates by the length of the
\ vector, which we can calculate using Pythagoras. Once normalised, 96 (&60) is
\ used to represent a value of 1, and 96 with bit 7 set (&E0) is used to
\ represent -1. This enables us to represent fractional values of less than 1
\ using integers.
\
\ Arguments:
\
\   XX15                The vector to normalise, with:
\
\                         * The x-coordinate in XX15
\
\                         * The y-coordinate in XX15+1
\
\                         * The z-coordinate in XX15+2
\
\ Returns:
\
\   XX15                The normalised vector
\
\   Q                   The length of the original XX15 vector
\
\ Other entry points:
\
\   NO1                 Contains an RTS
\
\ ******************************************************************************

.NORM

 LDA XX15               \ Fetch the x-coordinate into A

 JSR SQUA               \ Set (A P) = A * A = x^2

 STA R                  \ Set (R Q) = (A P) = x^2
 LDA P
 STA Q

 LDA XX15+1             \ Fetch the y-coordinate into A

 JSR SQUA               \ Set (A P) = A * A = y^2

 STA T                  \ Set (T P) = (A P) = y^2

 LDA P                  \ Set (R Q) = (R Q) + (T P) = x^2 + y^2
 ADC Q                  \
 STA Q                  \ First, doing the low bytes, Q = Q + P

 LDA T                  \ And then the high bytes, R = R + T
 ADC R
 STA R

 LDA XX15+2             \ Fetch the z-coordinate into A

 JSR SQUA               \ Set (A P) = A * A = z^2

 STA T                  \ Set (T P) = (A P) = z^2

 LDA P                  \ Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
 ADC Q                  \
 STA Q                  \ First, doing the low bytes, Q = Q + P

 LDA T                  \ And then the high bytes, R = R + T
 ADC R
 STA R

 JSR LL5                \ We now have the following:
                        \
                        \ (R Q) = x^2 + y^2 + z^2
                        \
                        \ so we can call LL5 to use Pythagoras to get:
                        \
                        \ Q = SQRT(R Q)
                        \   = SQRT(x^2 + y^2 + z^2)
                        \
                        \ So Q now contains the length of the vector (x, y, z),
                        \ and we can normalise the vector by dividing each of
                        \ the coordinates by this value, which we do by calling
                        \ routine TIS2. TIS2 returns the divided figure, using
                        \ 96 to represent 1 and 96 with bit 7 set for -1

 LDA XX15               \ Call TIS2 to divide the x-coordinate in XX15 by Q,
 JSR TIS2               \ with 1 being represented by 96
 STA XX15

 LDA XX15+1             \ Call TIS2 to divide the y-coordinate in XX15+1 by Q,
 JSR TIS2               \ with 1 being represented by 96
 STA XX15+1

 LDA XX15+2             \ Call TIS2 to divide the z-coordinate in XX15+2 by Q,
 JSR TIS2               \ with 1 being represented by 96
 STA XX15+2

.NO1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: scan_fire
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Check whether the joystick's fire button is being pressed by
\             sending a scan_fire command to the I/O processor
\
\ ******************************************************************************

.scan_fire

 LDA #&89               \ Send command &89 to the I/O processor:
 JSR tube_write         \
                        \   =scan_fire()
                        \
                        \ which will check whether the fire button is being
                        \ pressed and return the result in bit 4 of the returned
                        \ value

 JMP tube_read          \ Set A to the response from the I/O processor, which
                        \ will have bit 4 clear if the fire button is being
                        \ pressed, or set if it isn't, and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: RDKEY
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan the keyboard for key presses by sending a scan_10in command
\             to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   If a key is being pressed, X contains the internal key
\                       number, otherwise it contains 0
\
\   A                   Contains the same as X
\
\ ******************************************************************************

.RDKEY

 LDA #&8C               \ Send command &8C to the I/O processor:
 JSR tube_write         \
                        \   =scan_10in()
                        \
                        \ which will scan the keyboard

 JSR tube_read          \ Set A to the response from the I/O processor, which
                        \ will either be the internal key number of the key
                        \ being pressed, or 0 if no key is being pressed

 TAX                    \ Copy the response into X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ECMOF
\       Type: Subroutine
\   Category: Sound
\    Summary: Switch off the E.C.M.
\
\ ------------------------------------------------------------------------------
\
\ Switch the E.C.M. off, turn off the dashboard bulb and make the sound of the
\ E.C.M. switching off).
\
\ ******************************************************************************

.ECMOF

 LDA #0                 \ Set ECMA and ECMP to 0 to indicate that no E.C.M. is
 STA ECMA               \ currently running
 STA ECMP

 JSR ECBLB              \ Update the E.C.M. indicator bulb on the dashboard

 LDA #72                \ Call the NOISE routine with A = 72 to make the sound
 BNE NOISE              \ of the E.C.M. being turned off and return from the
                        \ subroutine using a tail call (this BNE is effectively
                        \ a JMP as A will never be zero)

\ ******************************************************************************
\
\       Name: BEEP
\       Type: Subroutine
\   Category: Sound
\    Summary: Make a short, high beep
\
\ ******************************************************************************

.BEEP

 LDA #32                \ Set A = 32 to denote a short, high beep, and fall
                        \ through into the NOISE routine to make the sound

\ ******************************************************************************
\
\       Name: NOISE
\       Type: Subroutine
\   Category: Sound
\    Summary: Make the sound whose number is in A
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of the sound to be made. See the
\                       documentation for variable SFX for a list of sound
\                       numbers
\
\ ******************************************************************************

.NOISE

 JSR NOS1               \ Set up the sound block in XX16 for the sound in A and
                        \ fall through into NO3 to make the sound

\ ******************************************************************************
\
\       Name: NO3
\       Type: Subroutine
\   Category: Sound
\    Summary: Make a sound from a prepared sound block
\
\ ------------------------------------------------------------------------------
\
\ Make a sound from a prepared sound block in XX16 (if sound is enabled). See
\ routine NOS1 for details of preparing the XX16 sound block.
\
\ ******************************************************************************

.NO3

 LDX DNOIZ              \ Set X to the DNOIZ configuration setting

 BNE NO1                \ If DNOIZ is non-zero, then sound is disabled, so
                        \ return from the subroutine (as NO1 contains an RTS)

 LDX #LO(XX16)          \ Otherwise set (Y X) to point to the sound block in
 LDY #HI(XX16)          \ XX16

 LDA #7                 \ Call OSWORD 7 to makes the sound, as described in the
 JMP OSWORD             \ documentation for variable SFX, and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: NOS1
\       Type: Subroutine
\   Category: Sound
\    Summary: Prepare a sound block
\
\ ------------------------------------------------------------------------------
\
\ Copy four sound bytes from SFX into XX16, interspersing them with null bytes,
\ with Y indicating the sound number to copy (from the values in the sound
\ table at SFX). So, for example, if we call this routine with A = 40 (long,
\ low beep), the following bytes will be set in XX16 to XX16+7:
\
\   &13 &00 &F4 &00 &0C &00 &08 &00
\
\ This block will be passed to OSWORD 7 to make the sound, which expects the
\ four sound attributes as 16-bit big-endian values - in other words, with the
\ low byte first. So the above block would pass the values &0013, &00F4, &000C
\ and &0008 to the SOUND statement when used with OSWORD 7, or:
\
\   SOUND &13, &F4, &0C, &08
\
\ as the high bytes are always zero.
\
\ Arguments:
\
\   A                   The sound number to copy from SFX to XX16, which is
\                       always a multiple of 8
\
\ ******************************************************************************

.NOS1

 LSR A                  \ Divide A by 2, and also clear the C flag, as bit 0 of
                        \ A is always zero (as A is a multiple of 8)

 ADC #3                 \ Set Y = A + 3, so Y now points to the last byte of
 TAY                    \ four within the block of four-byte values

 LDX #7                 \ We want to copy four bytes, spread out into an 8-byte
                        \ block, so set a counter in Y to cover 8 bytes

.NOL1

 LDA #0                 \ Set the X-th byte of XX16 to 0
 STA XX16,X

 DEX                    \ Decrement the destination byte pointer

 LDA SFX,Y              \ Set the X-th byte of XX16 to the value from SFX+Y
 STA XX16,X

 DEY                    \ Decrement the source byte pointer again

 DEX                    \ Decrement the destination byte pointer again

 BPL NOL1               \ Loop back for the next source byte

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CTRL
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan the keyboard to see if CTRL is currently pressed
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   X = %10000001 (i.e. 129 or -127) if CTRL is being
\                       pressed
\
\                       X = 1 if CTRL is not being pressed
\
\   A                   Contains the same as X
\
\ ******************************************************************************

.CTRL

 LDX #1                 \ Set X to the internal key number for CTRL and fall
                        \ through to DKS4 to scan the keyboard

\ ******************************************************************************
\
\       Name: DKS4
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan for a particular key press by sending a scan_xin command to
\             the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The internal number of the key to check
\
\ Returns:
\
\   A                   If the key is being pressed, A contains the original
\                       key number in X but with bit 7 set (i.e. key number +
\                       128). If the key is not being pressed, A contains the
\                       unchanged key number
\
\ ******************************************************************************

.DKS4

 LDA #&8B               \ Send command &8B to the I/O processor:
 JSR tube_write         \
                        \   =scan_xin(key_number)
                        \
                        \ which will scan the keyboard for the specified
                        \ internal key number

 TXA                    \ Send the parameter to the I/O processor:
 JSR tube_write         \
                        \   * key_number = X

 JSR tube_read          \ Set A to the response from the I/O processor, which
                        \ will contain the key number with bit 7 set if the key
                        \ is being pressed, or bit 7 clear if it isn't

 TAX                    \ Copy the response into X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DKS2
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Read the joystick position
\
\ ------------------------------------------------------------------------------
\
\ Return the value of ADC channel in X (used to read the joystick). The value
\ will be inverted if the game has been configured to reverse both joystick
\ channels (which can be done by pausing the game and pressing J).
\
\ Arguments:
\
\   X                   The ADC channel to read:
\
\                         * 1 = joystick X
\
\                         * 2 = joystick Y
\
\ Returns:
\
\   (A X)               The 16-bit value read from channel X, with the value
\                       inverted if the game has been configured to reverse the
\                       joystick
\
\ Other entry points:
\
\   DKS2-1              Contains an RTS
\
\ ******************************************************************************

.DKS2

 LDA #128               \ Call OSBYTE with A = 128 to fetch the 16-bit value
 JSR OSBYTE             \ from ADC channel X, returning (Y X), i.e. the high
                        \ byte in Y and the low byte in X
                        \
                        \   * Channel 1 is the x-axis: 0 = right, 65520 = left
                        \
                        \   * Channel 2 is the y-axis: 0 = down,  65520 = up

 TYA                    \ Copy Y to A, so the result is now in (A X)

 EOR JSTE               \ The high byte A is now EOR'd with the value in
                        \ location JSTE, which contains &FF if both joystick
                        \ channels are reversed and 0 otherwise (so A now
                        \ contains the high byte but inverted, if that's what
                        \ the current settings say)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DKS3
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Toggle a configuration setting and emit a beep
\
\ ------------------------------------------------------------------------------
\
\ This is called when the game is paused and a key is pressed that changes the
\ game's configuration.
\
\ Specifically, this routine toggles the configuration settings for the
\ following keys:
\
\   * CAPS LOCK toggles keyboard flight damping (&40)
\   * A toggles keyboard auto-recentre (&41)
\   * X toggles author names on start-up screen (&42)
\   * F toggles flashing console bars (&43)
\   * Y toggles reverse joystick Y channel (&44)
\   * J toggles reverse both joystick channels (&45)
\   * K toggles keyboard and joystick (&46)
\   * @ toggles keyboard and Delta 14B joystick (&47)
\
\ The numbers in brackets are the internal key numbers (see p.142 of the
\ Advanced User Guide for a list of internal key numbers). We pass the key that
\ has been pressed in X, and the configuration option to check it against in Y,
\ so this routine is typically called in a loop that loops through the various
\ configuration options.
\
\ Arguments:
\
\   X                   The internal number of the key that's been pressed
\
\   Y                   The internal number of the configuration key to check
\                       against, from the list above (i.e. Y must be from &40 to
\                       &46)
\
\ ******************************************************************************

.DKS3

 STY T                  \ Store the configuration key argument in T

 CPX T                  \ If X <> Y, jump to Dk3 to return from the subroutine
 BNE Dk3

                        \ We have a match between X and Y, so now to toggle
                        \ the relevant configuration byte. CAPS LOCK has a key
                        \ value of &40 and has its configuration byte at
                        \ location DAMP, A has a value of &41 and has its byte
                        \ at location DJD, which is DAMP+1, and so on. So we
                        \ can toggle the configuration byte by changing the
                        \ byte at DAMP + (X - &40), or to put it in indexing
                        \ terms, DAMP-&40,X. It's no coincidence that the
                        \ game's configuration bytes are set up in this order
                        \ and with these keys (and this is also why the sound
                        \ on/off keys are dealt with elsewhere, as the internal
                        \ key for S and Q are &51 and &10, which don't fit
                        \ nicely into this approach)

 LDA DAMP-&40,X         \ Fetch the byte from DAMP + (X - &40), invert it and
 EOR #&FF               \ put it back (0 means no and &FF means yes in the
 STA DAMP-&40,X         \ configuration bytes, so this toggles the setting)

 JSR BELL               \ Make a beep sound so we know something has happened

 JSR DELAY              \ Wait for Y vertical syncs (Y is between 64 and 70, so
                        \ this is always a bit longer than a second)

 LDY T                  \ Restore the configuration key argument into Y

.Dk3

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DOKEY
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan for the seven primary flight controls
\  Deep dive: The key logger
\             The docking computer
\
\ ******************************************************************************

.DOKEY

 LDA JSTK               \ If JSTK is zero, then we are configured to use the
 BEQ DK4                \ keyboard rather than the joystick, so jump to DK4 to
                        \ scan for pause, configuration and secondary flight
                        \ keys

 LDX #1                 \ Call DKS2 to fetch the value of ADC channel 1 (the
 JSR DKS2               \ joystick X value) into (A X), and OR A with 1. This
 ORA #1                 \ ensures that the high byte is at least 1, and then we
 STA JSTX               \ store the result in JSTX

 LDX #2                 \ Call DKS2 to fetch the value of ADC channel 2 (the
 JSR DKS2               \ joystick Y value) into (A X), and EOR A with JSTGY.
 EOR JSTGY              \ JSTGY will be &FF if the game is configured to
 STA JSTY               \ reverse the joystick Y channel, so this EOR does
                        \ exactly that, and then we store the result in JSTY

                        \ Fall through into DK4 to scan for other keys

\ ******************************************************************************
\
\       Name: DK4
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan for pause, configuration and secondary flight keys
\  Deep dive: The key logger
\
\ ------------------------------------------------------------------------------
\
\ Scan for pause and configuration keys, and if this is a space view, also scan
\ for secondary flight controls.
\
\ Specifically:
\
\   * Scan for the pause button (COPY) and if it's pressed, pause the game and
\     process any configuration key presses until the game is unpaused (DELETE)
\
\   * If this is a space view, scan for secondary flight keys and update the
\     relevant bytes in the key logger
\
\ ******************************************************************************

.DK4

 JSR RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press)

 STX KL                 \ Store X in KL, byte #0 of the key logger

 CPX #&69               \ If COPY is not being pressed, jump to DK2 below,
 BNE DK2                \ otherwise let's process the configuration keys

.FREEZE

                        \ COPY is being pressed, so we enter a loop that
                        \ listens for configuration keys, and we keep looping
                        \ until we detect a DELETE key press. This effectively
                        \ pauses the game when COPY is pressed, and unpauses
                        \ it when DELETE is pressed

 JSR WSCAN              \ Call WSCAN to wait for the vertical sync, so the whole
                        \ screen gets drawn

 JSR RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press)

 CPX #&51               \ If "S" is not being pressed, skip to DK6
 BNE DK6

 LDA #0                 \ "S" is being pressed, so set DNOIZ to 0 to turn the
 STA DNOIZ              \ sound on

.DK6

 LDY #&40               \ We now want to loop through the keys that toggle
                        \ various settings. These have internal key numbers
                        \ between &40 (CAPS LOCK) and &46 ("K"), so we set up
                        \ the first key number in Y to act as a loop counter.
                        \ See subroutine DKS3 for more details on this

.DKL4

 JSR DKS3               \ Call DKS3 to scan for the key given in Y, and toggle
                        \ the relevant setting if it is pressed

 INY                    \ Increment Y to point to the next toggle key

 CPY #&48               \ The last toggle key is &47 (@), so check whether we
                        \ have just done that one

 BNE DKL4               \ If not, loop back to check for the next toggle key

.DK55

 CPX #&10               \ If "Q" is not being pressed, skip to DK7
 BNE DK7

 STX DNOIZ              \ "Q" is being pressed, so set DNOIZ to X, which is
                        \ non-zero (&10), so this will turn the sound off

.DK7

 CPX #&70               \ If ESCAPE is not being pressed, skip over the next
 BNE P%+5               \ instruction

 JMP BR1                \ ESCAPE is being pressed, so jump to BR1 to end the
                        \ game

 CPX #&59               \ If DELETE is not being pressed, we are still paused,
 BNE FREEZE             \ so loop back up to keep listening for configuration
                        \ keys, otherwise fall through into the rest of the
                        \ key detection code, which unpauses the game

.DK2

 LDA QQ11               \ If the current view is non-zero (i.e. not a space
 BNE out                \ view), return from the subroutine (as out contains
                        \ an RTS)

 LDY #16                \ This is a space view, so now we want to check for all
                        \ the secondary flight keys. The internal key numbers
                        \ are in the keyboard table KYTB from KYTB+8 to
                        \ KYTB+16, and their key logger locations are from KL+8
                        \ to KL+16. So set a decreasing counter in Y for the
                        \ index, starting at 16, so we can loop through them

 LDA #&FF               \ Set A to &FF so we can store this in the keyboard
                        \ logger for keys that are being pressed

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT217
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan the keyboard until a key is pressed by sending a get_key
\             command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Scan the keyboard until a key is pressed, and return the key's ASCII code.
\ If, on entry, a key is already being held down, then wait until that key is
\ released first (so this routine detects the first key down event following
\ the subroutine call).
\
\ Returns:
\
\   X                   The ASCII code of the key that was pressed
\
\   A                   Contains the same as X
\
\ Other entry points:
\
\   out                 Contains an RTS
\
\ ******************************************************************************

.TT217

.t

 LDA #&8D               \ Send command &8D to the I/O processor:
 JSR tube_write         \
                        \   =get_key()
                        \
                        \ which waits for any current key presses to be released
                        \ (if any), and then waits for a key to be pressed
                        \ before returning the result as an ASCII value

 JSR tube_read          \ Set A to the response from the I/O processor, which
                        \ will contain the ASCII value of the key press

 TAX                    \ Copy the response into X

.out

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ITEM
\       Type: Macro
\   Category: Market
\    Summary: Macro definition for the market prices table
\  Deep dive: Market item prices and availability
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used to build the market prices table:
\
\   ITEM price, factor, units, quantity, mask
\
\ It inserts an item into the market prices table at QQ23. See the deep dive on
\ "Market item prices and availability" for more information on how the market
\ system works.
\
\ Arguments:
\
\   price               Base price
\
\   factor              Economic factor
\
\   units               Units: "t", "g" or "k"
\
\   quantity            Base quantity
\
\   mask                Fluctuations mask
\
\ ******************************************************************************

MACRO ITEM price, factor, units, quantity, mask

 IF factor < 0
  s = 1 << 7
 ELSE
  s = 0
 ENDIF

 IF units = 't'
  u = 0
 ELIF units = 'k'
  u = 1 << 5
 ELSE
  u = 1 << 6
 ENDIF

 e = ABS(factor)

 EQUB price
 EQUB s + u + e
 EQUB quantity
 EQUB mask

ENDMACRO

\ ******************************************************************************
\
\       Name: QQ23
\       Type: Variable
\   Category: Market
\    Summary: Market prices table
\
\ ------------------------------------------------------------------------------
\
\ Each item has four bytes of data, like this:
\
\   Byte #0 = Base price
\   Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
\             Unit in bits 5-6
\   Byte #2 = Base quantity
\   Byte #3 = Mask to control price fluctuations
\
\ To make it easier for humans to follow, we've defined a macro called ITEM
\ that takes the following arguments and builds the four bytes for us:
\
\   ITEM base price, economic factor, units, base quantity, mask
\
\ So for food, we have the following:
\
\   * Base price = 19
\   * Economic factor = -2
\   * Unit = tonnes
\   * Base quantity = 6
\   * Mask = %00000001
\
\ ******************************************************************************

.QQ23

 ITEM 19,  -2, 't',   6, %00000001   \  0 = Food
 ITEM 20,  -1, 't',  10, %00000011   \  1 = Textiles
 ITEM 65,  -3, 't',   2, %00000111   \  2 = Radioactives
 ITEM 40,  -5, 't', 226, %00011111   \  3 = Slaves
 ITEM 83,  -5, 't', 251, %00001111   \  4 = Liquor/Wines
 ITEM 196,  8, 't',  54, %00000011   \  5 = Luxuries
 ITEM 235, 29, 't',   8, %01111000   \  6 = Narcotics
 ITEM 154, 14, 't',  56, %00000011   \  7 = Computers
 ITEM 117,  6, 't',  40, %00000111   \  8 = Machinery
 ITEM 78,   1, 't',  17, %00011111   \  9 = Alloys
 ITEM 124, 13, 't',  29, %00000111   \ 10 = Firearms
 ITEM 176, -9, 't', 220, %00111111   \ 11 = Furs
 ITEM 32,  -1, 't',  53, %00000011   \ 12 = Minerals
 ITEM 97,  -1, 'k',  66, %00000111   \ 13 = Gold
 ITEM 171, -2, 'k',  55, %00011111   \ 14 = Platinum
 ITEM 45,  -1, 'g', 250, %00001111   \ 15 = Gem-Stones
 ITEM 53,  15, 't', 192, %00000111   \ 16 = Alien items

\ ******************************************************************************
\
\       Name: TIDY
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Orthonormalise the orientation vectors for a ship
\  Deep dive: Tidying orthonormal vectors
\             Orientation vectors
\
\ ------------------------------------------------------------------------------
\
\ This routine orthonormalises the orientation vectors for a ship. This means
\ making the three orientation vectors orthogonal (perpendicular to each other),
\ and normal (so each of the vectors has length 1).
\
\ We do this because we use the small angle approximation to rotate these
\ vectors in space. It is not completely accurate, so the three vectors tend
\ to get stretched over time, so periodically we tidy the vectors with this
\ routine to ensure they remain as orthonormal as possible.
\
\ ******************************************************************************

.TI2

                        \ Called from below with A = 0, X = 0, Y = 4 when
                        \ nosev_x and nosev_y are small, so we assume that
                        \ nosev_z is big

 TYA                    \ A = Y = 4
 LDY #2
 JSR TIS3               \ Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
 STA INWK+20            \ -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z

 JMP TI3                \ Jump to TI3 to keep tidying

.TI1

                        \ Called from below with A = 0, Y = 4 when nosev_x is
                        \ small

 TAX                    \ Set X = A = 0

 LDA XX15+1             \ Set A = nosev_y, and if the top two magnitude bits
 AND #%01100000         \ are both clear, jump to TI2 with A = 0, X = 0, Y = 4
 BEQ TI2

 LDA #2                 \ Otherwise nosev_y is big, so set up the index values
                        \ to pass to TIS3

 JSR TIS3               \ Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
 STA INWK+18            \ -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y

 JMP TI3                \ Jump to TI3 to keep tidying

.TIDY

 LDA INWK+10            \ Set (XX15, XX15+1, XX15+2) = nosev
 STA XX15
 LDA INWK+12
 STA XX15+1
 LDA INWK+14
 STA XX15+2

 JSR NORM               \ Call NORM to normalise the vector in XX15, i.e. nosev

 LDA XX15               \ Set nosev = (XX15, XX15+1, XX15+2)
 STA INWK+10
 LDA XX15+1
 STA INWK+12
 LDA XX15+2
 STA INWK+14

 LDY #4                 \ Set Y = 4

 LDA XX15               \ Set A = nosev_x, and if the top two magnitude bits
 AND #%01100000         \ are both clear, jump to TI1 with A = 0, Y = 4
 BEQ TI1

 LDX #2                 \ Otherwise nosev_x is big, so set up the index values
 LDA #0                 \ to pass to TIS3

 JSR TIS3               \ Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
 STA INWK+16            \ -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x

.TI3

 LDA INWK+16            \ Set (XX15, XX15+1, XX15+2) = roofv
 STA XX15
 LDA INWK+18
 STA XX15+1
 LDA INWK+20
 STA XX15+2

 JSR NORM               \ Call NORM to normalise the vector in XX15, i.e. roofv

 LDA XX15               \ Set roofv = (XX15, XX15+1, XX15+2)
 STA INWK+16
 LDA XX15+1
 STA INWK+18
 LDA XX15+2
 STA INWK+20

 LDA INWK+12            \ Set Q = nosev_y
 STA Q

 LDA INWK+20            \ Set A = roofv_z

 JSR MULT12             \ Set (S R) = Q * A = nosev_y * roofv_z

 LDX INWK+14            \ Set X = nosev_z

 LDA INWK+18            \ Set A = roofv_y

 JSR TIS1               \ Set (A ?) = (-X * A + (S R)) / 96
                        \        = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
                        \
                        \ This also sets Q = nosev_z

 EOR #%10000000         \ Set sidev_x = -A
 STA INWK+22            \        = (nosev_z * roofv_y - nosev_y * roofv_z) / 96

 LDA INWK+16            \ Set A = roofv_x

 JSR MULT12             \ Set (S R) = Q * A = nosev_z * roofv_x

 LDX INWK+10            \ Set X = nosev_x

 LDA INWK+20            \ Set A = roofv_z

 JSR TIS1               \ Set (A ?) = (-X * A + (S R)) / 96
                        \        = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
                        \
                        \ This also sets Q = nosev_x

 EOR #%10000000         \ Set sidev_y = -A
 STA INWK+24            \        = (nosev_x * roofv_z - nosev_z * roofv_x) / 96

 LDA INWK+18            \ Set A = roofv_y

 JSR MULT12             \ Set (S R) = Q * A = nosev_x * roofv_y

 LDX INWK+12            \ Set X = nosev_y

 LDA INWK+16            \ Set A = roofv_x

 JSR TIS1               \ Set (A ?) = (-X * A + (S R)) / 96
                        \        = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96

 EOR #%10000000         \ Set sidev_z = -A
 STA INWK+26            \        = (nosev_y * roofv_x - nosev_x * roofv_y) / 96

 LDA #0                 \ Set A = 0 so we can clear the low bytes of the
                        \ orientation vectors

 LDX #14                \ We want to clear the low bytes, so start from sidev_y
                        \ at byte #9+14 (we clear all except sidev_z_lo, though
                        \ I suspect this is in error and that X should be 16)

.TIL1

 STA INWK+9,X           \ Set the low byte in byte #9+X to zero

 DEX                    \ Set X = X - 2 to jump down to the next low byte
 DEX

 BPL TIL1               \ Loop back until we have zeroed all the low bytes

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TIS2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate A = A / Q
\  Deep dive: Shift-and-subtract division
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following division, where A is a sign-magnitude number and Q is
\ a positive integer:
\
\   A = A / Q
\
\ The value of A is returned as a sign-magnitude number with 96 representing 1,
\ and the maximum value returned is 1 (i.e. 96). This routine is used when
\ normalising vectors, where we represent fractions using integers, so this
\ gives us an approximation to two decimal places.
\
\ ******************************************************************************

.TIS2

 TAY                    \ Store the argument A in Y

 AND #%01111111         \ Strip the sign bit from the argument, so A = |A|

 CMP Q                  \ If A >= Q then jump to TI4 to return a 1 with the
 BCS TI4                \ correct sign

 LDX #%11111110         \ Set T to have bits 1-7 set, so we can rotate through 7
 STX T                  \ loop iterations, getting a 1 each time, and then
                        \ getting a 0 on the 8th iteration... and we can also
                        \ use T to catch our result bits into bit 0 each time

.TIL2

 ASL A                  \ Shift A to the left

 CMP Q                  \ If A < Q skip the following subtraction
 BCC P%+4

 SBC Q                  \ A >= Q, so set A = A - Q
                        \
                        \ Going into this subtraction we know the C flag is
                        \ set as we passed through the BCC above, and we also
                        \ know that A >= Q, so the C flag will still be set once
                        \ we are done

 ROL T                  \ Rotate the counter in T to the left, and catch the
                        \ result bit into bit 0 (which will be a 0 if we didn't
                        \ do the subtraction, or 1 if we did)

 BCS TIL2               \ If we still have set bits in T, loop back to TIL2 to
                        \ do the next iteration of 7

                        \ We've done the division and now have a result in the
                        \ range 0-255 here, which we need to reduce to the range
                        \ 0-96. We can do that by multiplying the result by 3/8,
                        \ as 256 * 3/8 = 96

 LDA T                  \ Set T = T / 4
 LSR A
 LSR A
 STA T

 LSR A                  \ Set T = T / 8 + T / 4
 ADC T                  \       = 3T / 8
 STA T

 TYA                    \ Fetch the sign bit of the original argument A
 AND #%10000000

 ORA T                  \ Apply the sign bit to T

 RTS                    \ Return from the subroutine

.TI4

 TYA                    \ Fetch the sign bit of the original argument A
 AND #%10000000

 ORA #96                \ Apply the sign bit to 96 (which represents 1)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TIS3
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following expression:
\
\   A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
\
\ where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
\ routine is called with the following values:
\
\   X = 0, Y = 2, A = 4 ->
\         A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
\
\   X = 0, Y = 4, A = 2 ->
\         A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
\
\   X = 2, Y = 4, A = 0 ->
\         A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
\
\ Arguments:
\
\   X                   Index 1 (0 = x, 2 = y, 4 = z)
\
\   Y                   Index 2 (0 = x, 2 = y, 4 = z)
\
\   A                   Index 3 (0 = x, 2 = y, 4 = z)
\
\ ******************************************************************************

.TIS3

 STA P+2                \ Store P+2 in A for later

 LDA INWK+10,X          \ Set Q = nosev_x_hi (plus X)
 STA Q

 LDA INWK+16,X          \ Set A = roofv_x_hi (plus X)

 JSR MULT12             \ Set (S R) = Q * A
                        \           = nosev_x_hi * roofv_x_hi

 LDX INWK+10,Y          \ Set Q = nosev_x_hi (plus Y)
 STX Q

 LDA INWK+16,Y          \ Set A = roofv_x_hi (plus Y)

 JSR MAD                \ Set (A X) = Q * A + (S R)
                        \           = (nosev_x,X * roofv_x,X) +
                        \             (nosev_x,Y * roofv_x,Y)

 STX P                  \ Store low byte of result in P, so result is now in
                        \ (A P)

 LDY P+2                \ Set Q = roofv_x_hi (plus argument A)
 LDX INWK+10,Y
 STX Q

 EOR #%10000000         \ Flip the sign of A

                        \ Fall through into DIVDT to do:
                        \
                        \   (P+1 A) = (A P) / Q
                        \
                        \     = -((nosev_x,X * roofv_x,X) +
                        \         (nosev_x,Y * roofv_x,Y))
                        \       / nosev_x,A

\ ******************************************************************************
\
\       Name: DVIDT
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (P+1 A) = (A P) / Q
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following integer division between sign-magnitude numbers:
\
\   (P+1 A) = (A P) / Q
\
\ This uses the same shift-and-subtract algorithm as TIS2.
\
\ ******************************************************************************

.DVIDT

 STA P+1                \ Set P+1 = A, so P(1 0) = (A P)

 EOR Q                  \ Set T = the sign bit of A EOR Q, so it's 1 if A and Q
 AND #%10000000         \ have different signs, i.e. it's the sign of the result
 STA T                  \ of A / Q

 LDA #0                 \ Set A = 0 for us to build a result

 LDX #16                \ Set a counter in X to count the 16 bits in P(1 0)

 ASL P                  \ Shift P(1 0) left
 ROL P+1

 ASL Q                  \ Clear the sign bit of Q the C flag at the same time
 LSR Q

.DVL2

 ROL A                  \ Shift A to the left

 CMP Q                  \ If A < Q skip the following subtraction
 BCC P%+4

 SBC Q                  \ Set A = A - Q
                        \
                        \ Going into this subtraction we know the C flag is
                        \ set as we passed through the BCC above, and we also
                        \ know that A >= Q, so the C flag will still be set once
                        \ we are done

 ROL P                  \ Rotate P(1 0) to the left, and catch the result bit
 ROL P+1                \ into the C flag (which will be a 0 if we didn't
                        \ do the subtraction, or 1 if we did)

 DEX                    \ Decrement the loop counter

 BNE DVL2               \ Loop back for the next bit until we have done all 16
                        \ bits of P(1 0)

 LDA P                  \ Set A = P so the low byte is in the result in A

 ORA T                  \ Set A to the correct sign bit that we set in T above

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\ Save ELTF.bin
\
\ ******************************************************************************

 PRINT "ELITE F"
 PRINT "Assembled at ", ~CODE_F%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_F%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_F%

 PRINT "S.2.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
\SAVE "3-assembled-output/2.ELTF.bin", CODE_F%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE G FILE
\
\ ******************************************************************************

 CODE_G% = P%
 LOAD_G% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: SHPPT
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw a distant ship as a point rather than a full wireframe
\
\ ******************************************************************************

.SHPPT

 JSR EE51               \ Call EE51 to remove the ship's wireframe from the
                        \ screen, if there is one

 JSR PROJ               \ Project the ship onto the screen, returning:
                        \
                        \   * K3(1 0) = the screen x-coordinate
                        \   * K4(1 0) = the screen y-coordinate
                        \   * A = K4+1

 ORA K3+1               \ If either of the high bytes of the screen coordinates
 BNE nono               \ are non-zero, jump to nono as the ship is off-screen

 LDA K4                 \ Set A = the y-coordinate of the dot

 CMP #Y*2-2             \ If the y-coordinate is bigger than the y-coordinate of
 BCS nono               \ the bottom of the screen, jump to nono as the ship's
                        \ dot is off the bottom of the space view

 LDY #2                 \ Call Shpt with Y = 2 to set up bytes 1-4 in the ship
 JSR Shpt               \ lines space, aborting the call to LL9 if the dot is
                        \ off the side of the screen. This call sets up the
                        \ first row of the dot (i.e. a four-pixel dash)

 LDY #6                 \ Set Y to 6 for the next call to Shpt

 LDA K4                 \ Set A = y-coordinate of dot + 1 (so this is the second
 ADC #1                 \ row of the two-pixel-high dot)

 JSR Shpt               \ Call Shpt with Y = 6 to set up bytes 5-8 in the ship
                        \ lines space, aborting the call to LL9 if the dot is
                        \ off the side of the screen. This call sets up the
                        \ second row of the dot (i.e. another four-pixel dash,
                        \ on the row below the first one)

 LDA #%00001000         \ Set bit 3 of the ship's byte #31 to record that we
 ORA XX1+31             \ have now drawn something on-screen for this ship
 STA XX1+31

 LDA #8                 \ Set A = 8 so when we call LL18+2 next, byte #0 of the
                        \ heap gets set to 8, for the 8 bytes we just stuck on
                        \ the heap

 JMP LL81+2             \ Call LL81+2 to draw the ship's dot, returning from the
                        \ subroutine using a tail call

 PLA                    \ Pull the return address from the stack, so the RTS
 PLA                    \ below actually returns from the subroutine that called
                        \ LL9 (as we called SHPPT from LL9 with a JMP)

.nono

 LDA #%11110111         \ Clear bit 3 of the ship's byte #31 to record that
 AND XX1+31             \ nothing is being drawn on-screen for this ship
 STA XX1+31

 RTS                    \ Return from the subroutine

.Shpt

                        \ This routine sets up four bytes in the ship line heap,
                        \ from byte Y-1 to byte Y+2. If the ship's screen point
                        \ turns out to be off-screen, then this routine aborts
                        \ the entire call to LL9, exiting via nono. The four
                        \ bytes define a horizontal 4-pixel dash, for either the
                        \ top or the bottom of the ship's dot

 STA (XX19),Y           \ Store A in byte Y of the ship line heap

 INY                    \ Store A in byte Y+2 of the ship line heap
 INY
 STA (XX19),Y

 LDA K3                 \ Set A = screen x-coordinate of the ship dot

 DEY                    \ Store A in byte Y+1 of the ship line heap
 STA (XX19),Y

 ADC #3                 \ Set A = screen x-coordinate of the ship dot + 3

 BCS nono-2             \ If the addition pushed the dot off the right side of
                        \ the screen, jump to nono-2 to return from the parent
                        \ subroutine early (i.e. LL9). This works because we
                        \ called Shpt from above with a JSR, so nono-2 removes
                        \ that return address from the stack, leaving the next
                        \ return address exposed. LL9 called SHPPT with a JMP.
                        \ so the next return address is the one that was put on
                        \ the stack by the original call to LL9. So the RTS in
                        \ nono will actually return us from the original call
                        \ to LL9, thus aborting the entire drawing process

 DEY                    \ Store A in byte Y-1 of the ship line heap
 DEY
 STA (XX19),Y

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL5
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate Q = SQRT(R Q)
\  Deep dive: Calculating square roots
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following square root:
\
\   Q = SQRT(R Q)
\
\ ******************************************************************************

.LL5

 LDY R                  \ Set (Y S) = (R Q)
 LDA Q
 STA S

                        \ So now to calculate Q = SQRT(Y S)

 LDX #0                 \ Set X = 0, to hold the remainder

 STX Q                  \ Set Q = 0, to hold the result

 LDA #8                 \ Set T = 8, to use as a loop counter
 STA T

.LL6

 CPX Q                  \ If X < Q, jump to LL7
 BCC LL7

 BNE LL8                \ If X > Q, jump to LL8

 CPY #64                \ If Y < 64, jump to LL7 with the C flag clear,
 BCC LL7                \ otherwise fall through into LL8 with the C flag set

.LL8

 TYA                    \ Set Y = Y - 64
 SBC #64                \
 TAY                    \ This subtraction will work as we know C is set from
                        \ the BCC above, and the result will not underflow as we
                        \ already checked that Y >= 64, so the C flag is also
                        \ set for the next subtraction

 TXA                    \ Set X = X - Q
 SBC Q
 TAX

.LL7

 ROL Q                  \ Shift the result in Q to the left, shifting the C flag
                        \ into bit 0 and bit 7 into the C flag

 ASL S                  \ Shift the dividend in (Y S) to the left, inserting
 TYA                    \ bit 7 from above into bit 0
 ROL A
 TAY

 TXA                    \ Shift the remainder in X to the left
 ROL A
 TAX

 ASL S                  \ Shift the dividend in (Y S) to the left
 TYA
 ROL A
 TAY

 TXA                    \ Shift the remainder in X to the left
 ROL A
 TAX

 DEC T                  \ Decrement the loop counter

 BNE LL6                \ Loop back to LL6 until we have done 8 loops

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL28
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate R = 256 * A / Q
\  Deep dive: Shift-and-subtract division
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following, where A < Q:
\
\   R = 256 * A / Q
\
\ This is a sister routine to LL61, which does the division when A >= Q.
\
\ If A >= Q then 255 is returned and the C flag is set to indicate an overflow
\ (the C flag is clear if the division was a success).
\
\ The result is returned in one byte as the result of the division multiplied
\ by 256, so we can return fractional results using integers.
\
\ This routine uses the same shift-and-subtract algorithm that's documented in
\ TIS2, but it leaves the fractional result in the integer range 0-255.
\
\ Returns:
\
\   C flag              Set if the answer is too big for one byte, clear if the
\                       division was a success
\
\ Other entry points:
\
\   LL28+4              Skips the A >= Q check and always returns with C flag
\                       cleared, so this can be called if we know the division
\                       will work
\
\   LL31                Skips the A >= Q check and does not set the R counter,
\                       so this can be used for jumping straight into the
\                       division loop if R is already set to 254 and we know the
\                       division will work
\
\ ******************************************************************************

.LL28

 CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
 BCS LL2                \ so jump to LL2 to return 255

 LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7
 STX R                  \ loop iterations, getting a 1 each time, and then
                        \ getting a 0 on the 8th iteration... and we can also
                        \ use R to catch our result bits into bit 0 each time

.LL31

 ASL A                  \ Shift A to the left

 BCS LL29               \ If bit 7 of A was set, then jump straight to the
                        \ subtraction

 CMP Q                  \ If A < Q, skip the following subtraction
 BCC P%+4

 SBC Q                  \ A >= Q, so set A = A - Q

 ROL R                  \ Rotate the counter in R to the left, and catch the
                        \ result bit into bit 0 (which will be a 0 if we didn't
                        \ do the subtraction, or 1 if we did)

 BCS LL31               \ If we still have set bits in R, loop back to LL31 to
                        \ do the next iteration of 7

 RTS                    \ R left with remainder of division

.LL29

 SBC Q                  \ A >= Q, so set A = A - Q

 SEC                    \ Set the C flag to rotate into the result in R

 ROL R                  \ Rotate the counter in R to the left, and catch the
                        \ result bit into bit 0 (which will be a 0 if we didn't
                        \ do the subtraction, or 1 if we did)

 BCS LL31               \ If we still have set bits in R, loop back to LL31 to
                        \ do the next iteration of 7

 RTS                    \ Return from the subroutine with R containing the
                        \ remainder of the division

.LL2

 LDA #255               \ The division is very close to 1, so return the closest
 STA R                  \ possible answer to 256, i.e. R = 255

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL38
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (S A) = (S R) + (A Q)
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following between sign-magnitude numbers:
\
\   (S A) = (S R) + (A Q)
\
\ where the sign bytes only contain the sign bits, not magnitudes.
\
\ Returns:
\
\   C flag              Set if the addition overflowed, clear otherwise
\
\ ******************************************************************************

.LL38

 EOR S                  \ If the sign of A * S is negative, skip to LL35, as
 BMI LL39               \ A and S have different signs so we need to subtract

 LDA Q                  \ Otherwise set A = R + Q, which is the result we need,
 CLC                    \ as S already contains the correct sign
 ADC R

 RTS                    \ Return from the subroutine

.LL39

 LDA R                  \ Set A = R - Q
 SEC
 SBC Q

 BCC P%+4               \ If the subtraction underflowed, skip the next two
                        \ instructions so we can negate the result

 CLC                    \ Otherwise the result is correct, and S contains the
                        \ correct sign of the result as R is the dominant side
                        \ of the subtraction, so clear the C flag

 RTS                    \ And return from the subroutine

                        \ If we get here we need to negate both the result and
                        \ the sign in S, as both are the wrong sign

 PHA                    \ Store the result of the subtraction on the stack

 LDA S                  \ Flip the sign of S
 EOR #%10000000
 STA S

 PLA                    \ Restore the subtraction result into A

 EOR #%11111111         \ Negate the result in A using two's complement, i.e.
 ADC #1                 \ set A = ~A + 1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL51
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the dot product of XX15 and XX16
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following dot products:
\
\   XX12(1 0) = XX15(5 0) . XX16(5 0)
\   XX12(3 2) = XX15(5 0) . XX16(11 6)
\   XX12(5 4) = XX15(5 0) . XX16(12 17)
\
\ storing the results as sign-magnitude numbers in XX12 through XX12+5.
\
\ When called from part 5 of LL9, XX12 contains the vector [x y z] to the ship
\ we're drawing, and XX16 contains the orientation vectors, so it returns:
\
\   [ x ]   [ sidev_x ]         [ x ]   [ roofv_x ]         [ x ]   [ nosev_x ]
\   [ y ] . [ sidev_y ]         [ y ] . [ roofv_y ]         [ y ] . [ nosev_y ]
\   [ z ]   [ sidev_z ]         [ z ]   [ roofv_z ]         [ z ]   [ nosev_z ]
\
\ When called from part 6 of LL9, XX12 contains the vector [x y z] of the vertex
\ we're analysing, and XX16 contains the transposed orientation vectors with
\ each of them containing the x, y and z elements of the original vectors, so it
\ returns:
\
\   [ x ]   [ sidev_x ]         [ x ]   [ sidev_y ]         [ x ]   [ sidev_z ]
\   [ y ] . [ roofv_x ]         [ y ] . [ roofv_y ]         [ y ] . [ roofv_z ]
\   [ z ]   [ nosev_x ]         [ z ]   [ nosev_y ]         [ z ]   [ nosev_z ]
\
\ Arguments:
\
\   XX15(1 0)           The ship (or vertex)'s x-coordinate as (x_sign x_lo)
\
\   XX15(3 2)           The ship (or vertex)'s y-coordinate as (y_sign y_lo)
\
\   XX15(5 4)           The ship (or vertex)'s z-coordinate as (z_sign z_lo)
\
\   XX16 to XX16+5      The scaled sidev (or _x) vector, with:
\
\                         * x, y, z magnitudes in XX16, XX16+2, XX16+4
\
\                         * x, y, z signs in XX16+1, XX16+3, XX16+5
\
\   XX16+6 to XX16+11   The scaled roofv (or _y) vector, with:
\
\                         * x, y, z magnitudes in XX16+6, XX16+8, XX16+10
\
\                         * x, y, z signs in XX16+7, XX16+9, XX16+11
\
\   XX16+12 to XX16+17  The scaled nosev (or _z) vector, with:
\
\                         * x, y, z magnitudes in XX16+12, XX16+14, XX16+16
\
\                         * x, y, z signs in XX16+13, XX16+15, XX16+17
\
\ Returns:
\
\   XX12(1 0)           The dot product of [x y z] vector with the sidev (or _x)
\                       vector, with the sign in XX12+1 and magnitude in XX12
\
\   XX12(3 2)           The dot product of [x y z] vector with the roofv (or _y)
\                       vector, with the sign in XX12+3 and magnitude in XX12+2
\
\   XX12(5 4)           The dot product of [x y z] vector with the nosev (or _z)
\                       vector, with the sign in XX12+5 and magnitude in XX12+4
\
\ ******************************************************************************

.LL51

 LDX #0                 \ Set X = 0, which will contain the offset of the vector
                        \ to use in the calculation, increasing by 6 for each
                        \ new vector

 LDY #0                 \ Set Y = 0, which will contain the offset of the
                        \ result bytes in XX12, increasing by 2 for each new
                        \ result

.ll51

 LDA XX15               \ Set Q = x_lo
 STA Q

 LDA XX16,X             \ Set A = |sidev_x|

 JSR FMLTU              \ Set T = A * Q / 256
 STA T                  \       = |sidev_x| * x_lo / 256

 LDA XX15+1             \ Set S to the sign of x_sign * sidev_x
 EOR XX16+1,X
 STA S

 LDA XX15+2             \ Set Q = y_lo
 STA Q

 LDA XX16+2,X           \ Set A = |sidev_y|

 JSR FMLTU              \ Set Q = A * Q / 256
 STA Q                  \       = |sidev_y| * y_lo / 256

 LDA T                  \ Set R = T
 STA R                  \       = |sidev_x| * x_lo / 256

 LDA XX15+3             \ Set A to the sign of y_sign * sidev_y
 EOR XX16+3,X

 JSR LL38               \ Set (S T) = (S R) + (A Q)
 STA T                  \           = |sidev_x| * x_lo + |sidev_y| * y_lo

 LDA XX15+4             \ Set Q = z_lo
 STA Q

 LDA XX16+4,X           \ Set A = |sidev_z|

 JSR FMLTU              \ Set Q = A * Q / 256
 STA Q                  \       = |sidev_z| * z_lo / 256

 LDA T                  \ Set R = T
 STA R                  \       = |sidev_x| * x_lo + |sidev_y| * y_lo

 LDA XX15+5             \ Set A to the sign of z_sign * sidev_z
 EOR XX16+5,X

 JSR LL38               \ Set (S A) = (S R) + (A Q)
                        \           = |sidev_x| * x_lo + |sidev_y| * y_lo
                        \             + |sidev_z| * z_lo

 STA XX12,Y             \ Store the result in XX12+Y(1 0)
 LDA S
 STA XX12+1,Y

 INY                    \ Set Y = Y + 2
 INY

 TXA                    \ Set X = X + 6
 CLC
 ADC #6
 TAX

 CMP #17                \ If X < 17, loop back to ll51 for the next vector
 BCC ll51

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL9 (Part 1 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Check if ship is exploding, check if ship is in front
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This routine draws the current ship on the screen. This part checks to see if
\ the ship is exploding, or if it should start exploding, and if it does it sets
\ things up accordingly.
\
\ It also does some basic checks to see if we can see the ship, and if not it
\ removes it from the screen.
\
\ In this code, XX1 is used to point to the current ship's data block at INWK
\ (the two labels are interchangeable).
\
\ Arguments:
\
\   XX1                 XX1 shares its location with INWK, which contains the
\                       zero-page copy of the data block for this ship from the
\                       K% workspace
\
\   INF                 The address of the data block for this ship in workspace
\                       K%
\
\   XX19(1 0)           XX19(1 0) shares its location with INWK(34 33), which
\                       contains the ship line heap address pointer
\
\   XX0                 The address of the blueprint for this ship
\
\ Other entry points:
\
\   EE51                Remove the current ship from the screen, called from
\                       SHPPT before drawing the ship as a point
\
\ ******************************************************************************

.LL9

 LDA #31                \ Set XX4 = 31 to store the ship's distance for later
 STA XX4                \ comparison with the visibility distance. We will
                        \ update this value below with the actual ship's
                        \ distance if it turns out to be visible on-screen

 LDA NEWB               \ If bit 7 of the ship's NEWB flags is set, then the
 BMI EE51               \ ship has been scooped or has docked, so jump down to
                        \ EE51 to redraw its wireframe, to remove it from the
                        \ screen

 LDA #%00100000         \ If bit 5 of the ship's byte #31 is set, then the ship
 BIT XX1+31             \ is currently exploding, so jump down to EE28
 BNE EE28

 BPL EE28               \ If bit 7 of the ship's byte #31 is clear then the ship
                        \ has not just been killed, so jump down to EE28

                        \ Otherwise bit 5 is clear and bit 7 is set, so the ship
                        \ is not yet exploding but it has been killed, so we
                        \ need to start an explosion

 ORA XX1+31             \ Clear bits 6 and 7 of the ship's byte #31, to stop the
 AND #%00111111         \ ship from firing its laser and to mark it as no longer
 STA XX1+31             \ having just been killed

 LDA #0                 \ Set the ship's acceleration in byte #31 to 0, updating
 LDY #28                \ the byte in the workspace K% data block so we don't
 STA (INF),Y            \ have to copy it back from INWK later

 LDY #30                \ Set the ship's pitch counter in byte #30 to 0, to stop
 STA (INF),Y            \ the ship from pitching

 JSR EE51               \ Call EE51 to remove the ship from the screen

                        \ We now need to set up a new explosion cloud. We
                        \ initialise it with a size of 18 (which gets increased
                        \ by 4 every time the cloud gets redrawn), and the
                        \ explosion count (i.e. the number of particles in the
                        \ explosion), which go into bytes 1 and 2 of the ship
                        \ line heap. See DOEXP for more details of explosion
                        \ clouds

 LDY #1                 \ Set byte #1 of the ship line heap to 18, the initial
 LDA #18                \ size of the explosion cloud
 STA (XX19),Y

 LDY #7                 \ Fetch byte #7 from the ship's blueprint, which
 LDA (XX0),Y            \ determines the explosion count (i.e. the number of
 LDY #2                 \ vertices used as origins for explosion clouds), and
 STA (XX19),Y           \ store it in byte #2 of the ship line heap

                        \ The following loop sets bytes 3-6 of the of the ship
                        \ line heap to random numbers

.EE55

 INY                    \ Increment Y (so the loop starts at 3)

 JSR DORND              \ Set A and X to random numbers

 STA (XX19),Y           \ Store A in the Y-th byte of the ship line heap

 CPY #6                 \ Loop back until we have randomised the 6th byte
 BNE EE55

.EE28

 LDA XX1+8              \ Set A = z_sign

.EE49

 BPL LL10               \ If A is positive, i.e. the ship is in front of us,
                        \ jump down to LL10

.LL14

                        \ The following removes the ship from the screen by
                        \ redrawing it (or, if it is exploding, by redrawing the
                        \ explosion cloud). We call it when the ship is no
                        \ longer on-screen, is too far away to be fully drawn,
                        \ and so on

 LDA XX1+31             \ If bit 5 of the ship's byte #31 is clear, then the
 AND #%00100000         \ ship is not currently exploding, so jump down to EE51
 BEQ EE51               \ to redraw its wireframe

 LDA XX1+31             \ The ship is exploding, so clear bit 3 of the ship's
 AND #%11110111         \ byte #31 to denote that the ship is no longer being
 STA XX1+31             \ drawn on-screen

 JMP DOEXP              \ Jump to DOEXP to display the explosion cloud, which
                        \ will remove it from the screen, returning from the
                        \ subroutine using a tail call

.EE51

 LDA #%00001000         \ If bit 3 of the ship's byte #31 is clear, then there
 BIT XX1+31             \ is already nothing being shown for this ship, so
 BEQ LL10-1             \ return from the subroutine (as LL10-1 contains an RTS)

 EOR XX1+31             \ Otherwise flip bit 3 of byte #31 and store it (which
 STA XX1+31             \ clears bit 3 as we know it was set before the EOR), so
                        \ this sets this ship as no longer being drawn on-screen

 JMP LL155              \ Jump to LL155 to draw the ship, which removes it from
                        \ the screen, returning from the subroutine using a
                        \ tail call

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL9 (Part 2 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Check if ship is in field of view, close enough to draw
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This part checks whether the ship is in our field of view, and whether it is
\ close enough to be fully drawn (if not, we jump to SHPPT to draw it as a dot).
\
\ Other entry points:
\
\   LL10-1              Contains an RTS
\
\ ******************************************************************************

.LL10

 LDA XX1+7              \ Set A = z_hi

 CMP #192               \ If A >= 192 then the ship is a long way away, so jump
 BCS LL14               \ to LL14 to remove the ship from the screen

 LDA XX1                \ If x_lo >= z_lo, set the C flag, otherwise clear it
 CMP XX1+6

 LDA XX1+1              \ Set A = x_hi - z_hi using the carry from the low
 SBC XX1+7              \ bytes, which sets the C flag as if we had done a full
                        \ two-byte subtraction (x_hi x_lo) - (z_hi z_lo)

 BCS LL14               \ If the C flag is set then x >= z, so the ship is
                        \ further to the side than it is in front of us, so it's
                        \ outside our viewing angle of 45 degrees, and we jump
                        \ to LL14 to remove it from the screen

 LDA XX1+3              \ If y_lo >= z_lo, set the C flag, otherwise clear it
 CMP XX1+6

 LDA XX1+4              \ Set A = y_hi - z_hi using the carry from the low
 SBC XX1+7              \ bytes, which sets the C flag as if we had done a full
                        \ two-byte subtraction (y_hi y_lo) - (z_hi z_lo)

 BCS LL14               \ If the C flag is set then y >= z, so the ship is
                        \ further above us than it is in front of us, so it's
                        \ outside our viewing angle of 45 degrees, and we jump
                        \ to LL14 to remove it from the screen

 LDY #6                 \ Fetch byte #6 from the ship's blueprint into X, which
 LDA (XX0),Y            \ is the number * 4 of the vertex used for the ship's
 TAX                    \ laser

 LDA #255               \ Set bytes X and X+1 of the XX3 heap to 255. We're
 STA XX3,X              \ going to use XX3 to store the screen coordinates of
 STA XX3+1,X            \ all the visible vertices of this ship, so setting the
                        \ laser vertex to 255 means that if we don't update this
                        \ vertex with its screen coordinates in parts 6 and 7,
                        \ this vertex's entry in the XX3 heap will still be 255,
                        \ which we can check in part 9 to see if the laser
                        \ vertex is visible (and therefore whether we should
                        \ draw laser lines if the ship is firing on us)

 LDA XX1+6              \ Set (A T) = (z_hi z_lo)
 STA T
 LDA XX1+7

 LSR A                  \ Set (A T) = (A T) / 8
 ROR T
 LSR A
 ROR T
 LSR A
 ROR T

 LSR A                  \ If A >> 4 is non-zero, i.e. z_hi >= 16, jump to LL13
 BNE LL13               \ as the ship is possibly far away enough to be shown as
                        \ a dot

 LDA T                  \ Otherwise the C flag contains the previous bit 0 of A,
 ROR A                  \ which could have been set, so rotate A right four
 LSR A                  \ times so it's in the form %000xxxxx, i.e. z_hi reduced
 LSR A                  \ to a maximum value of 31
 LSR A

 STA XX4                \ Store A in XX4, which is now the distance of the ship
                        \ we can use for visibility testing

 BPL LL17               \ Jump down to LL17 (this BPL is effectively a JMP as we
                        \ know bit 7 of A is definitely clear)

.LL13

                        \ If we get here then the ship is possibly far enough
                        \ away to be shown as a dot

 LDY #13                \ Fetch byte #13 from the ship's blueprint, which gives
 LDA (XX0),Y            \ the ship's visibility distance, beyond which we show
                        \ the ship as a dot

 CMP XX1+7              \ If z_hi <= the visibility distance, skip to LL17 to
 BCS LL17               \ draw the ship fully, rather than as a dot, as it is
                        \ closer than the visibility distance

 LDA #%00100000         \ If bit 5 of the ship's byte #31 is set, then the
 AND XX1+31             \ ship is currently exploding, so skip to LL17 to draw
 BNE LL17               \ the ship's explosion cloud

 JMP SHPPT              \ Otherwise jump to SHPPT to draw the ship as a dot,
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: LL9 (Part 3 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Set up orientation vector, ship coordinate variables
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This part sets up the following variable blocks:
\
\   * XX16 contains the orientation vectors, divided to normalise them
\
\   * XX18 contains the ship's x, y and z coordinates in space
\
\ ******************************************************************************

.LL17

 LDX #5                 \ First we copy the three orientation vectors into XX16,
                        \ so set up a counter in X for the 6 bytes in each
                        \ vector

.LL15

 LDA XX1+21,X           \ Copy the X-th byte of sidev to the X-th byte of XX16
 STA XX16,X

 LDA XX1+15,X           \ Copy the X-th byte of roofv to XX16+6 to the X-th byte
 STA XX16+6,X           \ of XX16+6

 LDA XX1+9,X            \ Copy the X-th byte of nosev to XX16+12 to the X-th
 STA XX16+12,X          \ byte of XX16+12

 DEX                    \ Decrement the counter

 BPL LL15               \ Loop back to copy the next byte of each vector, until
                        \ we have the following:
                        \
                        \   * XX16(1 0) = sidev_x
                        \   * XX16(3 2) = sidev_y
                        \   * XX16(5 4) = sidev_z
                        \
                        \   * XX16(7 6) = roofv_x
                        \   * XX16(9 8) = roofv_y
                        \   * XX16(11 10) = roofv_z
                        \
                        \   * XX16(13 12) = nosev_x
                        \   * XX16(15 14) = nosev_y
                        \   * XX16(17 16) = nosev_z

 LDA #197               \ Set Q = 197
 STA Q

 LDY #16                \ Set Y to be a counter that counts down by 2 each time,
                        \ starting with 16, then 14, 12 and so on. We use this
                        \ to work through each of the coordinates in each of the
                        \ orientation vectors

.LL21

 LDA XX16,Y             \ Set A = the low byte of the vector coordinate, e.g.
                        \ nosev_z_lo when Y = 16

 ASL A                  \ Shift bit 7 into the C flag

 LDA XX16+1,Y           \ Set A = the high byte of the vector coordinate, e.g.
                        \ nosev_z_hi when Y = 16

 ROL A                  \ Rotate A left, incorporating the C flag, so A now
                        \ contains the original high byte, doubled, and without
                        \ a sign bit, e.g. A = |nosev_z_hi| * 2

 JSR LL28               \ Call LL28 to calculate:
                        \
                        \   R = 256 * A / Q
                        \
                        \ so, for nosev, this would be:
                        \
                        \   R = 256 * |nosev_z_hi| * 2 / 197
                        \     = 2.6 * |nosev_z_hi|

 LDX R                  \ Store R in the low byte's location, so we can keep the
 STX XX16,Y             \ old, unscaled high byte intact for the sign

 DEY                    \ Decrement the loop counter twice
 DEY

 BPL LL21               \ Loop back for the next vector coordinate until we have
                        \ divided them all

                        \ By this point, the vectors have been turned into
                        \ scaled magnitudes, so we have the following:
                        \
                        \   * XX16   = scaled |sidev_x|
                        \   * XX16+2 = scaled |sidev_y|
                        \   * XX16+4 = scaled |sidev_z|
                        \
                        \   * XX16+6  = scaled |roofv_x|
                        \   * XX16+8  = scaled |roofv_y|
                        \   * XX16+10 = scaled |roofv_z|
                        \
                        \   * XX16+12 = scaled |nosev_x|
                        \   * XX16+14 = scaled |nosev_y|
                        \   * XX16+16 = scaled |nosev_z|

 LDX #8                 \ Next we copy the ship's coordinates into XX18, so set
                        \ up a counter in X for 9 bytes

.ll91

 LDA XX1,X              \ Copy the X-th byte from XX1 to XX18
 STA XX18,X

 DEX                    \ Decrement the loop counter

 BPL ll91               \ Loop back for the next byte until we have copied all
                        \ three coordinates

                        \ So we now have the following:
                        \
                        \   * XX18(2 1 0) = (x_sign x_hi x_lo)
                        \
                        \   * XX18(5 4 3) = (y_sign y_hi y_lo)
                        \
                        \   * XX18(8 7 6) = (z_sign z_hi z_lo)

 LDA #255               \ Set the 15th byte of XX2 to 255, so that face 15 is
 STA XX2+15             \ always visible. No ship definitions actually have this
                        \ number of faces in the cassette version, but this
                        \ allows us to force a vertex to always be visible by
                        \ associating it with face 15 (see the blueprints for
                        \ the Cobra Mk III at SHIP_COBRA_MK_3 and asteroid at
                        \ SHIP_ASTEROID for examples)

 LDY #12                \ Set Y = 12 to point to the ship blueprint byte #12,

 LDA XX1+31             \ If bit 5 of the ship's byte #31 is clear, then the
 AND #%00100000         \ ship is not currently exploding, so jump down to EE29
 BEQ EE29               \ to skip the following

                        \ Otherwise we fall through to set up the visibility
                        \ block for an exploding ship

\ ******************************************************************************
\
\       Name: LL9 (Part 4 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Set visibility for exploding ship (all faces visible)
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This part sets up the visibility block in XX2 for a ship that is exploding.
\
\ The XX2 block consists of one byte for each face in the ship's blueprint,
\ which holds the visibility of that face. Because the ship is exploding, we
\ want to set all the faces to be visible. A value of 255 in the visibility
\ table means the face is visible, so the following code sets each face to 255
\ and then skips over the face visibility calculations that we would apply to a
\ non-exploding ship.
\
\ ******************************************************************************

 LDA (XX0),Y            \ Fetch byte #12 of the ship's blueprint, which contains
                        \ the number of faces * 4

 LSR A                  \ Set X = A / 4
 LSR A                  \       = the number of faces
 TAX

 LDA #255               \ Set A = 255

.EE30

 STA XX2,X              \ Set the X-th byte of XX2 to 255

 DEX                    \ Decrement the loop counter

 BPL EE30               \ Loop back for the next byte until there is one byte
                        \ set to 255 for each face

 INX                    \ Set XX4 = 0 for the distance value we use to test
 STX XX4                \ for visibility, so we always shows everything

.LL41

 JMP LL42               \ Jump to LL42 to skip the face visibility calculations
                        \ as we don't need to do them now we've set up the XX2
                        \ block for the explosion

\ ******************************************************************************
\
\       Name: LL9 (Part 5 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Calculate the visibility of each of the ship's faces
\  Deep dive: Drawing ships
\             Back-face culling
\
\ ******************************************************************************

.EE29

 LDA (XX0),Y            \ We set Y to 12 above before jumping down to EE29, so
                        \ this fetches byte #12 of the ship's blueprint, which
                        \ contains the number of faces * 4

 BEQ LL41               \ If there are no faces in this ship, jump to LL42 (via
                        \ LL41) to skip the face visibility calculations

 STA XX20               \ Set A = the number of faces * 4

 LDY #18                \ Fetch byte #18 of the ship's blueprint, which contains
 LDA (XX0),Y            \ the factor by which we scale the face normals, into X
 TAX

 LDA XX18+7             \ Set A = z_hi

.LL90

 TAY                    \ Set Y = z_hi

 BEQ LL91               \ If z_hi = 0 then jump to LL91

                        \ The following is a loop that jumps back to LL90+3,
                        \ i.e. here. LL90 is only used for this loop, so it's a
                        \ bit of a strange use of the label here

 INX                    \ Increment the scale factor in X

 LSR XX18+4             \ Divide (y_hi y_lo) by 2
 ROR XX18+3

 LSR XX18+1             \ Divide (x_hi x_lo) by 2
 ROR XX18

 LSR A                  \ Divide (z_hi z_lo) by 2 (as A contains z_hi)
 ROR XX18+6

 TAY                    \ Set Y = z_hi

 BNE LL90+3             \ If Y is non-zero, loop back to LL90+3 to divide the
                        \ three coordinates until z_hi is 0

.LL91

                        \ By this point z_hi is 0 and X contains the number of
                        \ right shifts we had to do, plus the scale factor from
                        \ the blueprint

 STX XX17               \ Store the updated scale factor in XX17

 LDA XX18+8             \ Set XX15+5 = z_sign
 STA XX15+5

 LDA XX18               \ Set XX15(1 0) = (x_sign x_lo)
 STA XX15
 LDA XX18+2
 STA XX15+1

 LDA XX18+3             \ Set XX15(3 2) = (y_sign y_lo)
 STA XX15+2
 LDA XX18+5
 STA XX15+3

 LDA XX18+6             \ Set XX15+4 = z_lo, so now XX15(5 4) = (z_sign z_lo)
 STA XX15+4

 JSR LL51               \ Call LL51 to set XX12 to the dot products of XX15 and
                        \ XX16, which we'll call dot_sidev, dot_roofv and
                        \ dot_nosev:
                        \
                        \   XX12(1 0) = [x y z] . sidev
                        \             = (dot_sidev_sign dot_sidev_lo)
                        \             = dot_sidev
                        \
                        \   XX12(3 2) = [x y z] . roofv
                        \             = (dot_roofv_sign dot_roofv_lo)
                        \             = dot_roofv
                        \
                        \   XX12(5 4) = [x y z] . nosev
                        \             = (dot_nosev_sign dot_nosev_lo)
                        \             = dot_nosev

 LDA XX12               \ Set XX18(2 0) = dot_sidev
 STA XX18
 LDA XX12+1
 STA XX18+2

 LDA XX12+2             \ Set XX18(5 3) = dot_roofv
 STA XX18+3
 LDA XX12+3
 STA XX18+5

 LDA XX12+4             \ Set XX18(8 6) = dot_nosev
 STA XX18+6
 LDA XX12+5
 STA XX18+8

 LDY #4                 \ Fetch byte #4 of the ship's blueprint, which contains
 LDA (XX0),Y            \ the low byte of the offset to the faces data

 CLC                    \ Set V = low byte faces offset + XX0
 ADC XX0
 STA V

 LDY #17                \ Fetch byte #17 of the ship's blueprint, which contains
 LDA (XX0),Y            \ the high byte of the offset to the faces data

 ADC XX0+1              \ Set V+1 = high byte faces offset + XX0+1
 STA V+1                \
                        \ So V(1 0) now points to the start of the faces data
                        \ for this ship

 LDY #0                 \ We're now going to loop through all the faces for this
                        \ ship, so set a counter in Y, starting from 0, which we
                        \ will increment by 4 each loop to step through the
                        \ four bytes of data for each face

.LL86

 LDA (V),Y              \ Fetch byte #0 for this face into A, so:
                        \
                        \   A = %xyz vvvvv, where:
                        \
                        \     * Bits 0-4 = visibility distance, beyond which the
                        \       face is always shown
                        \
                        \     * Bits 7-5 = the sign bits of normal_x, normal_y
                        \       and normal_z

 STA XX12+1             \ Store byte #0 in XX12+1, so XX12+1 now has the sign of
                        \ normal_x

 AND #%00011111         \ Extract bits 0-4 to give the visibility distance

 CMP XX4                \ If XX4 <= the visibility distance, where XX4 contains
 BCS LL87               \ the ship's z-distance reduced to 0-31 (which we set in
                        \ part 2), skip to LL87 as this face is close enough
                        \ that we have to test its visibility using the face
                        \ normals

                        \ Otherwise this face is within range and is therefore
                        \ always shown

 TYA                    \ Set X = Y / 4
 LSR A                  \       = the number of this face * 4 /4
 LSR A                  \       = the number of this face
 TAX

 LDA #255               \ Set the X-th byte of XX2 to 255 to denote that this
 STA XX2,X              \ face is visible

 TYA                    \ Set Y = Y + 4 to point to the next face
 ADC #4
 TAY

 JMP LL88               \ Jump down to LL88 to skip the following, as we don't
                        \ need to test the face normals

.LL87

 LDA XX12+1             \ Fetch byte #0 for this face into A

 ASL A                  \ Shift A left and store it, so XX12+3 now has the sign
 STA XX12+3             \ of normal_y

 ASL A                  \ Shift A left and store it, so XX12+5 now has the sign
 STA XX12+5             \ of normal_z

 INY                    \ Increment Y to point to byte #1

 LDA (V),Y              \ Fetch byte #1 for this face and store in XX12, so
 STA XX12               \ XX12 = normal_x

 INY                    \ Increment Y to point to byte #2

 LDA (V),Y              \ Fetch byte #2 for this face and store in XX12+2, so
 STA XX12+2             \ XX12+2 = normal_y

 INY                    \ Increment Y to point to byte #3

 LDA (V),Y              \ Fetch byte #3 for this face and store in XX12+4, so
 STA XX12+4             \ XX12+4 = normal_z

                        \ So we now have:
                        \
                        \   XX12(1 0) = (normal_x_sign normal_x)
                        \
                        \   XX12(3 2) = (normal_y_sign normal_y)
                        \
                        \   XX12(5 4) = (normal_z_sign normal_z)

 LDX XX17               \ If XX17 < 4 then jump to LL92, otherwise we stored a
 CPX #4                 \ larger scale factor above
 BCC LL92

.LL143

 LDA XX18               \ Set XX15(1 0) = XX18(2 0)
 STA XX15               \               = dot_sidev
 LDA XX18+2
 STA XX15+1

 LDA XX18+3             \ Set XX15(3 2) = XX18(5 3)
 STA XX15+2             \               = dot_roofv
 LDA XX18+5
 STA XX15+3

 LDA XX18+6             \ Set XX15(5 4) = XX18(8 6)
 STA XX15+4             \               = dot_nosev
 LDA XX18+8
 STA XX15+5

 JMP LL89               \ Jump down to LL89

.ovflw

                        \ If we get here then the addition below overflowed, so
                        \ we halve the dot products and normal vector

 LSR XX18               \ Divide dot_sidev_lo by 2, so dot_sidev = dot_sidev / 2

 LSR XX18+6             \ Divide dot_nosev_lo by 2, so dot_nosev = dot_nosev / 2

 LSR XX18+3             \ Divide dot_roofv_lo by 2, so dot_roofv = dot_roofv / 2

 LDX #1                 \ Set X = 1 so when we fall through into LL92, we divide
                        \ the normal vector by 2 as well

.LL92

                        \ We jump here from above with the scale factor in X,
                        \ and now we apply it by scaling the normal vector down
                        \ by a factor of 2^X (i.e. divide by 2^X)

 LDA XX12               \ Set XX15 = normal_x
 STA XX15

 LDA XX12+2             \ Set XX15+2 = normal_y
 STA XX15+2

 LDA XX12+4             \ Set A = normal_z

.LL93

 DEX                    \ Decrement the scale factor in X

 BMI LL94               \ If X was 0 before the decrement, there is no scaling
                        \ to do, so jump to LL94 to exit the loop

 LSR XX15               \ Set XX15 = XX15 / 2
                        \          = normal_x / 2

 LSR XX15+2             \ Set XX15+2 = XX15+2 / 2
                        \            = normal_y / 2

 LSR A                  \ Set A = A / 2
                        \       = normal_z / 2

 DEX                    \ Decrement the scale factor in X

 BPL LL93+3             \ If we have more scaling to do, loop back up to the
                        \ first LSR above until the normal vector is scaled down

.LL94

 STA R                  \ Set R = normal_z

 LDA XX12+5             \ Set S = normal_z_sign
 STA S

 LDA XX18+6             \ Set Q = dot_nosev_lo
 STA Q

 LDA XX18+8             \ Set A = dot_nosev_sign

 JSR LL38               \ Set (S A) = (S R) + (A Q)
                        \           = normal_z + dot_nosev
                        \
                        \ setting the sign of the result in S

 BCS ovflw              \ If the addition overflowed, jump up to ovflw to divide
                        \ both the normal vector and dot products by 2 and try
                        \ again

 STA XX15+4             \ Set XX15(5 4) = (S A)
 LDA S                  \               = normal_z + dot_nosev
 STA XX15+5

 LDA XX15               \ Set R = normal_x
 STA R

 LDA XX12+1             \ Set S = normal_x_sign
 STA S

 LDA XX18               \ Set Q = dot_sidev_lo
 STA Q

 LDA XX18+2             \ Set A = dot_sidev_sign

 JSR LL38               \ Set (S A) = (S R) + (A Q)
                        \           = normal_x + dot_sidev
                        \
                        \ setting the sign of the result in S

 BCS ovflw              \ If the addition overflowed, jump up to ovflw to divide
                        \ both the normal vector and dot products by 2 and try
                        \ again

 STA XX15               \ Set XX15(1 0) = (S A)
 LDA S                  \               = normal_x + dot_sidev
 STA XX15+1

 LDA XX15+2             \ Set R = normal_y
 STA R

 LDA XX12+3             \ Set S = normal_y_sign
 STA S

 LDA XX18+3             \ Set Q = dot_roofv_lo
 STA Q

 LDA XX18+5             \ Set A = dot_roofv_sign

 JSR LL38               \ Set (S A) = (S R) + (A Q)
                        \           = normal_y + dot_roofv

 BCS ovflw              \ If the addition overflowed, jump up to ovflw to divide
                        \ both the normal vector and dot products by 2 and try
                        \ again

 STA XX15+2             \ Set XX15(3 2) = (S A)
 LDA S                  \               = normal_y + dot_roofv
 STA XX15+3

.LL89

                        \ When we get here, we have set up the following:
                        \
                        \   XX15(1 0) = normal_x + dot_sidev
                        \             = normal_x + [x y z] . sidev
                        \
                        \   XX15(3 2) = normal_y + dot_roofv
                        \             = normal_y + [x y z] . roofv
                        \
                        \   XX15(5 4) = normal_z + dot_nosev
                        \             = normal_z + [x y z] . nosev
                        \
                        \ and:
                        \
                        \   XX12(1 0) = (normal_x_sign normal_x)
                        \
                        \   XX12(3 2) = (normal_y_sign normal_y)
                        \
                        \   XX12(5 4) = (normal_z_sign normal_z)
                        \
                        \ We now calculate the dot product XX12 . XX15 to tell
                        \ us whether or not this face is visible

 LDA XX12               \ Set Q = XX12
 STA Q

 LDA XX15               \ Set A = XX15

 JSR FMLTU              \ Set T = A * Q / 256
 STA T                  \       = XX15 * XX12 / 256

 LDA XX12+1             \ Set S = sign of XX15(1 0) * XX12(1 0), so:
 EOR XX15+1             \
 STA S                  \   (S T) = XX15(1 0) * XX12(1 0) / 256

 LDA XX12+2             \ Set Q = XX12+2
 STA Q

 LDA XX15+2             \ Set A = XX15+2

 JSR FMLTU              \ Set Q = A * Q
 STA Q                  \       = XX15+2 * XX12+2 / 256

 LDA T                  \ Set T = R, so now:
 STA R                  \
                        \   (S R) = XX15(1 0) * XX12(1 0) / 256

 LDA XX12+3             \ Set A = sign of XX15+3 * XX12+3, so:
 EOR XX15+3             \
                        \   (A Q) = XX15(3 2) * XX12(3 2) / 256

 JSR LL38               \ Set (S T) = (S R) + (A Q)
 STA T                  \           =   XX15(1 0) * XX12(1 0) / 256
                        \             + XX15(3 2) * XX12(3 2) / 256

 LDA XX12+4             \ Set Q = XX12+4
 STA Q

 LDA XX15+4             \ Set A = XX15+4

 JSR FMLTU              \ Set Q = A * Q
 STA Q                  \       = XX15+4 * XX12+4 / 256

 LDA T                  \ Set T = R, so now:
 STA R                  \
                        \   (S R) =   XX15(1 0) * XX12(1 0) / 256
                        \           + XX15(3 2) * XX12(3 2) / 256

 LDA XX15+5             \ Set A = sign of XX15+5 * XX12+5, so:
 EOR XX12+5             \
                        \   (A Q) = XX15(5 4) * XX12(5 4) / 256

 JSR LL38               \ Set (S A) = (S R) + (A Q)
                        \           =   XX15(1 0) * XX12(1 0) / 256
                        \             + XX15(3 2) * XX12(3 2) / 256
                        \             + XX15(5 4) * XX12(5 4) / 256

 PHA                    \ Push the result A onto the stack, so the stack now
                        \ contains the dot product XX12 . XX15

 TYA                    \ Set X = Y / 4
 LSR A                  \       = the number of this face * 4 /4
 LSR A                  \       = the number of this face
 TAX

 PLA                    \ Pull the dot product off the stack into A

 BIT S                  \ If bit 7 of S is set, i.e. the dot product is
 BMI P%+4               \ negative, then this face is visible as its normal is
                        \ pointing towards us, so skip the following instruction

 LDA #0                 \ Otherwise the face is not visible, so set A = 0 so we
                        \ can store this to mean "not visible"

 STA XX2,X              \ Store the face's visibility in the X-th byte of XX2

 INY                    \ Above we incremented Y to point to byte #3, so this
                        \ increments Y to point to byte #4, i.e. byte #0 of the
                        \ next face

.LL88

 CPY XX20               \ If Y >= XX20, the number of faces * 4, jump down to
 BCS LL42               \ LL42 to move on to the

 JMP LL86               \ Otherwise loop back to LL86 to work out the visibility
                        \ of the next face

\ ******************************************************************************
\
\       Name: LL9 (Part 6 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Calculate the visibility of each of the ship's vertices
\  Deep dive: Drawing ships
\             Calculating vertex coordinates
\
\ ------------------------------------------------------------------------------
\
\ This section calculates the visibility of each of the ship's vertices, and for
\ those that are visible, it starts the process of calculating the screen
\ coordinates of each vertex
\
\ ******************************************************************************

.LL42

                        \ The first task is to set up the inverse matrix, ready
                        \ for us to send to the dot product routine at LL51.
                        \ Back up in part 3, we set up the following variables:
                        \
                        \   * XX16(1 0) = sidev_x
                        \   * XX16(3 2) = sidev_y
                        \   * XX16(5 4) = sidev_z
                        \
                        \   * XX16(7 6) = roofv_x
                        \   * XX16(9 8) = roofv_y
                        \   * XX16(11 10) = roofv_z
                        \
                        \   * XX16(13 12) = nosev_x
                        \   * XX16(15 14) = nosev_y
                        \   * XX16(17 16) = nosev_z
                        \
                        \ and we then scaled the vectors to give the following:
                        \
                        \   * XX16   = scaled |sidev_x|
                        \   * XX16+2 = scaled |sidev_y|
                        \   * XX16+4 = scaled |sidev_z|
                        \
                        \   * XX16+6  = scaled |roofv_x|
                        \   * XX16+8  = scaled |roofv_y|
                        \   * XX16+10 = scaled |roofv_z|
                        \
                        \   * XX16+12 = scaled |nosev_x|
                        \   * XX16+14 = scaled |nosev_y|
                        \   * XX16+16 = scaled |nosev_z|
                        \
                        \ We now need to rearrange these locations so they
                        \ effectively transpose the matrix into its inverse

 LDY XX16+2             \ Set XX16+2 = XX16+6 = scaled |roofv_x|
 LDX XX16+3             \ Set XX16+3 = XX16+7 = roofv_x_hi
 LDA XX16+6             \ Set XX16+6 = XX16+2 = scaled |sidev_y|
 STA XX16+2             \ Set XX16+7 = XX16+3 = sidev_y_hi
 LDA XX16+7
 STA XX16+3
 STY XX16+6
 STX XX16+7

 LDY XX16+4             \ Set XX16+4 = XX16+12 = scaled |nosev_x|
 LDX XX16+5             \ Set XX16+5 = XX16+13 = nosev_x_hi
 LDA XX16+12            \ Set XX16+12 = XX16+4 = scaled |sidev_z|
 STA XX16+4             \ Set XX16+13 = XX16+5 = sidev_z_hi
 LDA XX16+13
 STA XX16+5
 STY XX16+12
 STX XX16+13

 LDY XX16+10            \ Set XX16+10 = XX16+14 = scaled |nosev_y|
 LDX XX16+11            \ Set XX16+11 = XX16+15 = nosev_y_hi
 LDA XX16+14            \ Set XX16+14 = XX16+10 = scaled |roofv_z|
 STA XX16+10            \ Set XX16+15 = XX16+11 = roofv_z
 LDA XX16+15
 STA XX16+11
 STY XX16+14
 STX XX16+15

                        \ So now we have the following sign-magnitude variables
                        \ containing parts of the scaled orientation vectors:
                        \
                        \   XX16(1 0)   = scaled sidev_x
                        \   XX16(3 2)   = scaled roofv_x
                        \   XX16(5 4)   = scaled nosev_x
                        \
                        \   XX16(7 6)   = scaled sidev_y
                        \   XX16(9 8)   = scaled roofv_y
                        \   XX16(11 10) = scaled nosev_y
                        \
                        \   XX16(13 12) = scaled sidev_z
                        \   XX16(15 14) = scaled roofv_z
                        \   XX16(17 16) = scaled nosev_z
                        \
                        \ which is what we want, as the various vectors are now
                        \ arranged so we can use LL51 to multiply by the
                        \ transpose (i.e. the inverse of the matrix)

 LDY #8                 \ Fetch byte #8 of the ship's blueprint, which is the
 LDA (XX0),Y            \ number of vertices * 8, and store it in XX20
 STA XX20

                        \ We now set V(1 0) = XX0(1 0) + 20, so V(1 0) points
                        \ to byte #20 of the ship's blueprint, which is always
                        \ where the vertex data starts (i.e. just after the 20
                        \ byte block that define the ship's characteristics)

 LDA XX0                \ We start with the low bytes
 CLC
 ADC #20
 STA V

 LDA XX0+1              \ And then do the high bytes
 ADC #0
 STA V+1

 LDY #0                 \ We are about to step through all the vertices, using
                        \ Y as a counter. There are six data bytes for each
                        \ vertex, so we will increment Y by 6 for each iteration
                        \ so it can act as an offset from V(1 0) to the current
                        \ vertex's data

 STY CNT                \ Set CNT = 0, which we will use as a pointer to the
                        \ heap at XX3, starting it at zero so the heap starts
                        \ out empty

.LL48

 STY XX17               \ Set XX17 = Y, so XX17 now contains the offset of the
                        \ current vertex's data

 LDA (V),Y              \ Fetch byte #0 for this vertex into XX15, so:
 STA XX15               \
                        \   XX15 = magnitude of the vertex's x-coordinate

 INY                    \ Increment Y to point to byte #1

 LDA (V),Y              \ Fetch byte #1 for this vertex into XX15+2, so:
 STA XX15+2             \
                        \   XX15+2 = magnitude of the vertex's y-coordinate

 INY                    \ Increment Y to point to byte #2

 LDA (V),Y              \ Fetch byte #2 for this vertex into XX15+4, so:
 STA XX15+4             \
                        \   XX15+4 = magnitude of the vertex's z-coordinate

 INY                    \ Increment Y to point to byte #3

 LDA (V),Y              \ Fetch byte #3 for this vertex into T, so:
 STA T                  \
                        \   T = %xyz vvvvv, where:
                        \
                        \     * Bits 0-4 = visibility distance, beyond which the
                        \                  vertex is not shown
                        \
                        \     * Bits 7-5 = the sign bits of x, y and z

 AND #%00011111         \ Extract bits 0-4 to get the visibility distance

 CMP XX4                \ If XX4 > the visibility distance, where XX4 contains
 BCC LL49-3             \ the ship's z-distance reduced to 0-31 (which we set in
                        \ part 2), then this vertex is too far away to be
                        \ visible, so jump down to LL50 (via the JMP instruction
                        \ in LL49-3) to move on to the next vertex

 INY                    \ Increment Y to point to byte #4

 LDA (V),Y              \ Fetch byte #4 for this vertex into P, so:
 STA P                  \
                        \  P = %ffff ffff, where:
                        \
                        \    * Bits 0-3 = the number of face 1
                        \
                        \    * Bits 4-7 = the number of face 2

 AND #%00001111         \ Extract the number of face 1 into X
 TAX

 LDA XX2,X              \ If XX2+X is non-zero then we decided in part 5 that
 BNE LL49               \ face 1 is visible, so jump to LL49

 LDA P                  \ Fetch byte #4 for this vertex into A

 LSR A                  \ Shift right four times to extract the number of face 2
 LSR A                  \ from bits 4-7 into X
 LSR A
 LSR A
 TAX

 LDA XX2,X              \ If XX2+X is non-zero then we decided in part 5 that
 BNE LL49               \ face 2 is visible, so jump to LL49

 INY                    \ Increment Y to point to byte #5

 LDA (V),Y              \ Fetch byte #5 for this vertex into P, so:
 STA P                  \
                        \  P = %ffff ffff, where:
                        \
                        \    * Bits 0-3 = the number of face 3
                        \
                        \    * Bits 4-7 = the number of face 4

 AND #%00001111         \ Extract the number of face 1 into X
 TAX

 LDA XX2,X              \ If XX2+X is non-zero then we decided in part 5 that
 BNE LL49               \ face 3 is visible, so jump to LL49

 LDA P                  \ Fetch byte #5 for this vertex into A

 LSR A                  \ Shift right four times to extract the number of face 4
 LSR A                  \ from bits 4-7 into X
 LSR A
 LSR A
 TAX

 LDA XX2,X              \ If XX2+X is non-zero then we decided in part 5 that
 BNE LL49               \ face 4 is visible, so jump to LL49

 JMP LL50               \ If we get here then none of the four faces associated
                        \ with this vertex are visible, so this vertex is also
                        \ not visible, so jump to LL50 to move on to the next
                        \ vertex

.LL49

 LDA T                  \ Fetch byte #5 for this vertex into A and store it, so
 STA XX15+1             \ XX15+1 now has the sign of the vertex's x-coordinate

 ASL A                  \ Shift A left and store it, so XX15+3 now has the sign
 STA XX15+3             \ of the vertex's y-coordinate

 ASL A                  \ Shift A left and store it, so XX15+5 now has the sign
 STA XX15+5             \ of the vertex's z-coordinate

                        \ By this point we have the following:
                        \
                        \   XX15(1 0) = vertex x-coordinate
                        \   XX15(3 2) = vertex y-coordinate
                        \   XX15(5 4) = vertex z-coordinate
                        \
                        \   XX16(1 0)   = scaled sidev_x
                        \   XX16(3 2)   = scaled roofv_x
                        \   XX16(5 4)   = scaled nosev_x
                        \
                        \   XX16(7 6)   = scaled sidev_y
                        \   XX16(9 8)   = scaled roofv_y
                        \   XX16(11 10) = scaled nosev_y
                        \
                        \   XX16(13 12) = scaled sidev_z
                        \   XX16(15 14) = scaled roofv_z
                        \   XX16(17 16) = scaled nosev_z

 JSR LL51               \ Call LL51 to set XX12 to the dot products of XX15 and
                        \ XX16, as follows:
                        \
                        \   XX12(1 0) = [ x y z ] . [ sidev_x roofv_x nosev_x ]
                        \
                        \   XX12(3 2) = [ x y z ] . [ sidev_y roofv_y nosev_y ]
                        \
                        \   XX12(5 4) = [ x y z ] . [ sidev_z roofv_z nosev_z ]
                        \
                        \ XX12 contains the vector from the ship's centre to
                        \ the vertex, transformed from the orientation vector
                        \ space to the universe orientated around our ship. So
                        \ we can refer to this vector below, let's call it
                        \ vertv, so:
                        \
                        \   vertv_x = [ x y z ] . [ sidev_x roofv_x nosev_x ]
                        \
                        \   vertv_y = [ x y z ] . [ sidev_y roofv_y nosev_y ]
                        \
                        \   vertv_z = [ x y z ] . [ sidev_z roofv_z nosev_z ]
                        \
                        \ To finish the calculation, we now want to calculate:
                        \
                        \   vertv + [ x y z ]
                        \
                        \ So let's start with the vertv_x + x

 LDA XX1+2              \ Set A = x_sign of the ship's location

 STA XX15+2             \ Set XX15+2 = x_sign

 EOR XX12+1             \ If the sign of x_sign * the sign of vertv_x is
 BMI LL52               \ negative (i.e. they have different signs), skip to
                        \ LL52

 CLC                    \ Set XX15(2 1 0) = XX1(2 1 0) + XX12(1 0)
 LDA XX12               \                 = (x_sign x_hi x_lo) + vertv_x
 ADC XX1                \
 STA XX15               \ Starting with the low bytes

 LDA XX1+1              \ And then doing the high bytes (we can add 0 here as
 ADC #0                 \ we know the sign byte of vertv_x is 0)
 STA XX15+1

 JMP LL53               \ We've added the x-coordinates, so jump to LL53 to do
                        \ the y-coordinates

.LL52

                        \ If we get here then x_sign and vertv_x have different
                        \ signs, so we need to subtract them to get the result

 LDA XX1                \ Set XX15(2 1 0) = XX1(2 1 0) - XX12(1 0)
 SEC                    \                 = (x_sign x_hi x_lo) - vertv_x
 SBC XX12               \
 STA XX15               \ Starting with the low bytes

 LDA XX1+1              \ And then doing the high bytes (we can subtract 0 here
 SBC #0                 \ as we know the sign byte of vertv_x is 0)
 STA XX15+1

 BCS LL53               \ If the subtraction didn't underflow, then the sign of
                        \ the result is the same sign as x_sign, and that's what
                        \ we want, so we can jump down to LL53 to do the
                        \ y-coordinates

 EOR #%11111111         \ Otherwise we need to negate the result using two's
 STA XX15+1             \ complement, so first we flip the bits of the high byte

 LDA #1                 \ And then subtract the low byte from 1
 SBC XX15
 STA XX15

 BCC P%+4               \ If the above subtraction underflowed then we need to
 INC XX15+1             \ bump the high byte of the result up by 1

 LDA XX15+2             \ And now we flip the sign of the result to get the
 EOR #%10000000         \ correct result
 STA XX15+2

.LL53

                        \ Now for the y-coordinates, vertv_y + y

 LDA XX1+5              \ Set A = y_sign of the ship's location

 STA XX15+5             \ Set XX15+5 = y_sign

 EOR XX12+3             \ If the sign of y_sign * the sign of vertv_y is
 BMI LL54               \ negative (i.e. they have different signs), skip to
                        \ LL54

 CLC                    \ Set XX15(5 4 3) = XX1(5 4 3) + XX12(3 2)
 LDA XX12+2             \                 = (y_sign y_hi y_lo) + vertv_y
 ADC XX1+3              \
 STA XX15+3             \ Starting with the low bytes

 LDA XX1+4              \ And then doing the high bytes (we can add 0 here as
 ADC #0                 \ we know the sign byte of vertv_y is 0)
 STA XX15+4

 JMP LL55               \ We've added the y-coordinates, so jump to LL55 to do
                        \ the z-coordinates

.LL54

                        \ If we get here then y_sign and vertv_y have different
                        \ signs, so we need to subtract them to get the result

 LDA XX1+3              \ Set XX15(5 4 3) = XX1(5 4 3) - XX12(3 2)
 SEC                    \                 = (y_sign y_hi y_lo) - vertv_y
 SBC XX12+2             \
 STA XX15+3             \ Starting with the low bytes

 LDA XX1+4              \ And then doing the high bytes (we can subtract 0 here
 SBC #0                 \ as we know the sign byte of vertv_z is 0)
 STA XX15+4

 BCS LL55               \ If the subtraction didn't underflow, then the sign of
                        \ the result is the same sign as y_sign, and that's what
                        \ we want, so we can jump down to LL55 to do the
                        \ z-coordinates

 EOR #%11111111         \ Otherwise we need to negate the result using two's
 STA XX15+4             \ complement, so first we flip the bits of the high byte

 LDA XX15+3             \ And then flip the bits of the low byte and add 1
 EOR #%11111111
 ADC #1
 STA XX15+3

 LDA XX15+5             \ And now we flip the sign of the result to get the
 EOR #%10000000         \ correct result
 STA XX15+5

 BCC LL55               \ If the above subtraction underflowed then we need to
 INC XX15+4             \ bump the high byte of the result up by 1

.LL55

                        \ Now for the z-coordinates, vertv_z + z

 LDA XX12+5             \ If vertv_z_hi is negative, jump down to LL56
 BMI LL56

 LDA XX12+4             \ Set (U T) = XX1(7 6) + XX12(5 4)
 CLC                    \           = (z_hi z_lo) + vertv_z
 ADC XX1+6              \
 STA T                  \ Starting with the low bytes

 LDA XX1+7              \ And then doing the high bytes (we can add 0 here as
 ADC #0                 \ we know the sign byte of vertv_y is 0)
 STA U

 JMP LL57               \ We've added the z-coordinates, so jump to LL57

                        \ The adding process is continued in part 7, after a
                        \ couple of subroutines that we don't need quite yet

\ ******************************************************************************
\
\       Name: LL61
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (U R) = 256 * A / Q
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following, where A >= Q:
\
\   (U R) = 256 * A / Q
\
\ This is a sister routine to LL28, which does the division when A < Q.
\
\ ******************************************************************************

.LL61

 LDX Q                  \ If Q = 0, jump down to LL84 to return a division
 BEQ LL84               \ error

                        \ The LL28 routine returns A / Q, but only if A < Q. In
                        \ our case A >= Q, but we still want to use the LL28
                        \ routine, so we halve A until it's less than Q, call
                        \ the division routine, and then double A by the same
                        \ number of times

 LDX #0                 \ Set X = 0 to count the number of times we halve A

.LL63

 LSR A                  \ Halve A by shifting right

 INX                    \ Increment X

 CMP Q                  \ If A >= Q, loop back to LL63 to halve it again
 BCS LL63

 STX S                  \ Otherwise store the number of times we halved A in S

 JSR LL28               \ Call LL28 to calculate:
                        \
                        \   R = 256 * A / Q
                        \
                        \ which we can do now as A < Q

 LDX S                  \ Otherwise restore the number of times we halved A
                        \ above into X

 LDA R                  \ Set A = our division result

.LL64

 ASL A                  \ Double (U A) by shifting left
 ROL U

 BMI LL84               \ If bit 7 of U is set, the doubling has overflowed, so
                        \ jump to LL84 to return a division error

 DEX                    \ Decrement X

 BNE LL64               \ If X is not yet zero then we haven't done as many
                        \ doublings as we did halvings earlier, so loop back for
                        \ another doubling

 STA R                  \ Store the low byte of the division result in R

 RTS                    \ Return from the subroutine

.LL84

 LDA #50                \ If we get here then either we tried to divide by 0, or
 STA R                  \ the result overflowed, so we set U and R to 50
 STA U

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL62
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate 128 - (U R)
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following for a positive sign-magnitude number (U R):
\
\   128 - (U R)
\
\ and then store the result, low byte then high byte, on the end of the heap at
\ XX3, where X points to the first free byte on the heap. Return by jumping down
\ to LL66.
\
\ Returns:
\
\   X                   X is incremented by 1
\
\ ******************************************************************************

.LL62

 LDA #128               \ Calculate 128 - (U R), starting with the low bytes
 SEC
 SBC R

 STA XX3,X              \ Store the low byte of the result in the X-th byte of
                        \ the heap at XX3

 INX                    \ Increment the heap pointer in X to point to the next
                        \ byte

 LDA #0                 \ And then subtract the high bytes
 SBC U

 STA XX3,X              \ Store the low byte of the result in the X-th byte of
                        \ the heap at XX3

 JMP LL66               \ Jump down to LL66

\ ******************************************************************************
\
\       Name: LL9 (Part 7 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Calculate the visibility of each of the ship's vertices
\  Deep dive: Drawing ships
\             Calculating vertex coordinates
\
\ ------------------------------------------------------------------------------
\
\ This section continues the coordinate adding from part 6 by finishing off the
\ calculation that we started above:
\
\                      [ sidev_x roofv_x nosev_x ]   [ x ]   [ x ]
\   vector to vertex = [ sidev_y roofv_y nosev_y ] . [ y ] + [ y ]
\                      [ sidev_z roofv_z nosev_z ]   [ z ]   [ z ]
\
\ The gets stored as follows, in sign-magnitude values with the magnitudes
\ fitting into the low bytes:
\
\   XX15(2 0)           [ x y z ] . [ sidev_x roofv_x nosev_x ] + [ x y z ]
\
\   XX15(5 3)           [ x y z ] . [ sidev_y roofv_y nosev_y ] + [ x y z ]
\
\   (U T)               [ x y z ] . [ sidev_z roofv_z nosev_z ] + [ x y z ]
\
\ Finally, because this vector is from our ship to the vertex, and we are at the
\ origin, this vector is the same as the coordinates of the vertex. In other
\ words, we have just worked out:
\
\   XX15(2 0)           x-coordinate of the current vertex
\
\   XX15(5 3)           y-coordinate of the current vertex
\
\   (U T)               z-coordinate of the current vertex
\
\ ******************************************************************************

.LL56

 LDA XX1+6              \ Set (U T) = XX1(7 6) - XX12(5 4)
 SEC                    \           = (z_hi z_lo) - vertv_z
 SBC XX12+4             \
 STA T                  \ Starting with the low bytes

 LDA XX1+7              \ And then doing the high bytes (we can subtract 0 here
 SBC #0                 \ as we know the sign byte of vertv_z is 0)
 STA U

 BCC LL140              \ If the subtraction just underflowed, skip to LL140 to
                        \ set (U T) to the minimum value of 4

 BNE LL57               \ If U is non-zero, jump down to LL57

 LDA T                  \ If T >= 4, jump down to LL57
 CMP #4
 BCS LL57

.LL140

 LDA #0                 \ If we get here then either (U T) < 4 or the
 STA U                  \ subtraction underflowed, so set (U T) = 4
 LDA #4
 STA T

.LL57

                        \ By this point we have our results, so now to scale
                        \ the 16-bit results down into 8-bit values

 LDA U                  \ If the high bytes of the result are all zero, we are
 ORA XX15+1             \ done, so jump down to LL60 for the next stage
 ORA XX15+4
 BEQ LL60

 LSR XX15+1             \ Shift XX15(1 0) to the right
 ROR XX15

 LSR XX15+4             \ Shift XX15(4 3) to the right
 ROR XX15+3

 LSR U                  \ Shift (U T) to the right
 ROR T

 JMP LL57               \ Jump back to LL57 to see if we can shift the result
                        \ any more

\ ******************************************************************************
\
\       Name: LL9 (Part 8 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Calculate the screen coordinates of visible vertices
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This section projects the coordinate of the vertex into screen coordinates and
\ stores them on the XX3 heap. By the end of this part, the XX3 heap contains
\ four bytes containing the 16-bit screen coordinates of the current vertex, in
\ the order: x_lo, x_hi, y_lo, y_hi.
\
\ When we reach here, we are looping through the vertices, and we've just worked
\ out the coordinates of the vertex in our normal coordinate system, as follows
\
\   XX15(2 0)           (x_sign x_lo) = x-coordinate of the current vertex
\
\   XX15(5 3)           (y_sign y_lo) = y-coordinate of the current vertex
\
\   (U T)               (z_sign z_lo) = z-coordinate of the current vertex
\
\ Note that U is always zero when we get to this point, as the vertex is always
\ in front of us (so it has a positive z-coordinate, into the screen).
\
\ Other entry points:
\
\   LL70+1              Contains an RTS (as the first byte of an LDA
\                       instruction)
\
\ ******************************************************************************

.LL60

 LDA T                  \ Set Q = z_lo
 STA Q

 LDA XX15               \ Set A = x_lo

 CMP Q                  \ If x_lo < z_lo jump to LL69
 BCC LL69

 JSR LL61               \ Call LL61 to calculate:
                        \
                        \   (U R) = 256 * A / Q
                        \         = 256 * x / z
                        \
                        \ which we can do as x >= z

 JMP LL65               \ Jump to LL65 to skip the division for x_lo < z_lo

.LL69

 JSR LL28               \ Call LL28 to calculate:
                        \
                        \   R = 256 * A / Q
                        \     = 256 * x / z
                        \
                        \ Because x < z, the result fits into one byte, and we
                        \ also know that U = 0, so (U R) also contains the
                        \ result

.LL65

                        \ At this point we have:
                        \
                        \   (U R) = x / z
                        \
                        \ so (U R) contains the vertex's x-coordinate projected
                        \ on screen
                        \
                        \ The next task is to convert (U R) to a pixel screen
                        \ coordinate and stick it on the XX3 heap.
                        \
                        \ We start with the x-coordinate. To convert the
                        \ x-coordinate to a screen pixel we add 128, the
                        \ x-coordinate of the centre of the screen, because the
                        \ projected value is relative to an origin at the centre
                        \ of the screen, but the origin of the screen pixels is
                        \ at the top-left of the screen

 LDX CNT                \ Fetch the pointer to the end of the XX3 heap from CNT
                        \ into X

 LDA XX15+2             \ If x_sign is negative, jump up to LL62, which will
 BMI LL62               \ store 128 - (U R) on the XX3 heap and return by
                        \ jumping down to LL66 below

 LDA R                  \ Calculate 128 + (U R), starting with the low bytes
 CLC
 ADC #128

 STA XX3,X              \ Store the low byte of the result in the X-th byte of
                        \ the heap at XX3

 INX                    \ Increment the heap pointer in X to point to the next
                        \ byte

 LDA U                  \ And then add the high bytes
 ADC #0

 STA XX3,X              \ Store the high byte of the result in the X-th byte of
                        \ the heap at XX3

.LL66

                        \ We've just stored the screen x-coordinate of the
                        \ vertex on the XX3 heap, so now for the y-coordinate

 TXA                    \ Store the heap pointer in X on the stack (at this
 PHA                    \ it points to the last entry on the heap, not the first
                        \ free byte)

 LDA #0                 \ Set U = 0
 STA U

 LDA T                  \ Set Q = z_lo
 STA Q

 LDA XX15+3             \ Set A = y_lo

 CMP Q                  \ If y_lo < z_lo jump to LL67
 BCC LL67

 JSR LL61               \ Call LL61 to calculate:
                        \
                        \   (U R) = 256 * A / Q
                        \         = 256 * y / z
                        \
                        \ which we can do as y >= z

 JMP LL68               \ Jump to LL68 to skip the division for y_lo < z_lo

.LL70

                        \ This gets called from below when y_sign is negative

 LDA #Y                 \ Calculate #Y + (U R), starting with the low bytes
 CLC
 ADC R

 STA XX3,X              \ Store the low byte of the result in the X-th byte of
                        \ the heap at XX3

 INX                    \ Increment the heap pointer in X to point to the next
                        \ byte

 LDA #0                 \ And then add the high bytes
 ADC U

 STA XX3,X              \ Store the high byte of the result in the X-th byte of
                        \ the heap at XX3

 JMP LL50               \ Jump to LL50 to move on to the next vertex

.LL67

 JSR LL28               \ Call LL28 to calculate:
                        \
                        \   R = 256 * A / Q
                        \     = 256 * y / z
                        \
                        \ Because y < z, the result fits into one byte, and we
                        \ also know that U = 0, so (U R) also contains the
                        \ result

.LL68

                        \ At this point we have:
                        \
                        \   (U R) = y / z
                        \
                        \ so (U R) contains the vertex's y-coordinate projected
                        \ on screen
                        \
                        \ We now want to convert this to a screen y-coordinate
                        \ and stick it on the XX3 heap, much like we did with
                        \ the x-coordinate above. Again, we convert the
                        \ coordinate by adding or subtracting the y-coordinate
                        \ of the centre of the screen, which is in the constant
                        \ #Y, but this time we do the opposite, as a positive
                        \ projected y-coordinate, i.e. up the space y-axis and
                        \ up the screen, converts to a low y-coordinate, which
                        \ is the opposite way round to the x-coordinates

 PLA                    \ Restore the heap pointer from the stack into X
 TAX

 INX                    \ When we stored the heap pointer, it pointed to the
                        \ last entry on the heap, not the first free byte, so we
                        \ increment it so it does point to the next free byte

 LDA XX15+5             \ If y_sign is negative, jump up to LL70, which will
 BMI LL70               \ store #Y + (U R) on the XX3 heap and return by jumping
                        \ down to LL50 below

 LDA #Y                 \ Calculate #Y - (U R), starting with the low bytes
 SEC
 SBC R

 STA XX3,X              \ Store the low byte of the result in the X-th byte of
                        \ the heap at XX3

 INX                    \ Increment the heap pointer in X to point to the next
                        \ byte

 LDA #0                 \ And then subtract the high bytes
 SBC U

 STA XX3,X              \ Store the high byte of the result in the X-th byte of
                        \ the heap at XX3

.LL50

                        \ By the time we get here, the XX3 heap contains four
                        \ bytes containing the screen coordinates of the current
                        \ vertex, in the order: x_lo, x_hi, y_lo, y_hi

 CLC                    \ Set CNT = CNT + 4, so the heap pointer points to the
 LDA CNT                \ next free byte on the heap
 ADC #4
 STA CNT

 LDA XX17               \ Set A to the offset of the current vertex's data,
                        \ which we set in part 6

 ADC #6                 \ Set Y = A + 6, so Y now points to the data for the
 TAY                    \ next vertex

 BCS LL72               \ If the addition just overflowed, meaning we just tried
                        \ to access vertex #43, jump to LL72, as the maximum
                        \ number of vertices allowed is 42

 CMP XX20               \ If Y >= number of vertices * 6 (which we stored in
 BCS LL72               \ XX20 in part 6), jump to LL72, as we have processed
                        \ all the vertices for this ship

 JMP LL48               \ Loop back to LL48 in part 6 to calculate visibility
                        \ and screen coordinates for the next vertex

\ ******************************************************************************
\
\       Name: LL9 (Part 9 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Draw laser beams if the ship is firing its laser at us
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This part sets things up so we can loop through the edges in the next part. It
\ also adds a line to the ship line heap, if the ship is firing at us.
\
\ When we get here, the heap at XX3 contains all the visible vertex screen
\ coordinates.
\
\ ******************************************************************************

.LL72

 LDA XX1+31             \ If bit 5 of the ship's byte #31 is clear, then the
 AND #%00100000         \ ship is not currently exploding, so jump down to EE31
 BEQ EE31

 LDA XX1+31             \ The ship is exploding, so set bit 3 of the ship's byte
 ORA #%00001000         \ #31 to denote that we are drawing something on-screen
 STA XX1+31             \ for this ship

 JMP DOEXP              \ Jump to DOEXP to display the explosion cloud,
                        \ returning from the subroutine using a tail call

.EE31

 LDA #%00001000         \ If bit 3 of the ship's byte #31 is clear, then there
 BIT XX1+31             \ is nothing already being shown for this ship, so skip
 BEQ LL74               \ to LL74 as we don't need to erase anything from the
                        \ screen

 JSR LL155              \ Otherwise call LL155 to draw the existing ship, which
                        \ removes it from the screen

 LDA #%00001000         \ Set bit 3 of A so the next instruction sets bit 3 of
                        \ the ship's byte #31 to denote that we are drawing
                        \ something on-screen for this ship

.LL74

 ORA XX1+31             \ Apply bit 3 of A to the ship's byte #31, so if there
 STA XX1+31             \ was no ship already on screen, the bit is clear,
                        \ otherwise it is set

 LDY #9                 \ Fetch byte #9 of the ship's blueprint, which is the
 LDA (XX0),Y            \ number of edges, and store it in XX20
 STA XX20

 LDY #0                 \ We are about to step through all the edges, using Y
                        \ as a counter

 STY U                  \ Set U = 0 (though we increment it to 1 below)

 STY XX17               \ Set XX17 = 0, which we are going to use as a counter
                        \ for stepping through the ship's edges

 INC U                  \ We are going to start calculating the lines we need to
                        \ draw for this ship, and will store them in the ship
                        \ line heap, using U to point to the end of the heap, so
                        \ we start by setting U = 1

 BIT XX1+31             \ If bit 6 of the ship's byte #31 is clear, then the
 BVC LL170              \ ship is not firing its lasers, so jump to LL170 to
                        \ skip the drawing of laser lines

                        \ The ship is firing its laser at us, so we need to draw
                        \ the laser lines

 LDA XX1+31             \ Clear bit 6 of the ship's byte #31 so the ship doesn't
 AND #%10111111         \ keep firing endlessly
 STA XX1+31

 LDY #6                 \ Fetch byte #6 of the ship's blueprint, which is the
 LDA (XX0),Y            \ number * 4 of the vertex where the ship has its lasers

 TAY                    \ Put the vertex number into Y, where it can act as an
                        \ index into list of vertex screen coordinates we added
                        \ to the XX3 heap

 LDX XX3,Y              \ Fetch the x_lo coordinate of the laser vertex from the
 STX XX15               \ XX3 heap into XX15

 INX                    \ If X = 255 then the laser vertex is not visible, as
 BEQ LL170              \ the value we stored in part 2 wasn't overwritten by
                        \ the vertex calculation in part 6 and 7, so jump to
                        \ LL170 to skip drawing the laser lines

                        \ We now build a laser beam from the ship's laser vertex
                        \ towards our ship, as follows:
                        \
                        \   XX15(1 0) = laser vertex x-coordinate
                        \
                        \   XX15(3 2) = laser vertex y-coordinate
                        \
                        \   XX15(5 4) = x-coordinate of the end of the beam
                        \
                        \   XX12(1 0) = y-coordinate of the end of the beam
                        \
                        \ The end of the laser beam will be set positioned to
                        \ look good, rather than being directly aimed at us, as
                        \ otherwise we would only see a flashing point of light
                        \ as they unleashed their attack

 LDX XX3+1,Y            \ Fetch the x_hi coordinate of the laser vertex from the
 STX XX15+1             \ XX3 heap into XX15+1

 INX                    \ If X = 255 then the laser vertex is not visible, as
 BEQ LL170              \ the value we stored in part 2 wasn't overwritten by
                        \ a vertex calculation in part 6 and 7, so jump to LL170
                        \ to skip drawing the laser beam

 LDX XX3+2,Y            \ Fetch the y_lo coordinate of the laser vertex from the
 STX XX15+2             \ XX3 heap into XX15+2

 LDX XX3+3,Y            \ Fetch the y_hi coordinate of the laser vertex from the
 STX XX15+3             \ XX3 heap into XX15+3

 LDA #0                 \ Set XX15(5 4) = 0, so their laser beam fires to the
 STA XX15+4             \ left edge of the screen
 STA XX15+5

 STA XX12+1             \ Set XX12(1 0) = the ship's z_lo coordinate, which will
 LDA XX1+6              \ effectively make the vertical position of the end of
 STA XX12               \ the laser beam move around as the ship moves in space

 LDA XX1+2              \ If the ship's x_sign is positive, skip the next
 BPL P%+4               \ instruction

 DEC XX15+4             \ The ship's x_sign is negative (i.e. it's on the left
                        \ side of the screen), so switch the laser beam so it
                        \ goes to the right edge of the screen by decrementing
                        \ XX15(5 4) to 255

 JSR LL145              \ Call LL145 to see if the laser beam needs to be
                        \ clipped to fit on-screen, returning the clipped line's
                        \ end-points in (X1, Y1) and (X2, Y2)

 BCS LL170              \ If the C flag is set then the line is not visible on
                        \ screen, so jump to LL170 so we don't store this line
                        \ in the ship line heap

 LDY U                  \ Fetch the ship line heap pointer, which points to the
                        \ next free byte on the heap, into Y

 LDA XX15               \ Add X1 to the end of the heap
 STA (XX19),Y

 INY                    \ Increment the heap pointer

 LDA XX15+1             \ Add Y1 to the end of the heap
 STA (XX19),Y

 INY                    \ Increment the heap pointer

 LDA XX15+2             \ Add X2 to the end of the heap
 STA (XX19),Y

 INY                    \ Increment the heap pointer

 LDA XX15+3             \ Add Y2 to the end of the heap
 STA (XX19),Y

 INY                    \ Increment the heap pointer

 STY U                  \ Store the updated ship line heap pointer in U

\ ******************************************************************************
\
\       Name: LL9 (Part 10 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Calculate the visibility of each of the ship's edges
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This part calculates which edges are visible - in other words, which lines we
\ should draw - and clips them to fit on the screen.
\
\ When we get here, the heap at XX3 contains all the visible vertex screen
\ coordinates.
\
\ ******************************************************************************

.LL170

 LDY #3                 \ Fetch byte #3 of the ship's blueprint, which contains
 CLC                    \ the low byte of the offset to the edges data
 LDA (XX0),Y

 ADC XX0                \ Set V = low byte edges offset + XX0
 STA V

 LDY #16                \ Fetch byte #16 of the ship's blueprint, which contains
 LDA (XX0),Y            \ the high byte of the offset to the edges data

 ADC XX0+1              \ Set V+1 = high byte edges offset + XX0+1
 STA V+1                \
                        \ So V(1 0) now points to the start of the edges data
                        \ for this ship

 LDY #5                 \ Fetch byte #5 of the ship's blueprint, which contains
 LDA (XX0),Y            \ the maximum heap size for plotting the ship (which is
 STA T1                 \ 1 + 4 * the maximum number of visible edges) and store
                        \ it in T1

 LDY XX17               \ Set Y to the edge counter in XX17

.LL75

 LDA (V),Y              \ Fetch byte #0 for this edge, which contains the
                        \ visibility distance for this edge, beyond which the
                        \ edge is not shown

 CMP XX4                \ If XX4 > the visibility distance, where XX4 contains
 BCC LL79-3             \ the ship's z-distance reduced to 0-31 (which we set in
                        \ part 2), then this edge is too far away to be visible,
                        \ so jump down to LL78 (via LL79-3) to move on to the
                        \ next edge

 INY                    \ Increment Y to point to byte #1

 LDA (V),Y              \ Fetch byte #1 for this edge into A, so:
                        \
                        \   A = %ffff ffff, where:
                        \
                        \     * Bits 0-3 = the number of face 1
                        \
                        \     * Bits 4-7 = the number of face 2

 INY                    \ Increment Y to point to byte #2

 STA P                  \ Store byte #1 into P

 AND #%00001111         \ Extract the number of face 1 into X
 TAX

 LDA XX2,X              \ If XX2+X is non-zero then we decided in part 5 that
 BNE LL79               \ face 1 is visible, so jump to LL79

 LDA P                  \ Fetch byte #1 for this edge into A

 LSR A                  \ Shift right four times to extract the number of face 2
 LSR A                  \ from bits 4-7 into X
 LSR A
 LSR A
 TAX

 LDA XX2,X              \ If XX2+X is non-zero then we decided in part 5 that
 BNE LL79               \ face 2 is visible, so skip the following instruction

 JMP LL78               \ Face 2 is hidden, so jump to LL78

.LL79

                        \ We now build the screen line for this edge, as
                        \ follows:
                        \
                        \   XX15(1 0) = start x-coordinate
                        \
                        \   XX15(3 2) = start y-coordinate
                        \
                        \   XX15(5 4) = end x-coordinate
                        \
                        \   XX12(1 0) = end y-coordinate
                        \
                        \ We can then pass this to the line clipping routine
                        \ before storing the resulting line in the ship line
                        \ heap

 LDA (V),Y              \ Fetch byte #2 for this edge into X, which contains
 TAX                    \ the number of the vertex at the start of the edge

 INY                    \ Increment Y to point to byte #3

 LDA (V),Y              \ Fetch byte #3 for this edge into Q, which contains
 STA Q                  \ the number of the vertex at the end of the edge

 LDA XX3+1,X            \ Fetch the x_hi coordinate of the edge's start vertex
 STA XX15+1             \ from the XX3 heap into XX15+1

 LDA XX3,X              \ Fetch the x_lo coordinate of the edge's start vertex
 STA XX15               \ from the XX3 heap into XX15

 LDA XX3+2,X            \ Fetch the y_lo coordinate of the edge's start vertex
 STA XX15+2             \ from the XX3 heap into XX15+2

 LDA XX3+3,X            \ Fetch the y_hi coordinate of the edge's start vertex
 STA XX15+3             \ from the XX3 heap into XX15+3

 LDX Q                  \ Set X to the number of the vertex at the end of the
                        \ edge, which we stored in Q

 LDA XX3,X              \ Fetch the x_lo coordinate of the edge's end vertex
 STA XX15+4             \ from the XX3 heap into XX15+4

 LDA XX3+3,X            \ Fetch the y_hi coordinate of the edge's end vertex
 STA XX12+1             \ from the XX3 heap into XX11+1

 LDA XX3+2,X            \ Fetch the y_lo coordinate of the edge's end vertex
 STA XX12               \ from the XX3 heap into XX12

 LDA XX3+1,X            \ Fetch the x_hi coordinate of the edge's end vertex
 STA XX15+5             \ from the XX3 heap into XX15+5

 JSR LL147              \ Call LL147 to see if the new line segment needs to be
                        \ clipped to fit on-screen, returning the clipped line's
                        \ end-points in (X1, Y1) and (X2, Y2)

 BCS LL79-3             \ If the C flag is set then the line is not visible on
                        \ screen, so jump to LL78 (via LL79-3) so we don't store
                        \ this line in the ship line heap

 JMP LL80               \ Jump down to part 11 to draw this edge

\ ******************************************************************************
\
\       Name: LL145 (Part 1 of 4)
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Clip line: Work out which end-points are on-screen, if any
\  Deep dive: Line-clipping
\             Extended screen coordinates
\
\ ------------------------------------------------------------------------------
\
\ This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or
\ returns an error if it can't be clipped to fit. The arguments are 16-bit
\ coordinates, and the clipped line is returned using 8-bit screen coordinates.
\
\ This part sets XX13 to reflect which of the two points are on-screen and
\ off-screen.
\
\ Arguments:
\
\   XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
\
\   XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
\
\   XX15(5 4)           x2 as a 16-bit coordinate (x2_hi x2_lo)
\
\   XX12(1 0)           y2 as a 16-bit coordinate (y2_hi y2_lo)
\
\ Returns:
\
\   (X1, Y1)            Screen coordinate of the start of the clipped line
\
\   (X2, Y2)            Screen coordinate of the end of the clipped line
\
\   C flag              Clear if the clipped line fits on-screen, set if it
\                       doesn't
\
\   XX13                The state of the original coordinates on-screen:
\
\                         * 0   = (x2, y2) on-screen
\
\                         * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
\
\                         * 191 = (x1, y1) off-screen, (x2, y2) off-screen
\
\                       So XX13 is non-zero if the end of the line was clipped,
\                       meaning the next line sent to BLINE can't join onto the
\                       end but has to start a new segment
\
\   SWAP                The swap status of the returned coordinates:
\
\                         * &FF if we swapped the values of (x1, y1) and
\                           (x2, y2) as part of the clipping process
\
\                         * 0 if the coordinates are still in the same order
\
\   Y                   Y is preserved
\
\ Other entry points:
\
\   LL147               Don't initialise the values in SWAP or A
\
\ ******************************************************************************

.LL145

 LDA #0                 \ Set SWAP = 0
 STA SWAP

 LDA XX15+5             \ Set A = x2_hi

.LL147

 LDX #Y*2-1             \ Set X = #Y * 2 - 1. The constant #Y is 96, the
                        \ y-coordinate of the mid-point of the space view, so
                        \ this sets Y2 to 191, the y-coordinate of the bottom
                        \ pixel row of the space view

 ORA XX12+1             \ If one or both of x2_hi and y2_hi are non-zero, jump
 BNE LL107              \ to LL107 to skip the following, leaving X at 191

 CPX XX12               \ If y2_lo > the y-coordinate of the bottom of screen
 BCC LL107              \ then (x2, y2) is off the bottom of the screen, so skip
                        \ the following instruction, leaving X at 191

 LDX #0                 \ Set X = 0

.LL107

 STX XX13               \ Set XX13 = X, so we have:
                        \
                        \   * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen
                        \
                        \   * XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo
                        \            is off the bottom of the screen
                        \
                        \ In other words, XX13 is 191 if (x2, y2) is off-screen,
                        \ otherwise it is 0

 LDA XX15+1             \ If one or both of x1_hi and y1_hi are non-zero, jump
 ORA XX15+3             \ to LL83
 BNE LL83

 LDA #Y*2-1             \ If y1_lo > the y-coordinate of the bottom of screen
 CMP XX15+2             \ then (x1, y1) is off the bottom of the screen, so jump
 BCC LL83               \ to LL83

                        \ If we get here, (x1, y1) is on-screen

 LDA XX13               \ If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
 BNE LL108              \ to LL108 to halve it before continuing at LL83

                        \ If we get here, the high bytes are all zero, which
                        \ means the x-coordinates are < 256 and therefore fit on
                        \ screen, and neither coordinate is off the bottom of
                        \ the screen. That means both coordinates are already on
                        \ screen, so we don't need to do any clipping, all we
                        \ need to do is move the low bytes into (X1, Y1) and
                        \ X2, Y2) and return

.LL146

                        \ If we get here then we have clipped our line to the
                        \ (if we had to clip it at all), so we move the low
                        \ bytes from (x1, y1) and (x2, y2) into (X1, Y1) and
                        \ (X2, Y2), remembering that they share locations with
                        \ XX15:
                        \
                        \   X1 = XX15
                        \   Y1 = XX15+1
                        \   X2 = XX15+2
                        \   Y2 = XX15+3
                        \
                        \ X1 already contains x1_lo, so now we do the rest

 LDA XX15+2             \ Set Y1 (aka XX15+1) = y1_lo
 STA XX15+1

 LDA XX15+4             \ Set X2 (aka XX15+2) = x2_lo
 STA XX15+2

 LDA XX12               \ Set Y2 (aka XX15+3) = y2_lo
 STA XX15+3

 CLC                    \ Clear the C flag as the clipped line fits on-screen

 RTS                    \ Return from the subroutine

.LL109

 SEC                    \ Set the C flag to indicate the clipped line does not
                        \ fit on-screen

 RTS                    \ Return from the subroutine

.LL108

 LSR XX13               \ If we get here then (x2, y2) is off-screen and XX13 is
                        \ 191, so shift XX13 right to halve it to 95

\ ******************************************************************************
\
\       Name: LL145 (Part 2 of 4)
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Clip line: Work out if any part of the line is on-screen
\  Deep dive: Line-clipping
\             Extended screen coordinates
\
\ ------------------------------------------------------------------------------
\
\ This part does a number of tests to see if the line is on or off the screen.
\
\ If we get here then at least one of (x1, y1) and (x2, y2) is off-screen, with
\ XX13 set as follows:
\
\   * 0   = (x1, y1) off-screen, (x2, y2) on-screen
\
\   * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
\
\   * 191 = (x1, y1) off-screen, (x2, y2) off-screen
\
\ where "off-screen" is defined as having a non-zero high byte in one of the
\ coordinates, or in the case of y-coordinates, having a low byte > 191, the
\ y-coordinate of the bottom of the space view.
\
\ ******************************************************************************

.LL83

 LDA XX13               \ If XX13 < 128 then only one of the points is on-screen
 BPL LL115              \ so jump down to LL115 to skip the checks of whether
                        \ both points are in the strips to the right or bottom
                        \ of the screen

                        \ If we get here, both points are off-screen

 LDA XX15+1             \ If both x1_hi and x2_hi have bit 7 set, jump to LL109
 AND XX15+5             \ to return from the subroutine with the C flag set, as
 BMI LL109              \ the entire line is above the top of the screen

 LDA XX15+3             \ If both y1_hi and y2_hi have bit 7 set, jump to LL109
 AND XX12+1             \ to return from the subroutine with the C flag set, as
 BMI LL109              \ the entire line is to the left of the screen

 LDX XX15+1             \ Set A = X = x1_hi - 1
 DEX
 TXA

 LDX XX15+5             \ Set XX12+2 = x2_hi - 1
 DEX
 STX XX12+2

 ORA XX12+2             \ If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
 BPL LL109              \ jump to LL109 to return from the subroutine with the C
                        \ flag set, as the line doesn't fit on-screen

 LDA XX15+2             \ If y1_lo < y-coordinate of screen bottom, clear the C
 CMP #Y*2               \ flag, otherwise set it

 LDA XX15+3             \ Set XX12+2 = y1_hi - (1 - C), so:
 SBC #0                 \
 STA XX12+2             \  * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen
                        \  * Set XX12+2 = y1_hi     otherwise
                        \
                        \ We do this subtraction because we are only interested
                        \ in trying to move the points up by a screen if that
                        \ might move the point into the space view portion of
                        \ the screen, i.e. if y1_lo is on-screen

 LDA XX12               \ If y2_lo < y-coordinate of screen bottom, clear the C
 CMP #Y*2               \ flag, otherwise set it

 LDA XX12+1             \ Set XX12+2 = y2_hi - (1 - C), so:
 SBC #0                 \
                        \  * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen
                        \  * Set XX12+1 = y2_hi     otherwise
                        \
                        \ We do this subtraction because we are only interested
                        \ in trying to move the points up by a screen if that
                        \ might move the point into the space view portion of
                        \ the screen, i.e. if y1_lo is on-screen

 ORA XX12+2             \ If neither XX12+1 or XX12+2 have bit 7 set, jump to
 BPL LL109              \ LL109 to return from the subroutine with the C flag
                        \ set, as the line doesn't fit on-screen

\ ******************************************************************************
\
\       Name: LL145 (Part 3 of 4)
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Clip line: Calculate the line's gradient
\  Deep dive: Line-clipping
\             Extended screen coordinates
\
\ ******************************************************************************

.LL115

 TYA                    \ Store Y on the stack so we can preserve it through the
 PHA                    \ call to this subroutine

 LDA XX15+4             \ Set XX12+2 = x2_lo - x1_lo
 SEC
 SBC XX15
 STA XX12+2

 LDA XX15+5             \ Set XX12+3 = x2_hi - x1_hi
 SBC XX15+1
 STA XX12+3

 LDA XX12               \ Set XX12+4 = y2_lo - y1_lo
 SEC
 SBC XX15+2
 STA XX12+4

 LDA XX12+1             \ Set XX12+5 = y2_hi - y1_hi
 SBC XX15+3
 STA XX12+5

                        \ So we now have:
                        \
                        \   delta_x in XX12(3 2)
                        \   delta_y in XX12(5 4)
                        \
                        \ where the delta is (x1, y1) - (x2, y2))

 EOR XX12+3             \ Set S = the sign of delta_x * the sign of delta_y, so
 STA S                  \ if bit 7 of S is set, the deltas have different signs

 LDA XX12+5             \ If delta_y_hi is positive, jump down to LL110 to skip
 BPL LL110              \ the following

 LDA #0                 \ Otherwise flip the sign of delta_y to make it
 SEC                    \ positive, starting with the low bytes
 SBC XX12+4
 STA XX12+4

 LDA #0                 \ And then doing the high bytes, so now:
 SBC XX12+5             \
 STA XX12+5             \   XX12(5 4) = |delta_y|

.LL110

 LDA XX12+3             \ If delta_x_hi is positive, jump down to LL111 to skip
 BPL LL111              \ the following

 SEC                    \ Otherwise flip the sign of delta_x to make it
 LDA #0                 \ positive, starting with the low bytes
 SBC XX12+2
 STA XX12+2

 LDA #0                 \ And then doing the high bytes, so now:
 SBC XX12+3             \
                        \   (A XX12+2) = |delta_x|

.LL111

                        \ We now keep halving |delta_x| and |delta_y| until
                        \ both of them have zero in their high bytes

 TAX                    \ If |delta_x_hi| is non-zero, skip the following
 BNE LL112

 LDX XX12+5             \ If |delta_y_hi| = 0, jump down to LL113 (as both
 BEQ LL113              \ |delta_x_hi| and |delta_y_hi| are 0)

.LL112

 LSR A                  \ Halve the value of delta_x in (A XX12+2)
 ROR XX12+2

 LSR XX12+5             \ Halve the value of delta_y XX12(5 4)
 ROR XX12+4

 JMP LL111              \ Loop back to LL111

.LL113

                        \ By now, the high bytes of both |delta_x| and |delta_y|
                        \ are zero

 STX T                  \ We know that X = 0 as that's what we tested with a BEQ
                        \ above, so this sets T = 0

 LDA XX12+2             \ If delta_x_lo < delta_y_lo, so our line is more
 CMP XX12+4             \ vertical than horizontal, jump to LL114
 BCC LL114

                        \ If we get here then our line is more horizontal than
                        \ vertical, so it is a shallow slope

 STA Q                  \ Set Q = delta_x_lo

 LDA XX12+4             \ Set A = delta_y_lo

 JSR LL28               \ Call LL28 to calculate:
                        \
                        \   R = 256 * A / Q
                        \     = 256 * delta_y_lo / delta_x_lo

 JMP LL116              \ Jump to LL116, as we now have the line's gradient in R

.LL114

                        \ If we get here then our line is more vertical than
                        \ horizontal, so it is a steep slope

 LDA XX12+4             \ Set Q = delta_y_lo
 STA Q
 LDA XX12+2             \ Set A = delta_x_lo

 JSR LL28               \ Call LL28 to calculate:
                        \
                        \   R = 256 * A / Q
                        \     = 256 * delta_x_lo / delta_y_lo

 DEC T                  \ T was set to 0 above, so this sets T = &FF when our
                        \ line is steep

\ ******************************************************************************
\
\       Name: LL145 (Part 4 of 4)
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Clip line: Call the routine in LL188 to do the actual clipping
\  Deep dive: Line-clipping
\             Extended screen coordinates
\
\ ------------------------------------------------------------------------------
\
\ This part sets things up to call the routine in LL188, which does the actual
\ clipping.
\
\ If we get here, then R has been set to the gradient of the line (x1, y1) to
\ (x2, y2), with T indicating the gradient of slope:
\
\   * 0   = shallow slope (more horizontal than vertical)
\
\   * &FF = steep slope (more vertical than horizontal)
\
\ and XX13 has been set as follows:
\
\   * 0   = (x1, y1) off-screen, (x2, y2) on-screen
\
\   * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
\
\   * 191 = (x1, y1) off-screen, (x2, y2) off-screen
\
\ ******************************************************************************

.LL116

 LDA R                  \ Store the gradient in XX12+2
 STA XX12+2

 LDA S                  \ Store the type of slope in XX12+3, bit 7 clear means
 STA XX12+3             \ top left to bottom right, bit 7 set means top right to
                        \ bottom left

 LDA XX13               \ If XX13 = 0, skip the following instruction
 BEQ LL138

 BPL LLX117             \ If XX13 is positive, it must be 95. This means
                        \ (x1, y1) is on-screen but (x2, y2) isn't, so we jump
                        \ to LLX117 to swap the (x1, y1) and (x2, y2)
                        \ coordinates around before doing the actual clipping,
                        \ because we need to clip (x2, y2) but the clipping
                        \ routine at LL118 only clips (x1, y1)

.LL138

                        \ If we get here, XX13 = 0 or 191, so (x1, y1) is
                        \ off-screen and needs clipping

 JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the
                        \ screen, i.e. clip the line at the (x1, y1) end

 LDA XX13               \ If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
 BPL LL124              \ LL124 to return with a successfully clipped line

.LL117

                        \ If we get here, XX13 = 191 (both coordinates are
                        \ off-screen)

 LDA XX15+1             \ If either of x1_hi or y1_hi are non-zero, jump to
 ORA XX15+3             \ LL137 to return from the subroutine with the C flag
 BNE LL137              \ set, as the line doesn't fit on-screen

 LDA XX15+2             \ If y1_lo > y-coordinate of the bottom of the screen
 CMP #Y*2               \ jump to LL137 to return from the subroutine with the
 BCS LL137              \ C flag set, as the line doesn't fit on-screen

.LLX117

                        \ If we get here, XX13 = 95 or 191, and in both cases
                        \ (x2, y2) is off-screen, so we now need to swap the
                        \ (x1, y1) and (x2, y2) coordinates around before doing
                        \ the actual clipping, because we need to clip (x2, y2)
                        \ but the clipping routine at LL118 only clips (x1, y1)

 LDX XX15               \ Swap x1_lo = x2_lo
 LDA XX15+4
 STA XX15
 STX XX15+4

 LDA XX15+5             \ Swap x2_lo = x1_lo
 LDX XX15+1
 STX XX15+5
 STA XX15+1

 LDX XX15+2             \ Swap y1_lo = y2_lo
 LDA XX12
 STA XX15+2
 STX XX12

 LDA XX12+1             \ Swap y2_lo = y1_lo
 LDX XX15+3
 STX XX12+1
 STA XX15+3

 JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the
                        \ screen, i.e. clip the line at the (x1, y1) end

 DEC SWAP               \ Set SWAP = &FF to indicate that we just clipped the
                        \ line at the (x2, y2) end by swapping the coordinates
                        \ (the DEC does this as we set SWAP to 0 at the start of
                        \ this subroutine)

.LL124

 PLA                    \ Restore Y from the stack so it gets preserved through
 TAY                    \ the call to this subroutine

 JMP LL146              \ Jump up to LL146 to move the low bytes of (x1, y1) and
                        \ (x2, y2) into (X1, Y1) and (X2, Y2), and return from
                        \ the subroutine with a successfully clipped line

.LL137

 PLA                    \ Restore Y from the stack so it gets preserved through
 TAY                    \ the call to this subroutine

 SEC                    \ Set the C flag to indicate the clipped line does not
                        \ fit on-screen

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL9 (Part 11 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Add all visible edges to the ship line heap
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This part adds all the visible edges to the ship line heap, so we can draw
\ them in part 12.
\
\ Other entry points:
\
\   LL81+2              Draw the contents of the ship line heap, used to draw
\                       the ship as a dot from SHPPT
\
\ ******************************************************************************

.LL80

 LDY U                  \ Fetch the ship line heap pointer, which points to the
                        \ next free byte on the heap, into Y

 LDA XX15               \ Add X1 to the end of the heap
 STA (XX19),Y

 INY                    \ Increment the heap pointer

 LDA XX15+1             \ Add Y1 to the end of the heap
 STA (XX19),Y

 INY                    \ Increment the heap pointer

 LDA XX15+2             \ Add X2 to the end of the heap
 STA (XX19),Y

 INY                    \ Increment the heap pointer

 LDA XX15+3             \ Add Y2 to the end of the heap
 STA (XX19),Y

 INY                    \ Increment the heap pointer

 STY U                  \ Store the updated ship line heap pointer in U

 CPY T1                 \ If Y >= T1 then we have reached the maximum number of
 BCS LL81               \ edge lines that we can store in the ship line heap, so
                        \ skip to LL81 so we don't loop back for the next edge

.LL78

 INC XX17               \ Increment the edge counter to point to the next edge

 LDY XX17               \ If Y >= XX20, which contains the number of edges in
 CPY XX20               \ the blueprint, jump to LL81 as we have processed all
 BCS LL81               \ the edges and don't need to loop back for the next one

 LDY #0                 \ Set Y to point to byte #0 again, ready for the next
                        \ edge

 LDA V                  \ Increment V by 4 so V(1 0) points to the data for the
 ADC #4                 \ next edge
 STA V

 BCC ll81               \ If the above addition didn't overflow, jump to ll81 to
                        \ skip the following instruction

 INC V+1                \ Otherwise increment the high byte of V(1 0), as we
                        \ just moved the V(1 0) pointer past a page boundary

.ll81

 JMP LL75               \ Loop back to LL75 to process the next edge

.LL81

                        \ We have finished adding lines to the ship line heap,
                        \ so now we need to set the first byte of the heap to
                        \ the number of bytes stored there

 LDA U                  \ Fetch the ship line heap pointer from U into A, which
                        \ points to the end of the heap, and therefore contains
                        \ the heap size

 LDY #0                 \ Store A as the first byte of the ship line heap, so
 STA (XX19),Y           \ the heap is now correctly set up

\ ******************************************************************************
\
\       Name: LL9 (Part 12 of 12)
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw ship: Draw all the visible edges from the ship line heap
\  Deep dive: Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ This part draws the lines in the ship line heap, which is used both to draw
\ the ship, and to remove it from the screen.
\
\ ******************************************************************************

.LL155

 LDY #0                 \ Fetch the first byte from the ship line heap into A,
 LDA (XX19),Y           \ which contains the number of bytes in the heap

 STA XX20               \ Store the heap size in XX20

 CMP #4                 \ If the heap size is less than 4, there is nothing to
 BCC LL118-1            \ draw, so return from the subroutine (as LL118-1
                        \ contains an RTS)

 INY                    \ Set Y = 1, which we will use as an index into the ship
                        \ line heap, starting at byte #1 (as byte #0 contains
                        \ the heap size)

.LL27

 LDA (XX19),Y           \ Fetch the X1 line coordinate from the heap and store
 STA XX15               \ it in XX15

 INY                    \ Increment the heap pointer

 LDA (XX19),Y           \ Fetch the Y1 line coordinate from the heap and store
 STA XX15+1             \ it in XX15+1

 INY                    \ Increment the heap pointer

 LDA (XX19),Y           \ Fetch the X2 line coordinate from the heap and store
 STA XX15+2             \ it in XX15+2

 INY                    \ Increment the heap pointer

 LDA (XX19),Y           \ Fetch the Y2 line coordinate from the heap and store
 STA XX15+3             \ it in XX15+3

 JSR LL30               \ Draw a line from (X1, Y1) to (X2, Y2)

 INY                    \ Increment the heap pointer

 CPY XX20               \ If the heap counter is less than the size of the heap,
 BCC LL27               \ loop back to LL27 to draw the next line from the heap

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL118
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Move a point along a line until it is on-screen
\  Deep dive: Line-clipping
\
\ ------------------------------------------------------------------------------
\
\ Given a point (x1, y1), a gradient and a direction of slope, move the point
\ along the line until it is on-screen, so this effectively clips the (x1, y1)
\ end of a line to be on the screen.
\
\ See the deep dive on "Line-clipping" for more details.
\
\ Arguments:
\
\   XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
\
\   XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
\
\   XX12+2              The line's gradient * 256 (so 1.0 = 256)
\
\   XX12+3              The direction of slope:
\
\                         * Positive (bit 7 clear) = top left to bottom right
\
\                         * Negative (bit 7 set) = top right to bottom left
\
\   T                   The gradient of slope:
\
\                         * 0 if it's a shallow slope
\
\                         * &FF if it's a steep slope
\
\ Returns:
\
\   XX15                x1 as an 8-bit coordinate
\
\   XX15+2              y1 as an 8-bit coordinate
\
\ Other entry points:
\
\   LL118-1             Contains an RTS
\
\ ******************************************************************************

.LL118

 LDA XX15+1             \ If x1_hi is positive, jump down to LL119 to skip the
 BPL LL119              \ following

 STA S                  \ Otherwise x1_hi is negative, i.e. off the left of the
                        \ screen, so set S = x1_hi

 JSR LL120              \ Call LL120 to calculate:
                        \
                        \   (Y X) = (S x1_lo) * XX12+2      if T = 0
                        \         = x1 * gradient
                        \
                        \   (Y X) = (S x1_lo) / XX12+2      if T <> 0
                        \         = x1 / gradient
                        \
                        \ with the sign of (Y X) set to the opposite of the
                        \ line's direction of slope

 TXA                    \ Set y1 = y1 + (Y X)
 CLC                    \
 ADC XX15+2             \ starting with the low bytes
 STA XX15+2

 TYA                    \ And then adding the high bytes
 ADC XX15+3
 STA XX15+3

 LDA #0                 \ Set x1 = 0
 STA XX15
 STA XX15+1

 TAX                    \ Set X = 0 so the next instruction becomes a JMP

.LL119

 BEQ LL134              \ If x1_hi = 0 then jump down to LL134 to skip the
                        \ following, as the x-coordinate is already on-screen
                        \ (as 0 <= (x_hi x_lo) <= 255)

 STA S                  \ Otherwise x1_hi is positive, i.e. x1 >= 256 and off
 DEC S                  \ the right side of the screen, so set S = x1_hi - 1

 JSR LL120              \ Call LL120 to calculate:
                        \
                        \   (Y X) = (S x1_lo) * XX12+2      if T = 0
                        \         = (x1 - 256) * gradient
                        \
                        \   (Y X) = (S x1_lo) / XX12+2      if T <> 0
                        \         = (x1 - 256) / gradient
                        \
                        \ with the sign of (Y X) set to the opposite of the
                        \ line's direction of slope

 TXA                    \ Set y1 = y1 + (Y X)
 CLC                    \
 ADC XX15+2             \ starting with the low bytes
 STA XX15+2

 TYA                    \ And then adding the high bytes
 ADC XX15+3
 STA XX15+3

 LDX #255               \ Set x1 = 255
 STX XX15
 INX
 STX XX15+1

.LL134

                        \ We have moved the point so the x-coordinate is on
                        \ screen (i.e. in the range 0-255), so now for the
                        \ y-coordinate

 LDA XX15+3             \ If y1_hi is positive, jump down to LL119 to skip
 BPL LL135              \ the following

 STA S                  \ Otherwise y1_hi is negative, i.e. off the top of the
                        \ screen, so set S = y1_hi

 LDA XX15+2             \ Set R = y1_lo
 STA R

 JSR LL123              \ Call LL123 to calculate:
                        \
                        \   (Y X) = (S R) / XX12+2      if T = 0
                        \         = y1 / gradient
                        \
                        \   (Y X) = (S R) * XX12+2      if T <> 0
                        \         = y1 * gradient
                        \
                        \ with the sign of (Y X) set to the opposite of the
                        \ line's direction of slope

 TXA                    \ Set x1 = x1 + (Y X)
 CLC                    \
 ADC XX15               \ starting with the low bytes
 STA XX15

 TYA                    \ And then adding the high bytes
 ADC XX15+1
 STA XX15+1

 LDA #0                 \ Set y1 = 0
 STA XX15+2
 STA XX15+3

.LL135

 LDA XX15+2             \ Set (S R) = (y1_hi y1_lo) - screen height
 SEC                    \
 SBC #Y*2               \ starting with the low bytes
 STA R

 LDA XX15+3             \ And then subtracting the high bytes
 SBC #0
 STA S

 BCC LL136              \ If the subtraction underflowed, i.e. if y1 < screen
                        \ height, then y1 is already on-screen, so jump to LL136
                        \ to return from the subroutine, as we are done

.LL139

                        \ If we get here then y1 >= screen height, i.e. off the
                        \ bottom of the screen

 JSR LL123              \ Call LL123 to calculate:
                        \
                        \   (Y X) = (S R) / XX12+2      if T = 0
                        \         = (y1 - screen height) / gradient
                        \
                        \   (Y X) = (S R) * XX12+2      if T <> 0
                        \         = (y1 - screen height) * gradient
                        \
                        \ with the sign of (Y X) set to the opposite of the
                        \ line's direction of slope

 TXA                    \ Set x1 = x1 + (Y X)
 CLC                    \
 ADC XX15               \ starting with the low bytes
 STA XX15

 TYA                    \ And then adding the high bytes
 ADC XX15+1
 STA XX15+1

 LDA #Y*2-1             \ Set y1 = 2 * #Y - 1. The constant #Y is 96, the
 STA XX15+2             \ y-coordinate of the mid-point of the space view, so
 LDA #0                 \ this sets Y2 to 191, the y-coordinate of the bottom
 STA XX15+3             \ pixel row of the space view

.LL136

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL120
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (Y X) = (S x1_lo) * XX12+2 or (S x1_lo) / XX12+2
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
\
\   * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
\
\ giving (Y X) the opposite sign to the slope direction in XX12+3.
\
\ Arguments:
\
\   T                   The gradient of slope:
\
\                         * 0 if it's a shallow slope
\
\                         * &FF if it's a steep slope
\
\ Other entry points:
\
\   LL122               Calculate (Y X) = (S R) * Q and set the sign to the
\                       opposite of the top byte on the stack
\
\ ******************************************************************************

.LL120

 LDA XX15               \ Set R = x1_lo
 STA R

 JSR LL129              \ Call LL129 to do the following:
                        \
                        \   Q = XX12+2
                        \     = line gradient
                        \
                        \   A = S EOR XX12+3
                        \     = S EOR slope direction
                        \
                        \   (S R) = |S R|
                        \
                        \ So A contains the sign of S * slope direction

 PHA                    \ Store A on the stack so we can use it later

 LDX T                  \ If T is non-zero, then it's a steep slope, so jump
 BNE LL121              \ down to LL121 to calculate this instead:
                        \
                        \   (Y X) = (S R) / Q

.LL122

                        \ The following calculates:
                        \
                        \   (Y X) = (S R) * Q
                        \
                        \ using the same shift-and-add algorithm that's
                        \ documented in MULT1

 LDA #0                 \ Set A = 0

 TAX                    \ Set (Y X) = 0 so we can start building the answer here
 TAY

 LSR S                  \ Shift (S R) to the right, so we extract bit 0 of (S R)
 ROR R                  \ into the C flag

 ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag

 BCC LL126              \ If C (i.e. the next bit from Q) is clear, do not do
                        \ the addition for this bit of Q, and instead skip to
                        \ LL126 to just do the shifts

.LL125

 TXA                    \ Set (Y X) = (Y X) + (S R)
 CLC                    \
 ADC R                  \ starting with the low bytes
 TAX

 TYA                    \ And then doing the high bytes
 ADC S
 TAY

.LL126

 LSR S                  \ Shift (S R) to the right
 ROR R

 ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag

 BCS LL125              \ If C (i.e. the next bit from Q) is set, loop back to
                        \ LL125 to do the addition for this bit of Q

 BNE LL126              \ If Q has not yet run out of set bits, loop back to
                        \ LL126 to do the "shift" part of shift-and-add until
                        \ we have done additions for all the set bits in Q, to
                        \ give us our multiplication result

 PLA                    \ Restore A, which we calculated above, from the stack

 BPL LL133              \ If A is positive jump to LL133 to negate (Y X) and
                        \ return from the subroutine using a tail call

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL123
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (Y X) = (S R) / XX12+2 or (S R) * XX12+2
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
\
\   * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
\
\ giving (Y X) the opposite sign to the slope direction in XX12+3.
\
\ Arguments:
\
\   XX12+2              The line's gradient * 256 (so 1.0 = 256)
\
\   XX12+3              The direction of slope:
\
\                         * Bit 7 clear means top left to bottom right
\
\                         * Bit 7 set means top right to bottom left
\
\   T                   The gradient of slope:
\
\                         * 0 if it's a shallow slope
\
\                         * &FF if it's a steep slope
\
\ Other entry points:
\
\   LL121               Calculate (Y X) = (S R) / Q and set the sign to the
\                       opposite of the top byte on the stack
\
\   LL133               Negate (Y X) and return from the subroutine
\
\   LL128               Contains an RTS
\
\ ******************************************************************************

.LL123

 JSR LL129              \ Call LL129 to do the following:
                        \
                        \   Q = XX12+2
                        \     = line gradient
                        \
                        \   A = S EOR XX12+3
                        \     = S EOR slope direction
                        \
                        \   (S R) = |S R|
                        \
                        \ So A contains the sign of S * slope direction

 PHA                    \ Store A on the stack so we can use it later

 LDX T                  \ If T is non-zero, then it's a steep slope, so jump up
 BNE LL122              \ to LL122 to calculate this instead:
                        \
                        \   (Y X) = (S R) * Q

.LL121

                        \ The following calculates:
                        \
                        \   (Y X) = (S R) / Q
                        \
                        \ using the same shift-and-subtract algorithm that's
                        \ documented in TIS2

 LDA #%11111111         \ Set Y = %11111111
 TAY

 ASL A                  \ Set X = %11111110
 TAX

                        \ This sets (Y X) = %1111111111111110, so we can rotate
                        \ through 15 loop iterations, getting a 1 each time, and
                        \ then getting a 0 on the 16th iteration... and we can
                        \ also use it to catch our result bits into bit 0 each
                        \ time

.LL130

 ASL R                  \ Shift (S R) to the left
 ROL S

 LDA S                  \ Set A = S

 BCS LL131              \ If bit 7 of S was set, then jump straight to the
                        \ subtraction

 CMP Q                  \ If A < Q (i.e. S < Q), skip the following subtractions
 BCC LL132

.LL131

 SBC Q                  \ A >= Q (i.e. S >= Q) so set:
 STA S                  \
                        \   S = (A R) - Q
                        \     = (S R) - Q
                        \
                        \ starting with the low bytes (we know the C flag is
                        \ set so the subtraction will be correct)

 LDA R                  \ And then doing the high bytes
 SBC #0
 STA R

 SEC                    \ Set the C flag to rotate into the result in (Y X)

.LL132

 TXA                    \ Rotate the counter in (Y X) to the left, and catch the
 ROL A                  \ result bit into bit 0 (which will be a 0 if we didn't
 TAX                    \ do the subtraction, or 1 if we did)
 TYA
 ROL A
 TAY

 BCS LL130              \ If we still have set bits in (Y X), loop back to LL130
                        \ to do the next iteration of 15, until we have done the
                        \ whole division

 PLA                    \ Restore A, which we calculated above, from the stack

 BMI LL128              \ If A is negative jump to LL128 to return from the
                        \ subroutine with (Y X) as is

.LL133

 TXA                    \ Otherwise negate (Y X) using two's complement by first
 EOR #%11111111         \ setting the low byte to ~X + 1
 ADC #1                 \
 TAX                    \ The addition works as we know the C flag is clear from
                        \ when we passed through the BCS above

 TYA                    \ Then set the high byte to ~Y + C
 EOR #%11111111
 ADC #0
 TAY

.LL128

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LL129
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate Q = XX12+2, A = S EOR XX12+3 and (S R) = |S R|
\
\ ------------------------------------------------------------------------------
\
\ Do the following, in this order:
\
\   Q = XX12+2
\
\   A = S EOR XX12+3
\
\   (S R) = |S R|
\
\ This sets up the variables required above to calculate (S R) / XX12+2 and give
\ the result the opposite sign to XX13+3.
\
\ ******************************************************************************

.LL129

 LDX XX12+2             \ Set Q = XX12+2
 STX Q

 LDA S                  \ If S is positive, jump to LL127
 BPL LL127

 LDA #0                 \ Otherwise set R = -R
 SEC
 SBC R
 STA R

 LDA S                  \ Push S onto the stack
 PHA

 EOR #%11111111         \ Set S = ~S + 1 + C
 ADC #0
 STA S

 PLA                    \ Pull the original, negative S from the stack into A

.LL127

 EOR XX12+3             \ Set A = original argument S EOR'd with XX12+3

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: n_buyship
\       Type: Subroutine
\   Category: Buying ships
\    Summary: Show the Buy Ship screen (CTRL-f3)
\  Deep dive: Buying and flying ships in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   cash_query          Print "CASH?", make a short, high beep, delay for 1
\                       second and go to the docking bay (i.e. show the Status
\                       Mode screen)
\
\   jmp_start3          Make a short, high beep, and delay for 1 second and go
\                       to the docking bay (i.e. show the Status Mode screen)
\
\ ******************************************************************************

.n_buyship

 LDX #0                 \ Set a counter in X so we can work our way through the
                        \ available ships, starting with X = 0, and working our
                        \ way through the types in the new_ships table (where
                        \ the ships are in order of increasing price)

 SEC                    \ Set QQ25 = 15 - 2 * QQ28
 LDA #15                \
 SBC QQ28               \ QQ25 contains the number of ship types that we offer
 SBC QQ28               \ for sale, so the number is smaller in less advanced
 STA QQ25               \ economies, and ranges from 15 ship types for rich
                        \ industrial economies, down to 1 for poor agricultural
                        \ economies

.n_bloop

 STX XX13               \ Store the loop counter X in XX13 so we can retrieve it
                        \ after the call to TT67, and throughout the following

 JSR TT67               \ Print a newline

 LDX XX13               \ Set X = XX13 + 1, so X contains 1 for the first ship
 INX                    \ type, 2 for the second ship type, and so on

 CLC                    \ Clear the C flag so the call to pr2 doesn't show a
                        \ decimal point

 JSR pr2                \ Call pr2 to print the number in X to a width of 3
                        \ 3 figures, so this prints the item number at the start
                        \ of the menu item, starting with item 1 at the top

 JSR TT162              \ Print a space

 LDY XX13               \ Print the name of the ship type given in XX13
 JSR n_name

 LDY XX13               \ Set K(3 2 1 0) to the price of the ship given in XX13
 JSR n_price

 LDA #22                \ Move the text cursor to column 22
 STA XC

 LDA #9                 \ We want to print the ship price using up to 9 digits
 STA U                  \ (including the decimal point), so store this in U
                        \ for BRPNT to take as an argument

 SEC                    \ We want to print the price with a decimal point,
                        \ so set the C flag for BRPNT to take as an argument

 JSR BPRNT              \ Print the amount of cash to 9 digits with a decimal
                        \ point

 LDX XX13               \ Fetch the loop counter from XX13

 INX                    \ Increment the loop counter

 CPX QQ25               \ Loop back to n_bloop until we have shown the first
 BCC n_bloop            \ QQ25 ship types (ordered by price)

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

 LDA #185               \ Print recursive token 25 ("SHIP") followed by a
 JSR prq                \ question mark

 JSR gnum               \ Call gnum to get a number from the keyboard, which
                        \ will be the menu item number of the ship we want to
                        \ buy, returning the number entered in A and R, and
                        \ setting the C flag if the number is bigger than the
                        \ highest menu item number in QQ25

 BEQ jmp_start3         \ If no number was entered, jump to jmp_start3 to make a
                        \ beep and show the cargo bay

 BCS jmp_start3         \ If the number entered was too big, jump to jmp_start3
                        \ to make a beep and show the cargo bay

 SBC #0                 \ Set A = A - 1 (as we know the C flag is clear)

 CMP QQ25               \ If A >= QQ25 then the number entered is bigger than
 BCS jmp_start3         \ the number of entries in the menu, so jump to
                        \ jmp_start3 to make a beep and show the cargo bay

 LDX #2                 \ Move the text cursor to column 2
 STX XC

 INC YC                 \ Move the text cursor down one line

 STA Q                  \ Set INWK to the number of the ship type we want to buy

 LDY cmdr_type          \ Set K(0 1 2 3) to the price of our current ship, whose
 JSR n_price            \ type is in new_type

                        \ We now want to do the following 32-bit addition:
                        \
                        \   XX16(0 1 2 3) = CASH(0 1 2 3) + K(0 1 2 3)
                        \
                        \ so XX16 contains the cash pot after we get a refund
                        \ for the price of our existing ship

 CLC                    \ Clear the C flag for the addition below

 LDX #3                 \ Set a counter in X to loop through the four bytes in
                        \ the addition

.n_addl

 LDA CASH,X             \ Add the X-th bytes of CASH and K and store the result
 ADC K,X                \ in the X-th byte of XX16
 STA XX16,X

 DEX                    \ Decrement the loop counter

 BPL n_addl             \ Loop back until we have added all four bytes

 LDY Q                  \ Fetch the number of the ship type that we want to buy
                        \ into Y

 JSR n_price            \ Set K(0 1 2 3) to the price of the ship we want to buy

                        \ We now want to do the following 32-bit subtraction:
                        \
                        \   K(0 1 2 3) = XX16(0 1 2 3) - K(0 1 2 3)
                        \
                        \ so K(0 1 2 3) contains the cash we have left after we
                        \ buy our new ship

 SEC                    \ Set the C flag for the subtraction below

 LDX #3                 \ Set a counter in X to loop through the four bytes in
                        \ the subtraction

.n_subl

 LDA XX16,X             \ Subtract the X-th byte of K from the X-th byte of XX16
 SBC K,X                \ and store the result in the X-th byte of K
 STA K,X

 DEX                    \ Decrement the loop counter

 BPL n_subl             \ Loop back until we have subtracted all four bytes

 LDA Q                  \ Fetch the number of the ship type that we just bought
                        \ into A

 BCS n_buy              \ If the subtraction didn't underflow, then we have
                        \ enough cash after the refund to buy the ship, so jump
                        \ to n_buy to skip the following

.cash_query

 LDA #197               \ We don't have enough cash to buy this ship, so print
 JSR prq                \ recursive token 37 ("CASH") followed by a question
                        \ mark

.jmp_start3

 JSR dn2                \ Call dn2 to make a short, high beep and delay for 1
                        \ second

 JMP BAY                \ Jump to BAY to go to the docking bay (i.e. show the
                        \ Status Mode screen)

.n_buy

 TAX                    \ Store the number of the ship type that we just bought
                        \ in X

 LDY #3                 \ As the transaction has gone through, we now update our
                        \ cash levels in CASH(0 1 2 3) to the amount we have
                        \ left after buying our new ship, which is in K(0 1 2 3)

.n_cpyl

 LDA K,Y                \ Copy the Y-th byte of K(0 1 2 3) to the Y-th byte of
 STA CASH,Y             \ CASH(0 1 2 3)

 DEY                    \ Decrement the loop counter

 BPL n_cpyl             \ Loop back until we have copied all four bytes

                        \ Next we want to reset the current ship's equipment, so
                        \ we start with nothing and don't carry anything over
                        \ from our previous ship, and we also want to reset
                        \ any special cargo missions, as well as our legal
                        \ status (so buying a new ship is a good way to get the
                        \ law off our backs)

 LDA #0                 \ Set A = 0 so we can use it to zero the settings

 LDY #36                \ We want to zero everything from LASER (the start of
                        \ our current ship's equipment table) to LASER+36 (our
                        \ legal status in FIST), so set Y as an index, starting
                        \ at 36

.n_wipe

 STA LASER,Y            \ Zero the Y-th byte of the block starting with LASER

 DEY                    \ Decrement the index

 BPL n_wipe             \ Loop back until we have zeroed from LASER+36 down to
                        \ LASER+0

 STX cmdr_type          \ Store the type of ship we just bought in cmdr_type, to
                        \ set our current ship type to our new purchase

 JSR n_load             \ Call n_load to load the flight characteristics and set
                        \ the name token for our new ship

 LDA new_range          \ Set our fuel level in QQ14 to the hyperspace range of
 STA QQ14               \ our new ship, so our new ship comes with a full tank

 JSR msblob             \ Reset the dashboard's missile indicators so they show
                        \ the correct number of missiles fitted to our new ship
                        \ (which will be zero)

 JSR update_pod         \ Update the dashboard colours to reflect whether we
                        \ have an escape pod fitted to our new ship (which we
                        \ don't)

 JMP BAY                \ Jump to BAY to go to the docking bay (i.e. show the
                        \ Status Mode screen)

\ ******************************************************************************
\
\       Name: n_load
\       Type: Subroutine
\   Category: Buying ships
\    Summary: Load the name and flight characteristics for the current ship type
\  Deep dive: Buying and flying ships in Elite-A
\
\ ******************************************************************************

.n_load

 LDY cmdr_type          \ Set Y to the type of our current ship, which is stored
                        \ in new_type

 LDX new_offsets,Y      \ Set X to the offset, measured from new_ships, for this
                        \ ship's details block, so X now points to the offset of
                        \ the first character of the ship's type in the
                        \ new_ships table, as well as the first byte of flight
                        \ characteristics data in new_details

 LDY #0                 \ We now want to do two things:
                        \
                        \   * Update extended text token 132 in the QQ18 table
                        \     with the name of the ship type, so that printing
                        \     token 132 always shows the current ship type
                        \
                        \   * Copy the flight characteristics of the specified
                        \     ship type from the new_details table to our
                        \     current ship data block, which is stored between
                        \     new_pulse and new_max
                        \
                        \ We can do these two at the same time in one loop, so
                        \ set a counter in Y to count through the above

.n_lname

 CPY #9                 \ If Y >= 9, jump to n_linfo to skip copying the name,
 BCS n_linfo            \ as the ship type contains a maximum of 9 characters or
                        \ tokens, and there are more than 9 bytes of flight
                        \ characteristics data

 LDA new_ships,X        \ Set A to the character/token we want to fetch from
                        \ the new_ships table

 EOR #RE                \ Tokens in the new_ships table are stored as token
                        \ numbers that are not EOR'd with RE, but the extended
                        \ text token table at QQ18 expects all tokens to be
                        \ obfuscated, so we add the obfuscation here

 STA new_name,Y         \ Store the obfuscated character/token into extended
                        \ text token 132 at the Y-th character of new_name

.n_linfo

                        \ We now want to copy the flight characteristics data
                        \ for this ship type

 LDA new_details,X      \ Set A to the flight characteristic byte we want to
                        \ fetch from the new_details table

 STA new_pulse,Y        \ And store it in the Y-th byte of the new_pulse block
                        \ to set our current ship accordingly

 INX                    \ Increment the offset so we can fetch the next
                        \ character (for the name) and the next byte (for the
                        \ flight characteristics)

 INY                    \ Increment the loop counter

 CPY #13                \ If Y < 13 then we still have data to copy, so loop
 BNE n_lname            \ back to n_lname until we have copied 9 characters from
                        \ the name and 13 bytes of flight characteristics

 LDA new_max            \ Set the minimum roll/pitch rate in new_min to 255 -
 EOR #%11111110         \ the maximum roll/pitch rate, which we can achieve
 STA new_min            \ by EOR'ing with %11111110

 LDY #11                \ We now work our way through the equipment that takes
                        \ up space in the hold, and reduce the amount of free
                        \ space for each item on the list that is fitted. The
                        \ items that take up space are defined in the count_offs
                        \ table, so set a counter in Y so we can work our way
                        \ through the table, checking each of the items in turn

.count_lasers

 LDX count_offs,Y       \ Set X to the Y-th entry in the count_offs table, which
                        \ contains offsets from LASER for each of the equipment
                        \ items that take up space in the hold

 LDA LASER,X            \ Check whether we have this item fitted, by testing
 BEQ count_sys          \ whether LASER+X is zero, and if it is, then this item
                        \ is not fitted, so skip the following instruction

 DEC new_hold           \ The item at offset X is fitted, so decrement the free
                        \ space in new_hold

.count_sys

 DEY                    \ Decrement the loop counter in Y

 BPL count_lasers       \ Loop back to process the next item of equipment until
                        \ we have checked them all and reduced the free space
                        \ accordingly

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: count_offs
\       Type: Variable
\   Category: Buying ships
\    Summary: Offsets from LASER for equipment that takes up space in the hold
\
\ ******************************************************************************

.count_offs

 EQUB 0                 \ LASER+0 = Front laser
 EQUB 1                 \ LASER+1 = Rear laser
 EQUB 2                 \ LASER+2 = Left laser
 EQUB 3                 \ LASER+3 = Right laser
 EQUB 6                 \ LASER+6 = CRGO = I.F.F. system
 EQUB 24                \ LASER+24 = ECM = E.C.M. system
 EQUB 25                \ LASER+25 = BST = Fuel scoops
 EQUB 26                \ LASER+26 = BOMB = Hyperspace unit
 EQUB 27                \ LASER+27 = ENGY = Energy unit
 EQUB 28                \ LASER+28 = DKCMP = Docking computer
 EQUB 29                \ LASER+29 = GHYP = Galactic hyperdrive
 EQUB 30                \ LASER+30 = ESCP = Escape pod

\ ******************************************************************************
\
\       Name: n_name
\       Type: Subroutine
\   Category: Text
\    Summary: Print the type of a given ship
\  Deep dive: Buying and flying ships in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The ship type number, in the range 0 to 14, as defined
\                       in the new_ships table
\
\ ******************************************************************************

.n_name

 LDX new_offsets,Y      \ Set X to the offset, measured from new_ships, for this
                        \ ship's details block, so X now points to the offset of
                        \ the first character of the ship's type in the
                        \ new_ships table

 LDA #9                 \ Each ship type consists of exactly 9 characters
 STA K+1                \ (including spaces), so set K+1 = 9 as a character
                        \ counter in the following loop

.n_lprint

 LDA new_ships,X        \ Set A to the character we want to print from the
                        \ new_ships table

 STX K                  \ Store the offset in K so we can retrieve it after the
                        \ call to TT27

 JSR TT27               \ Call TT27 to print the text token in A

 LDX K                  \ Restore the offset from K back into X

 INX                    \ Increment X to point to the next character

 DEC K+1                \ Decrement the character counter in K+1

 BNE n_lprint           \ Loop back to print the next character until we have
                        \ printed all 9 of them

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: n_price
\       Type: Subroutine
\   Category: Buying ships
\    Summary: Set K(0 1 2 3) to the price of a given ship
\  Deep dive: Buying and flying ships in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ This routine fetches the ship price from the new_price table, where prices are
\ stored in the standard little-endian manner of 6502 assembly (i.e. using an
\ EQUD), and copies it in to K(0 1 2 3), which is a big-endian number like the
\ CASH variable.
\
\ Arguments:
\
\   Y                   The ship type number, in the range 0 to 14, as defined
\                       in the new_ships table
\
\ ******************************************************************************

.n_price

 LDX new_offsets,Y      \ Set X to the offset, measured from new_price, for this
                        \ ship's details block, so X now points to the offset of
                        \ the ship's price in the new_ships table

 LDY #3                 \ Each ship price consists of exactly four bytes (as it
                        \ is a 32-bit number), so set Y = 3 to act as a byte
                        \ counter in the following loop

.n_lprice

 LDA new_price,X        \ Set A to X-th byte of the ship's price from the
                        \ new_ships table

 STA K,Y                \ Store it in the X-th byte of K(0 1 2 3)

 INX                    \ Increment X to point to the next price byte

 DEY                    \ Decrement the byte counter

 BPL n_lprice           \ Loop back to copy the next byte until we have copied
                        \ all 4 of them

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: cour_buy
\       Type: Subroutine
\   Category: Missions
\    Summary: Show the Special Cargo screen (CTRL-f1)
\  Deep dive: Special cargo missions
\
\ ******************************************************************************

.cour_buy

 LDA cmdr_cour          \ If there is no special cargo delivery mission in
 ORA cmdr_cour+1        \ progress, then the mission reward in cmdr_cour(1 0)
 BEQ cour_start         \ will be zero, so jump to cour_start to skip the next
                        \ instruction

 JMP jmp_start3         \ There is already a special cargo delivery mission in
                        \ progress, so jump to jmp_start3 to make a beep and
                        \ show the cargo bay

.cour_start

 LDA #10                \ Move the text cursor to column 10
 STA XC

 LDA #111               \ Print extended recursive token 111 ("{all caps}SPECIAL
 JSR DETOK              \ CARGO")

 JSR NLIN4              \ Draw a horizontal line at pixel row 19 to box in the
                        \ title

 LDA #%10000000         \ Set bit 7 of QQ17 to switch standard tokens to
 STA QQ17               \ Sentence Case

 LDA QQ26               \ Set INWK = the random market seed for this system in
 EOR QQ0                \ QQ26, EOR'd with the current system's galactic
 EOR QQ1                \ x-coordinate in QQ0, the current system's galactic
 EOR FIST               \ y-coordinate in QQ1, our legal status in FIST, and
 EOR TALLY              \ the low byte of our combat rank, which should give us
 STA INWK               \ a pretty random number that will stay the same until
                        \ we leave the station
                        \
                        \ We use this to determine the number of systems to skip
                        \ when generating the first delivery mission in the menu

 SEC                    \ Set INWK+1 = 1 + our legal status in FIST + the
 LDA FIST               \ current galaxy number in GCNT + the type of our
 ADC GCNT               \ current ship in cmdr_type, which again will give us
 ADC cmdr_type          \ a random number that will stay the same until we
 STA INWK+1             \ leave the station, as well as randomising the C flag
                        \
                        \ We use this to determine the number of systems to skip
                        \ when generating subsequent delivery missions in the
                        \ menu

 ADC INWK               \ Set QQ25 = INWK+1 + INWK + C - cmdr_courx - cmdr_coury
 SBC cmdr_courx         \
 SBC cmdr_coury         \ where (cmdr_courx, cmdr_coury) are the coordinates of
 AND #15                \ the previous special cargo delivery destination (which
 STA QQ25               \ will be (0, 0) if this is the first) and reduce the
                        \ result to be in the range 0 to 15
                        \
                        \ We use this to determine the maximum number of
                        \ delivery missions in the menu

 BEQ cour_pres          \ If the value of QQ25 = 0, jump to cour_pres to make a
                        \ beep and show the cargo bay (as QQ25 contains the
                        \ number of missions in the menu, so if it's zero we
                        \ have nothing more to do)

 LDA #0                 \ Set INWK+3 = 0 to act as a counter of the number of
 STA INWK+3             \ delivery missions we have displayed in the menu so far

 STA INWK+6             \ Set INWK+6 = 0 to act as a system counter that runs
                        \ from 0 to 255 as we work our way through all the
                        \ systems in the galaxy

 JSR TT81               \ Set the seeds in QQ15 to those of system 0 in the
                        \ current galaxy (i.e. copy the seeds from QQ21 to QQ15)

                        \ We now iterate around the cour_loop loop, working our
                        \ way through systems in the galaxy and picking suitable
                        \ destinations for display in the Special Cargo menu. We
                        \ use the following counters as we go:
                        \
                        \   * QQ25 contains the maximum number of delivery
                        \     missions to display in the menu
                        \
                        \   * INWK is the number of systems we skip past for the
                        \     very first menu item, when generating destinations
                        \     in cour_count
                        \
                        \   * INWK+1 is the number of systems we skip past for
                        \     subsequent menu items, when generating
                        \     destinations in cour_count
                        \
                        \   * INWK+3 counts the number of delivery missions we
                        \     have already displayed in the menu, starting at 0
                        \
                        \   * INWK+6 contains the system number we are currently
                        \     considering, starting at 0 and working through to
                        \     255, at which point we are done (even if we
                        \     haven't managed to find QQ25 delivery missions)

.cour_loop

 LDA INWK+3             \ If INWK+3 < QQ25 then call cour_count to add another
 CMP QQ25               \ destination to the menu, as we have not yet shown QQ25
 BCC cour_count         \ delivery missions in the menu (cour_count ends with a
                        \ jump back to cour_loop)

.cour_menu

                        \ If we get here then we have either got QQ25 items in
                        \ the menu, or we have worked our way through the whole
                        \ galaxy, so in either case we have finished displaying
                        \ the menu of destinations, and we want to process the
                        \ choice

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

 LDA #206               \ Print recursive token 46 (" CARGO{sentence case}")
 JSR prq                \ followed by a question mark

 JSR gnum               \ Call gnum to get a number from the keyboard, which
                        \ will be the menu item number of the mission we want to
                        \ take, returning the number entered in A and R, and
                        \ setting the C flag if the number is bigger than the
                        \ highest menu item number in QQ25

 BEQ cour_pres          \ If no number was entered, jump to cour_pres to make a
                        \ beep and show the cargo bay

 BCS cour_pres          \ If the number entered was too big, jump to cour_pres
                        \ to make a beep and show the cargo bay

 TAX                    \ Set X = A - 1, so X is now 0 if we picked the first
 DEX                    \ destination, 1 if we picked the second, and so on

 CPX INWK+3             \ If X >= INWK+3 then the number entered is bigger than
 BCS cour_pres          \ the number of entries in the menu, so jump to
                        \ cour_pres to make a beep and show the cargo bay

 LDA #2                 \ Move the text cursor to column 2
 STA XC

 INC YC                 \ Move the text cursor down one line

 STX INWK               \ Set INWK to the number of the chosen mission

 LDY &0C50,X            \ Set (Y X) to the cost of this mission in
 LDA &0C40,X            \ (&0C50+X &0C40+X)
 TAX

 JSR LCASH              \ Subtract (Y X) cash from the cash pot, but only if
                        \ we have enough cash

 BCS cour_cash          \ If the transaction was successful, we have just bought
                        \ ourselves a delivery mission, so jump to cour_cash

 JMP cash_query         \ Otherwise we didn't have enough cash, so jump to
                        \ cash_query to print "CASH?", make a short, high beep,
                        \ delay for 1 second and go to the docking bay (i.e.
                        \ show the Status Mode screen)

.cour_cash

                        \ We have now taken on the delivery mission, so we need
                        \ to set variables that govern the mission progress,
                        \ i.e. the destination and the mission reward

 LDX INWK               \ Set X to the number of the chosen mission which we
                        \ stored in INWK above

 LDA &0C00,X            \ Set cmdr_courx to the galactic x-coordinate of the
 STA cmdr_courx         \ destination of the chosen mission, which we stored in
                        \ &0C00+X when setting up the menu

 LDA &0C10,X            \ Set cmdr_coury to the galactic y-coordinate of the
 STA cmdr_coury         \ destination of the chosen mission, which we stored in
                        \ &0C10+X when setting up the menu

 CLC                    \ When setting up the menu, we set &0C20+X to the legal
 LDA &0C20,X            \ status of taking this mission, so we add this value to
 ADC FIST               \ our legal status in FIST, so taking on dodgy delivery
 STA FIST               \ missions adversely affects our legal status

 LDA &0C30,X            \ Set the mission reward in cmdr_cour(1 0) to the value
 STA cmdr_cour+1        \ we set in (&0C30+X &0C40+X) when setting up the menu
 LDA &0C40,X
 STA cmdr_cour

.cour_pres

 JMP jmp_start3         \ Jump to jmp_start3 to make a beep and show the cargo
                        \ bay

\ ******************************************************************************
\
\       Name: cour_count
\       Type: Subroutine
\   Category: Missions
\    Summary: Generate a single special cargo mission and display its menu item
\  Deep dive: Special cargo missions
\
\ ******************************************************************************

.cour_count

                        \ If we get here then we want to display another item
                        \ in the menu, so first we need to skip our way through
                        \ the number of systems given in INWK

 JSR TT20               \ We want to move on to the next system, so call TT20
                        \ to twist the three 16-bit seeds in QQ15

 INC INWK+6             \ We also increment the counter in INWK+6 to point to
                        \ the next system

 BEQ cour_menu          \ If INWK+6 has wrapped around back to 0, then we have
                        \ worked our way through the entire galaxy, so jump to
                        \ cour_menu to display the menu

 DEC INWK               \ Loop back to keep twisting the seeds until we have
 BNE cour_count         \ stepped through the number of systems in INWK

                        \ We now have a system that we can consider for
                        \ inclusion in the destination menu

 LDX INWK+3             \ Set X = INWK+3, which counts the number of delivery
                        \ missions we have already displayed in the menu, and
                        \ which we can use as an index when populating the menu
                        \ data in &0C00 below

 LDA QQ15+3             \ Fetch the s1_hi seed of the system we are considering
                        \ adding to the menu into A, which gives us the galactic
                        \ x-coordinate of the system we are considering

 CMP QQ0                \ If the x-coordinate of the system we are considering
 BNE cour_star          \ is different to the current system's galactic
                        \ x-coordinate in QQ0, then jump to cour_star to keep
                        \ going

 LDA QQ15+1             \ Fetch the s0_hi seed of the system we are considering
                        \ adding to the menu into A, which gives us the galactic
                        \ y-coordinate of the system we are considering

 CMP QQ1                \ If the y-coordinate of the system we are considering
 BNE cour_star          \ is different to the current system's galactic
                        \ y-coordinate in QQ1, then jump to cour_star to keep
                        \ going

 JMP cour_next          \ If we get here then the system we are considering has
                        \ the same coordinates as the current system, and we
                        \ can't offer a cargo mission to the system we are
                        \ already in, so jump to cour_next to move onto the next
                        \ system

.cour_star

                        \ If we get here then this destination is a suitable
                        \ system for a delivery mission, so we now want to add
                        \ the destination's data to the block at &0C00, which is
                        \ where we build up the menu data
                        \
                        \ We build up the data as follows, where X is the number
                        \ of the menu item (0-15):
                        \
                        \   * &0C00+X = x-coordinate of the delivery destination
                        \   * &0C10+X = y-coordinate of the delivery destination
                        \   * &0C20+X = legal status of the delivery mission
                        \   * &0C30+X = high byte of the mission reward
                        \   * &0C40+X = low byte of the mission reward
                        \               low byte of the mission cost
                        \   * &0C50+X = high byte of the mission cost
                        \
                        \ In other words, when we take on a mission, the reward
                        \ in cmdr_cour(1 0) is set to (&0C30+X &0C40+X), we pay
                        \ the mission cost of (&0C50+X &0C40+X), and our legal
                        \ status goes up by the amount in &0C20+X

 LDA QQ15+3             \ Set A = s1_hi EOR s2_hi EOR INWK+1
 EOR QQ15+5             \
 EOR INWK+1             \ which is a pretty random number based on the seeds for
                        \ the destination system, plus the random INWK+1 that we
                        \ generated above

 CMP FIST               \ If A < FIST then jump to cour_legal, so we will only
 BCC cour_legal         \ jump if FIST is non-zero, with a bigger chance of
                        \ jumping if we've been bad

 LDA #0                 \ We have either been very good or very lucky, so set
                        \ A = 0 to indicate that this delivery mission is legit

.cour_legal

 STA &0C20,X            \ Store A in the X-th byte of &0C20, which is the legal
                        \ status of this delivery mission (A = 0 means it's
                        \ legit, while higher numbers are increasingly bad)

 LDA QQ15+3             \ Set the X-th byte of &0C00 to s1_hi, the galactic
 STA &0C00,X            \ x-coordinate of the delivery destination

                        \ We need to calculate the distance from the current
                        \ system to the delivery destination, as the mission
                        \ reward is based on the distance of the delivery (as
                        \ well as the legality of the mission)
                        \
                        \ We do this using Pythagoras, so let's denote the
                        \ current system's coordinates as (current_x, current_y)
                        \ and the delivery destination's coordinates as
                        \ (destination_x, destination_y)

 SEC                    \ Set A = A - QQ0
 SBC QQ0                \       = destination_x - current_x

 BCS cour_negx          \ If the subtraction didn't underflow, jump to cour_negx

 EOR #&FF               \ The subtraction underflowed, so negate the result
 ADC #1                 \ using two's complement, so we know A is positive, i.e.
                        \
                        \   A = |destination_x - current_x|

.cour_negx

 JSR SQUA2              \ Set K(1 0) = A * A
 STA K+1                \            = |destination_x - current_x| ^ 2
 LDA P
 STA K

 LDX INWK+3             \ Set X = INWK+3 again, so we can use as an index when
                        \ populating the menu data in &0C00

 LDA QQ15+1             \ Set the X-th byte of &0C10 to s0_hi, the galactic
 STA &0C10,X            \ y-coordinate of the delivery destination

 SEC                    \ Set A = A - QQ1
 SBC QQ1                \       = destination_y - current_y

 BCS cour_negy          \ If the subtraction didn't underflow, jump to cour_negy

 EOR #&FF               \ The subtraction underflowed, so negate the result
 ADC #1                 \ using two's complement, so we know A is positive, i.e.
                        \
                        \   A = |destination_y - current_y|

.cour_negy

 LSR A                  \ Set A = A / 2

                        \ A now contains the difference between the two
                        \ systems' y-coordinates, with the sign removed, and
                        \ halved. We halve the value because the galaxy in
                        \ Elite is rectangular rather than square, and is
                        \ twice as wide (x-axis) as it is high (y-axis), so to
                        \ get a distance that matches the shape of the
                        \ long-range galaxy chart, we need to halve the
                        \ distance between the vertical y-coordinates

 JSR SQUA2              \ Set (A P) = A * A
                        \           = (|destination_y - current_y| / 2) ^ 2

                        \ We now want to add the two so we can then apply
                        \ Pythagoras, so first we do this:
                        \
                        \   (R Q) = K(1 0) + (A P))
                        \         =    |destination_x - current_x| ^ 2
                        \           + (|destination_y - current_y| / 2) ^ 2
                        \
                        \ and then the distance will be the square root:
                        \
                        \   Q = SQRT(R Q)

 PHA                    \ Store the high byte of the result on the stack

 LDA P                  \ Set Q = P + K
 CLC                    \
 ADC K                  \ which adds the low bytes
 STA Q

 PLA                    \ Set R = A + K+1
 ADC K+1                \
 STA R                  \ which adds the high bytes

 JSR LL5                \ Set Q = SQRT(R Q), so Q now contains the distance
                        \ between the two systems, in terms of coordinates,
                        \ which we can use to determine the reward for this
                        \ delivery mission

 LDX INWK+3             \ Set X = INWK+3 again, so we can use as an index when
                        \ populating the menu data in &0C00

 LDA QQ15+1             \ Set A = (s0_hi EOR s2_hi EOR INWK+1) / 8
 EOR QQ15+5             \
 EOR INWK+1             \ which is another pretty random number based on the
 LSR A                  \ seeds for the destination system, plus the random
 LSR A                  \ INWK+1 that we generated above
 LSR A

 CMP Q                  \ If A >= Q then skip the following
 BCS cour_dist

 LDA Q                  \ A < Q, so set A = Q, so A has a minimum value of Q,
                        \ i.e. our mission reward is always at least the
                        \ distance we have to travel

.cour_dist

 ORA &0C20,X            \ We now OR this value with the legal status of this
                        \ delivery mission, so a legit mission (which has a
                        \ status of 0) will not change the value in A, but more
                        \ dangerous missions will bump the value up, with a
                        \ higher premium paid for more illegal missions

 STA &0C30,X            \ Set the X-th byte of &0C30 to A, which we use as the
                        \ high byte of the mission reward

 STA INWK+4             \ Set INWK(5 4) = (A A) / 8
 LSR A                  \
 ROR INWK+4             \ which we use as the mission cost (i.e. the amount of
 LSR A                  \ cash we have to part with in order to take on the
 ROR INWK+4             \ delivery mission)
 LSR A
 ROR INWK+4
 STA INWK+5

 STA &0C50,X            \ Store INWK+5 in the X-th byte of &0C50, so it contains
                        \ the high byte of the mission cost

 LDA INWK+4             \ Store INWK+4 in the X-th byte of &0C40, so it contains
 STA &0C40,X            \ the low byte of the mission cost (and the low byte of
                        \ the mission reward, as they share the same value)

 LDA #1                 \ Move the text cursor to column 1
 STA XC

 CLC                    \ Move the text cursor to row INWK+3 plus 3, where
 LDA INWK+3             \ INWK+3 is the menu item number, starting from 0 (so
 ADC #3                 \ the first menu item is on row 3, the next is on row 4
 STA YC                 \ and so on)

 LDX INWK+3             \ Set X to INWK+3 + 1, which we can use as the menu item
 INX                    \ number on-screen (so the first menu item with is shown
                        \ as item 1 on screen, the next is shown as item 2, and
                        \ so on)

 CLC                    \ Clear the C flag so the call to pr2 doesn't show a
                        \ decimal point

 JSR pr2                \ Call pr2 to print the number in X to a width of 3
                        \ 3 figures, so this prints the item number at the start
                        \ of the menu item

 JSR TT162              \ Print a space

 JSR cpl                \ Call cpl to print the name of the selected system
                        \ (i.e. the destination system)

 LDX INWK+4             \ Set (Y X) = INWK(5 4)
 LDY INWK+5             \
                        \ so (Y X) contains the mission cost, as we set up
                        \ INWK(5 4) with this value above

 SEC                    \ Set the C flag so the call to TT11 below includes a
                        \ decimal point

 LDA #25                \ Move the text cursor to column 25, so we can print the
 STA XC                 \ mission cost

 LDA #6                 \ Set A = 6, for the call to TT11 below, so we pad out
                        \ the number to 6 digits

 JSR TT11               \ Call TT11 to print the mission cost in (Y X), padded
                        \ to six digits and with a decimal point

 INC INWK+3             \ We have just printed a menu item, so increment the
                        \ counter in INWK+3, as it contains a count of menu
                        \ items we have printed

.cour_next

 LDA INWK+1             \ Reset INWK to the value in INWK+1, so the next time we
 STA INWK               \ iterate round the loop, we skip over INWK+1 systems
                        \ before adding to the menu

 JMP cour_loop          \ Loop back to cour_loop to add the next menu item

\ ******************************************************************************
\
\       Name: cour_dock
\       Type: Subroutine
\   Category: Missions
\    Summary: Update the current special cargo delivery mission on docking
\  Deep dive: Special cargo missions
\
\ ******************************************************************************

.cour_dock

 LDA cmdr_cour          \ If there is no special cargo delivery mission in
 ORA cmdr_cour+1        \ progress, then the mission reward in cmdr_cour(1 0)
 BEQ cour_quit          \ will be zero, so jump to cour_quit to return from the
                        \ subroutine

 LDA QQ0                \ Set A = the current system's galactic x-coordinate

 CMP cmdr_courx         \ If A does not match the x-coordinate of the cargo
 BNE cour_half          \ mission's destination in cmdr_courx then we aren't at
                        \ the destination station, so jump to cour_half to
                        \ halve the mission reward

 LDA QQ1                \ Set A = the current system's galactic y-coordinate

 CMP cmdr_coury         \ If A does not match the y-coordinate of the cargo
 BNE cour_half          \ mission's destination in cmdr_coury then we aren't at
                        \ the destination station, so jump to cour_half to
                        \ halve the mission reward

 LDA #2                 \ We have arrived at the destination for the special
 JSR TT66               \ cargo mission, so clear the top part of the screen,
                        \ draw a white border, and set the current view type
                        \ in QQ11 to 2 (for the Buy Cargo screen)

 LDA #6                 \ Move the text cursor to column 6
 STA XC

 LDA #10                \ Move the text cursor to row 10
 STA YC

 LDA #113               \ Print extended token 113 ("CARGO VALUE:")
 JSR DETOK

 LDX cmdr_cour          \ Set (Y X) to the mission reward in cmdr_cour(1 0)
 LDY cmdr_cour+1

 SEC                    \ Set the C flag so the call to TT11 includes a decimal
                        \ point

 LDA #6                 \ Set A = 6, for the call to TT11 below, so we pad out
                        \ the number to 6 digits

 JSR TT11               \ Call TT11 to print the mission reward in (Y X), padded
                        \ to six digits and with a decimal point

 LDA #226               \ Print recursive text token 66 (" CR")
 JSR TT27

 LDX cmdr_cour          \ Set (Y X) to the mission reward in cmdr_cour(1 0)
 LDY cmdr_cour+1

 JSR MCASH              \ Call MCASH to add (Y X) to the cash pot

 LDA #0                 \ Reset the mission reward by doing cmdr_cour(1 0) = 0
 STA cmdr_cour
 STA cmdr_cour+1

 LDY #96                \ Wait for 96 vertical syncs (96/50 = 1.92 seconds)
 JSR DELAY

.cour_half

 LSR cmdr_cour+1        \ Halve the value of the mission reward in
 ROR cmdr_cour          \ cmdr_cour(1 0)

.cour_quit

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: stay_here
\       Type: Subroutine
\   Category: Market
\    Summary: Pay a docking fee and refresh the system's market prices
\
\ ******************************************************************************

.stay_here

 LDX #&F4               \ It costs 50.0 Cr to refresh the station's market
 LDY #&01               \ prices, which is represented as a value of 500, so
                        \ this sets (Y X) = &1F4 = 500

 JSR LCASH              \ Subtract (Y X) cash from the cash pot, but only if
                        \ we have enough cash

 BCC stay_quit          \ If the C flag is clear then we did not have enough
                        \ cash for the transaction, so jump to stay_quit to
                        \ return from the subroutine without refreshing the
                        \ market prices

 JSR cour_dock          \ Update the current special cargo delivery mission

 JSR DORND              \ Set A and X to random numbers

 STA QQ26               \ Set QQ26 to the random byte that's used in the market
                        \ calculations

 JSR GVL                \ Calculate the availability for each market item in the
                        \ new system

.stay_quit

 JMP BAY                \ Go to the docking bay (i.e. show the Status Mode
                        \ screen)

\ ******************************************************************************
\
\       Name: GVL
\       Type: Subroutine
\   Category: Universe
\    Summary: Calculate the availability of market items
\  Deep dive: Market item prices and availability
\             Galaxy and system seeds
\
\ ------------------------------------------------------------------------------
\
\ Calculate the availability for each market item and store it in AVL. This is
\ called on arrival in a new system.
\
\ Other entry points:
\
\   hyR                 Contains an RTS
\
\ ******************************************************************************

.GVL

 LDX #0                 \ We are now going to loop through the market item
 STX XX4                \ availability table in AVL, so set a counter in XX4
                        \ (and X) for the market item number, starting with 0

.hy9

 LDA QQ23+1,X           \ Fetch byte #1 from the market prices table (units and
 STA QQ19+1             \ economic_factor) for item number X and store it in
                        \ QQ19+1

 JSR var                \ Call var to set QQ19+3 = economy * |economic_factor|
                        \ (and set the availability of alien items to 0)

 LDA QQ23+3,X           \ Fetch byte #3 from the market prices table (mask) and
 AND QQ26               \ AND with the random number for this system visit
                        \ to give:
                        \
                        \   A = random AND mask

 CLC                    \ Add byte #2 from the market prices table
 ADC QQ23+2,X           \ (base_quantity) so we now have:
                        \
                        \   A = base_quantity + (random AND mask)

 LDY QQ19+1             \ Fetch the byte #1 that we stored above and jump to
 BMI TT157              \ TT157 if it is negative (i.e. if the economic_factor
                        \ is negative)

 SEC                    \ Set A = A - QQ19+3
 SBC QQ19+3             \
                        \       = base_quantity + (random AND mask)
                        \         - (economy * |economic_factor|)
                        \
                        \ which is the result we want, as the economic_factor
                        \ is positive

 JMP TT158              \ Jump to TT158 to skip TT157

.TT157

 CLC                    \ Set A = A + QQ19+3
 ADC QQ19+3             \
                        \       = base_quantity + (random AND mask)
                        \         + (economy * |economic_factor|)
                        \
                        \ which is the result we want, as the economic_factor
                        \ is negative

.TT158

 BPL TT159              \ If A < 0, then set A = 0, so we don't have negative
 LDA #0                 \ availability

.TT159

 LDY XX4                \ Fetch the counter (the market item number) into Y

 AND #%00111111         \ Take bits 0-5 of A, i.e. A mod 64, and store this as
 STA AVL,Y              \ this item's availability in the Y=th byte of AVL, so
                        \ each item has a maximum availability of 63t

 INY                    \ Increment the counter into XX44, Y and A
 TYA
 STA XX4

 ASL A                  \ Set X = counter * 4, so that X points to the next
 ASL A                  \ item's entry in the four-byte market prices table,
 TAX                    \ ready for the next loop

 CMP #63                \ If A < 63, jump back up to hy9 to set the availability
 BCC hy9                \ for the next market item

.hyR

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: new_offsets
\       Type: Variable
\   Category: Buying ships
\    Summary: Table of offsets for each ship type
\  Deep dive: Buying and flying ships in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ There are 13 bytes in of flight characteristics for each ship type in the
\ new_details table.
\
\ There are also 13 bytes of name and price data for each ship type in the
\ new_ships table (9 characters in the name plus 4 bytes in the 32-bit price).
\
\ As a result, the offset in this table at position X can be used for any of the
\ following:
\
\   * An offset into the new_details to fetch the flight characteristics for
\     ship type X
\
\   * An offset into the new_ships table to fetch the type name of ship type X
\
\   * An offset into the new_price table to fetch the price of ship type X
\
\ ******************************************************************************

.new_offsets

 FOR I%, 0, 14

  EQUB I% * 13          \ Offset of the 13-byte details block for ship I%

 NEXT

\ ******************************************************************************
\
\       Name: new_ships
\       Type: Variable
\   Category: Buying ships
\    Summary: Ship names and prices for the different ship types we can buy
\  Deep dive: Buying and flying ships in Elite-A
\
\ ******************************************************************************

.new_ships

IF _SOURCE_DISC OR _BUG_FIX

 EQUS "ADDER    "       \ #0 = Adder         = 27,000.0 Cr

.new_price

 EQUD 270000

 EQUS "GECKO    "       \ #1 = Gecko         = 32,500.0 Cr
 EQUD 325000

 EQUS "MORAY    "       \ #2 = Moray         = 36,000.0 Cr
 EQUD 360000

 EQUS "COBRA MK1"       \ #3 = Cobra Mk I    = 39,500.0 Cr
 EQUD 395000

 EQUS "IGUANA   "       \ #4 = Iguana        = 64,000.0 Cr
 EQUD 640000

 EQUS "OPHIDIAN "       \ #5 = Ophidian      = 64,500.0 Cr
 EQUD 645000

 EQUS "CHAMELEON"       \ #6 = Chameleon     = 97,500.0 Cr
 EQUD 975000

 EQUS "COBRA MK3"       \ #7 = Cobra Mk III  = 100,000.0 Cr
 EQUD 1000000

 EQUS "GHAVIAL  "       \ #8 = Ghavial       = 136,500.0 Cr
 EQUD 1365000

 EQUS "F"               \ #9 = Fer-de-Lance  = 143,500.0 Cr
 EQUB 144               \
 EQUS "-DE-L"           \ 144 = Two-letter token 'ER'
 EQUB 155               \ 155 = Two-letter token 'AN'
 EQUB 133               \ 133 = Two-letter token 'CE'
 EQUD 1435000

 EQUS "MONITOR  "       \ #10 = Monitor      = 175,000.0 Cr
 EQUD 1750000

 EQUS "PYTHON   "       \ #11 = Python       = 205,000.0 Cr
 EQUD 2050000

 EQUS "BOA      "       \ #12 = Boa          = 240,000.0 Cr
 EQUD 2400000

 EQUS "ANACONDA "       \ #13 = Anaconda     = 400,000.0 Cr
 EQUD 4000000

 EQUS "ASP MK2  "       \ #14 = Asp Mk II    = 895,000.0 Cr
 EQUD 8950000

ELIF _RELEASED

 EQUS "ADDER    "       \ #0 = Adder         = 31,000.0 Cr

.new_price

 EQUD 310000

 EQUS "GECKO    "       \ #1 = Gecko         = 40,000.0 Cr
 EQUD 400000

 EQUS "MORAY    "       \ #2 = Moray         = 56,500.0 Cr
 EQUD 565000

 EQUS "COBRA MK1"       \ #3 = Cobra Mk I    = 75,000.0 Cr
 EQUD 750000

 EQUS "IGUANA   "       \ #4 = Iguana        = 131,500.0 Cr
 EQUD 1315000

 EQUS "OPHIDIAN "       \ #5 = Ophidian      = 147,000.0 Cr
 EQUD 1470000

 EQUS "CHAMELEON"       \ #6 = Chameleon     = 225,000.0 Cr
 EQUD 2250000

 EQUS "COBRA MK3"       \ #7 = Cobra Mk III  = 287,000.0 Cr
 EQUD 2870000

 EQUS "F"               \ #8 = Fer-de-Lance  = 359,500.0 Cr
 EQUB 144               \
 EQUS "-DE-L"           \ 144 = Two-letter token 'ER'
 EQUB 155               \ 155 = Two-letter token 'AN'
 EQUB 133               \ 133 = Two-letter token 'CE'
 EQUD 3595000

 EQUS "GHAVIAL  "       \ #9 = Ghavial       = 379,500.0 Cr
 EQUD 3795000

 EQUS "MONITOR  "       \ #10 = Monitor      = 585,500.0 Cr
 EQUD 5855000

 EQUS "PYTHON   "       \ #11 = Python       = 762,000.0 Cr
 EQUD 7620000

 EQUS "BOA      "       \ #12 = Boa          = 960,000.0 Cr
 EQUD 9600000

 EQUS "ASP MK2  "       \ #13 = Asp Mk II    = 1012,000.0 Cr
 EQUD 10120000

 EQUS "ANACONDA "       \ #14 = Anaconda     = 1869,500.0 Cr
 EQUD 18695000

ENDIF

\ ******************************************************************************
\
\       Name: new_details
\       Type: Variable
\   Category: Buying ships
\    Summary: The flight characteristics for each of the different ship types
\  Deep dive: Buying and flying ships in Elite-A
\
\ ******************************************************************************

.new_details

                        \ Adder

 EQUB 14                \ Pulse laser power                     = 14
 EQUB 142               \ Beam laser power                      = 142
 EQUB 146               \ Military laser power                  = 146
 EQUB 25                \ Mining laser power                    = 25
 EQUB 2                 \ Laser mounts                          = Front, rear
 EQUB 2                 \ Maximum missile count                 = 2 - 1 = 1
 EQUB 4                 \ Shields                               = 4
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 36                \ Maximum speed                         = 36
 EQUB 9                 \ Cargo hold capacity                   = 9 - 1 = 8
 EQUB 60                \ Hyperspace range                      = 6.0 LY
 EQUB 1 * 26            \ Equipment prices offset from PRXS     = 1
 EQUB 223               \ Maximum roll/pitch rate               = 223
\EQUB 33                \ Not used (minimum roll/pitch rate)    = 33
\EQUB 5                 \ Not used (new_space)                  = 5
\EQUB 0                 \ Not used

                        \ Gecko

 EQUB 14                \ Pulse laser power                     = 14
 EQUB 143               \ Beam laser power                      = 143
 EQUB 147               \ Military laser power                  = 147
 EQUB 25                \ Mining laser power                    = 25
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 3                 \ Maximum missile count                 = 3 - 1 = 2
 EQUB 5                 \ Shields                               = 5
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 45                \ Maximum speed                         = 45
 EQUB 10                \ Cargo hold capacity                   = 10 - 1 = 9
 EQUB 70                \ Hyperspace range                      = 7.0 LY
 EQUB 1 * 26            \ Equipment prices offset from PRXS     = 1
 EQUB 239               \ Maximum roll/pitch rate               = 239
\EQUB 17                \ Not used (minimum roll/pitch rate)    = 17
\EQUB 6                 \ Not used (new_space)                  = 6
\EQUB 0                 \ Not used

                        \ Moray

 EQUB 16                \ Pulse laser power                     = 16
 EQUB 143               \ Beam laser power                      = 143
 EQUB 150               \ Military laser power                  = 150
 EQUB 25                \ Mining laser power                    = 25
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 3                 \ Maximum missile count                 = 3 - 1 = 2
 EQUB 6                 \ Shields                               = 6
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 38                \ Maximum speed                         = 38
 EQUB 12                \ Cargo hold capacity                   = 12 - 1 = 11
 EQUB 80                \ Hyperspace range                      = 8.0 LY
 EQUB 4 * 26            \ Equipment prices offset from PRXS     = 4
 EQUB 239               \ Maximum roll/pitch rate               = 239
\EQUB 17                \ Not used (minimum roll/pitch rate)    = 17
\EQUB 7                 \ Not used (new_space)                  = 7
\EQUB 0                 \ Not used

                        \ Cobra Mk I

 EQUB 14                \ Pulse laser power                     = 14
 EQUB 142               \ Beam laser power                      = 142
 EQUB 148               \ Military laser power                  = 148
 EQUB 25                \ Mining laser power                    = 25
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 4                 \ Maximum missile count                 = 4 - 1 = 3
 EQUB 5                 \ Shields                               = 5
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 39                \ Maximum speed                         = 39
 EQUB 15                \ Cargo hold capacity                   = 15 - 1 = 14
 EQUB 60                \ Hyperspace range                      = 6.0 LY
 EQUB 1 * 26            \ Equipment prices offset from PRXS     = 1
 EQUB 207               \ Maximum roll/pitch rate               = 207
\EQUB 49                \ Not used (minimum roll/pitch rate)    = 49
\EQUB 8                 \ Not used (new_space)                  = 8
\EQUB 0                 \ Not used

                        \ Iguana

 EQUB 14                \ Pulse laser power                     = 14
 EQUB 142               \ Beam laser power                      = 142
 EQUB 148               \ Military laser power                  = 148
 EQUB 25                \ Mining laser power                    = 25
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 4                 \ Maximum missile count                 = 4 - 1 = 3
 EQUB 7                 \ Shields                               = 7
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 50                \ Maximum speed                         = 50
 EQUB 22                \ Cargo hold capacity                   = 22 - 1 = 21
 EQUB 75                \ Hyperspace range                      = 7.5 LY
 EQUB 0 * 26            \ Equipment prices offset from PRXS     = 0
 EQUB 223               \ Maximum roll/pitch rate               = 223
\EQUB 33                \ Not used (minimum roll/pitch rate)    = 33
\EQUB 8                 \ Not used (new_space)                  = 8
\EQUB 0                 \ Not used

                        \ Ophidian

 EQUB 13                \ Pulse laser power                     = 13
 EQUB 141               \ Beam laser power                      = 141
 EQUB 144               \ Military laser power                  = 144
 EQUB 12                \ Mining laser power                    = 12
 EQUB 1                 \ Laser mounts                          = Front
 EQUB 3                 \ Maximum missile count                 = 3 - 1 = 2
 EQUB 4                 \ Shields                               = 4
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 51                \ Maximum speed                         = 51
 EQUB 25                \ Cargo hold capacity                   = 25 - 1 = 24
 EQUB 70                \ Hyperspace range                      = 7.0 LY
 EQUB 4 * 26            \ Equipment prices offset from PRXS     = 4
 EQUB 255               \ Maximum roll/pitch rate               = 255
\EQUB 1                 \ Not used (minimum roll/pitch rate)    = 1
\EQUB 6                 \ Not used (new_space)                  = 6
\EQUB 0                 \ Not used

                        \ Chameleon

 EQUB 16                \ Pulse laser power                     = 16
 EQUB 143               \ Beam laser power                      = 143
 EQUB 151               \ Military laser power                  = 151
 EQUB 50                \ Mining laser power                    = 50
 EQUB 2                 \ Laser mounts                          = Front, rear
 EQUB 4                 \ Maximum missile count                 = 4 - 1 = 3
 EQUB 8                 \ Shields                               = 8
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 43                \ Maximum speed                         = 43
 EQUB 36                \ Cargo hold capacity                   = 36 - 1 = 35
 EQUB 80                \ Hyperspace range                      = 8.0 LY
 EQUB 4 * 26            \ Equipment prices offset from PRXS     = 4
 EQUB 223               \ Maximum roll/pitch rate               = 223
\EQUB 33                \ Not used (minimum roll/pitch rate)    = 33
\EQUB 5                 \ Not used (new_space)                  = 5
\EQUB 0                 \ Not used

                        \ Cobra Mk III

 EQUB 18                \ Pulse laser power                     = 18
 EQUB 143               \ Beam laser power                      = 143
 EQUB 152               \ Military laser power                  = 152
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 5                 \ Maximum missile count                 = 5 - 1 = 4
 EQUB 7                 \ Shields                               = 7
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 42                \ Maximum speed                         = 42
 EQUB 43                \ Cargo hold capacity                   = 43 - 1 = 42
 EQUB 70                \ Hyperspace range                      = 7.0 LY
 EQUB 0 * 26            \ Equipment prices offset from PRXS     = 0
 EQUB 239               \ Maximum roll/pitch rate               = 239
\EQUB 17                \ Not used (minimum roll/pitch rate)    = 17
\EQUB 10                \ Not used (new_space)                  = 10
\EQUB 0                 \ Not used

IF _SOURCE_DISC

                        \ Ghavial

 EQUB 17                \ Pulse laser power                     = 17
 EQUB 144               \ Beam laser power                      = 144
 EQUB 153               \ Military laser power                  = 153
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 4                 \ Maximum missile count                 = 4 - 1 = 3
 EQUB 9                 \ Shields                               = 9
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 37                \ Maximum speed                         = 37
 EQUB 56                \ Cargo hold capacity                   = 56 - 1 = 55
 EQUB 80                \ Hyperspace range                      = 8.0 LY
 EQUB 0 * 26            \ Equipment prices offset from PRXS     = 0
 EQUB 207               \ Maximum roll/pitch rate               = 207
\EQUB 49                \ Not used (minimum roll/pitch rate)    = 49
\EQUB 9                 \ Not used (new_space)                  = 9
\EQUB 0                 \ Not used

                        \ Fer-de-lance

 EQUB 18                \ Pulse laser power                     = 18
 EQUB 146               \ Beam laser power                      = 146
 EQUB 156               \ Military laser power                  = 156
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 4                 \ Maximum missile count                 = 4 - 1 = 3
 EQUB 8                 \ Shields                               = 8
 EQUB 2                 \ Energy recharge rate                  = 2
 EQUB 45                \ Maximum speed                         = 45
 EQUB 10                \ Cargo hold capacity                   = 10 - 1 = 9
 EQUB 85                \ Hyperspace range                      = 8.5 LY
 EQUB 2 * 26            \ Equipment prices offset from PRXS     = 2
 EQUB 223               \ Maximum roll/pitch rate               = 223
\EQUB 33                \ Not used (minimum roll/pitch rate)    = 33
\EQUB 9                 \ Not used (new_space)                  = 9
\EQUB 0                 \ Not used

ELIF _RELEASED

                        \ Fer-de-lance

 EQUB 18                \ Pulse laser power                     = 18
 EQUB 146               \ Beam laser power                      = 146
 EQUB 156               \ Military laser power                  = 156
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 4                 \ Maximum missile count                 = 4 - 1 = 3
 EQUB 8                 \ Shields                               = 8
 EQUB 2                 \ Energy recharge rate                  = 2
 EQUB 45                \ Maximum speed                         = 45
 EQUB 10                \ Cargo hold capacity                   = 10 - 1 = 9
 EQUB 85                \ Hyperspace range                      = 8.5 LY
 EQUB 2 * 26            \ Equipment prices offset from PRXS     = 2
 EQUB 223               \ Maximum roll/pitch rate               = 223
\EQUB 33                \ Not used (minimum roll/pitch rate)    = 33
\EQUB 9                 \ Not used (new_space)                  = 9
\EQUB 0                 \ Not used

                        \ Ghavial

 EQUB 17                \ Pulse laser power                     = 17
 EQUB 144               \ Beam laser power                      = 144
 EQUB 153               \ Military laser power                  = 153
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 4                 \ Maximum missile count                 = 4 - 1 = 3
 EQUB 9                 \ Shields                               = 9
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 37                \ Maximum speed                         = 37
 EQUB 56                \ Cargo hold capacity                   = 56 - 1 = 55
 EQUB 80                \ Hyperspace range                      = 8.0 LY
 EQUB 0 * 26            \ Equipment prices offset from PRXS     = 0
 EQUB 207               \ Maximum roll/pitch rate               = 207
\EQUB 49                \ Not used (minimum roll/pitch rate)    = 49
\EQUB 9                 \ Not used (new_space)                  = 9
\EQUB 0                 \ Not used

ENDIF

                        \ Monitor

 EQUB 24                \ Pulse laser power                     = 24
 EQUB 147               \ Beam laser power                      = 147
 EQUB 156               \ Military laser power                  = 156
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 9                 \ Maximum missile count                 = 9 - 1 = 8
 EQUB 10                \ Shields                               = 10
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 24                \ Maximum speed                         = 24
 EQUB 82                \ Cargo hold capacity                   = 82 - 1 = 81
 EQUB 110               \ Hyperspace range                      = 11.0 LY
 EQUB 3 * 26            \ Equipment prices offset from PRXS     = 3
 EQUB 191               \ Maximum roll/pitch rate               = 191
\EQUB 65                \ Not used (minimum roll/pitch rate)    = 65
\EQUB 12                \ Not used (new_space)                  = 12
\EQUB 0                 \ Not used

                        \ Python

 EQUB 24                \ Pulse laser power                     = 24
 EQUB 146               \ Beam laser power                      = 146
 EQUB 155               \ Military laser power                  = 155
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 5                 \ Maximum missile count                 = 5 - 1 = 4
 EQUB 11                \ Shields                               = 11
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 30                \ Maximum speed                         = 30
 EQUB 107               \ Cargo hold capacity                   = 107 - 1 = 106
 EQUB 80                \ Hyperspace range                      = 8.0 LY
 EQUB 1 * 26            \ Equipment prices offset from PRXS     = 1
 EQUB 175               \ Maximum roll/pitch rate               = 175
\EQUB 81                \ Not used (minimum roll/pitch rate)    = 81
\EQUB 9                 \ Not used (new_space)                  = 9
\EQUB 0                 \ Not used

                        \ Boa

 EQUB 20                \ Pulse laser power                     = 20
 EQUB 142               \ Beam laser power                      = 142
 EQUB 152               \ Military laser power                  = 152
 EQUB 50                \ Mining laser power                    = 50
 EQUB 2                 \ Laser mounts                          = Front, rear
 EQUB 7                 \ Maximum missile count                 = 7 - 1 = 6
 EQUB 10                \ Shields                               = 10
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 36                \ Maximum speed                         = 36
 EQUB 133               \ Cargo hold capacity                   = 133 - 1 = 132
 EQUB 90                \ Hyperspace range                      = 9.0 LY
 EQUB 0 * 26            \ Equipment prices offset from PRXS     = 0
 EQUB 191               \ Maximum roll/pitch rate               = 191
\EQUB 65                \ Not used (minimum roll/pitch rate)    = 65
\EQUB 10                \ Not used (new_space)                  = 10
\EQUB 0                 \ Not used

IF _SOURCE_DISC

                        \ Anaconda

 EQUB 28                \ Pulse laser power                     = 28
 EQUB 144               \ Beam laser power                      = 144
 EQUB 127               \ Military laser power                  = 127
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 17                \ Maximum missile count                 = 17 - 1 = 16
 EQUB 13                \ Shields                               = 13
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 21                \ Maximum speed                         = 21
 EQUB 254               \ Cargo hold capacity                   = 254 - 1 = 253
 EQUB 100               \ Hyperspace range                      = 10.0 LY
 EQUB 3 * 26            \ Equipment prices offset from PRXS     = 3
 EQUB 175               \ Maximum roll/pitch rate               = 175
\EQUB 81                \ Not used (minimum roll/pitch rate)    = 81
\EQUB 12                \ Not used (new_space)                  = 12
\EQUB 0                 \ Not used

                        \ Asp Mk II

 EQUB 16                \ Pulse laser power                     = 16
 EQUB 145               \ Beam laser power                      = 145
 EQUB 159               \ Military laser power                  = 159
 EQUB 12                \ Mining laser power                    = 12
 EQUB 1                 \ Laser mounts                          = Front
 EQUB 2                 \ Maximum missile count                 = 2 - 1 = 1
 EQUB 10                \ Shields                               = 10
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 60                \ Maximum speed                         = 60
 EQUB 7                 \ Cargo hold capacity                   = 7 - 1 = 6
 EQUB 125               \ Hyperspace range                      = 12.5 LY
 EQUB 2 * 26            \ Equipment prices offset from PRXS     = 2
 EQUB 223               \ Maximum roll/pitch rate               = 223
\EQUB 33                \ Not used (minimum roll/pitch rate)    = 33
\EQUB 7                 \ Not used (new_space)                  = 7
\EQUB 0                 \ Not used

ELIF _RELEASED

                        \ Asp Mk II

 EQUB 16                \ Pulse laser power                     = 16
 EQUB 145               \ Beam laser power                      = 145
 EQUB 159               \ Military laser power                  = 159
 EQUB 12                \ Mining laser power                    = 12
 EQUB 1                 \ Laser mounts                          = Front
 EQUB 2                 \ Maximum missile count                 = 2 - 1 = 1
 EQUB 10                \ Shields                               = 10
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 60                \ Maximum speed                         = 60
 EQUB 7                 \ Cargo hold capacity                   = 7 - 1 = 6
 EQUB 125               \ Hyperspace range                      = 12.5 LY
 EQUB 2 * 26            \ Equipment prices offset from PRXS     = 2
 EQUB 223               \ Maximum roll/pitch rate               = 223
\EQUB 33                \ Not used (minimum roll/pitch rate)    = 33
\EQUB 7                 \ Not used (new_space)                  = 7
\EQUB 0                 \ Not used

                        \ Anaconda

 EQUB 28                \ Pulse laser power                     = 28
 EQUB 144               \ Beam laser power                      = 144
 EQUB 127               \ Military laser power                  = 127
 EQUB 50                \ Mining laser power                    = 50
 EQUB 4                 \ Laser mounts                          = All four
 EQUB 17                \ Maximum missile count                 = 17 - 1 = 16
 EQUB 13                \ Shields                               = 13
 EQUB 1                 \ Energy recharge rate                  = 1
 EQUB 21                \ Maximum speed                         = 21
 EQUB 254               \ Cargo hold capacity                   = 254 - 1 = 253
 EQUB 100               \ Hyperspace range                      = 10.0 LY
 EQUB 3 * 26            \ Equipment prices offset from PRXS     = 3
 EQUB 175               \ Maximum roll/pitch rate               = 175
\EQUB 81                \ Not used (minimum roll/pitch rate)    = 81
\EQUB 12                \ Not used (new_space)                  = 12
\EQUB 0                 \ Not used

ENDIF

\ ******************************************************************************
\
\ Save ELTG.bin
\
\ ******************************************************************************

 PRINT "ELITE G"
 PRINT "Assembled at ", ~CODE_G%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_G%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_G%

 PRINT "S.2.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
\SAVE "3-assembled-output/2.ELTG.bin", CODE_G%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE H FILE
\
\ ******************************************************************************

 CODE_H% = P%
 LOAD_H% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: EJMP
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for jump tokens in the extended token table
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the extended token table:
\
\   EJMP n              Insert a jump to address n in the JMTB table
\
\ See the deep dive on "Printing extended text tokens" for details on how jump
\ tokens are stored in the extended token table.
\
\ Arguments:
\
\   n                   The jump number to insert into the table
\
\ ******************************************************************************

MACRO EJMP n

 EQUB n EOR VE

ENDMACRO

\ ******************************************************************************
\
\       Name: ECHR
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for characters in the extended token table
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the extended token table:
\
\   ECHR 'x'            Insert ASCII character "x"
\
\ To include an apostrophe, use a backtick character, as in ECHR '`'.
\
\ See the deep dive on "Printing extended text tokens" for details on how
\ characters are stored in the extended token table.
\
\ Arguments:
\
\   'x'                 The character to insert into the table
\
\ ******************************************************************************

MACRO ECHR x

 IF x = '`'
  EQUB 39 EOR VE
 ELSE
  EQUB x EOR VE
 ENDIF

ENDMACRO

\ ******************************************************************************
\
\       Name: ETOK
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for recursive tokens in the extended token table
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the extended token table:
\
\   ETOK n              Insert extended recursive token [n]
\
\ See the deep dive on "Printing extended text tokens" for details on how
\ recursive tokens are stored in the extended token table.
\
\ Arguments:
\
\   n                   The number of the recursive token to insert into the
\                       table, in the range 129 to 214
\
\ ******************************************************************************

MACRO ETOK n

 EQUB n EOR VE

ENDMACRO

\ ******************************************************************************
\
\       Name: ETWO
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for two-letter tokens in the extended token table
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the extended token table:
\
\   ETWO 'x', 'y'       Insert two-letter token "xy"
\
\ The newline token can be entered using ETWO '-', '-'.
\
\ See the deep dive on "Printing extended text tokens" for details on how
\ two-letter tokens are stored in the extended token table.
\
\ Arguments:
\
\   'x'                 The first letter of the two-letter token to insert into
\                       the table
\
\   'y'                 The second letter of the two-letter token to insert into
\                       the table
\
\ ******************************************************************************

MACRO ETWO t, k

 IF t = '-' AND k = '-' : EQUB 215 EOR VE : ENDIF
 IF t = 'A' AND k = 'B' : EQUB 216 EOR VE : ENDIF
 IF t = 'O' AND k = 'U' : EQUB 217 EOR VE : ENDIF
 IF t = 'S' AND k = 'E' : EQUB 218 EOR VE : ENDIF
 IF t = 'I' AND k = 'T' : EQUB 219 EOR VE : ENDIF
 IF t = 'I' AND k = 'L' : EQUB 220 EOR VE : ENDIF
 IF t = 'E' AND k = 'T' : EQUB 221 EOR VE : ENDIF
 IF t = 'S' AND k = 'T' : EQUB 222 EOR VE : ENDIF
 IF t = 'O' AND k = 'N' : EQUB 223 EOR VE : ENDIF
 IF t = 'L' AND k = 'O' : EQUB 224 EOR VE : ENDIF
 IF t = 'N' AND k = 'U' : EQUB 225 EOR VE : ENDIF
 IF t = 'T' AND k = 'H' : EQUB 226 EOR VE : ENDIF
 IF t = 'N' AND k = 'O' : EQUB 227 EOR VE : ENDIF

 IF t = 'A' AND k = 'L' : EQUB 228 EOR VE : ENDIF
 IF t = 'L' AND k = 'E' : EQUB 229 EOR VE : ENDIF
 IF t = 'X' AND k = 'E' : EQUB 230 EOR VE : ENDIF
 IF t = 'G' AND k = 'E' : EQUB 231 EOR VE : ENDIF
 IF t = 'Z' AND k = 'A' : EQUB 232 EOR VE : ENDIF
 IF t = 'C' AND k = 'E' : EQUB 233 EOR VE : ENDIF
 IF t = 'B' AND k = 'I' : EQUB 234 EOR VE : ENDIF
 IF t = 'S' AND k = 'O' : EQUB 235 EOR VE : ENDIF
 IF t = 'U' AND k = 'S' : EQUB 236 EOR VE : ENDIF
 IF t = 'E' AND k = 'S' : EQUB 237 EOR VE : ENDIF
 IF t = 'A' AND k = 'R' : EQUB 238 EOR VE : ENDIF
 IF t = 'M' AND k = 'A' : EQUB 239 EOR VE : ENDIF
 IF t = 'I' AND k = 'N' : EQUB 240 EOR VE : ENDIF
 IF t = 'D' AND k = 'I' : EQUB 241 EOR VE : ENDIF
 IF t = 'R' AND k = 'E' : EQUB 242 EOR VE : ENDIF
 IF t = 'A' AND k = '?' : EQUB 243 EOR VE : ENDIF
 IF t = 'E' AND k = 'R' : EQUB 244 EOR VE : ENDIF
 IF t = 'A' AND k = 'T' : EQUB 245 EOR VE : ENDIF
 IF t = 'E' AND k = 'N' : EQUB 246 EOR VE : ENDIF
 IF t = 'B' AND k = 'E' : EQUB 247 EOR VE : ENDIF
 IF t = 'R' AND k = 'A' : EQUB 248 EOR VE : ENDIF
 IF t = 'L' AND k = 'A' : EQUB 249 EOR VE : ENDIF
 IF t = 'V' AND k = 'E' : EQUB 250 EOR VE : ENDIF
 IF t = 'T' AND k = 'I' : EQUB 251 EOR VE : ENDIF
 IF t = 'E' AND k = 'D' : EQUB 252 EOR VE : ENDIF
 IF t = 'O' AND k = 'R' : EQUB 253 EOR VE : ENDIF
 IF t = 'Q' AND k = 'U' : EQUB 254 EOR VE : ENDIF
 IF t = 'A' AND k = 'N' : EQUB 255 EOR VE : ENDIF

ENDMACRO

\ ******************************************************************************
\
\       Name: ERND
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for random tokens in the extended token table
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the extended token table:
\
\   ERND n              Insert recursive token [n]
\
\                         * Tokens 0-123 get stored as n + 91
\
\ See the deep dive on "Printing extended text tokens" for details on how
\ random tokens are stored in the extended token table.
\
\ Arguments:
\
\   n                   The number of the random token to insert into the
\                       table, in the range 0 to 37
\
\ ******************************************************************************

MACRO ERND n

 EQUB (n + 91) EOR VE

ENDMACRO

\ ******************************************************************************
\
\       Name: TOKN
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for standard tokens in the extended token table
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the recursive token table:
\
\   TOKN n              Insert recursive token [n]
\
\                         * Tokens 0-95 get stored as n + 160
\
\                         * Tokens 128-145 get stored as n - 114
\
\                         * Tokens 96-127 get stored as n
\
\ See the deep dive on "Printing text tokens" for details on how recursive
\ tokens are stored in the recursive token table.
\
\ Arguments:
\
\   n                   The number of the recursive token to insert into the
\                       table, in the range 0 to 145
\
\ ******************************************************************************

MACRO TOKN n

 IF n >= 0 AND n <= 95
  t = n + 160
 ELIF n >= 128
  t = n - 114
 ELSE
  t = n
 ENDIF

 EQUB t EOR VE

ENDMACRO

\ ******************************************************************************
\
\       Name: TKN1
\       Type: Variable
\   Category: Text
\    Summary: The first extended token table for recursive tokens 0-255 (DETOK)
\  Deep dive: Extended text tokens
\
\ ******************************************************************************

.TKN1

 EQUB VE                \ Token 0:      ""
                        \
                        \ Encoded as:   ""

 EJMP 9                 \ Token 1:      "{clear screen}
 EJMP 11                \                {draw box around title}
 EJMP 1                 \                {all caps}
 EJMP 8                 \                {tab 6} DISK ACCESS MENU{crlf}
 ECHR ' '               \                {lf}
 ETWO 'D', 'I'          \                {sentence case}
 ECHR 'S'               \                1. LOAD NEW {single cap}COMMANDER{crlf}
 ECHR 'K'               \                2. SAVE {single cap}COMMANDER
 ECHR ' '               \                   {commander name}{crlf}
 ECHR 'A'               \                3. CATALOGUE{crlf}
 ECHR 'C'               \                4. DELETE A FILE{crlf}
 ETWO 'C', 'E'          \                5. EXIT{crlf}
 ECHR 'S'               \               "
 ECHR 'S'               \
 ECHR ' '               \ Encoded as:   "{9}{11}{1}{8} <241>SK AC<233>SS ME
 ECHR 'M'               \                <225><215>{10}{2}1. [149]<215>2. SA
 ECHR 'E'               \                <250> [154] {4}<215>3. C<245>A<224>GUE
 ETWO 'N', 'U'          \                <215>4. DEL<221>E[208]FI<229><215>5. EX
 ETWO '-', '-'          \                <219><215>"
 EJMP 10
 EJMP 2
 ECHR '1'
 ECHR '.'
 ECHR ' '
 ETOK 149
 ETWO '-', '-'
 ECHR '2'
 ECHR '.'
 ECHR ' '
 ECHR 'S'
 ECHR 'A'
 ETWO 'V', 'E'
 ECHR ' '
 ETOK 154
 ECHR ' '
 EJMP 4
 ETWO '-', '-'
 ECHR '3'
 ECHR '.'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'T'
 ECHR 'A'
 ETWO 'L', 'O'
 ECHR 'G'
 ECHR 'U'
 ECHR 'E'
 ETWO '-', '-'
 ECHR '4'
 ECHR '.'
 ECHR ' '
 ECHR 'D'
 ECHR 'E'
 ECHR 'L'
 ETWO 'E', 'T'
 ECHR 'E'
 ETOK 208
 ECHR 'F'
 ECHR 'I'
 ETWO 'L', 'E'
 ETWO '-', '-'
 ECHR '5'
 ECHR '.'
 ECHR ' '
 ECHR 'E'
 ECHR 'X'
 ETWO 'I', 'T'
 ETWO '-', '-'
 EQUB VE

 EJMP 12                \ Token 2:      "{cr}
 ECHR 'W'               \                WHICH DRIVE?"
 ECHR 'H'               \
 ECHR 'I'               \ Encoded as:   "{12}WHICH [151]?"
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETOK 151
 ECHR '?'
 EQUB VE

 ETWO 'A', 'R'          \ Token 3:      "ARE YOU SURE?"
 ECHR 'E'               \
 ECHR ' '               \ Encoded as:   "<238>E [179] SU<242>?"
 ETOK 179
 ECHR ' '
 ECHR 'S'
 ECHR 'U'
 ETWO 'R', 'E'
 ECHR '?'
 EQUB VE

 ETOK 150               \ Token 4:      "{clear screen}
 ETOK 151               \                {draw box around title}
 ECHR ' '               \                {all caps}
 EJMP 16                \                {tab 6}DRIVE {drive number} CATALOGUE
 ETOK 152               \                {crlf}
 ETWO '-', '-'          \               "
 EQUB VE                \
                        \ Encoded as:   "[150][151] {16}[152]<215>"

 ETOK 176               \ Token 5:      "{lower case}
 ERND 18                \                {justify}
 ETOK 202               \                {single cap}[86-90] IS [140-144].{cr}
 ERND 19                \                {left align}"
 ETOK 177               \
 EQUB VE                \ Encoded as:   "[176][18?][202][19?][177]"

 ECHR ' '               \ Token 6:      "  LOAD NEW {single cap}COMMANDER {all
 ECHR ' '               \                caps}(Y/N)?{sentence case}{cr}{cr}"
 ETOK 149               \
 ECHR ' '               \ Encoded as:   "  [149] {1}(Y/N)?{2}{12}{12}"
 EJMP 1
 ECHR '('
 ECHR 'Y'
 ECHR '/'
 ECHR 'N'
 ECHR ')'
 ECHR '?'
 EJMP 2
 EJMP 12
 EJMP 12
 EQUB VE

 ECHR 'P'               \ Token 7:      "PRESS SPACE OR FIRE,{single cap}
 ETWO 'R', 'E'          \                COMMANDER.{cr}{cr}"
 ECHR 'S'               \
 ECHR 'S'               \ Encoded as:   "P<242>SS SPA<233> <253> FI<242>,[154].
 ECHR ' '               \                {12}{12}"
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'F'
 ECHR 'I'
 ETWO 'R', 'E'
 ECHR ','
 ETOK 154
 ECHR '.'
 EJMP 12
 EJMP 12
 EQUB VE

 ETOK 154               \ Token 8:      "{single cap}COMMANDER'S NAME? "
 ECHR '`'               \
 ECHR 'S'               \ Encoded as:   "[154][39]S[200]"
 ETOK 200
 EQUB VE

 EJMP 21                \ Token 9:      "{clear bottom of screen}
 ECHR 'F'               \                FILE TO DELETE?"
 ECHR 'I'               \
 ETWO 'L', 'E'          \ Encoded as:   "{21}FI<229>[201]DEL<221>E?"
 ETOK 201
 ECHR 'D'
 ECHR 'E'
 ECHR 'L'
 ETWO 'E', 'T'
 ECHR 'E'
 ECHR '?'
 EQUB VE

 EJMP 23                \ Token 10:     "{move to row 10, white, lower case}
 EJMP 14                \                {justify}
 EJMP 2                 \                {sentence case}
 ECHR 'G'               \                GREETINGS {single cap}COMMANDER
 ETWO 'R', 'E'          \                {commander name}, I {lower case}AM
 ETWO 'E', 'T'          \                {sentence case} CAPTAIN {mission
 ETWO 'I', 'N'          \                captain's name} {lower case}OF{sentence
 ECHR 'G'               \                case} HER MAJESTY'S SPACE NAVY{lower
 ECHR 'S'               \                case} AND {single cap}I BEG A MOMENT OF
 ETOK 213               \                YOUR VALUABLE TIME.{cr}
 ETOK 178               \                 {single cap}WE WOULD LIKE YOU TO DO A
 EJMP 19                \                LITTLE JOB FOR US.{cr}
 ECHR 'I'               \                 {single cap}THE SHIP YOU SEE HERE IS A
 ECHR ' '               \                NEW MODEL, THE {single cap}CONSTRICTOR,
 ETWO 'B', 'E'          \                EQUIPED WITH A TOP SECRET NEW SHIELD
 ECHR 'G'               \                GENERATOR.{cr}
 ETOK 208               \                 {single cap}UNFORTUNATELY IT'S BEEN
 ECHR 'M'               \                STOLEN.{cr}
 ECHR 'O'               \                 {single cap}{display ship, wait for
 ECHR 'M'               \                key press}IT WENT MISSING FROM OUR SHIP
 ETWO 'E', 'N'          \                YARD ON {single cap}XEER FIVE MONTHS
 ECHR 'T'               \                AGO AND {mission 1 location hint}.{cr}
 ECHR ' '               \                 {single cap}YOUR MISSION, SHOULD YOU
 ECHR 'O'               \                DECIDE TO ACCEPT IT, IS TO SEEK AND
 ECHR 'F'               \                DESTROY THIS SHIP.{cr}
 ECHR ' '               \                 {single cap}YOU ARE CAUTIONED THAT
 ETOK 179               \                ONLY {standard tokens, sentence case}
 ECHR 'R'               \                MILITARY  LASERS{extended tokens} WILL
 ECHR ' '               \                PENETRATE THE NEW SHIELDS AND THAT THE
 ECHR 'V'               \                {single cap}CONSTRICTOR IS FITTED WITH
 ETWO 'A', 'L'          \                AN {standard tokens, sentence case}
 ECHR 'U'               \                E.C.M.SYSTEM{extended tokens}.{cr}
 ETWO 'A', 'B'          \                 {left align}{sentence case}{tab 6}GOOD
 ETWO 'L', 'E'          \                LUCK, {single cap}COMMANDER.{cr}
 ECHR ' '               \                 {left align}{tab 6}{all caps}  MESSAGE
 ETWO 'T', 'I'          \                ENDS{display ship, wait for key press}"
 ECHR 'M'               \
 ECHR 'E'               \ Encoded as:   "{23}{14}{2}G<242><221><240>GS[213][178]
 ETOK 204               \                {19}I <247>G[208]MOM<246>T OF [179]R V
 ECHR 'W'               \                <228>U<216><229> <251>ME[204]WE W<217>
 ECHR 'E'               \                LD LIKE [179][201]DO[208]L<219>T<229>
 ECHR ' '               \                 JOB F<253> <236>[204][147][207] [179]
 ECHR 'W'               \                 <218>E HE<242>[202]A[210]MODEL, [147]
 ETWO 'O', 'U'          \                {19}C<223><222>RICT<253>, E<254>IP[196]
 ECHR 'L'               \                WI<226>[208]TOP <218>CR<221>[210]SHIELD
 ECHR 'D'               \                 G<246><244><245><253>[204]UNF<253>TUN
 ECHR ' '               \                <245>ELY <219>[39]S <247><246> <222>OL
 ECHR 'L'               \                <246>[204]{22}<219> W<246>T MISS[195]
 ECHR 'I'               \                FROM <217>R [207] Y<238>D <223> {19}
 ECHR 'K'               \                <230><244> FI<250> M<223><226>S AGO
 ECHR 'E'               \                [178]{28}[204][179]R MISSI<223>, SH
 ECHR ' '               \                <217>LD [179] DECIDE[201]AC<233>PT
 ETOK 179               \                 <219>, IS[201]<218>EK[178]D<237>TROY
 ETOK 201               \                 [148][207][204][179] A<242> CAU<251>
 ECHR 'D'               \                <223>[196]<226><245> <223>LY {6}[116]
 ECHR 'O'               \                {5}S W<220>L P<246><221><248>TE [147]
 ETOK 208               \                NEW SHIELDS[178]<226><245> [147]{19}
 ECHR 'L'               \                C<223><222>RICT<253>[202]F<219>T[196]WI
 ETWO 'I', 'T'          \                <226> <255> {6}[108]{5}[177]{2}{8}GOOD
 ECHR 'T'               \                 LUCK, [154][212]{22}"
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'J'
 ECHR 'O'
 ECHR 'B'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'U', 'S'
 ETOK 204
 ETOK 147
 ETOK 207
 ECHR ' '
 ETOK 179
 ECHR ' '
 ETWO 'S', 'E'
 ECHR 'E'
 ECHR ' '
 ECHR 'H'
 ECHR 'E'
 ETWO 'R', 'E'
 ETOK 202
 ECHR 'A'
 ETOK 210
 ECHR 'M'
 ECHR 'O'
 ECHR 'D'
 ECHR 'E'
 ECHR 'L'
 ECHR ','
 ECHR ' '
 ETOK 147
 EJMP 19
 ECHR 'C'
 ETWO 'O', 'N'
 ETWO 'S', 'T'
 ECHR 'R'
 ECHR 'I'
 ECHR 'C'
 ECHR 'T'
 ETWO 'O', 'R'
 ECHR ','
 ECHR ' '
 ECHR 'E'
 ETWO 'Q', 'U'
 ECHR 'I'
 ECHR 'P'
 ETOK 196
 ECHR 'W'
 ECHR 'I'
 ETWO 'T', 'H'
 ETOK 208
 ECHR 'T'
 ECHR 'O'
 ECHR 'P'
 ECHR ' '
 ETWO 'S', 'E'
 ECHR 'C'
 ECHR 'R'
 ETWO 'E', 'T'
 ETOK 210
 ECHR 'S'
 ECHR 'H'
 ECHR 'I'
 ECHR 'E'
 ECHR 'L'
 ECHR 'D'
 ECHR ' '
 ECHR 'G'
 ETWO 'E', 'N'
 ETWO 'E', 'R'
 ETWO 'A', 'T'
 ETWO 'O', 'R'
 ETOK 204
 ECHR 'U'
 ECHR 'N'
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR 'T'
 ECHR 'U'
 ECHR 'N'
 ETWO 'A', 'T'
 ECHR 'E'
 ECHR 'L'
 ECHR 'Y'
 ECHR ' '
 ETWO 'I', 'T'
 ECHR '`'
 ECHR 'S'
 ECHR ' '
 ETWO 'B', 'E'
 ETWO 'E', 'N'
 ECHR ' '
 ETWO 'S', 'T'
 ECHR 'O'
 ECHR 'L'
 ETWO 'E', 'N'
 ETOK 204
 EJMP 22
 ETWO 'I', 'T'
 ECHR ' '
 ECHR 'W'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR ' '
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ETOK 195
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ETWO 'O', 'U'
 ECHR 'R'
 ECHR ' '
 ETOK 207
 ECHR ' '
 ECHR 'Y'
 ETWO 'A', 'R'
 ECHR 'D'
 ECHR ' '
 ETWO 'O', 'N'
 ECHR ' '
 EJMP 19
 ETWO 'X', 'E'
 ETWO 'E', 'R'
 ECHR ' '
 ECHR 'F'
 ECHR 'I'
 ETWO 'V', 'E'
 ECHR ' '
 ECHR 'M'
 ETWO 'O', 'N'
 ETWO 'T', 'H'
 ECHR 'S'
 ECHR ' '
 ECHR 'A'
 ECHR 'G'
 ECHR 'O'
 ETOK 178
 EJMP 28
 ETOK 204
 ETOK 179
 ECHR 'R'
 ECHR ' '
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR ','
 ECHR ' '
 ECHR 'S'
 ECHR 'H'
 ETWO 'O', 'U'
 ECHR 'L'
 ECHR 'D'
 ECHR ' '
 ETOK 179
 ECHR ' '
 ECHR 'D'
 ECHR 'E'
 ECHR 'C'
 ECHR 'I'
 ECHR 'D'
 ECHR 'E'
 ETOK 201
 ECHR 'A'
 ECHR 'C'
 ETWO 'C', 'E'
 ECHR 'P'
 ECHR 'T'
 ECHR ' '
 ETWO 'I', 'T'
 ECHR ','
 ECHR ' '
 ECHR 'I'
 ECHR 'S'
 ETOK 201
 ETWO 'S', 'E'
 ECHR 'E'
 ECHR 'K'
 ETOK 178
 ECHR 'D'
 ETWO 'E', 'S'
 ECHR 'T'
 ECHR 'R'
 ECHR 'O'
 ECHR 'Y'
 ECHR ' '
 ETOK 148
 ETOK 207
 ETOK 204
 ETOK 179
 ECHR ' '
 ECHR 'A'
 ETWO 'R', 'E'
 ECHR ' '
 ECHR 'C'
 ECHR 'A'
 ECHR 'U'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 ETOK 196
 ETWO 'T', 'H'
 ETWO 'A', 'T'
 ECHR ' '
 ETWO 'O', 'N'
 ECHR 'L'
 ECHR 'Y'
 ECHR ' '
 EJMP 6
 TOKN 117
 EJMP 5
 ECHR 'S'
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ECHR 'P'
 ETWO 'E', 'N'
 ETWO 'E', 'T'
 ETWO 'R', 'A'
 ECHR 'T'
 ECHR 'E'
 ECHR ' '
 ETOK 147
 ECHR 'N'
 ECHR 'E'
 ECHR 'W'
 ECHR ' '
 ECHR 'S'
 ECHR 'H'
 ECHR 'I'
 ECHR 'E'
 ECHR 'L'
 ECHR 'D'
 ECHR 'S'
 ETOK 178
 ETWO 'T', 'H'
 ETWO 'A', 'T'
 ECHR ' '
 ETOK 147
 EJMP 19
 ECHR 'C'
 ETWO 'O', 'N'
 ETWO 'S', 'T'
 ECHR 'R'
 ECHR 'I'
 ECHR 'C'
 ECHR 'T'
 ETWO 'O', 'R'
 ETOK 202
 ECHR 'F'
 ETWO 'I', 'T'
 ECHR 'T'
 ETOK 196
 ECHR 'W'
 ECHR 'I'
 ETWO 'T', 'H'
 ECHR ' '
 ETWO 'A', 'N'
 ECHR ' '
 EJMP 6
 TOKN 108
 EJMP 5
 ETOK 177
 EJMP 2
 EJMP 8
 ECHR 'G'
 ECHR 'O'
 ECHR 'O'
 ECHR 'D'
 ECHR ' '
 ECHR 'L'
 ECHR 'U'
 ECHR 'C'
 ECHR 'K'
 ECHR ','
 ECHR ' '
 ETOK 154
 ETOK 212
 EJMP 22
 EQUB VE

 EJMP 25                \ Token 11:     "{incoming message screen, wait 2s}
 EJMP 9                 \                {clear screen}
 EJMP 23                \                {move to row 10, white, lower case}
 EJMP 14                \                {justify}
 EJMP 2                 \                {sentence case}
 ECHR ' '               \                  ATTENTION {single cap}COMMANDER
 ECHR ' '               \                {commander name}, I {lower case}AM
 ETWO 'A', 'T'          \                {sentence case} CAPTAIN {mission
 ECHR 'T'               \                captain's name} {lower case}OF{sentence
 ETWO 'E', 'N'          \                case} HER MAJESTY'S SPACE NAVY{lower
 ETWO 'T', 'I'          \                case}. {single cap}WE HAVE NEED OF YOUR
 ETWO 'O', 'N'          \                SERVICES AGAIN.{cr}
 ETOK 213               \                 {single cap}IF YOU WOULD BE SO GOOD AS
 ECHR '.'               \                TO GO TO {single cap}CEERDI YOU WILL BE
 ECHR ' '               \                BRIEFED.{cr}
 EJMP 19                \                 {single cap}IF SUCCESSFUL, YOU WILL BE
 ECHR 'W'               \                WELL REWARDED.{cr}
 ECHR 'E'               \                {left align}{tab 6}{all caps}  MESSAGE
 ECHR ' '               \                ENDS{wait for key press}"
 ECHR 'H'               \
 ECHR 'A'               \ Encoded as:   "{25}{9}{23}{14}{2}  <245>T<246>
 ETWO 'V', 'E'          \                <251><223>[213]. {19}WE HA<250> NE[196]
 ECHR ' '               \                OF [179]R <218>RVIC<237> AGA<240>[204]
 ECHR 'N'               \                IF [179] W<217>LD <247> <235> GOOD AS
 ECHR 'E'               \                [201]GO[201]{19}<233><244><241> [179]
 ETOK 196               \                 W<220>L <247> BRIEF<252>[204]IF SUC
 ECHR 'O'               \                <233>SSFUL, [179] W<220>L <247> WELL
 ECHR 'F'               \                 <242>W<238>D<252>[212]{24}"
 ECHR ' '
 ETOK 179
 ECHR 'R'
 ECHR ' '
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'V'
 ECHR 'I'
 ECHR 'C'
 ETWO 'E', 'S'
 ECHR ' '
 ECHR 'A'
 ECHR 'G'
 ECHR 'A'
 ETWO 'I', 'N'
 ETOK 204
 ECHR 'I'
 ECHR 'F'
 ECHR ' '
 ETOK 179
 ECHR ' '
 ECHR 'W'
 ETWO 'O', 'U'
 ECHR 'L'
 ECHR 'D'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ETWO 'S', 'O'
 ECHR ' '
 ECHR 'G'
 ECHR 'O'
 ECHR 'O'
 ECHR 'D'
 ECHR ' '
 ECHR 'A'
 ECHR 'S'
 ETOK 201
 ECHR 'G'
 ECHR 'O'
 ETOK 201
 EJMP 19
 ETWO 'C', 'E'
 ETWO 'E', 'R'
 ETWO 'D', 'I'
 ECHR ' '
 ETOK 179
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'B'
 ECHR 'R'
 ECHR 'I'
 ECHR 'E'
 ECHR 'F'
 ETWO 'E', 'D'
 ETOK 204
 ECHR 'I'
 ECHR 'F'
 ECHR ' '
 ECHR 'S'
 ECHR 'U'
 ECHR 'C'
 ETWO 'C', 'E'
 ECHR 'S'
 ECHR 'S'
 ECHR 'F'
 ECHR 'U'
 ECHR 'L'
 ECHR ','
 ECHR ' '
 ETOK 179
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'W'
 ECHR 'E'
 ECHR 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'R', 'E'
 ECHR 'W'
 ETWO 'A', 'R'
 ECHR 'D'
 ETWO 'E', 'D'
 ETOK 212
 EJMP 24
 EQUB VE

 ECHR '('               \ Token 12:     "({single cap}C) ACORNSOFT 1984"
 EJMP 19                \
 ECHR 'C'               \ Encoded as:   "({19}C) AC<253>N<235>FT 1984"
 ECHR ')'
 ECHR ' '
 ECHR 'A'
 ECHR 'C'
 ETWO 'O', 'R'
 ECHR 'N'
 ETWO 'S', 'O'
 ECHR 'F'
 ECHR 'T'
 ECHR ' '
 ECHR '1'
 ECHR '9'
 ECHR '8'
 ECHR '4'
 EQUB VE

 ECHR 'B'               \ Token 13:     "BY D.BRABEN & I.BELL"
 ECHR 'Y'               \
 ECHR ' '               \ Encoded as:   "BY D.B<248><247>N & I.<247>LL"
 ECHR 'D'
 ECHR '.'
 ECHR 'B'
 ETWO 'R', 'A'
 ETWO 'B', 'E'
 ECHR 'N'
 ECHR ' '
 ECHR '&'
 ECHR ' '
 ECHR 'I'
 ECHR '.'
 ETWO 'B', 'E'
 ECHR 'L'
 ECHR 'L'
 EQUB VE

 EJMP 21                \ Token 14:     "{clear bottom of screen}
 ETOK 145               \                PLANET NAME?
 ETOK 200               \                {fetch line input from keyboard}"
 EJMP 26                \
 EQUB VE                \ Encoded as:   "{21}[145][200]{26}"

 EJMP 25                \ Token 15:     "{incoming message screen, wait 2s}
 EJMP 9                 \                {clear screen}
 EJMP 23                \                {move to row 10, white, lower case}
 EJMP 14                \                {justify}
 EJMP 2                 \                {sentence case}
 ECHR ' '               \                  CONGRATULATIONS {single cap}
 ECHR ' '               \                COMMANDER!{cr}
 ECHR 'C'               \                {cr}
 ETWO 'O', 'N'          \                THERE{lower case} WILL ALWAYS BE A
 ECHR 'G'               \                PLACE FOR YOU IN{sentence case} HER
 ETWO 'R', 'A'          \                MAJESTY'S SPACE NAVY{lower case}.{cr}
 ECHR 'T'               \                 {single cap}AND MAYBE SOONER THAN YOU
 ECHR 'U'               \                THINK...{cr}
 ETWO 'L', 'A'          \                {left align}{tab 6}{all caps}  MESSAGE
 ETWO 'T', 'I'          \                ENDS{wait for key press}"
 ETWO 'O', 'N'          \
 ECHR 'S'               \ Encoded as:   "{25}{9}{23}{14}{2}  C<223>G<248>TU
 ECHR ' '               \                <249><251><223>S [154]!{12}{12}<226>
 ETOK 154               \                <244>E{13} W<220>L <228>WAYS <247>[208]
 ECHR '!'               \                P<249><233> F<253> [179] <240>[211]
 EJMP 12                \                [204]<255>D <239>Y<247> <235><223><244>
 EJMP 12                \                 <226><255> [179] <226><240>K..[212]
 ETWO 'T', 'H'          \                {24}"
 ETWO 'E', 'R'
 ECHR 'E'
 EJMP 13
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'A', 'L'
 ECHR 'W'
 ECHR 'A'
 ECHR 'Y'
 ECHR 'S'
 ECHR ' '
 ETWO 'B', 'E'
 ETOK 208
 ECHR 'P'
 ETWO 'L', 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ETOK 179
 ECHR ' '
 ETWO 'I', 'N'
 ETOK 211
 ETOK 204
 ETWO 'A', 'N'
 ECHR 'D'
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'Y'
 ETWO 'B', 'E'
 ECHR ' '
 ETWO 'S', 'O'
 ETWO 'O', 'N'
 ETWO 'E', 'R'
 ECHR ' '
 ETWO 'T', 'H'
 ETWO 'A', 'N'
 ECHR ' '
 ETOK 179
 ECHR ' '
 ETWO 'T', 'H'
 ETWO 'I', 'N'
 ECHR 'K'
 ECHR '.'
 ECHR '.'
 ETOK 212
 EJMP 24
 EQUB VE

 ECHR 'F'               \ Token 16:     "FABLED"
 ETWO 'A', 'B'          \
 ETWO 'L', 'E'          \ Encoded as:   "F<216><229>D"
 ECHR 'D'
 EQUB VE

 ETWO 'N', 'O'          \ Token 17:     "NOTABLE"
 ECHR 'T'               \
 ETWO 'A', 'B'          \ Encoded as:   "<227>T<216><229>"
 ETWO 'L', 'E'
 EQUB VE

 ECHR 'W'               \ Token 18:     "WELL KNOWN"
 ECHR 'E'               \
 ECHR 'L'               \ Encoded as:   "WELL K<227>WN"
 ECHR 'L'
 ECHR ' '
 ECHR 'K'
 ETWO 'N', 'O'
 ECHR 'W'
 ECHR 'N'
 EQUB VE

 ECHR 'F'               \ Token 19:     "FAMOUS"
 ECHR 'A'               \
 ECHR 'M'               \ Encoded as:   "FAMO<236>"
 ECHR 'O'
 ETWO 'U', 'S'
 EQUB VE

 ETWO 'N', 'O'          \ Token 20:     "NOTED"
 ECHR 'T'               \
 ETWO 'E', 'D'          \ Encoded as:   "<227>T<252>"
 EQUB VE

 ETWO 'V', 'E'          \ Token 21:     "VERY"
 ECHR 'R'               \
 ECHR 'Y'               \ Encoded as:   "<250>RY"
 EQUB VE

 ECHR 'M'               \ Token 22:     "MILDLY"
 ETWO 'I', 'L'          \
 ECHR 'D'               \ Encoded as:   "M<220>DLY"
 ECHR 'L'
 ECHR 'Y'
 EQUB VE

 ECHR 'M'               \ Token 23:     "MOST"
 ECHR 'O'               \
 ETWO 'S', 'T'          \ Encoded as:   "MO<222>"
 EQUB VE

 ETWO 'R', 'E'          \ Token 24:     "REASONABLY"
 ECHR 'A'               \
 ECHR 'S'               \ Encoded as:   "<242>AS<223><216>LY"
 ETWO 'O', 'N'
 ETWO 'A', 'B'
 ECHR 'L'
 ECHR 'Y'
 EQUB VE

 EQUB VE                \ Token 25:     ""
                        \
                        \ Encoded as:   ""

 ETOK 165               \ Token 26:     "ANCIENT"
 EQUB VE                \
                        \ Encoded as:   "[165]"

 ERND 23                \ Token 27:     "[130-134]"
 EQUB VE                \
                        \ Encoded as:   "[23?]"

 ECHR 'G'               \ Token 28:     "GREAT"
 ETWO 'R', 'E'          \
 ETWO 'A', 'T'          \ Encoded as:   "G<242><245>"
 EQUB VE

 ECHR 'V'               \ Token 29:     "VAST"
 ECHR 'A'               \
 ETWO 'S', 'T'          \ Encoded as:   "VA<222>"
 EQUB VE

 ECHR 'P'               \ Token 30:     "PINK"
 ETWO 'I', 'N'          \
 ECHR 'K'               \ Encoded as:   "P<240>K"
 EQUB VE

 EJMP 2                 \ Token 31:     "{sentence case}[190-194] [185-189]
 ERND 28                \                {lower case} PLANTATIONS"
 ECHR ' '               \
 ERND 27                \ Encoded as:   "{2}[28?] [27?]{13} [185]A<251><223>S"
 EJMP 13
 ECHR ' '
 ETOK 185
 ECHR 'A'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 ECHR 'S'
 EQUB VE

 ETOK 156               \ Token 32:     "MOUNTAINS"
 ECHR 'S'               \
 EQUB VE                \ Encoded as:   "[156]S"

 ERND 26                \ Token 33:     "[180-184]"
 EQUB VE                \
                        \ Encoded as:   "[26?]"

 ERND 37                \ Token 34:     "[125-129] FORESTS"
 ECHR ' '               \
 ECHR 'F'               \ Encoded as:   "[37?] F<253><237>TS"
 ETWO 'O', 'R'
 ETWO 'E', 'S'
 ECHR 'T'
 ECHR 'S'
 EQUB VE

 ECHR 'O'               \ Token 35:     "OCEANS"
 ETWO 'C', 'E'          \
 ETWO 'A', 'N'          \ Encoded as:   "O<233><255>S"
 ECHR 'S'
 EQUB VE

 ECHR 'S'               \ Token 36:     "SHYNESS"
 ECHR 'H'               \
 ECHR 'Y'               \ Encoded as:   "SHYN<237>S"
 ECHR 'N'
 ETWO 'E', 'S'
 ECHR 'S'
 EQUB VE

 ECHR 'S'               \ Token 37:     "SILLINESS"
 ETWO 'I', 'L'          \
 ECHR 'L'               \ Encoded as:   "S<220>L<240><237>S"
 ETWO 'I', 'N'
 ETWO 'E', 'S'
 ECHR 'S'
 EQUB VE

 ETWO 'M', 'A'          \ Token 38:     "MATING TRADITIONS"
 ECHR 'T'               \
 ETOK 195               \ Encoded as:   "<239>T[195]T<248><241><251><223>S"
 ECHR 'T'
 ETWO 'R', 'A'
 ETWO 'D', 'I'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 ECHR 'S'
 EQUB VE

 ETWO 'L', 'O'          \ Token 39:     "LOATHING OF [41-45]"
 ETWO 'A', 'T'          \
 ECHR 'H'               \ Encoded as:   "<224><245>H[195]OF [9?]"
 ETOK 195
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ERND 9
 EQUB VE

 ETWO 'L', 'O'          \ Token 40:     "LOVE FOR [41-45]"
 ETWO 'V', 'E'          \
 ECHR ' '               \ Encoded as:   "<224><250> F<253> [9?]"
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ERND 9
 EQUB VE

 ECHR 'F'               \ Token 41:     "FOOD BLENDERS"
 ECHR 'O'               \
 ECHR 'O'               \ Encoded as:   "FOOD B<229>ND<244>S"
 ECHR 'D'
 ECHR ' '
 ECHR 'B'
 ETWO 'L', 'E'
 ECHR 'N'
 ECHR 'D'
 ETWO 'E', 'R'
 ECHR 'S'
 EQUB VE

 ECHR 'T'               \ Token 42:     "TOURISTS"
 ETWO 'O', 'U'          \
 ECHR 'R'               \ Encoded as:   "T<217>RI<222>S"
 ECHR 'I'
 ETWO 'S', 'T'
 ECHR 'S'
 EQUB VE

 ECHR 'P'               \ Token 43:     "POETRY"
 ECHR 'O'               \
 ETWO 'E', 'T'          \ Encoded as:   "PO<221>RY"
 ECHR 'R'
 ECHR 'Y'
 EQUB VE

 ETWO 'D', 'I'          \ Token 44:     "DISCOS"
 ECHR 'S'               \
 ECHR 'C'               \ Encoded as:   "<241>SCOS"
 ECHR 'O'
 ECHR 'S'
 EQUB VE

 ERND 17                \ Token 45:     "[81-85]"
 EQUB VE                \
                        \ Encoded as:   "[17?]"

 ECHR 'W'               \ Token 46:     "WALKING TREE"
 ETWO 'A', 'L'          \
 ECHR 'K'               \ Encoded as:   "W<228>K[195][158]"
 ETOK 195
 ETOK 158
 EQUB VE

 ECHR 'C'               \ Token 47:     "CRAB"
 ETWO 'R', 'A'          \
 ECHR 'B'               \ Encoded as:   "C<248>B"
 EQUB VE

 ECHR 'B'               \ Token 48:     "BAT"
 ETWO 'A', 'T'          \
 EQUB VE                \ Encoded as:   "B<245>"

 ETWO 'L', 'O'          \ Token 49:     "LOBST"
 ECHR 'B'               \
 ETWO 'S', 'T'          \ Encoded as:   "<224>B<222>"
 EQUB VE

 EJMP 18                \ Token 50:     "{random 1-8 letter word}"
 EQUB VE                \
                        \ Encoded as:   "{18}"

 ETWO 'B', 'E'          \ Token 51:     "BESET"
 ECHR 'S'               \
 ETWO 'E', 'T'          \ Encoded as:   "<247>S<221>"
 EQUB VE

 ECHR 'P'               \ Token 52:     "PLAGUED"
 ETWO 'L', 'A'          \
 ECHR 'G'               \ Encoded as:   "P<249>GU<252>"
 ECHR 'U'
 ETWO 'E', 'D'
 EQUB VE

 ETWO 'R', 'A'          \ Token 53:     "RAVAGED"
 ECHR 'V'               \
 ECHR 'A'               \ Encoded as:   "<248>VAG<252>"
 ECHR 'G'
 ETWO 'E', 'D'
 EQUB VE

 ECHR 'C'               \ Token 54:     "CURSED"
 ECHR 'U'               \
 ECHR 'R'               \ Encoded as:   "CURS<252>"
 ECHR 'S'
 ETWO 'E', 'D'
 EQUB VE

 ECHR 'S'               \ Token 55:     "SCOURGED"
 ECHR 'C'               \
 ETWO 'O', 'U'          \ Encoded as:   "SC<217>RG<252>"
 ECHR 'R'
 ECHR 'G'
 ETWO 'E', 'D'
 EQUB VE

 ERND 22                \ Token 56:     "[135-139] CIVIL WAR"
 ECHR ' '               \
 ECHR 'C'               \ Encoded as:   "[22?] CIV<220> W<238>"
 ECHR 'I'
 ECHR 'V'
 ETWO 'I', 'L'
 ECHR ' '
 ECHR 'W'
 ETWO 'A', 'R'
 EQUB VE

 ERND 13                \ Token 57:     "[170-174] [155-159] [160-164]S"
 ECHR ' '               \
 ERND 4                 \ Encoded as:   "[13?] [4?] [5?]S"
 ECHR ' '
 ERND 5
 ECHR 'S'
 EQUB VE

 ECHR 'A'               \ Token 58:     "A [170-174] DISEASE"
 ECHR ' '               \
 ERND 13                \ Encoded as:   "A [13?] <241><218>A<218>"
 ECHR ' '
 ETWO 'D', 'I'
 ETWO 'S', 'E'
 ECHR 'A'
 ETWO 'S', 'E'
 EQUB VE

 ERND 22                \ Token 59:     "[135-139] EARTHQUAKES"
 ECHR ' '               \
 ECHR 'E'               \ Encoded as:   "[22?] E<238><226><254>AK<237>"
 ETWO 'A', 'R'
 ETWO 'T', 'H'
 ETWO 'Q', 'U'
 ECHR 'A'
 ECHR 'K'
 ETWO 'E', 'S'
 EQUB VE

 ERND 22                \ Token 60:     "[135-139] SOLAR ACTIVITY"
 ECHR ' '               \
 ETWO 'S', 'O'          \ Encoded as:   "[22?] <235><249>R AC<251>V<219>Y"
 ETWO 'L', 'A'
 ECHR 'R'
 ECHR ' '
 ECHR 'A'
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'V'
 ETWO 'I', 'T'
 ECHR 'Y'
 EQUB VE

 ETOK 175               \ Token 61:     "ITS [26-30] [31-35]"
 ERND 2                 \
 ECHR ' '               \ Encoded as:   "[175][2?] [3?]"
 ERND 3
 EQUB VE

 ETOK 147               \ Token 62:     "THE {system name adjective} [155-159]
 EJMP 17                \                 [160-164]"
 ECHR ' '               \
 ERND 4                 \ Encoded as:   "[147]{17} [4?] [5?]"
 ECHR ' '
 ERND 5
 EQUB VE

 ETOK 175               \ Token 63:     "ITS INHABITANTS' [165-169] [36-40]"
 ETOK 193               \
 ECHR 'S'               \ Encoded as:   "[175][193]S[39] [7?] [8?]"
 ECHR '`'
 ECHR ' '
 ERND 7
 ECHR ' '
 ERND 8
 EQUB VE

 EJMP 2                 \ Token 64:     "{sentence case}[235-239]{lower case}"
 ERND 31                \
 EJMP 13                \ Encoded as:   "{2}[31?]{13}"
 EQUB VE

 ETOK 175               \ Token 65:     "ITS [76-80] [81-85]"
 ERND 16                \
 ECHR ' '               \ Encoded as:   "[175][16?] [17?]"
 ERND 17
 EQUB VE

 ECHR 'J'               \ Token 66:     "JUICE"
 ECHR 'U'               \
 ECHR 'I'               \ Encoded as:   "JUI<233>"
 ETWO 'C', 'E'
 EQUB VE

 ECHR 'B'               \ Token 67:     "BRANDY"
 ETWO 'R', 'A'          \
 ECHR 'N'               \ Encoded as:   "B<248>NDY"
 ECHR 'D'
 ECHR 'Y'
 EQUB VE

 ECHR 'W'               \ Token 68:     "WATER"
 ETWO 'A', 'T'          \
 ETWO 'E', 'R'          \ Encoded as:   "W<245><244>"
 EQUB VE

 ECHR 'B'               \ Token 69:     "BREW"
 ETWO 'R', 'E'          \
 ECHR 'W'               \ Encoded as:   "B<242>W"
 EQUB VE

 ECHR 'G'               \ Token 70:     "GARGLE BLASTERS"
 ETWO 'A', 'R'          \
 ECHR 'G'               \ Encoded as:   "G<238>G<229> B<249><222><244>S"
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'B'
 ETWO 'L', 'A'
 ETWO 'S', 'T'
 ETWO 'E', 'R'
 ECHR 'S'
 EQUB VE

 EJMP 18                \ Token 71:     "{random 1-8 letter word}"
 EQUB VE                \
                        \ Encoded as:   "{18}"

 EJMP 17                \ Token 72:     "{system name adjective} [160-164]"
 ECHR ' '               \
 ERND 5                 \ Encoded as:   "{17} [5?]"
 EQUB VE

 EJMP 17                \ Token 73:     "{system name adjective} {random 1-8
 ECHR ' '               \                letter word}"
 EJMP 18                \
 EQUB VE                \ Encoded as:   "{17} {18}"

 EJMP 17                \ Token 74:     "{system name adjective} [170-174]"
 ECHR ' '               \
 ERND 13                \ Encoded as:   "{17} [13?]"
 EQUB VE

 ERND 13                \ Token 75:     "[170-174] {random 1-8 letter word}"
 ECHR ' '               \
 EJMP 18                \ Encoded as:   "[13?] {18}"
 EQUB VE

 ECHR 'F'               \ Token 76:     "FABULOUS"
 ETWO 'A', 'B'          \
 ECHR 'U'               \ Encoded as:   "F<216>U<224><236>"
 ETWO 'L', 'O'
 ETWO 'U', 'S'
 EQUB VE

 ECHR 'E'               \ Token 77:     "EXOTIC"
 ECHR 'X'               \
 ECHR 'O'               \ Encoded as:   "EXO<251>C"
 ETWO 'T', 'I'
 ECHR 'C'
 EQUB VE

 ECHR 'H'               \ Token 78:     "HOOPY"
 ECHR 'O'               \
 ECHR 'O'               \ Encoded as:   "HOOPY"
 ECHR 'P'
 ECHR 'Y'
 EQUB VE

 ECHR 'U'               \ Token 79:     "UNUSUAL"
 ETWO 'N', 'U'          \
 ECHR 'S'               \ Encoded as:   "U<225>SU<228>"
 ECHR 'U'
 ETWO 'A', 'L'
 EQUB VE

 ECHR 'E'               \ Token 80:     "EXCITING"
 ECHR 'X'               \
 ECHR 'C'               \ Encoded as:   "EXC<219><240>G"
 ETWO 'I', 'T'
 ETWO 'I', 'N'
 ECHR 'G'
 EQUB VE

 ECHR 'C'               \ Token 81:     "CUISINE"
 ECHR 'U'               \
 ECHR 'I'               \ Encoded as:   "CUIS<240>E"
 ECHR 'S'
 ETWO 'I', 'N'
 ECHR 'E'
 EQUB VE

 ECHR 'N'               \ Token 82:     "NIGHT LIFE"
 ECHR 'I'               \
 ECHR 'G'               \ Encoded as:   "NIGHT LIFE"
 ECHR 'H'
 ECHR 'T'
 ECHR ' '
 ECHR 'L'
 ECHR 'I'
 ECHR 'F'
 ECHR 'E'
 EQUB VE

 ECHR 'C'               \ Token 83:     "CASINOS"
 ECHR 'A'               \
 ECHR 'S'               \ Encoded as:   "CASI<227>S"
 ECHR 'I'
 ETWO 'N', 'O'
 ECHR 'S'
 EQUB VE

 ECHR 'S'               \ Token 84:     "SIT COMS"
 ETWO 'I', 'T'          \
 ECHR ' '               \ Encoded as:   "S<219> COMS"
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'S'
 EQUB VE

 EJMP 2                 \ Token 85:     "{sentence case}[235-239]{lower case}"
 ERND 31                \
 EJMP 13                \ Encoded as:   "{2}[31?]{13}"
 EQUB VE

 EJMP 3                 \ Token 86:     "{selected system name}"
 EQUB VE                \
                        \ Encoded as:   "{3}"

 ETOK 147               \ Token 87:     "THE PLANET {selected system name}"
 ETOK 145               \
 ECHR ' '               \ Encoded as:   "[147][145] {3}"
 EJMP 3
 EQUB VE

 ETOK 147               \ Token 88:     "THE WORLD {selected system name}"
 ETOK 146               \
 ECHR ' '               \ Encoded as:   "[147][146] {3}"
 EJMP 3
 EQUB VE

 ETOK 148               \ Token 89:     "THIS PLANET"
 ETOK 145               \
 EQUB VE                \ Encoded as:   "[148][145]"

 ETOK 148               \ Token 90:     "THIS WORLD"
 ETOK 146               \
 EQUB VE                \ Encoded as:   "[148][146]"

 ECHR 'S'               \ Token 91:     "SON OF A BITCH"
 ETWO 'O', 'N'          \
 ECHR ' '               \ Encoded as:   "S<223> OF[208]B<219>CH"
 ECHR 'O'
 ECHR 'F'
 ETOK 208
 ECHR 'B'
 ETWO 'I', 'T'
 ECHR 'C'
 ECHR 'H'
 EQUB VE

 ECHR 'S'               \ Token 92:     "SCOUNDREL"
 ECHR 'C'               \
 ETWO 'O', 'U'          \ Encoded as:   "SC<217>ND<242>L"
 ECHR 'N'
 ECHR 'D'
 ETWO 'R', 'E'
 ECHR 'L'
 EQUB VE

 ECHR 'B'               \ Token 93:     "BLACKGUARD"
 ETWO 'L', 'A'          \
 ECHR 'C'               \ Encoded as:   "B<249>CKGU<238>D"
 ECHR 'K'
 ECHR 'G'
 ECHR 'U'
 ETWO 'A', 'R'
 ECHR 'D'
 EQUB VE

 ECHR 'R'               \ Token 94:     "ROGUE"
 ECHR 'O'               \
 ECHR 'G'               \ Encoded as:   "ROGUE"
 ECHR 'U'
 ECHR 'E'
 EQUB VE

 ECHR 'W'               \ Token 95:     "WHORESON BEETLE HEAD FLAP EAR'D
 ECHR 'H'               \                KNAVE"
 ETWO 'O', 'R'          \
 ETWO 'E', 'S'          \ Encoded as:   "WH<253><237><223> <247><221><229> HEAD
 ETWO 'O', 'N'          \                [198]F<249>P E<238>[39]D KNA<250>"
 ECHR ' '
 ETWO 'B', 'E'
 ETWO 'E', 'T'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'H'
 ECHR 'E'
 ECHR 'A'
 ECHR 'D'
 ETOK 198
 ECHR 'F'
 ETWO 'L', 'A'
 ECHR 'P'
 ECHR ' '
 ECHR 'E'
 ETWO 'A', 'R'
 ECHR '`'
 ECHR 'D'
 ECHR ' '
 ECHR 'K'
 ECHR 'N'
 ECHR 'A'
 ETWO 'V', 'E'
 EQUB VE

 ECHR 'N'               \ Token 96:     "N UNREMARKABLE"
 ECHR ' '               \
 ECHR 'U'               \ Encoded as:   "N UN<242><239>RK<216><229>"
 ECHR 'N'
 ETWO 'R', 'E'
 ETWO 'M', 'A'
 ECHR 'R'
 ECHR 'K'
 ETWO 'A', 'B'
 ETWO 'L', 'E'
 EQUB VE

 ECHR ' '               \ Token 97:     " BORING"
 ECHR 'B'               \
 ETWO 'O', 'R'          \ Encoded as:   " B<253><240>G"
 ETWO 'I', 'N'
 ECHR 'G'
 EQUB VE

 ECHR ' '               \ Token 98:     " DULL"
 ECHR 'D'               \
 ECHR 'U'               \ Encoded as:   " DULL"
 ECHR 'L'
 ECHR 'L'
 EQUB VE

 ECHR ' '               \ Token 99:     " TEDIOUS"
 ECHR 'T'               \
 ECHR 'E'               \ Encoded as:   " TE<241>O<236>"
 ETWO 'D', 'I'
 ECHR 'O'
 ETWO 'U', 'S'
 EQUB VE

 ECHR ' '               \ Token 100:    " REVOLTING"
 ETWO 'R', 'E'          \
 ECHR 'V'               \ Encoded as:   " <242>VOLT<240>G"
 ECHR 'O'
 ECHR 'L'
 ECHR 'T'
 ETWO 'I', 'N'
 ECHR 'G'
 EQUB VE

 ETOK 145               \ Token 101:    "PLANET"
 EQUB VE                \
                        \ Encoded as:   "[145]"

 ETOK 146               \ Token 102:    "WORLD"
 EQUB VE                \
                        \ Encoded as:   "[146]"

 ECHR 'P'               \ Token 103:    "PLACE"
 ETWO 'L', 'A'          \
 ETWO 'C', 'E'          \ Encoded as:   "P<249><233>"
 EQUB VE

 ECHR 'L'               \ Token 104:    "LITTLE PLANET"
 ETWO 'I', 'T'          \
 ECHR 'T'               \ Encoded as:   "L<219>T<229> [145]"
 ETWO 'L', 'E'
 ECHR ' '
 ETOK 145
 EQUB VE

 ECHR 'D'               \ Token 105:    "DUMP"
 ECHR 'U'               \
 ECHR 'M'               \ Encoded as:   "DUMP"
 ECHR 'P'
 EQUB VE

 ECHR 'I'               \ Token 106:    "I HEAR A [130-134] LOOKING SHIP
 ECHR ' '               \                APPEARED AT ERRIUS"
 ECHR 'H'               \
 ECHR 'E'               \ Encoded as:   "I HE<238>[208][23?] <224>OK[195][207]
 ETWO 'A', 'R'          \                 APPE<238>[196]<245>[209]"
 ETOK 208
 ERND 23
 ECHR ' '
 ETWO 'L', 'O'
 ECHR 'O'
 ECHR 'K'
 ETOK 195
 ETOK 207
 ECHR ' '
 ECHR 'A'
 ECHR 'P'
 ECHR 'P'
 ECHR 'E'
 ETWO 'A', 'R'
 ETOK 196
 ETWO 'A', 'T'
 ETOK 209
 EQUB VE

 ECHR 'Y'               \ Token 107:    "YEAH, I HEAR A [130-134] SHIP LEFT
 ECHR 'E'               \                ERRIUS A  WHILE BACK"
 ECHR 'A'               \
 ECHR 'H'               \ Encoded as:   "YEAH, I HE<238>[208][23?] [207]
 ECHR ','               \                 <229>FT[209][208] WHI<229> BACK"
 ECHR ' '
 ECHR 'I'
 ECHR ' '
 ECHR 'H'
 ECHR 'E'
 ETWO 'A', 'R'
 ETOK 208
 ERND 23
 ECHR ' '
 ETOK 207
 ECHR ' '
 ETWO 'L', 'E'
 ECHR 'F'
 ECHR 'T'
 ETOK 209
 ETOK 208
 ECHR ' '
 ECHR 'W'
 ECHR 'H'
 ECHR 'I'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'B'
 ECHR 'A'
 ECHR 'C'
 ECHR 'K'
 EQUB VE

 ECHR 'G'               \ Token 108:    "GET YOUR IRON ASS OVER TO ERRIUS"
 ETWO 'E', 'T'          \
 ECHR ' '               \ Encoded as:   "G<221> [179]R IR<223> ASS OV<244> TO
 ETOK 179               \                [209]"
 ECHR 'R'
 ECHR ' '
 ECHR 'I'
 ECHR 'R'
 ETWO 'O', 'N'
 ECHR ' '
 ECHR 'A'
 ECHR 'S'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'V'
 ETWO 'E', 'R'
 ECHR ' '
 ECHR 'T'
 ECHR 'O'
 ETOK 209
 EQUB VE

 ETWO 'S', 'O'          \ Token 109:    "SOME [91-95] NEW SHIP WAS SEEN AT
 ECHR 'M'               \                ERRIUS"
 ECHR 'E'               \
 ECHR ' '               \ Encoded as:   "<235>ME [24?][210][207] WAS <218><246>
 ERND 24                \                 <245>[209]"
 ETOK 210
 ETOK 207
 ECHR ' '
 ECHR 'W'
 ECHR 'A'
 ECHR 'S'
 ECHR ' '
 ETWO 'S', 'E'
 ETWO 'E', 'N'
 ECHR ' '
 ETWO 'A', 'T'
 ETOK 209
 EQUB VE

 ECHR 'T'               \ Token 110:    "TRY ERRIUS"
 ECHR 'R'               \
 ECHR 'Y'               \ Encoded as:   "TRY[209]"
 ETOK 209
 EQUB VE

 EJMP 1                 \ Token 111:    "{all caps}SPECIAL CARGO"
 ECHR 'S'               \
 ECHR 'P'               \ Encoded as:   "{1}SPECI<228> C<238>GO"
 ECHR 'E'
 ECHR 'C'
 ECHR 'I'
 ETWO 'A', 'L'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'R'
 ECHR 'G'
 ECHR 'O'
 EQUB VE

 EQUB VE                \ Token 112:    ""
                        \
                        \ Encoded as:   ""

 ECHR 'C'               \ Token 113:    "CARGO VALUE:"
 ETWO 'A', 'R'          \
 ECHR 'G'               \ Encoded as:   "C<238>GO V<228>UE:"
 ECHR 'O'
 ECHR ' '
 ECHR 'V'
 ETWO 'A', 'L'
 ECHR 'U'
 ECHR 'E'
 ECHR ':'
 EQUB VE

 ECHR ' '               \ Token 114:    " MODIFIED BY A.J.C.DUGGAN"
 ECHR 'M'               \
 ECHR 'O'               \ Encoded as:   " MO<241>FI<252> BY A.J.C.DUGG<255>"
 ETWO 'D', 'I'
 ECHR 'F'
 ECHR 'I'
 ETWO 'E', 'D'
 ECHR ' '
 ECHR 'B'
 ECHR 'Y'
 ECHR ' '
 ECHR 'A'
 ECHR '.'
 ECHR 'J'
 ECHR '.'
 ECHR 'C'
 ECHR '.'
 ECHR 'D'
 ECHR 'U'
 ECHR 'G'
 ECHR 'G'
 ETWO 'A', 'N'
 EQUB VE

 ECHR 'W'               \ Token 115:    "WASP"
 ECHR 'A'               \
 ECHR 'S'               \ Encoded as:   "WASP"
 ECHR 'P'
 EQUB VE

 ECHR 'M'               \ Token 116:    "MOTH"
 ECHR 'O'               \
 ETWO 'T', 'H'          \ Encoded as:   "MO<226>"
 EQUB VE

 ECHR 'G'               \ Token 117:    "GRUB"
 ECHR 'R'               \
 ECHR 'U'               \ Encoded as:   "GRUB"
 ECHR 'B'
 EQUB VE

 ETWO 'A', 'N'          \ Token 118:    "ANT"
 ECHR 'T'               \
 EQUB VE                \ Encoded as:   "<255>T"

 EJMP 18                \ Token 119:    "{random 1-8 letter word}"
 EQUB VE                \
                        \ Encoded as:   "{18}"

 ECHR 'P'               \ Token 120:    "POET"
 ECHR 'O'               \
 ETWO 'E', 'T'          \ Encoded as:   "PO<221>"
 EQUB VE

 ETWO 'A', 'R'          \ Token 121:    "ARTS GRADUATE"
 ECHR 'T'               \
 ECHR 'S'               \ Encoded as:   "<238>TS G<248>DU<245>E"
 ECHR ' '
 ECHR 'G'
 ETWO 'R', 'A'
 ECHR 'D'
 ECHR 'U'
 ETWO 'A', 'T'
 ECHR 'E'
 EQUB VE

 ECHR 'Y'               \ Token 122:    "YAK"
 ECHR 'A'               \
 ECHR 'K'               \ Encoded as:   "YAK"
 EQUB VE

 ECHR 'S'               \ Token 123:    "SNAIL"
 ECHR 'N'               \
 ECHR 'A'               \ Encoded as:   "SNA<220>"
 ETWO 'I', 'L'
 EQUB VE

 ECHR 'S'               \ Token 124:    "SLUG"
 ECHR 'L'               \
 ECHR 'U'               \ Encoded as:   "SLUG"
 ECHR 'G'
 EQUB VE

 ECHR 'T'               \ Token 125:    "TROPICAL"
 ECHR 'R'               \
 ECHR 'O'               \ Encoded as:   "TROPIC<228>"
 ECHR 'P'
 ECHR 'I'
 ECHR 'C'
 ETWO 'A', 'L'
 EQUB VE

 ECHR 'D'               \ Token 126:    "DENSE"
 ETWO 'E', 'N'          \
 ETWO 'S', 'E'          \ Encoded as:   "D<246><218>"
 EQUB VE

 ETWO 'R', 'A'          \ Token 127:    "RAIN"
 ETWO 'I', 'N'          \
 EQUB VE                \ Encoded as:   "<248><240>"

 ECHR 'I'               \ Token 128:    "IMPENETRABLE"
 ECHR 'M'               \
 ECHR 'P'               \ Encoded as:   "IMP<246><221><248>B<229>"
 ETWO 'E', 'N'
 ETWO 'E', 'T'
 ETWO 'R', 'A'
 ECHR 'B'
 ETWO 'L', 'E'
 EQUB VE

 ECHR 'E'               \ Token 129:    "EXUBERANT"
 ECHR 'X'               \
 ECHR 'U'               \ Encoded as:   "EXU<247><248>NT"
 ETWO 'B', 'E'
 ETWO 'R', 'A'
 ECHR 'N'
 ECHR 'T'
 EQUB VE

 ECHR 'F'               \ Token 130:    "FUNNY"
 ECHR 'U'               \
 ECHR 'N'               \ Encoded as:   "FUNNY"
 ECHR 'N'
 ECHR 'Y'
 EQUB VE

 ECHR 'W'               \ Token 131:    "WIERD"
 ECHR 'I'               \
 ETWO 'E', 'R'          \ Encoded as:   "WI<244>D"
 ECHR 'D'
 EQUB VE

 ECHR 'U'               \ Token 132:    "UNUSUAL"
 ETWO 'N', 'U'          \
 ECHR 'S'               \ Encoded as:   "U<225>SU<228>"
 ECHR 'U'
 ETWO 'A', 'L'
 EQUB VE

 ETWO 'S', 'T'          \ Token 133:    "STRANGE"
 ETWO 'R', 'A'          \
 ECHR 'N'               \ Encoded as:   "<222><248>N<231>"
 ETWO 'G', 'E'
 EQUB VE

 ECHR 'P'               \ Token 134:    "PECULIAR"
 ECHR 'E'               \
 ECHR 'C'               \ Encoded as:   "PECULI<238>"
 ECHR 'U'
 ECHR 'L'
 ECHR 'I'
 ETWO 'A', 'R'
 EQUB VE

 ECHR 'F'               \ Token 135:    "FREQUENT"
 ETWO 'R', 'E'          \
 ETWO 'Q', 'U'          \ Encoded as:   "F<242><254><246>T"
 ETWO 'E', 'N'
 ECHR 'T'
 EQUB VE

 ECHR 'O'               \ Token 136:    "OCCASIONAL"
 ECHR 'C'               \
 ECHR 'C'               \ Encoded as:   "OCCASI<223><228>"
 ECHR 'A'
 ECHR 'S'
 ECHR 'I'
 ETWO 'O', 'N'
 ETWO 'A', 'L'
 EQUB VE

 ECHR 'U'               \ Token 137:    "UNPREDICTABLE"
 ECHR 'N'               \
 ECHR 'P'               \ Encoded as:   "UNP<242><241>CT<216><229>"
 ETWO 'R', 'E'
 ETWO 'D', 'I'
 ECHR 'C'
 ECHR 'T'
 ETWO 'A', 'B'
 ETWO 'L', 'E'
 EQUB VE

 ECHR 'D'               \ Token 138:    "DREADFUL"
 ETWO 'R', 'E'          \
 ECHR 'A'               \ Encoded as:   "D<242>ADFUL"
 ECHR 'D'
 ECHR 'F'
 ECHR 'U'
 ECHR 'L'
 EQUB VE

 ETOK 171               \ Token 139:    "DEADLY"
 EQUB VE                \
                        \ Encoded as:   "[171]"

 ERND 1                 \ Token 140:    "[21-25] [16-20] FOR [61-65]"
 ECHR ' '               \
 ERND 0                 \ Encoded as:   "[1?] [0?] F<253> [10?]"
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ERND 10
 EQUB VE

 ETOK 140               \ Token 141:    "[21-25] [16-20] FOR [61-65] AND
 ETOK 178               \                [61-65]"
 ERND 10                \
 EQUB VE                \ Encoded as:   "[140][178][10?]"

 ERND 11                \ Token 142:    "[51-55] BY [56-60]"
 ECHR ' '               \
 ECHR 'B'               \ Encoded as:   "[11?] BY [12?]"
 ECHR 'Y'
 ECHR ' '
 ERND 12
 EQUB VE

 ETOK 140               \ Token 143:    "[21-25] [16-20] FOR [61-65] BUT [51-55]
 ECHR ' '               \                BY [56-60]"
 ECHR 'B'               \
 ECHR 'U'               \ Encoded as:   "[140] BUT [142]"
 ECHR 'T'
 ECHR ' '
 ETOK 142
 EQUB VE

 ECHR ' '               \ Token 144:    " A[96-100] [101-105]"
 ECHR 'A'               \
 ERND 20                \ Encoded as:   " A[20?] [21?]"
 ECHR ' '
 ERND 21
 EQUB VE

 ECHR 'P'               \ Token 145:    "PLANET"
 ECHR 'L'               \
 ETWO 'A', 'N'          \ Encoded as:   "PL<255><221>"
 ETWO 'E', 'T'
 EQUB VE

 ECHR 'W'               \ Token 146:    "WORLD"
 ETWO 'O', 'R'          \
 ECHR 'L'               \ Encoded as:   "W<253>LD"
 ECHR 'D'
 EQUB VE

 ETWO 'T', 'H'          \ Token 147:    "THE "
 ECHR 'E'               \
 ECHR ' '               \ Encoded as:   "<226>E "
 EQUB VE

 ETWO 'T', 'H'          \ Token 148:    "THIS "
 ECHR 'I'               \
 ECHR 'S'               \ Encoded as:   "<226>IS "
 ECHR ' '
 EQUB VE

 ETWO 'L', 'O'          \ Token 149:    "LOAD NEW {single cap}COMMANDER"
 ECHR 'A'               \
 ECHR 'D'               \ Encoded as:   "<224>AD[210][154]"
 ETOK 210
 ETOK 154
 EQUB VE

 EJMP 9                 \ Token 150:    "{clear screen}
 EJMP 11                \                {draw box around title}
 EJMP 1                 \                {all caps}
 EJMP 8                 \                {tab 6}"
 EQUB VE                \
                        \ Encoded as:   "{9}{11}{1}{8}"

 ECHR 'D'               \ Token 151:    "DRIVE"
 ECHR 'R'               \
 ECHR 'I'               \ Encoded as:   "DRI<250>"
 ETWO 'V', 'E'
 EQUB VE

 ECHR ' '               \ Token 152:    " CATALOGUE"
 ECHR 'C'               \
 ETWO 'A', 'T'          \ Encoded as:   " C<245>A<224>GUE"
 ECHR 'A'
 ETWO 'L', 'O'
 ECHR 'G'
 ECHR 'U'
 ECHR 'E'
 EQUB VE

 ECHR 'I'               \ Token 153:    "IAN"
 ETWO 'A', 'N'          \
 EQUB VE                \ Encoded as:   "I<255>"

 EJMP 19                \ Token 154:    "{single cap}COMMANDER"
 ECHR 'C'               \
 ECHR 'O'               \ Encoded as:   "{19}COMM<255>D<244>"
 ECHR 'M'
 ECHR 'M'
 ETWO 'A', 'N'
 ECHR 'D'
 ETWO 'E', 'R'
 EQUB VE

 ERND 13                \ Token 155:    "[170-174]"
 EQUB VE                \
                        \ Encoded as:   "[13?]"

 ECHR 'M'               \ Token 156:    "MOUNTAIN"
 ETWO 'O', 'U'          \
 ECHR 'N'               \ Encoded as:   "M<217>NTA<240>"
 ECHR 'T'
 ECHR 'A'
 ETWO 'I', 'N'
 EQUB VE

 ETWO 'E', 'D'          \ Token 157:    "EDIBLE"
 ECHR 'I'               \
 ECHR 'B'               \ Encoded as:   "<252>IB<229>"
 ETWO 'L', 'E'
 EQUB VE

 ECHR 'T'               \ Token 158:    "TREE"
 ETWO 'R', 'E'          \
 ECHR 'E'               \ Encoded as:   "T<242>E"
 EQUB VE

 ECHR 'S'               \ Token 159:    "SPOTTED"
 ECHR 'P'               \
 ECHR 'O'               \ Encoded as:   "SPOTT<252>"
 ECHR 'T'
 ECHR 'T'
 ETWO 'E', 'D'
 EQUB VE

 ERND 29                \ Token 160:    "[225-229]"
 EQUB VE                \
                        \ Encoded as:   "[29?]"

 ERND 30                \ Token 161:    "[230-234]"
 EQUB VE                \
                        \ Encoded as:   "[30?]"

 ERND 6                 \ Token 162:    "[46-50]OID"
 ECHR 'O'               \
 ECHR 'I'               \ Encoded as:   "[6?]OID"
 ECHR 'D'
 EQUB VE

 ERND 36                \ Token 163:    "[120-124]"
 EQUB VE                \
                        \ Encoded as:   "[36?]"

 ERND 35                \ Token 164:    "[115-119]"
 EQUB VE                \
                        \ Encoded as:   "[35?]"

 ETWO 'A', 'N'          \ Token 165:    "ANCIENT"
 ECHR 'C'               \
 ECHR 'I'               \ Encoded as:   "<255>CI<246>T"
 ETWO 'E', 'N'
 ECHR 'T'
 EQUB VE

 ECHR 'E'               \ Token 166:    "EXCEPTIONAL"
 ECHR 'X'               \
 ETWO 'C', 'E'          \ Encoded as:   "EX<233>P<251><223><228>"
 ECHR 'P'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 ETWO 'A', 'L'
 EQUB VE

 ECHR 'E'               \ Token 167:    "ECCENTRIC"
 ECHR 'C'               \
 ETWO 'C', 'E'          \ Encoded as:   "EC<233>NTRIC"
 ECHR 'N'
 ECHR 'T'
 ECHR 'R'
 ECHR 'I'
 ECHR 'C'
 EQUB VE

 ETWO 'I', 'N'          \ Token 168:    "INGRAINED"
 ECHR 'G'               \
 ETWO 'R', 'A'          \ Encoded as:   "<240>G<248><240><252>"
 ETWO 'I', 'N'
 ETWO 'E', 'D'
 EQUB VE

 ERND 23                \ Token 169:    "[130-134]"
 EQUB VE                \
                        \ Encoded as:   "[23?]"

 ECHR 'K'               \ Token 170:    "KILLER"
 ETWO 'I', 'L'          \
 ECHR 'L'               \ Encoded as:   "K<220>L<244>"
 ETWO 'E', 'R'
 EQUB VE

 ECHR 'D'               \ Token 171:    "DEADLY"
 ECHR 'E'               \
 ECHR 'A'               \ Encoded as:   "DEADLY"
 ECHR 'D'
 ECHR 'L'
 ECHR 'Y'
 EQUB VE

 ECHR 'E'               \ Token 172:    "EVIL"
 ECHR 'V'               \
 ETWO 'I', 'L'          \ Encoded as:   "EV<220>"
 EQUB VE

 ETWO 'L', 'E'          \ Token 173:    "LETHAL"
 ETWO 'T', 'H'          \
 ETWO 'A', 'L'          \ Encoded as:   "<229><226><228>"
 EQUB VE

 ECHR 'V'               \ Token 174:    "VICIOUS"
 ECHR 'I'               \
 ECHR 'C'               \ Encoded as:   "VICIO<236>"
 ECHR 'I'
 ECHR 'O'
 ETWO 'U', 'S'
 EQUB VE

 ETWO 'I', 'T'          \ Token 175:    "ITS "
 ECHR 'S'               \
 ECHR ' '               \ Encoded as:   "<219>S "
 EQUB VE

 EJMP 13                \ Token 176:    "{lower case}
 EJMP 14                \                {justify}
 EJMP 19                \                {single cap}"
 EQUB VE                \
                        \ Encoded as:   "{13}{14}{19}"

 ECHR '.'               \ Token 177:    ".{cr}
 EJMP 12                \                {left align}"
 EJMP 15                \
 EQUB VE                \ Encoded as:   ".{12}{15}"

 ECHR ' '               \ Token 178:    " AND "
 ETWO 'A', 'N'          \
 ECHR 'D'               \ Encoded as:   " <255>D "
 ECHR ' '
 EQUB VE

 ECHR 'Y'               \ Token 179:    "YOU"
 ETWO 'O', 'U'          \
 EQUB VE                \ Encoded as:   "Y<217>"

 ECHR 'P'               \ Token 180:    "PARKING METERS"
 ETWO 'A', 'R'          \
 ECHR 'K'               \ Encoded as:   "P<238>K[195]M<221><244>S"
 ETOK 195
 ECHR 'M'
 ETWO 'E', 'T'
 ETWO 'E', 'R'
 ECHR 'S'
 EQUB VE

 ECHR 'D'               \ Token 181:    "DUST CLOUDS"
 ETWO 'U', 'S'          \
 ECHR 'T'               \ Encoded as:   "D<236>T C<224>UDS"
 ECHR ' '
 ECHR 'C'
 ETWO 'L', 'O'
 ECHR 'U'
 ECHR 'D'
 ECHR 'S'
 EQUB VE

 ECHR 'I'               \ Token 182:    "ICE BERGS"
 ETWO 'C', 'E'          \
 ECHR ' '               \ Encoded as:   "I<233> <247>RGS"
 ETWO 'B', 'E'
 ECHR 'R'
 ECHR 'G'
 ECHR 'S'
 EQUB VE

 ECHR 'R'               \ Token 183:    "ROCK FORMATIONS"
 ECHR 'O'               \
 ECHR 'C'               \ Encoded as:   "ROCK F<253><239><251><223>S"
 ECHR 'K'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ETWO 'M', 'A'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 ECHR 'S'
 EQUB VE

 ECHR 'V'               \ Token 184:    "VOLCANOES"
 ECHR 'O'               \
 ECHR 'L'               \ Encoded as:   "VOLCA<227><237>"
 ECHR 'C'
 ECHR 'A'
 ETWO 'N', 'O'
 ETWO 'E', 'S'
 EQUB VE

 ECHR 'P'               \ Token 185:    "PLANT"
 ECHR 'L'               \
 ETWO 'A', 'N'          \ Encoded as:   "PL<255>T"
 ECHR 'T'
 EQUB VE

 ECHR 'T'               \ Token 186:    "TULIP"
 ECHR 'U'               \
 ECHR 'L'               \ Encoded as:   "TULIP"
 ECHR 'I'
 ECHR 'P'
 EQUB VE

 ECHR 'B'               \ Token 187:    "BANANA"
 ETWO 'A', 'N'          \
 ETWO 'A', 'N'          \ Encoded as:   "B<255><255>A"
 ECHR 'A'
 EQUB VE

 ECHR 'C'               \ Token 188:    "CORN"
 ETWO 'O', 'R'          \
 ECHR 'N'               \ Encoded as:   "C<253>N"
 EQUB VE

 EJMP 18                \ Token 189:    "{random 1-8 letter word}WEED"
 ECHR 'W'               \
 ECHR 'E'               \ Encoded as:   "{18}WE<252>"
 ETWO 'E', 'D'
 EQUB VE

 EJMP 18                \ Token 190:    "{random 1-8 letter word}"
 EQUB VE                \
                        \ Encoded as:   "{18}"

 EJMP 17                \ Token 191:    "{system name adjective} {random 1-8
 ECHR ' '               \                letter word}"
 EJMP 18                \
 EQUB VE                \ Encoded as:   "{17} {18}"

 EJMP 17                \ Token 192:    "{system name adjective} [170-174]"
 ECHR ' '               \
 ERND 13                \ Encoded as:   "{17} [13?]"
 EQUB VE

 ETWO 'I', 'N'          \ Token 193:    "INHABITANT"
 ECHR 'H'               \
 ECHR 'A'               \ Encoded as:   "<240>HA<234>T<255>T"
 ETWO 'B', 'I'
 ECHR 'T'
 ETWO 'A', 'N'
 ECHR 'T'
 EQUB VE

 ETOK 191               \ Token 194:    "{system name adjective} {random 1-8
 EQUB VE                \                letter word}"
                        \
                        \ Encoded as:   "[191]"

 ETWO 'I', 'N'          \ Token 195:    "ING "
 ECHR 'G'               \
 ECHR ' '               \ Encoded as:   "<240>G "
 EQUB VE

 ETWO 'E', 'D'          \ Token 196:    "ED "
 ECHR ' '               \
 EQUB VE                \ Encoded as:   "<252> "

 EQUB VE                \ Token 197:    ""
                        \
                        \ Encoded as:   ""

 EQUB VE                \ Token 198:    ""
                        \
                        \ Encoded as:   ""

 EQUB VE                \ Token 199:    ""
                        \
                        \ Encoded as:   ""

 ECHR ' '               \ Token 200:    " NAME? "
 ECHR 'N'               \
 ECHR 'A'               \ Encoded as:   " NAME? "
 ECHR 'M'
 ECHR 'E'
 ECHR '?'
 ECHR ' '
 EQUB VE

 ECHR ' '               \ Token 201:    " TO "
 ECHR 'T'               \
 ECHR 'O'               \ Encoded as:   " TO "
 ECHR ' '
 EQUB VE

 ECHR ' '               \ Token 202:    " IS "
 ECHR 'I'               \
 ECHR 'S'               \ Encoded as:   " IS "
 ECHR ' '
 EQUB VE

 ECHR 'W'               \ Token 203:    "WAS LAST SEEN AT {single cap}"
 ECHR 'A'               \
 ECHR 'S'               \ Encoded as:   "WAS <249><222> <218><246> <245> {19}"
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'T'
 ECHR ' '
 ETWO 'S', 'E'
 ETWO 'E', 'N'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 EJMP 19
 EQUB VE

 ECHR '.'               \ Token 204:    ".{cr}
 EJMP 12                \                 {single cap}"
 ECHR ' '               \
 EJMP 19                \ Encoded as:   ".{12} {19}"
 EQUB VE

 ECHR 'D'               \ Token 205:    "DOCKED"
 ECHR 'O'               \
 ECHR 'C'               \ Encoded as:   "DOCK<252>"
 ECHR 'K'
 ETWO 'E', 'D'
 EQUB VE

 EJMP 1                 \ Token 206:    "{all caps}(Y/N)?"
 ECHR '('               \
 ECHR 'Y'               \ Encoded as:   "{1}(Y/N)?"
 ECHR '/'
 ECHR 'N'
 ECHR ')'
 ECHR '?'
 EQUB VE

 ECHR 'S'               \ Token 207:    "SHIP"
 ECHR 'H'               \
 ECHR 'I'               \ Encoded as:   "SHIP"
 ECHR 'P'
 EQUB VE

 ECHR ' '               \ Token 208:    " A "
 ECHR 'A'               \
 ECHR ' '               \ Encoded as:   " A "
 EQUB VE

 ECHR ' '               \ Token 209:    " ERRIUS"
 ETWO 'E', 'R'          \
 ECHR 'R'               \ Encoded as:   " <244>RI<236>"
 ECHR 'I'
 ETWO 'U', 'S'
 EQUB VE

 ECHR ' '               \ Token 210:    " NEW "
 ECHR 'N'               \
 ECHR 'E'               \ Encoded as:   " NEW "
 ECHR 'W'
 ECHR ' '
 EQUB VE

 EJMP 2                 \ Token 211:    "{sentence case} HER MAJESTY'S SPACE
 ECHR ' '               \                 NAVY{lower case}"
 ECHR 'H'               \
 ETWO 'E', 'R'          \ Encoded as:   "{2} H<244> <239>J<237>TY[39]S SPA<233>
 ECHR ' '               \                 NAVY{13}"
 ETWO 'M', 'A'
 ECHR 'J'
 ETWO 'E', 'S'
 ECHR 'T'
 ECHR 'Y'
 ECHR '`'
 ECHR 'S'
 ECHR ' '
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'N'
 ECHR 'A'
 ECHR 'V'
 ECHR 'Y'
 EJMP 13
 EQUB VE

 ETOK 177               \ Token 212:    ".{cr}
 EJMP 8                 \                {left align}
 EJMP 1                 \                {tab 6}{all caps}  MESSAGE ENDS"
 ECHR ' '               \
 ECHR ' '               \ Encoded as:   "[177]{8}{1}  M<237>SA<231> <246>DS"
 ECHR 'M'
 ETWO 'E', 'S'
 ECHR 'S'
 ECHR 'A'
 ETWO 'G', 'E'
 ECHR ' '
 ETWO 'E', 'N'
 ECHR 'D'
 ECHR 'S'
 EQUB VE

 ECHR ' '               \ Token 213:    " {single cap}COMMANDER {commander
 ETOK 154               \                name}, I {lower case}AM{sentence case}
 ECHR ' '               \                CAPTAIN {mission captain's name}
 EJMP 4                 \                {lower case}OF{sentence case} HER
 ECHR ','               \                MAJESTY'S SPACE NAVY{lower case}"
 ECHR ' '               \
 ECHR 'I'               \ Encoded as:   " [154] {4}, I {13}AM{2} CAPTA<240> {27}
 ECHR ' '               \                 {13}OF[211]"
 EJMP 13
 ECHR 'A'
 ECHR 'M'
 EJMP 2
 ECHR ' '
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'T'
 ECHR 'A'
 ETWO 'I', 'N'
 ECHR ' '
 EJMP 27
 ECHR ' '
 EJMP 13
 ECHR 'O'
 ECHR 'F'
 ETOK 211
 EQUB VE

 EQUB VE                \ Token 214:    ""
                        \
                        \ Encoded as:   ""

 EJMP 15                \ Token 215:    "{left align} UNKNOWN PLANET"
 ECHR ' '               \
 ECHR 'U'               \ Encoded as:   "{15} UNK<227>WN [145]"
 ECHR 'N'
 ECHR 'K'
 ETWO 'N', 'O'
 ECHR 'W'
 ECHR 'N'
 ECHR ' '
 ETOK 145
 EQUB VE

 EJMP 9                 \ Token 216:    "{clear screen}
 EJMP 8                 \                {tab 6}
 EJMP 23                \                {move to row 10, white, lower case}
 EJMP 1                 \                {all caps}
 ETWO 'I', 'N'          \                INCOMING MESSAGE"
 ECHR 'C'               \
 ECHR 'O'               \ Encoded as:   "{9}{8}{23}{1}<240>COM[195]M<237>SA
 ECHR 'M'               \                <231>"
 ETOK 195
 ECHR 'M'
 ETWO 'E', 'S'
 ECHR 'S'
 ECHR 'A'
 ETWO 'G', 'E'
 EQUB VE

 ECHR 'C'               \ Token 217:    "CURRUTHERS"
 ECHR 'U'               \
 ECHR 'R'               \ Encoded as:   "CURRU<226><244>S"
 ECHR 'R'
 ECHR 'U'
 ETWO 'T', 'H'
 ETWO 'E', 'R'
 ECHR 'S'
 EQUB VE

 ECHR 'F'               \ Token 218:    "FOSDYKE SMYTHE"
 ECHR 'O'               \
 ECHR 'S'               \ Encoded as:   "FOSDYKE SMY<226>E"
 ECHR 'D'
 ECHR 'Y'
 ECHR 'K'
 ECHR 'E'
 ECHR ' '
 ECHR 'S'
 ECHR 'M'
 ECHR 'Y'
 ETWO 'T', 'H'
 ECHR 'E'
 EQUB VE

 ECHR 'F'               \ Token 219:    "FORTESQUE"
 ETWO 'O', 'R'          \
 ECHR 'T'               \ Encoded as:   "F<253>T<237><254>E"
 ETWO 'E', 'S'
 ETWO 'Q', 'U'
 ECHR 'E'
 EQUB VE

 ETOK 203               \ Token 220:    "WAS LAST SEEN AT {single cap}REESDICE"
 ETWO 'R', 'E'          \
 ETWO 'E', 'S'          \ Encoded as:   "[203]<242><237><241><233>"
 ETWO 'D', 'I'
 ETWO 'C', 'E'
 EQUB VE

 ECHR 'I'               \ Token 221:    "IS BELIEVED TO HAVE JUMPED TO THIS
 ECHR 'S'               \                GALAXY"
 ECHR ' '               \
 ETWO 'B', 'E'          \ Encoded as:   "IS <247>LIEV<252>[201]HA<250> JUMP<252>
 ECHR 'L'               \                [201][148]G<228>AXY"
 ECHR 'I'
 ECHR 'E'
 ECHR 'V'
 ETWO 'E', 'D'
 ETOK 201
 ECHR 'H'
 ECHR 'A'
 ETWO 'V', 'E'
 ECHR ' '
 ECHR 'J'
 ECHR 'U'
 ECHR 'M'
 ECHR 'P'
 ETWO 'E', 'D'
 ETOK 201
 ETOK 148
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'X'
 ECHR 'Y'
 EQUB VE

 EJMP 25                \ Token 222:    "{incoming message screen, wait 2s}
 EJMP 9                 \                {clear screen}
 EJMP 29                \                {tab 6, white, lower case in words}
 EJMP 14                \                {justify}
 EJMP 2                 \                {sentence case}
 ECHR 'G'               \                GOOD DAY {single cap}COMMANDER
 ECHR 'O'               \                {commander name}.{cr}
 ECHR 'O'               \                 {single cap}I{lower case} AM {single
 ECHR 'D'               \                cap}AGENT{single cap}BLAKE OF {single
 ECHR ' '               \                cap}NAVAL {single cap}INTELLEGENCE.{cr}
 ECHR 'D'               \                 {single cap}AS YOU KNOW, THE {single
 ECHR 'A'               \                cap}NAVY HAVE BEEN KEEPING THE {single
 ECHR 'Y'               \                cap}THARGOIDS OFF YOUR ASS OUT IN DEEP
 ECHR ' '               \                SPACE FOR MANY YEARS NOW. {single cap}
 ETOK 154               \                WELL THE SITUATION HAS CHANGED.{cr}
 ECHR ' '               \                 {single cap}OUR BOYS ARE READY FOR A
 EJMP 4                 \                PUSH RIGHT TO THE HOME SYSTEM OF THOSE
 ETOK 204               \                MOTHERS.{cr}
 ECHR 'I'               \                 {single cap}
 EJMP 13                \                {wait for key press}
 ECHR ' '               \                {clear screen}
 ECHR 'A'               \                {white}
 ECHR 'M'               \                {tab 6, white, lower case in words}
 ECHR ' '               \                I{lower case} HAVE OBTAINED THE DEFENCE
 EJMP 19                \                PLANS FOR THEIR {single cap}HIVE
 ECHR 'A'               \                {single cap}WORLDS.{cr} {single cap}THE
 ECHR 'G'               \                BEETLES KNOW WE'VE GOT SOMETHING BUT
 ETWO 'E', 'N'          \                NOT WHAT.{cr} {single cap}IF {single
 ECHR 'T'               \                cap}I TRANSMIT THE PLANS TO OUR BASE ON
 ECHR ' '               \                {single cap}BIRERA THEY'LL INTERCEPT
 EJMP 19                \                THE TRANSMISSION. {single cap}I NEED A
 ECHR 'B'               \                SHIP TO MAKE THE RUN.{cr}
 ETWO 'L', 'A'          \                 {single cap}YOU'RE ELECTED.{cr}
 ECHR 'K'               \                 {single cap}THE PLANS ARE UNIPULSE
 ECHR 'E'               \                CODED WITHIN THIS TRANSMISSION.{cr}
 ECHR ' '               \                 {single cap}{tab 6}YOU WILL BE
 ECHR 'O'               \                PAID.{cr}
 ECHR 'F'               \                 {single cap}    {single cap}GOOD LUCK
 ECHR ' '               \                {single cap}COMMANDER.{cr}
 EJMP 19                \                {left align}
 ECHR 'N'               \                {tab 6}{all caps}  MESSAGE ENDS
 ECHR 'A'               \                {wait for key press}"
 ECHR 'V'               \
 ETWO 'A', 'L'          \ Encoded as:   "{25}{9}{29}{14}{2}GOOD DAY [154] {4}
 ECHR ' '               \                [204]I{13} AM {19}AG<246>T {19}B<249>
 EJMP 19                \                KE OF {19}NAV<228> {19}<240>TEL<229>
 ETWO 'I', 'N'          \                G<246><233>[204]AS [179] K<227>W, [147]
 ECHR 'T'               \                {19}NAVY HA<250> <247><246> KEEP[195]
 ECHR 'E'               \                [147]{19}<226><238>GOIDS OFF [179]R ASS
 ECHR 'L'               \                 <217>T <240> DEEP SPA<233> F<253>
 ETWO 'L', 'E'          \                 <239>NY YE<238>S <227>W. {19}WELL
 ECHR 'G'               \                 [147]S<219>UA<251><223> HAS CH<255>G
 ETWO 'E', 'N'          \                <252>[204]<217>R BOYS <238>E <242>ADY F
 ETWO 'C', 'E'          \                <253>[208]P<236>H RIGHT[201][147]HOME
 ETOK 204               \                 SY<222>EM OF <226>O<218> MO<226><244>S
 ECHR 'A'               \                [204]{24}{9}{29}I{13} HA<250> OBTA
 ECHR 'S'               \                <240>[196][147]DEF<246><233> P<249>NS F
 ECHR ' '               \                <253> <226>EIR {19}HI<250> {19}W<253>LD
 ETOK 179               \                S[204][147]<247><221><229>S K<227>W WE
 ECHR ' '               \                [39]<250> GOT <235>ME<226>[195]BUT
 ECHR 'K'               \                 <227>T WH<245>[204]IF {19}I T<248>NSM
 ETWO 'N', 'O'          \                <219> [147]P<249>NS[201]<217>R BA<218>
 ECHR 'W'               \                 <223> {19}<234><242><248> <226>EY[39]L
 ECHR ','               \                L <240>T<244><233>PT [147]TR<255>SMISSI
 ECHR ' '               \                <223>. {19}I NE<252>[208][207][201]
 ETOK 147               \                <239>KE [147]RUN[204][179][39]<242> E
 EJMP 19                \                <229>CT<252>[204][147]P<249>NS A<242>
 ECHR 'N'               \                 UNIPUL<218> COD[196]WI<226><240> [148]
 ECHR 'A'               \                TR<255>SMISSI<223>[204]{8}[179] W<220>L
 ECHR 'V'               \                 <247> PAID[204]    {19}GOOD LUCK [154]
 ECHR 'Y'               \                [212]{24}"
 ECHR ' '
 ECHR 'H'
 ECHR 'A'
 ETWO 'V', 'E'
 ECHR ' '
 ETWO 'B', 'E'
 ETWO 'E', 'N'
 ECHR ' '
 ECHR 'K'
 ECHR 'E'
 ECHR 'E'
 ECHR 'P'
 ETOK 195
 ETOK 147
 EJMP 19
 ETWO 'T', 'H'
 ETWO 'A', 'R'
 ECHR 'G'
 ECHR 'O'
 ECHR 'I'
 ECHR 'D'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR 'F'
 ECHR ' '
 ETOK 179
 ECHR 'R'
 ECHR ' '
 ECHR 'A'
 ECHR 'S'
 ECHR 'S'
 ECHR ' '
 ETWO 'O', 'U'
 ECHR 'T'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR ' '
 ECHR 'D'
 ECHR 'E'
 ECHR 'E'
 ECHR 'P'
 ECHR ' '
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'N'
 ECHR 'Y'
 ECHR ' '
 ECHR 'Y'
 ECHR 'E'
 ETWO 'A', 'R'
 ECHR 'S'
 ECHR ' '
 ETWO 'N', 'O'
 ECHR 'W'
 ECHR '.'
 ECHR ' '
 EJMP 19
 ECHR 'W'
 ECHR 'E'
 ECHR 'L'
 ECHR 'L'
 ECHR ' '
 ETOK 147
 ECHR 'S'
 ETWO 'I', 'T'
 ECHR 'U'
 ECHR 'A'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 ECHR ' '
 ECHR 'H'
 ECHR 'A'
 ECHR 'S'
 ECHR ' '
 ECHR 'C'
 ECHR 'H'
 ETWO 'A', 'N'
 ECHR 'G'
 ETWO 'E', 'D'
 ETOK 204
 ETWO 'O', 'U'
 ECHR 'R'
 ECHR ' '
 ECHR 'B'
 ECHR 'O'
 ECHR 'Y'
 ECHR 'S'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ETWO 'R', 'E'
 ECHR 'A'
 ECHR 'D'
 ECHR 'Y'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ETOK 208
 ECHR 'P'
 ETWO 'U', 'S'
 ECHR 'H'
 ECHR ' '
 ECHR 'R'
 ECHR 'I'
 ECHR 'G'
 ECHR 'H'
 ECHR 'T'
 ETOK 201
 ETOK 147
 ECHR 'H'
 ECHR 'O'
 ECHR 'M'
 ECHR 'E'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ETWO 'T', 'H'
 ECHR 'O'
 ETWO 'S', 'E'
 ECHR ' '
 ECHR 'M'
 ECHR 'O'
 ETWO 'T', 'H'
 ETWO 'E', 'R'
 ECHR 'S'
 ETOK 204
 EJMP 24
 EJMP 9
 EJMP 29
 ECHR 'I'
 EJMP 13
 ECHR ' '
 ECHR 'H'
 ECHR 'A'
 ETWO 'V', 'E'
 ECHR ' '
 ECHR 'O'
 ECHR 'B'
 ECHR 'T'
 ECHR 'A'
 ETWO 'I', 'N'
 ETOK 196
 ETOK 147
 ECHR 'D'
 ECHR 'E'
 ECHR 'F'
 ETWO 'E', 'N'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'P'
 ETWO 'L', 'A'
 ECHR 'N'
 ECHR 'S'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'T', 'H'
 ECHR 'E'
 ECHR 'I'
 ECHR 'R'
 ECHR ' '
 EJMP 19
 ECHR 'H'
 ECHR 'I'
 ETWO 'V', 'E'
 ECHR ' '
 EJMP 19
 ECHR 'W'
 ETWO 'O', 'R'
 ECHR 'L'
 ECHR 'D'
 ECHR 'S'
 ETOK 204
 ETOK 147
 ETWO 'B', 'E'
 ETWO 'E', 'T'
 ETWO 'L', 'E'
 ECHR 'S'
 ECHR ' '
 ECHR 'K'
 ETWO 'N', 'O'
 ECHR 'W'
 ECHR ' '
 ECHR 'W'
 ECHR 'E'
 ECHR '`'
 ETWO 'V', 'E'
 ECHR ' '
 ECHR 'G'
 ECHR 'O'
 ECHR 'T'
 ECHR ' '
 ETWO 'S', 'O'
 ECHR 'M'
 ECHR 'E'
 ETWO 'T', 'H'
 ETOK 195
 ECHR 'B'
 ECHR 'U'
 ECHR 'T'
 ECHR ' '
 ETWO 'N', 'O'
 ECHR 'T'
 ECHR ' '
 ECHR 'W'
 ECHR 'H'
 ETWO 'A', 'T'
 ETOK 204
 ECHR 'I'
 ECHR 'F'
 ECHR ' '
 EJMP 19
 ECHR 'I'
 ECHR ' '
 ECHR 'T'
 ETWO 'R', 'A'
 ECHR 'N'
 ECHR 'S'
 ECHR 'M'
 ETWO 'I', 'T'
 ECHR ' '
 ETOK 147
 ECHR 'P'
 ETWO 'L', 'A'
 ECHR 'N'
 ECHR 'S'
 ETOK 201
 ETWO 'O', 'U'
 ECHR 'R'
 ECHR ' '
 ECHR 'B'
 ECHR 'A'
 ETWO 'S', 'E'
 ECHR ' '
 ETWO 'O', 'N'
 ECHR ' '
 EJMP 19
 ETWO 'B', 'I'
 ETWO 'R', 'E'
 ETWO 'R', 'A'
 ECHR ' '
 ETWO 'T', 'H'
 ECHR 'E'
 ECHR 'Y'
 ECHR '`'
 ECHR 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR 'T'
 ETWO 'E', 'R'
 ETWO 'C', 'E'
 ECHR 'P'
 ECHR 'T'
 ECHR ' '
 ETOK 147
 ECHR 'T'
 ECHR 'R'
 ETWO 'A', 'N'
 ECHR 'S'
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR '.'
 ECHR ' '
 EJMP 19
 ECHR 'I'
 ECHR ' '
 ECHR 'N'
 ECHR 'E'
 ETWO 'E', 'D'
 ETOK 208
 ETOK 207
 ETOK 201
 ETWO 'M', 'A'
 ECHR 'K'
 ECHR 'E'
 ECHR ' '
 ETOK 147
 ECHR 'R'
 ECHR 'U'
 ECHR 'N'
 ETOK 204
 ETOK 179
 ECHR '`'
 ETWO 'R', 'E'
 ECHR ' '
 ECHR 'E'
 ETWO 'L', 'E'
 ECHR 'C'
 ECHR 'T'
 ETWO 'E', 'D'
 ETOK 204
 ETOK 147
 ECHR 'P'
 ETWO 'L', 'A'
 ECHR 'N'
 ECHR 'S'
 ECHR ' '
 ECHR 'A'
 ETWO 'R', 'E'
 ECHR ' '
 ECHR 'U'
 ECHR 'N'
 ECHR 'I'
 ECHR 'P'
 ECHR 'U'
 ECHR 'L'
 ETWO 'S', 'E'
 ECHR ' '
 ECHR 'C'
 ECHR 'O'
 ECHR 'D'
 ETOK 196
 ECHR 'W'
 ECHR 'I'
 ETWO 'T', 'H'
 ETWO 'I', 'N'
 ECHR ' '
 ETOK 148
 ECHR 'T'
 ECHR 'R'
 ETWO 'A', 'N'
 ECHR 'S'
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ECHR 'I'
 ETWO 'O', 'N'
 ETOK 204
 EJMP 8
 ETOK 179
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'P'
 ECHR 'A'
 ECHR 'I'
 ECHR 'D'
 ETOK 204
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR ' '
 EJMP 19
 ECHR 'G'
 ECHR 'O'
 ECHR 'O'
 ECHR 'D'
 ECHR ' '
 ECHR 'L'
 ECHR 'U'
 ECHR 'C'
 ECHR 'K'
 ECHR ' '
 ETOK 154
 ETOK 212
 EJMP 24
 EQUB VE

 EJMP 25                \ Token 223:    "{incoming message screen, wait 2s}
 EJMP 9                 \                {clear screen}
 EJMP 29                \                {tab 6, white, lower case in words}
 EJMP 8                 \                {tab 6}
 EJMP 14                \                {justify}
 EJMP 13                \                {lower case}
 EJMP 19                \                {single cap}WELL DONE {single cap}
 ECHR 'W'               \                COMMANDER.{cr}
 ECHR 'E'               \                 {single cap}YOU HAVE SERVED US WELL
 ECHR 'L'               \                AND WE SHALL REMEMBER.{cr}
 ECHR 'L'               \                 {single cap}WE DID NOT EXPECT THE
 ECHR ' '               \                 {single cap}THARGOIDS TO FIND OUT
 ECHR 'D'               \                ABOUT YOU.{cr}
 ETWO 'O', 'N'          \                 {single cap}FOR THE MOMENT PLEASE
 ECHR 'E'               \                ACCEPT THIS {single cap}NAVY {standard
 ECHR ' '               \                tokens, sentence case}EXTRA ENERGY
 ETOK 154               \                UNIT{extended tokens} AS PAYMENT.{cr}
 ETOK 204               \                {left align}
 ETOK 179               \                {tab 6}{all caps}  MESSAGE ENDS
 ECHR ' '               \                {wait for key press}"
 ECHR 'H'               \
 ECHR 'A'               \ Encoded as:   "{25}{9}{29}{8}{14}{13}{19}WELL D
 ETWO 'V', 'E'          \                <223>E [154][204][179] HA<250> <218>RV
 ECHR ' '               \                [196]<236> WELL[178]WE SH<228>L <242>ME
 ETWO 'S', 'E'          \                MB<244>[204]WE <241>D <227>T EXPECT
 ECHR 'R'               \                 [147]{19}<226><238>GOIDS[201]F<240>D
 ECHR 'V'               \                 <217>T <216><217>T [179][204]F<253>
 ETOK 196               \                 [147]MOM<246>T P<229>A<218> AC<233>PT
 ETWO 'U', 'S'          \                 [148]{19}NAVY {6}[114]{5} AS PAYM<246>
 ECHR ' '               \                T[212]{24}"
 ECHR 'W'
 ECHR 'E'
 ECHR 'L'
 ECHR 'L'
 ETOK 178
 ECHR 'W'
 ECHR 'E'
 ECHR ' '
 ECHR 'S'
 ECHR 'H'
 ETWO 'A', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'R', 'E'
 ECHR 'M'
 ECHR 'E'
 ECHR 'M'
 ECHR 'B'
 ETWO 'E', 'R'
 ETOK 204
 ECHR 'W'
 ECHR 'E'
 ECHR ' '
 ETWO 'D', 'I'
 ECHR 'D'
 ECHR ' '
 ETWO 'N', 'O'
 ECHR 'T'
 ECHR ' '
 ECHR 'E'
 ECHR 'X'
 ECHR 'P'
 ECHR 'E'
 ECHR 'C'
 ECHR 'T'
 ECHR ' '
 ETOK 147
 EJMP 19
 ETWO 'T', 'H'
 ETWO 'A', 'R'
 ECHR 'G'
 ECHR 'O'
 ECHR 'I'
 ECHR 'D'
 ECHR 'S'
 ETOK 201
 ECHR 'F'
 ETWO 'I', 'N'
 ECHR 'D'
 ECHR ' '
 ETWO 'O', 'U'
 ECHR 'T'
 ECHR ' '
 ETWO 'A', 'B'
 ETWO 'O', 'U'
 ECHR 'T'
 ECHR ' '
 ETOK 179
 ETOK 204
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ETOK 147
 ECHR 'M'
 ECHR 'O'
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR ' '
 ECHR 'P'
 ETWO 'L', 'E'
 ECHR 'A'
 ETWO 'S', 'E'
 ECHR ' '
 ECHR 'A'
 ECHR 'C'
 ETWO 'C', 'E'
 ECHR 'P'
 ECHR 'T'
 ECHR ' '
 ETOK 148
 EJMP 19
 ECHR 'N'
 ECHR 'A'
 ECHR 'V'
 ECHR 'Y'
 ECHR ' '
 EJMP 6
 TOKN 114
 EJMP 5
 ECHR ' '
 ECHR 'A'
 ECHR 'S'
 ECHR ' '
 ECHR 'P'
 ECHR 'A'
 ECHR 'Y'
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'T'
 ETOK 212
 EJMP 24
 EQUB VE

 EQUB VE                \ Token 224:    ""
                        \
                        \ Encoded as:   ""

 ECHR 'S'               \ Token 225:    "SHREW"
 ECHR 'H'               \
 ETWO 'R', 'E'          \ Encoded as:   "SH<242>W"
 ECHR 'W'
 EQUB VE

 ETWO 'B', 'E'          \ Token 226:    "BEAST"
 ECHR 'A'               \
 ETWO 'S', 'T'          \ Encoded as:   "<247>A<222>"
 EQUB VE

 ETWO 'B', 'I'          \ Token 227:    "BISON"
 ECHR 'S'               \
 ETWO 'O', 'N'          \ Encoded as:   "<234>IS<223>"
 EQUB VE

 ECHR 'S'               \ Token 228:    "SNAKE"
 ECHR 'N'               \
 ECHR 'A'               \ Encoded as:   "SNAKE"
 ECHR 'K'
 ECHR 'E'
 EQUB VE

 ECHR 'W'               \ Token 229:    "WOLF"
 ECHR 'O'               \
 ECHR 'L'               \ Encoded as:   "WOLF"
 ECHR 'F'
 EQUB VE

 ETWO 'L', 'E'          \ Token 230:    "LEOPARD"
 ECHR 'O'               \
 ECHR 'P'               \ Encoded as:   "<229>OP<238>D"
 ETWO 'A', 'R'
 ECHR 'D'
 EQUB VE

 ECHR 'C'               \ Token 231:    "CAT"
 ETWO 'A', 'T'          \
 EQUB VE                \ Encoded as:   "C<245>"

 ECHR 'M'               \ Token 232:    "MONKEY"
 ETWO 'O', 'N'          \
 ECHR 'K'               \ Encoded as:   "M<223>KEY"
 ECHR 'E'
 ECHR 'Y'
 EQUB VE

 ECHR 'G'               \ Token 233:    "GOAT"
 ECHR 'O'               \
 ETWO 'A', 'T'          \ Encoded as:   "GO<245>"
 EQUB VE

 ECHR 'F'               \ Token 234:    "FISH"
 ECHR 'I'               \
 ECHR 'S'               \ Encoded as:   "FISH"
 ECHR 'H'
 EQUB VE

 ERND 15                \ Token 235:    "[71-75] [66-70]"
 ECHR ' '               \
 ERND 14                \ Encoded as:   "[15?] [14?]"
 EQUB VE

 EJMP 17                \ Token 236:    "{system name adjective} [225-229]
 ECHR ' '               \                 [240-244]"
 ERND 29                \
 ECHR ' '               \ Encoded as:   "{17} [29?] [32?]"
 ERND 32
 EQUB VE

 ETOK 175               \ Token 237:    "ITS [76-80] [230-234] [240-244]"
 ERND 16                \
 ECHR ' '               \ Encoded as:   "[175][16?] [30?] [32?]"
 ERND 30
 ECHR ' '
 ERND 32
 EQUB VE

 ERND 33                \ Token 238:    "[245-249] [250-254]"
 ECHR ' '               \
 ERND 34                \ Encoded as:   "[33?] [34?]"
 EQUB VE

 ERND 15                \ Token 239:    "[71-75] [66-70]"
 ECHR ' '               \
 ERND 14                \ Encoded as:   "[15?] [14?]"
 EQUB VE

 ECHR 'M'               \ Token 240:    "MEAT"
 ECHR 'E'               \
 ETWO 'A', 'T'          \ Encoded as:   "ME<245>"
 EQUB VE

 ECHR 'C'               \ Token 241:    "CUTLET"
 ECHR 'U'               \
 ECHR 'T'               \ Encoded as:   "CUTL<221>"
 ECHR 'L'
 ETWO 'E', 'T'
 EQUB VE

 ETWO 'S', 'T'          \ Token 242:    "STEAK"
 ECHR 'E'               \
 ECHR 'A'               \ Encoded as:   "<222>EAK"
 ECHR 'K'
 EQUB VE

 ECHR 'B'               \ Token 243:    "BURGERS"
 ECHR 'U'               \
 ECHR 'R'               \ Encoded as:   "BURG<244>S"
 ECHR 'G'
 ETWO 'E', 'R'
 ECHR 'S'
 EQUB VE

 ETWO 'S', 'O'          \ Token 244:    "SOUP"
 ECHR 'U'               \
 ECHR 'P'               \ Encoded as:   "<235>UP"
 EQUB VE

 ECHR 'I'               \ Token 245:    "ICE"
 ETWO 'C', 'E'          \
 EQUB VE                \ Encoded as:   "I<233>"

 ECHR 'M'               \ Token 246:    "MUD"
 ECHR 'U'               \
 ECHR 'D'               \ Encoded as:   "MUD"
 EQUB VE

 ECHR 'Z'               \ Token 247:    "ZERO-{single cap}G"
 ETWO 'E', 'R'          \
 ECHR 'O'               \ Encoded as:   "Z<244>O-{19}G"
 ECHR '-'
 EJMP 19
 ECHR 'G'
 EQUB VE

 ECHR 'V'               \ Token 248:    "VACUUM"
 ECHR 'A'               \
 ECHR 'C'               \ Encoded as:   "VACUUM"
 ECHR 'U'
 ECHR 'U'
 ECHR 'M'
 EQUB VE

 EJMP 17                \ Token 249:    "{system name adjective} ULTRA"
 ECHR ' '               \
 ECHR 'U'               \ Encoded as:   "{17} ULT<248>"
 ECHR 'L'
 ECHR 'T'
 ETWO 'R', 'A'
 EQUB VE

 ECHR 'H'               \ Token 250:    "HOCKEY"
 ECHR 'O'               \
 ECHR 'C'               \ Encoded as:   "HOCKEY"
 ECHR 'K'
 ECHR 'E'
 ECHR 'Y'
 EQUB VE

 ECHR 'C'               \ Token 251:    "CRICKET"
 ECHR 'R'               \
 ECHR 'I'               \ Encoded as:   "CRICK<221>"
 ECHR 'C'
 ECHR 'K'
 ETWO 'E', 'T'
 EQUB VE

 ECHR 'K'               \ Token 252:    "KARATE"
 ETWO 'A', 'R'          \
 ETWO 'A', 'T'          \ Encoded as:   "K<238><245>E"
 ECHR 'E'
 EQUB VE

 ECHR 'P'               \ Token 253:    "POLO"
 ECHR 'O'               \
 ETWO 'L', 'O'          \ Encoded as:   "PO<224>"
 EQUB VE

 ECHR 'T'               \ Token 254:    "TENNIS"
 ETWO 'E', 'N'          \
 ECHR 'N'               \ Encoded as:   "T<246>NIS"
 ECHR 'I'
 ECHR 'S'
 EQUB VE

 EQUB VE                \ Token 255:    ""
                        \
                        \ Encoded as:   ""

\ ******************************************************************************
\
\       Name: RUPLA
\       Type: Variable
\   Category: Text
\    Summary: System numbers that have extended description overrides
\  Deep dive: Extended system descriptions
\             Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This table contains the extended token numbers to show as the specified
\ system's extended description, if the criteria in the RUGAL table are met.
\
\ The three variables work as follows:
\
\   * The RUPLA table contains the system numbers
\
\   * The RUGAL table contains the galaxy numbers and mission criteria
\
\   * The RUTOK table contains the extended token to display instead of the
\     normal extended description if the criteria in RUPLA and RUGAL are met
\
\ See the PDESC routine for details of how extended system descriptions work.
\
\ ******************************************************************************

.RUPLA

 EQUB 211               \ System 211, Galaxy 0                 Teorge = Token  1
 EQUB 150               \ System 150, Galaxy 0, Mission 1        Xeer = Token  2
 EQUB 36                \ System  36, Galaxy 0, Mission 1    Reesdice = Token  3
 EQUB 28                \ System  28, Galaxy 0, Mission 1       Arexe = Token  4
 EQUB 253               \ System 253, Galaxy 1, Mission 1      Errius = Token  5
 EQUB 79                \ System  79, Galaxy 1, Mission 1      Inbibe = Token  6
 EQUB 53                \ System  53, Galaxy 1, Mission 1       Ausar = Token  7
 EQUB 118               \ System 118, Galaxy 1, Mission 1      Usleri = Token  8
 EQUB 100               \ System 100, Galaxy 2                 Arredi = Token  9
 EQUB 32                \ System  32, Galaxy 1, Mission 1      Bebege = Token 10
 EQUB 68                \ System  68, Galaxy 1, Mission 1      Cearso = Token 11
 EQUB 164               \ System 164, Galaxy 1, Mission 1      Dicela = Token 12
 EQUB 220               \ System 220, Galaxy 1, Mission 1      Eringe = Token 13
 EQUB 106               \ System 106, Galaxy 1, Mission 1      Gexein = Token 14
 EQUB 16                \ System  16, Galaxy 1, Mission 1      Isarin = Token 15
 EQUB 162               \ System 162, Galaxy 1, Mission 1    Letibema = Token 16
 EQUB 3                 \ System   3, Galaxy 1, Mission 1      Maisso = Token 17
 EQUB 107               \ System 107, Galaxy 1, Mission 1        Onen = Token 18
 EQUB 26                \ System  26, Galaxy 1, Mission 1      Ramaza = Token 19
 EQUB 192               \ System 192, Galaxy 1, Mission 1      Sosole = Token 20
 EQUB 184               \ System 184, Galaxy 1, Mission 1      Tivere = Token 21
 EQUB 5                 \ System   5, Galaxy 1, Mission 1      Veriar = Token 22
 EQUB 101               \ System 101, Galaxy 2, Mission 1      Xeveon = Token 23
 EQUB 193               \ System 193, Galaxy 1, Mission 1      Orarra = Token 24
 EQUB 41                \ System  41, Galaxy 2                 Anreer = Token 25

\ ******************************************************************************
\
\       Name: RUGAL
\       Type: Variable
\   Category: Text
\    Summary: The criteria for systems with extended description overrides
\  Deep dive: Extended system descriptions
\             Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ This table contains the criteria for printing an extended description override
\ for a system. The galaxy number is in bits 0-6, while bit 7 determines whether
\ to show this token during mission 1 only (bit 7 is clear, i.e. a value of &0x
\ in the table below), or all of the time (bit 7 is set, i.e. a value of &8x in
\ the table below).
\
\ In other words, Teorge, Arredi, Anreer and Lave have extended description
\ overrides that are always shown, while the rest only appear when mission 1 is
\ in progress.
\
\ The three variables work as follows:
\
\   * The RUPLA table contains the system numbers
\
\   * The RUGAL table contains the galaxy numbers and mission criteria
\
\   * The RUTOK table contains the extended token to display instead of the
\     normal extended description if the criteria in RUPLA and RUGAL are met
\
\ See the PDESC routine for details of how extended system descriptions work.
\
\ ******************************************************************************

.RUGAL

 EQUB &80               \ System 211, Galaxy 0                 Teorge = Token  1
 EQUB &00               \ System 150, Galaxy 0, Mission 1        Xeer = Token  2
 EQUB &00               \ System  36, Galaxy 0, Mission 1    Reesdice = Token  3
 EQUB &00               \ System  28, Galaxy 0, Mission 1       Arexe = Token  4
 EQUB &01               \ System 253, Galaxy 1, Mission 1      Errius = Token  5
 EQUB &01               \ System  79, Galaxy 1, Mission 1      Inbibe = Token  6
 EQUB &01               \ System  53, Galaxy 1, Mission 1       Ausar = Token  7
 EQUB &01               \ System 118, Galaxy 1, Mission 1      Usleri = Token  8
 EQUB &82               \ System 100, Galaxy 2                 Arredi = Token  9
 EQUB &01               \ System  32, Galaxy 1, Mission 1      Bebege = Token 10
 EQUB &01               \ System  68, Galaxy 1, Mission 1      Cearso = Token 11
 EQUB &01               \ System 164, Galaxy 1, Mission 1      Dicela = Token 12
 EQUB &01               \ System 220, Galaxy 1, Mission 1      Eringe = Token 13
 EQUB &01               \ System 106, Galaxy 1, Mission 1      Gexein = Token 14
 EQUB &01               \ System  16, Galaxy 1, Mission 1      Isarin = Token 15
 EQUB &01               \ System 162, Galaxy 1, Mission 1    Letibema = Token 16
 EQUB &01               \ System   3, Galaxy 1, Mission 1      Maisso = Token 17
 EQUB &01               \ System 107, Galaxy 1, Mission 1        Onen = Token 18
 EQUB &01               \ System  26, Galaxy 1, Mission 1      Ramaza = Token 19
 EQUB &01               \ System 192, Galaxy 1, Mission 1      Sosole = Token 20
 EQUB &01               \ System 184, Galaxy 1, Mission 1      Tivere = Token 21
 EQUB &01               \ System   5, Galaxy 1, Mission 1      Veriar = Token 22
 EQUB &02               \ System 101, Galaxy 2, Mission 1      Xeveon = Token 23
 EQUB &01               \ System 193, Galaxy 1, Mission 1      Orarra = Token 24
 EQUB &82               \ System  41, Galaxy 2                 Anreer = Token 25

\ ******************************************************************************
\
\       Name: RUTOK
\       Type: Variable
\   Category: Text
\    Summary: The second extended token table for recursive tokens 0-26 (DETOK3)
\  Deep dive: Extended system descriptions
\             Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ Contains the tokens for extended description overrides of systems that match
\ the system number in RUPLA and the conditions in RUGAL.
\
\ The three variables work as follows:
\
\   * The RUPLA table contains the system numbers
\
\   * The RUGAL table contains the galaxy numbers and mission criteria
\
\   * The RUTOK table contains the extended token to display instead of the
\     normal extended description if the criteria in RUPLA and RUGAL are met
\
\ See the PDESC routine for details of how extended system descriptions work.
\
\ ******************************************************************************

.RUTOK

 EQUB VE                \ Token 0:      ""
                        \
                        \ Encoded as:   ""

 ETOK 147               \ Token 1:      "THE COLONISTS HERE HAVE VIOLATED
 ECHR 'C'               \                {sentence case} INTERGALACTIC CLONING
 ECHR 'O'               \                PROTOCOL{lower case} AND SHOULD BE
 ETWO 'L', 'O'          \                AVOIDED"
 ECHR 'N'               \
 ECHR 'I'               \ Encoded as:   "[147]CO<224>NI<222>S HE<242> HA<250>
 ETWO 'S', 'T'          \                 VIOL<245><252>{2} <240>T<244>G<228>AC
 ECHR 'S'               \                <251>C C<224>N[195]PROTOCOL{13}[178]SH
 ECHR ' '               \                <217>LD <247> AVOID<252>"
 ECHR 'H'
 ECHR 'E'
 ETWO 'R', 'E'
 ECHR ' '
 ECHR 'H'
 ECHR 'A'
 ETWO 'V', 'E'
 ECHR ' '
 ECHR 'V'
 ECHR 'I'
 ECHR 'O'
 ECHR 'L'
 ETWO 'A', 'T'
 ETWO 'E', 'D'
 EJMP 2
 ECHR ' '
 ETWO 'I', 'N'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'C'
 ECHR ' '
 ECHR 'C'
 ETWO 'L', 'O'
 ECHR 'N'
 ETOK 195
 ECHR 'P'
 ECHR 'R'
 ECHR 'O'
 ECHR 'T'
 ECHR 'O'
 ECHR 'C'
 ECHR 'O'
 ECHR 'L'
 EJMP 13
 ETOK 178
 ECHR 'S'
 ECHR 'H'
 ETWO 'O', 'U'
 ECHR 'L'
 ECHR 'D'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'A'
 ECHR 'V'
 ECHR 'O'
 ECHR 'I'
 ECHR 'D'
 ETWO 'E', 'D'
 EQUB VE

 ETOK 147               \ Token 2:      "THE CONSTRICTOR WAS LAST SEEN AT
 ECHR 'C'               \                {single cap}REESDICE, {single cap}
 ETWO 'O', 'N'          \                COMMANDER"
 ETWO 'S', 'T'          \
 ECHR 'R'               \ Encoded as:   "[147]C<223><222>RICT<253> [203]<242>
 ECHR 'I'               \                <237><241><233>, [154]"
 ECHR 'C'
 ECHR 'T'
 ETWO 'O', 'R'
 ECHR ' '
 ETOK 203
 ETWO 'R', 'E'
 ETWO 'E', 'S'
 ETWO 'D', 'I'
 ETWO 'C', 'E'
 ECHR ','
 ECHR ' '
 ETOK 154
 EQUB VE

 ECHR 'A'               \ Token 3:      "A [130-134] LOOKING SHIP LEFT HERE A
 ECHR ' '               \                WHILE BACK. LOOKED BOUND FOR AREXE"
 ERND 23                \
 ECHR ' '               \ Encoded as:   "A [23?] <224>OK[195][207] <229>FT HE
 ETWO 'L', 'O'          \                <242>[208]WHI<229> BACK. <224>OK[196]B
 ECHR 'O'               \                <217>ND F<253> <238>E<230>"
 ECHR 'K'
 ETOK 195
 ETOK 207
 ECHR ' '
 ETWO 'L', 'E'
 ECHR 'F'
 ECHR 'T'
 ECHR ' '
 ECHR 'H'
 ECHR 'E'
 ETWO 'R', 'E'
 ETOK 208
 ECHR 'W'
 ECHR 'H'
 ECHR 'I'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'B'
 ECHR 'A'
 ECHR 'C'
 ECHR 'K'
 ECHR '.'
 ECHR ' '
 ETWO 'L', 'O'
 ECHR 'O'
 ECHR 'K'
 ETOK 196
 ECHR 'B'
 ETWO 'O', 'U'
 ECHR 'N'
 ECHR 'D'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ETWO 'X', 'E'
 EQUB VE

 ECHR 'Y'               \ Token 4:      "YEP, A [130-134] NEW SHIP HAD A
 ECHR 'E'               \                GALACTIC HYPERDRIVE FITTED HERE. USED
 ECHR 'P'               \                IT TOO"
 ECHR ','               \
 ETOK 208               \ Encoded as:   "YEP,[208][23?][210][207] HAD[208]G
 ERND 23                \                <228>AC<251>C HYP<244>DRI<250> F<219>
 ETOK 210               \                T[196]HE<242>. <236>[196]<219> TOO"
 ETOK 207
 ECHR ' '
 ECHR 'H'
 ECHR 'A'
 ECHR 'D'
 ETOK 208
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'C'
 ECHR ' '
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'D'
 ECHR 'R'
 ECHR 'I'
 ETWO 'V', 'E'
 ECHR ' '
 ECHR 'F'
 ETWO 'I', 'T'
 ECHR 'T'
 ETOK 196
 ECHR 'H'
 ECHR 'E'
 ETWO 'R', 'E'
 ECHR '.'
 ECHR ' '
 ETWO 'U', 'S'
 ETOK 196
 ETWO 'I', 'T'
 ECHR ' '
 ECHR 'T'
 ECHR 'O'
 ECHR 'O'
 EQUB VE

 ETOK 148               \ Token 5:      "THIS  [130-134] SHIP DEHYPED HERE FROM
 ECHR ' '               \                NOWHERE, SUN SKIMMED AND JUMPED. I HEAR
 ERND 23                \                IT WENT TO INBIBE"
 ECHR ' '               \
 ETOK 207               \ Encoded as:   "[148] [23?] [207] DEHYP[196]HE<242> FRO
 ECHR ' '               \                M <227>WHE<242>, SUN SKIMM<252>[178]JUM
 ECHR 'D'               \                P<252>. I HE<238> <219> W<246>T[201]
 ECHR 'E'               \                <240><234><247>"
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETOK 196
 ECHR 'H'
 ECHR 'E'
 ETWO 'R', 'E'
 ECHR ' '
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ETWO 'N', 'O'
 ECHR 'W'
 ECHR 'H'
 ECHR 'E'
 ETWO 'R', 'E'
 ECHR ','
 ECHR ' '
 ECHR 'S'
 ECHR 'U'
 ECHR 'N'
 ECHR ' '
 ECHR 'S'
 ECHR 'K'
 ECHR 'I'
 ECHR 'M'
 ECHR 'M'
 ETWO 'E', 'D'
 ETOK 178
 ECHR 'J'
 ECHR 'U'
 ECHR 'M'
 ECHR 'P'
 ETWO 'E', 'D'
 ECHR '.'
 ECHR ' '
 ECHR 'I'
 ECHR ' '
 ECHR 'H'
 ECHR 'E'
 ETWO 'A', 'R'
 ECHR ' '
 ETWO 'I', 'T'
 ECHR ' '
 ECHR 'W'
 ETWO 'E', 'N'
 ECHR 'T'
 ETOK 201
 ETWO 'I', 'N'
 ETWO 'B', 'I'
 ETWO 'B', 'E'
 EQUB VE

 ERND 24                \ Token 6:      "[91-95] SHIP WENT FOR ME AT AUSAR. MY
 ECHR ' '               \                LASERS DIDN'T EVEN SCRATCH THE [91-95]"
 ETOK 207               \
 ECHR ' '               \ Encoded as:   "[24?] [207] W<246>T F<253> ME <245>
 ECHR 'W'               \                 A<236><238>. MY <249>S<244>S <241>DN
 ETWO 'E', 'N'          \                 [39]TEV<246> SC<248>TCH [147][24?]"
 ECHR 'T'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'M'
 ECHR 'E'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'A'
 ETWO 'U', 'S'
 ETWO 'A', 'R'
 ECHR '.'
 ECHR ' '
 ECHR 'M'
 ECHR 'Y'
 ECHR ' '
 ETWO 'L', 'A'
 ECHR 'S'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR ' '
 ETWO 'D', 'I'
 ECHR 'D'
 ECHR 'N'
 ECHR '`'
 ECHR 'T'
 ECHR ' '
 ECHR 'E'
 ECHR 'V'
 ETWO 'E', 'N'
 ECHR ' '
 ECHR 'S'
 ECHR 'C'
 ETWO 'R', 'A'
 ECHR 'T'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETOK 147
 ERND 24
 EQUB VE

 ECHR 'O'               \ Token 7:      "OH DEAR ME YES. A FRIGHTFUL ROGUE WITH
 ECHR 'H'               \                WHAT I BELIEVE YOU PEOPLE CALL A LEAD
 ECHR ' '               \                POSTERIOR SHOT UP LOTS OF THOSE BEASTLY
 ECHR 'D'               \                PIRATES AND WENT TO USLERI"
 ECHR 'E'               \
 ETWO 'A', 'R'          \ Encoded as:   "OH DE<238> ME Y<237>.[208]FRIGHTFUL ROG
 ECHR ' '               \                UE WI<226> WH<245> I <247>LIE<250>
 ECHR 'M'               \                 [179] PEOP<229> C<228>L[208]<229>AD PO
 ECHR 'E'               \                <222><244>I<253> SHOT UP <224>TS OF
 ECHR ' '               \                 <226>O<218> <247>A<222>LY PI<248>T
 ECHR 'Y'               \                <237>[178]W<246>T[201]<236><229>RI"
 ETWO 'E', 'S'
 ECHR '.'
 ETOK 208
 ECHR 'F'
 ECHR 'R'
 ECHR 'I'
 ECHR 'G'
 ECHR 'H'
 ECHR 'T'
 ECHR 'F'
 ECHR 'U'
 ECHR 'L'
 ECHR ' '
 ECHR 'R'
 ECHR 'O'
 ECHR 'G'
 ECHR 'U'
 ECHR 'E'
 ECHR ' '
 ECHR 'W'
 ECHR 'I'
 ETWO 'T', 'H'
 ECHR ' '
 ECHR 'W'
 ECHR 'H'
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'I'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR 'L'
 ECHR 'I'
 ECHR 'E'
 ETWO 'V', 'E'
 ECHR ' '
 ETOK 179
 ECHR ' '
 ECHR 'P'
 ECHR 'E'
 ECHR 'O'
 ECHR 'P'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'L'
 ECHR 'L'
 ETOK 208
 ETWO 'L', 'E'
 ECHR 'A'
 ECHR 'D'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ETWO 'S', 'T'
 ETWO 'E', 'R'
 ECHR 'I'
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'S'
 ECHR 'H'
 ECHR 'O'
 ECHR 'T'
 ECHR ' '
 ECHR 'U'
 ECHR 'P'
 ECHR ' '
 ETWO 'L', 'O'
 ECHR 'T'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ETWO 'T', 'H'
 ECHR 'O'
 ETWO 'S', 'E'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR 'A'
 ETWO 'S', 'T'
 ECHR 'L'
 ECHR 'Y'
 ECHR ' '
 ECHR 'P'
 ECHR 'I'
 ETWO 'R', 'A'
 ECHR 'T'
 ETWO 'E', 'S'
 ETOK 178
 ECHR 'W'
 ETWO 'E', 'N'
 ECHR 'T'
 ETOK 201
 ETWO 'U', 'S'
 ETWO 'L', 'E'
 ECHR 'R'
 ECHR 'I'
 EQUB VE

 ETOK 179               \ Token 8:      "YOU CAN TACKLE THE [170-174] [91-95]
 ECHR ' '               \                IF YOU LIKE. HE'S AT ORARRA"
 ECHR 'C'               \
 ETWO 'A', 'N'          \ Encoded as:   "[179] C<255> TACK<229> [147][13?] [24?]
 ECHR ' '               \                 IF [179] LIKE. HE[39]S <245> <253>
 ECHR 'T'               \                <238><248>"
 ECHR 'A'
 ECHR 'C'
 ECHR 'K'
 ETWO 'L', 'E'
 ECHR ' '
 ETOK 147
 ERND 13
 ECHR ' '
 ERND 24
 ECHR ' '
 ECHR 'I'
 ECHR 'F'
 ECHR ' '
 ETOK 179
 ECHR ' '
 ECHR 'L'
 ECHR 'I'
 ECHR 'K'
 ECHR 'E'
 ECHR '.'
 ECHR ' '
 ECHR 'H'
 ECHR 'E'
 ECHR '`'
 ECHR 'S'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ETWO 'O', 'R'
 ETWO 'A', 'R'
 ETWO 'R', 'A'
 EQUB VE

 EJMP 1                 \ Token 9:      "{all caps}COMING SOON: ELITE III"
 ECHR 'C'               \
 ECHR 'O'               \ Encoded as:   "{1}COM[195]<235><223>: EL<219>E III"
 ECHR 'M'
 ETOK 195
 ETWO 'S', 'O'
 ETWO 'O', 'N'
 ECHR ':'
 ECHR ' '
 ECHR 'E'
 ECHR 'L'
 ETWO 'I', 'T'
 ECHR 'E'
 ECHR ' '
 ECHR 'I'
 ECHR 'I'
 ECHR 'I'
 EQUB VE

 ERND 25                \ Token 10:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 11:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 12:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 13:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 14:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 15:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 16:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 17:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 18:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 19:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 20:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 21:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ERND 25                \ Token 22:     "[106-110]"
 EQUB VE                \
                        \ Encoded as:   "[25?]"

 ECHR 'B'               \ Token 23:     "BOY ARE YOU IN THE WRONG GALAXY!"
 ECHR 'O'               \
 ECHR 'Y'               \ Encoded as:   "BOY A<242> [179] <240> [147]WR<223>G G
 ECHR ' '               \                <228>AXY!"
 ECHR 'A'
 ETWO 'R', 'E'
 ECHR ' '
 ETOK 179
 ECHR ' '
 ETWO 'I', 'N'
 ECHR ' '
 ETOK 147
 ECHR 'W'
 ECHR 'R'
 ETWO 'O', 'N'
 ECHR 'G'
 ECHR ' '
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'X'
 ECHR 'Y'
 ECHR '!'
 EQUB VE

 ETWO 'T', 'H'          \ Token 24:     "THERE'S A REAL [91-95] PIRATE OUT
 ETWO 'E', 'R'          \                THERE"
 ECHR 'E'               \
 ECHR '`'               \ Encoded as:   "<226><244>E[39]S[208]<242><228> [24?] P
 ECHR 'S'               \                I<248>TE <217>T <226><244>E"
 ETOK 208
 ETWO 'R', 'E'
 ETWO 'A', 'L'
 ECHR ' '
 ERND 24
 ECHR ' '
 ECHR 'P'
 ECHR 'I'
 ETWO 'R', 'A'
 ECHR 'T'
 ECHR 'E'
 ECHR ' '
 ETWO 'O', 'U'
 ECHR 'T'
 ECHR ' '
 ETWO 'T', 'H'
 ETWO 'E', 'R'
 ECHR 'E'
 EQUB VE

 ETOK 147               \ Token 25:     "THE INHABITANTS OF [86-90] ARE SO
 ETOK 193               \                AMAZINGLY PRIMITIVE THAT THEY STILL
 ECHR 'S'               \                THINK {single cap}ELITE IS A PRETTY
 ECHR ' '               \                NEAT GAME"
 ECHR 'O'               \
 ECHR 'F'               \ Encoded as:   "[147][193]S OF [18?] A<242> <235> A
 ECHR ' '               \                <239>Z<240>GLY PRIMI<251><250> <226>
 ERND 18                \                <245> <226>EY <222><220>L <226><240>K
 ECHR ' '               \                 {19}EL<219>E[202]A P<242>TTY NE<245>
 ECHR 'A'               \                 GAME"
 ETWO 'R', 'E'
 ECHR ' '
 ETWO 'S', 'O'
 ECHR ' '
 ECHR 'A'
 ETWO 'M', 'A'
 ECHR 'Z'
 ETWO 'I', 'N'
 ECHR 'G'
 ECHR 'L'
 ECHR 'Y'
 ECHR ' '
 ECHR 'P'
 ECHR 'R'
 ECHR 'I'
 ECHR 'M'
 ECHR 'I'
 ETWO 'T', 'I'
 ETWO 'V', 'E'
 ECHR ' '
 ETWO 'T', 'H'
 ETWO 'A', 'T'
 ECHR ' '
 ETWO 'T', 'H'
 ECHR 'E'
 ECHR 'Y'
 ECHR ' '
 ETWO 'S', 'T'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'T', 'H'
 ETWO 'I', 'N'
 ECHR 'K'
 ECHR ' '
 EJMP 19
 ECHR 'E'
 ECHR 'L'
 ETWO 'I', 'T'
 ECHR 'E'
 ETOK 202
 ECHR 'A'
 ECHR ' '
 ECHR 'P'
 ETWO 'R', 'E'
 ECHR 'T'
 ECHR 'T'
 ECHR 'Y'
 ECHR ' '
 ECHR 'N'
 ECHR 'E'
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'G'
 ECHR 'A'
 ECHR 'M'
 ECHR 'E'
 EQUB VE

\ ******************************************************************************
\
\       Name: MTIN
\       Type: Variable
\   Category: Text
\    Summary: Lookup table for random tokens in the extended token table (0-37)
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ The ERND token type, which is part of the extended token system, takes an
\ argument between 0 and 37, and returns a randomly chosen token in the range
\ specified in this table. This is used to generate the extended description of
\ each system.
\
\ For example, the entry at position 13 in this table (counting from 0) is 66,
\ so ERND 14 will expand into a random token in the range 66-70, i.e. one of
\ "JUICE", "BRANDY", "WATER", "BREW" and "GARGLE BLASTERS".
\
\ ******************************************************************************

.MTIN

 EQUB 16                \ Token  0: a random extended token between 16 and 20
 EQUB 21                \ Token  1: a random extended token between 21 and 25
 EQUB 26                \ Token  2: a random extended token between 26 and 30
 EQUB 31                \ Token  3: a random extended token between 31 and 35
 EQUB 155               \ Token  4: a random extended token between 155 and 159
 EQUB 160               \ Token  5: a random extended token between 160 and 164
 EQUB 46                \ Token  6: a random extended token between 46 and 50
 EQUB 165               \ Token  7: a random extended token between 165 and 169
 EQUB 36                \ Token  8: a random extended token between 36 and 40
 EQUB 41                \ Token  9: a random extended token between 41 and 45
 EQUB 61                \ Token 10: a random extended token between 61 and 65
 EQUB 51                \ Token 11: a random extended token between 51 and 55
 EQUB 56                \ Token 12: a random extended token between 56 and 60
 EQUB 170               \ Token 13: a random extended token between 170 and 174
 EQUB 66                \ Token 14: a random extended token between 66 and 70
 EQUB 71                \ Token 15: a random extended token between 71 and 75
 EQUB 76                \ Token 16: a random extended token between 76 and 80
 EQUB 81                \ Token 17: a random extended token between 81 and 85
 EQUB 86                \ Token 18: a random extended token between 86 and 90
 EQUB 140               \ Token 19: a random extended token between 140 and 144
 EQUB 96                \ Token 20: a random extended token between 96 and 100
 EQUB 101               \ Token 21: a random extended token between 101 and 105
 EQUB 135               \ Token 22: a random extended token between 135 and 139
 EQUB 130               \ Token 23: a random extended token between 130 and 134
 EQUB 91                \ Token 24: a random extended token between 91 and 95
 EQUB 106               \ Token 25: a random extended token between 106 and 110
 EQUB 180               \ Token 26: a random extended token between 180 and 184
 EQUB 185               \ Token 27: a random extended token between 185 and 189
 EQUB 190               \ Token 28: a random extended token between 190 and 194
 EQUB 225               \ Token 29: a random extended token between 225 and 229
 EQUB 230               \ Token 30: a random extended token between 230 and 234
 EQUB 235               \ Token 31: a random extended token between 235 and 239
 EQUB 240               \ Token 32: a random extended token between 240 and 244
 EQUB 245               \ Token 33: a random extended token between 245 and 249
 EQUB 250               \ Token 34: a random extended token between 250 and 254
 EQUB 115               \ Token 35: a random extended token between 115 and 119
 EQUB 120               \ Token 36: a random extended token between 120 and 124
 EQUB 125               \ Token 37: a random extended token between 125 and 129

\ ******************************************************************************
\
\       Name: msg_3
\       Type: Variable
\   Category: Text
\    Summary: The second extended token table for recursive tokens 0-255
\             (write_msg3)
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.msg_3

 EQUB VE                \ Token 0:      ""
                        \
                        \ Encoded as:   ""

 ETWO 'E', 'N'          \ Token 1:      "ENCYCLOPEDIA GALACTICA"
 ECHR 'C'               \
 ECHR 'Y'               \ Encoded as:   "<246>CYC<224>P<252>IA G<228>AC<251>CA"
 ECHR 'C'
 ETWO 'L', 'O'
 ECHR 'P'
 ETWO 'E', 'D'
 ECHR 'I'
 ECHR 'A'
 ECHR ' '
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'C'
 ECHR 'A'
 EQUB VE

 ETOK 207               \ Token 2:      "SHIPS {all caps}A-G{sentence case}"
 ECHR 'S'               \
 ECHR ' '               \ Encoded as:   "[207]S {1}A-G{2}"
 EJMP 1
 ECHR 'A'
 ECHR '-'
 ECHR 'G'
 EJMP 2
 EQUB VE

 ETOK 207               \ Token 3:      "SHIPS {all caps}I-W{sentence case}"
 ECHR 'S'               \
 ECHR ' '               \ Encoded as:   "[207]S {1}I-W{2}"
 EJMP 1
 ECHR 'I'
 ECHR '-'
 ECHR 'W'
 EJMP 2
 EQUB VE

 ECHR 'E'               \ Token 4:      "EQUIPMENT"
 ETWO 'Q', 'U'          \
 ECHR 'I'               \ Encoded as:   "E<254>IPM<246>T"
 ECHR 'P'
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'T'
 EQUB VE

 ECHR 'C'               \ Token 5:      "CONTROLS"
 ETWO 'O', 'N'          \
 ECHR 'T'               \ Encoded as:   "C<223>TROLS"
 ECHR 'R'
 ECHR 'O'
 ECHR 'L'
 ECHR 'S'
 EQUB VE

 ETWO 'I', 'N'          \ Token 6:      "INFORMATION"
 ECHR 'F'               \
 ETWO 'O', 'R'          \ Encoded as:   "<240>F<253><239><251><223>"
 ETWO 'M', 'A'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 EQUB VE

 ECHR 'A'               \ Token 7:      "ADDER"
 ECHR 'D'               \
 ECHR 'D'               \ Encoded as:   "ADD<244>"
 ETWO 'E', 'R'
 EQUB VE

 ETWO 'A', 'N'          \ Token 8:      "ANACONDA"
 ECHR 'A'               \
 ECHR 'C'               \ Encoded as:   "<255>AC<223>DA"
 ETWO 'O', 'N'
 ECHR 'D'
 ECHR 'A'
 EQUB VE

 ECHR 'A'               \ Token 9:      "ASP MK2"
 ECHR 'S'               \
 ECHR 'P'               \ Encoded as:   "ASP MK2"
 ECHR ' '
 ECHR 'M'
 ECHR 'K'
 ECHR '2'
 EQUB VE

 ECHR 'B'               \ Token 10:     "BOA"
 ECHR 'O'               \
 ECHR 'A'               \ Encoded as:   "BOA"
 EQUB VE

 ECHR 'B'               \ Token 11:     "BUSHMASTER"
 ECHR 'U'               \
 ECHR 'S'               \ Encoded as:   "BUSHMASTER"
 ECHR 'H'
 ECHR 'M'
 ECHR 'A'
 ECHR 'S'
 ECHR 'T'
 ECHR 'E'
 ECHR 'R'
 EQUB VE

 ECHR 'C'               \ Token 12:     "CHAMELEON"
 ECHR 'H'               \
 ECHR 'A'               \ Encoded as:   "CHAMELEON"
 ECHR 'M'
 ECHR 'E'
 ECHR 'L'
 ECHR 'E'
 ECHR 'O'
 ECHR 'N'
 EQUB VE

 ECHR 'C'               \ Token 13:     "COBRA MK1"
 ECHR 'O'               \
 ECHR 'B'               \ Encoded as:   "COB<248> MK1"
 ETWO 'R', 'A'
 ECHR ' '
 ECHR 'M'
 ECHR 'K'
 ECHR '1'
 EQUB VE

 ECHR 'C'               \ Token 14:     "COBRA MK3"
 ECHR 'O'               \
 ECHR 'B'               \ Encoded as:   "COB<248> MK3"
 ETWO 'R', 'A'
 ECHR ' '
 ECHR 'M'
 ECHR 'K'
 ECHR '3'
 EQUB VE

 ECHR 'C'               \ Token 15:     "CORIOLIS STATION"
 ETWO 'O', 'R'          \
 ECHR 'I'               \ Encoded as:   "C<253>IOLIS <222><245>I<223>"
 ECHR 'O'
 ECHR 'L'
 ECHR 'I'
 ECHR 'S'
 ECHR ' '
 ETWO 'S', 'T'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 EQUB VE

 ECHR 'D'               \ Token 16:     "DODECAGON STATION"
 ECHR 'O'               \
 ECHR 'D'               \ Encoded as:   "DODECAG<223> <222><245>I<223>"
 ECHR 'E'
 ECHR 'C'
 ECHR 'A'
 ECHR 'G'
 ETWO 'O', 'N'
 ECHR ' '
 ETWO 'S', 'T'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 EQUB VE

 ETWO 'E', 'S'          \ Token 17:     "ESCAPE CAPSULE"
 ECHR 'C'               \
 ECHR 'A'               \ Encoded as:   "<237>CAPE CAPSU<229>"
 ECHR 'P'
 ECHR 'E'
 ECHR ' '
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'S'
 ECHR 'U'
 ETWO 'L', 'E'
 EQUB VE

 ECHR 'F'               \ Token 18:     "FER-DE-{single cap}LANCE"
 ETWO 'E', 'R'          \
 ECHR '-'               \ Encoded as:   "F<244>-DE-{19}<249>N<233>"
 ECHR 'D'
 ECHR 'E'
 ECHR '-'
 EJMP 19
 ETWO 'L', 'A'
 ECHR 'N'
 ETWO 'C', 'E'
 EQUB VE

 ETWO 'G', 'E'          \ Token 19:     "GECKO"
 ECHR 'C'               \
 ECHR 'K'               \ Encoded as:   "<231>CKO"
 ECHR 'O'
 EQUB VE

 ECHR 'G'               \ Token 20:     "GHAVIAL"
 ECHR 'H'               \
 ECHR 'A'               \ Encoded as:   "GHAVI<228>"
 ECHR 'V'
 ECHR 'I'
 ETWO 'A', 'L'
 EQUB VE

 ECHR 'I'               \ Token 21:     "IGUANA"
 ECHR 'G'               \
 ECHR 'U'               \ Encoded as:   "IGUANA"
 ECHR 'A'
 ECHR 'N'
 ECHR 'A'
 EQUB VE

 ECHR 'K'               \ Token 22:     "KRAIT"
 ETWO 'R', 'A'          \
 ETWO 'I', 'T'          \ Encoded as:   "K<248><219>"
 EQUB VE

 ETWO 'M', 'A'          \ Token 23:     "MAMBA"
 ECHR 'M'               \
 ECHR 'B'               \ Encoded as:   "<239>MBA"
 ECHR 'A'
 EQUB VE

 ECHR 'M'               \ Token 24:     "MONITOR"
 ETWO 'O', 'N'          \
 ETWO 'I', 'T'          \ Encoded as:   "M<223><219><253>"
 ETWO 'O', 'R'
 EQUB VE

 ECHR 'M'               \ Token 25:     "MORAY"
 ECHR 'O'               \
 ETWO 'R', 'A'          \ Encoded as:   "MO<248>Y"
 ECHR 'Y'
 EQUB VE

 ECHR 'O'               \ Token 26:     "OPHIDIAN"
 ECHR 'P'               \
 ECHR 'H'               \ Encoded as:   "OPHI<241><255>"
 ECHR 'I'
 ETWO 'D', 'I'
 ETWO 'A', 'N'
 EQUB VE

 ECHR 'P'               \ Token 27:     "PYTHON"
 ECHR 'Y'               \
 ETWO 'T', 'H'          \ Encoded as:   "PY<226><223>"
 ETWO 'O', 'N'
 EQUB VE

 ECHR 'S'               \ Token 28:     "SHUTTLE"
 ECHR 'H'               \
 ECHR 'U'               \ Encoded as:   "SHUTT<229>"
 ECHR 'T'
 ECHR 'T'
 ETWO 'L', 'E'
 EQUB VE

 ECHR 'S'               \ Token 29:     "SIDEWINDER"
 ECHR 'I'               \
 ECHR 'D'               \ Encoded as:   "SIDEW<240>D<244>"
 ECHR 'E'
 ECHR 'W'
 ETWO 'I', 'N'
 ECHR 'D'
 ETWO 'E', 'R'
 EQUB VE

 ETWO 'T', 'H'          \ Token 30:     "THARGOID"
 ETWO 'A', 'R'          \
 ECHR 'G'               \ Encoded as:   "<226><238>GOID"
 ECHR 'O'
 ECHR 'I'
 ECHR 'D'
 EQUB VE

 ETWO 'T', 'H'          \ Token 31:     "THARGON"
 ETWO 'A', 'R'          \
 ECHR 'G'               \ Encoded as:   "<226><238>G<223>"
 ETWO 'O', 'N'
 EQUB VE

 ECHR 'T'               \ Token 32:     "TRANSPORTER"
 ETWO 'R', 'A'          \
 ECHR 'N'               \ Encoded as:   "T<248>NSP<253>T<244>"
 ECHR 'S'
 ECHR 'P'
 ETWO 'O', 'R'
 ECHR 'T'
 ETWO 'E', 'R'
 EQUB VE

 ECHR 'V'               \ Token 33:     "VIPER"
 ECHR 'I'               \
 ECHR 'P'               \ Encoded as:   "VIP<244>"
 ETWO 'E', 'R'
 EQUB VE

 ECHR 'W'               \ Token 34:     "WORM"
 ETWO 'O', 'R'          \
 ECHR 'M'               \ Encoded as:   "W<253>M"
 EQUB VE

 ETWO 'A', 'R'          \ Token 35:     "ARMAMENTS:"
 ETWO 'M', 'A'          \
 ECHR 'M'               \ Encoded as:   "<238><239>M<246>TS:"
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR 'S'
 ECHR ':'
 EQUB VE

 ECHR 'S'               \ Token 36:     "SPEED:"
 ECHR 'P'               \
 ECHR 'E'               \ Encoded as:   "SPE<252>:"
 ETWO 'E', 'D'
 ECHR ':'
 EQUB VE

 ETWO 'I', 'N'          \ Token 37:     "INSERVICE DATE:"
 ETWO 'S', 'E'          \
 ECHR 'R'               \ Encoded as:   "<240><218>RVI<233> D<245>E:"
 ECHR 'V'
 ECHR 'I'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'D'
 ETWO 'A', 'T'
 ECHR 'E'
 ECHR ':'
 EQUB VE

 ECHR 'C'               \ Token 38:     "COMBAT"
 ECHR 'O'               \
 ECHR 'M'               \ Encoded as:   "COMB<245>"
 ECHR 'B'
 ETWO 'A', 'T'
 EQUB VE

 ECHR 'C'               \ Token 39:     "CREW:"
 ETWO 'R', 'E'          \
 ECHR 'W'               \ Encoded as:   "C<242>W:"
 ECHR ':'
 EQUB VE

 ETOK 151               \ Token 40:     "DRIVE MOTORS:"
 ECHR ' '               \
 ECHR 'M'               \ Encoded as:   "[151] MOT<253>S:"
 ECHR 'O'
 ECHR 'T'
 ETWO 'O', 'R'
 ECHR 'S'
 ECHR ':'
 EQUB VE

 ETWO 'R', 'A'          \ Token 41:     "RANGE:"
 ECHR 'N'               \
 ETWO 'G', 'E'          \ Encoded as:   "<248>N<231>:"
 ECHR ':'
 EQUB VE

 ECHR 'F'               \ Token 42:     "FT"
 ECHR 'T'               \
 EQUB VE                \ Encoded as:   "FT"

 ETWO 'D', 'I'          \ Token 43:     "DIMENSIONS:"
 ECHR 'M'               \
 ETWO 'E', 'N'          \ Encoded as:   "<241>M<246>SI<223>S:"
 ECHR 'S'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR 'S'
 ECHR ':'
 EQUB VE

 ECHR 'H'               \ Token 44:     "HULL:"
 ECHR 'U'               \
 ECHR 'L'               \ Encoded as:   "HULL:"
 ECHR 'L'
 ECHR ':'
 EQUB VE

 ECHR 'S'               \ Token 45:     "SPACE:"
 ECHR 'P'               \
 ECHR 'A'               \ Encoded as:   "SPA<233>:"
 ETWO 'C', 'E'
 ECHR ':'
 EQUB VE

 ECHR ' '               \ Token 46:     " MISSILES"
 ECHR 'M'               \
 ECHR 'I'               \ Encoded as:   " MISS<220><237>"
 ECHR 'S'
 ECHR 'S'
 ETWO 'I', 'L'
 ETWO 'E', 'S'
 EQUB VE

 ECHR 'F'               \ Token 47:     "FACTOR:"
 ECHR 'A'               \
 ECHR 'C'               \ Encoded as:   "FACT<253>:"
 ECHR 'T'
 ETWO 'O', 'R'
 ECHR ':'
 EQUB VE

 ETWO 'G', 'E'          \ Token 48:     "GERET STARSEEKER"
 ECHR 'R'               \
 ETWO 'E', 'T'          \ Encoded as:   "<231>R<221> <222><238><218>EK<244>"
 ECHR ' '
 ETWO 'S', 'T'
 ETWO 'A', 'R'
 ETWO 'S', 'E'
 ECHR 'E'
 ECHR 'K'
 ETWO 'E', 'R'
 EQUB VE

 ECHR ' '               \ Token 49:     " LASER"
 ETWO 'L', 'A'          \
 ETWO 'S', 'E'          \ Encoded as:   "<249><218>R"
 ECHR 'R'
 EQUB VE

 ECHR ' '               \ Token 50:     " PULSE"
 ECHR 'P'               \
 ECHR 'U'               \ Encoded as:   "PUL<218>"
 ECHR 'L'
 ETWO 'S', 'E'
 EQUB VE

 ECHR ' '               \ Token 51:     " SYSTEM"
 ECHR 'S'               \
 ECHR 'Y'               \ Encoded as:   " SY<222>EM"
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 EQUB VE

 ETWO 'E', 'R'          \ Token 52:     "ERGON"
 ECHR 'G'               \
 ETWO 'O', 'N'          \ Encoded as:   "<244>G<223>"
 EQUB VE

 ETOK 151               \ Token 53:     "DRIVE"
 EQUB VE                \
                        \ Encoded as:   "[151]"

 ETWO 'S', 'E'          \ Token 54:     "SEEK"
 ECHR 'E'               \
 ECHR 'K'               \ Encoded as:   "<218>EK"
 EQUB VE

 ECHR 'L'               \ Token 55:     "LIGHT"
 ECHR 'I'               \
 ECHR 'G'               \ Encoded as:   "LIGHT"
 ECHR 'H'
 ECHR 'T'
 EQUB VE

 ETWO 'I', 'N'          \ Token 56:     "INGRAM"
 ECHR 'G'               \
 ETWO 'R', 'A'          \ Encoded as:   "<240>G<248>M"
 ECHR 'M'
 EQUB VE

 ETWO 'L', 'A'          \ Token 57:     "LANCE & FERMAN"
 ECHR 'N'               \
 ETWO 'C', 'E'          \ Encoded as:   "<249>N<233> & F<244><239>N"
 ECHR ' '
 ECHR '&'
 ECHR ' '
 ECHR 'F'
 ETWO 'E', 'R'
 ETWO 'M', 'A'
 ECHR 'N'
 EQUB VE

 EJMP 19                \ Token 58:     "{single cap}KRUGER "
 ECHR 'K'               \
 ECHR 'R'               \ Encoded as:   "{19}KRU<231>R "
 ECHR 'U'
 ETWO 'G', 'E'
 ECHR 'R'
 ECHR ' '
 EQUB VE

 ECHR 'H'               \ Token 59:     "HASSONI"
 ECHR 'A'               \
 ECHR 'S'               \ Encoded as:   "HASS<223>I"
 ECHR 'S'
 ETWO 'O', 'N'
 ECHR 'I'
 EQUB VE

 ECHR 'V'               \ Token 60:     "VOLTAIRE"
 ECHR 'O'               \
 ECHR 'L'               \ Encoded as:   "VOLTAI<242>"
 ECHR 'T'
 ECHR 'A'
 ECHR 'I'
 ETWO 'R', 'E'
 EQUB VE

 ECHR 'C'               \ Token 61:     "CARGO"
 ETWO 'A', 'R'          \
 ECHR 'G'               \ Encoded as:   "C<238>GO"
 ECHR 'O'
 EQUB VE

 EJMP 1                 \ Token 62:     "{all caps}TC{sentence case}"
 ECHR 'T'               \
 ECHR 'C'               \ Encoded as:   "{1}TC{2}"
 EJMP 2
 EQUB VE

 EJMP 1                 \ Token 63:     "{all caps}LY{sentence case}"
 ECHR 'L'               \
 ECHR 'Y'               \ Encoded as:   "{1}LY{2}"
 EJMP 2
 EQUB VE

 EJMP 1                 \ Token 64:     "{all caps}LM{sentence case}"
 ECHR 'L'               \
 ECHR 'M'               \ Encoded as:   "{1}LM{2}"
 EJMP 2
 EQUB VE

 ECHR 'C'               \ Token 65:     "CF"
 ECHR 'F'               \
 EQUB VE                \ Encoded as:   "CF"

 ETWO 'T', 'H'          \ Token 66:     "THRUST"
 ECHR 'R'               \
 ECHR 'U'               \ Encoded as:   "<226>RU<222>"
 ETWO 'S', 'T'
 EQUB VE

 ECHR ' '               \ Token 67:     " SHIP"
 ETOK 207               \
 EQUB VE                \ Encoded as:   " [207]"

 ETWO 'I', 'N'          \ Token 68:     "INVENTION"
 ECHR 'V'               \
 ETWO 'E', 'N'          \ Encoded as:   "<240>V<246><251><223>"
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 EQUB VE

 ETWO 'O', 'U'          \ Token 69:     "OUTWORLD"
 ECHR 'T'               \
 ECHR 'W'               \ Encoded as:   "<217>TW<253>LD"
 ETWO 'O', 'R'
 ECHR 'L'
 ECHR 'D'
 EQUB VE

 ECHR 'Z'               \ Token 70:     "ZORGON PETTERSON)"
 ETWO 'O', 'R'          \
 ECHR 'G'               \ Encoded as:   "Z<253>G<223> P<221>T<244>S<223>)"
 ETWO 'O', 'N'
 ECHR ' '
 ECHR 'P'
 ETWO 'E', 'T'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'S'
 ETWO 'O', 'N'
 ECHR ')'
 EQUB VE

 ECHR 'D'               \ Token 71:     "DE{single cap}LACY"
 ECHR 'E'               \
 EJMP 19                \ Encoded as:   "DE{19}<249>CY"
 ETWO 'L', 'A'
 ECHR 'C'
 ECHR 'Y'
 EQUB VE

 EJMP 1                 \ Token 72:     "{all caps}4*C40KV{sentence case} AMES
 ECHR '4'               \                DRIVE"
 ECHR '*'               \ Encoded as:   "{1}4*C40KV{2} AM<237> [151]"
 ECHR 'C'
 ECHR '4'
 ECHR '0'
 ECHR 'K'
 ECHR 'V'
 EJMP 2
 ECHR ' '
 ECHR 'A'
 ECHR 'M'
 ETWO 'E', 'S'
 ECHR ' '
 ETOK 151
 EQUB VE

 ECHR 'V'               \ Token 73:     "V & K "
 ECHR ' '               \
 ECHR '&'               \ Encoded as:   "V & K "
 ECHR ' '
 ECHR 'K'
 ECHR ' '
 EQUB VE

 ECHR 'B'               \ Token 74:     "BLAST"
 ETWO 'L', 'A'          \
 ETWO 'S', 'T'          \ Encoded as:   "B<249><222>"
 EQUB VE

 ECHR ' '               \ Token 75:     " ({single cap}GASEC LABS, VETITICE)"
 ECHR '('               \
 EJMP 19                \ Encoded as:   "({19}GA<218>C L<216>S, <250><251><251>
 ECHR 'G'               \                <233>)"
 ECHR 'A'
 ETWO 'S', 'E'
 ECHR 'C'
 ECHR ' '
 ECHR 'L'
 ETWO 'A', 'B'
 ECHR 'S'
 ECHR ','
 ECHR ' '
 ETWO 'V', 'E'
 ETWO 'T', 'I'
 ETWO 'T', 'I'
 ETWO 'C', 'E'
 ECHR ')'
 EQUB VE

 ECHR 'F'               \ Token 76:     "FEDERATION"
 ETWO 'E', 'D'          \
 ECHR 'E'               \ Encoded as:   "F<252>E<248><251><223>"
 ETWO 'R', 'A'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 EQUB VE

 ECHR 'S'               \ Token 77:     "SPACE"
 ECHR 'P'               \
 ECHR 'A'               \ Encoded as:   "SPA<233>"
 ETWO 'C', 'E'
 EQUB VE

 EJMP 19                \ Token 78:     "{single cap}IONIC"
 ECHR 'I'               \
 ETWO 'O', 'N'          \ Encoded as:   "{19}I<223>IC"
 ECHR 'I'
 ECHR 'C'
 EQUB VE

 ECHR 'H'               \ Token 79:     "HUNT"
 ECHR 'U'               \
 ECHR 'N'               \ Encoded as:   "HUNT"
 ECHR 'T'
 EQUB VE

 ECHR 'P'               \ Token 80:     "PROSSET "
 ECHR 'R'               \
 ECHR 'O'               \ Encoded as:   "PROS<218>T "
 ECHR 'S'
 ETWO 'S', 'E'
 ECHR 'T'
 ECHR ' '
 EQUB VE

 ECHR ' '               \ Token 81:     " WORKSHOPS)"
 ECHR 'W'               \
 ETWO 'O', 'R'          \ Encoded as:   " W<253>KSHOPS)"
 ECHR 'K'
 ECHR 'S'
 ECHR 'H'
 ECHR 'O'
 ECHR 'P'
 ECHR 'S'
 ECHR ')'
 EQUB VE

 EJMP 1                 \ Token 82:     "{all caps}/1L{sentence case}"
 ECHR '/'               \
 ECHR '1'               \ Encoded as:   "{1}/1L{2}"
 ECHR 'L'
 EJMP 2
 EQUB VE

 EJMP 1                 \ Token 83:     "{all caps}/2L{sentence case}"
 ECHR '/'               \
 ECHR '2'               \ Encoded as:   "{1}/2L{2}"
 ECHR 'L'
 EJMP 2
 EQUB VE

 EJMP 1                 \ Token 84:     "{all caps}/4L{sentence case}"
 ECHR '/'               \
 ECHR '4'               \ Encoded as:   "{1}/4L{2}"
 ECHR 'L'
 EJMP 2
 EQUB VE

 ECHR ' '               \ Token 85:     " ({single cap}"
 ECHR '('               \
 EJMP 19                \ Encoded as:   " ({19}"
 EQUB VE

 EJMP 1                 \ Token 86:     "{all caps}IFS{sentence case} "
 ECHR 'I'               \
 ECHR 'F'               \ Encoded as:   "{1}IFS{2} "
 ECHR 'S'
 EJMP 2
 ECHR ' '
 EQUB VE

 EJMP 12                \ Token 87:     "{cr}
 ECHR 'F'               \                FLIGHT CONTROLS{crlf}
 ECHR 'L'               \                <{tab 6}ANTI-CLOCKWISE ROLL{cr}
 ECHR 'I'               \                >{tab 6}CLOCKWISE ROLL{cr}
 ECHR 'G'               \                S{tab 6}DIVE{cr}
 ECHR 'H'               \                X{tab 6}CLIMB{cr}
 ECHR 'T'               \                {all caps}SPC{sentence case}{tab 6}
 ECHR ' '               \                INCREASE SPEED{cr}
 ECHR 'C'               \                ?{tab 6}DECREASE SPEED{cr}
 ETWO 'O', 'N'          \                {all caps}TAB{sentence case}{tab 6}
 ECHR 'T'               \                HYPERSPACE ESCAPE{cr}
 ECHR 'R'               \                {all caps}ESC{sentence case}{tab 6}
 ECHR 'O'               \                ESCAPE CAPSULE{cr}
 ECHR 'L'               \                F{tab 6}TOGGLE COMPASS{cr}
 ECHR 'S'               \                V{tab 6} DOCKING COMPUTERS ON{cr}
 ETWO '-', '-'          \                P{tab 6} DOCKING COMPUTERS OFF{cr}
 ECHR '<'               \                J{tab 6}MICROJUMP{cr}
 EJMP 8                 \                {lower case}F0{sentence case}{tab 6}
 ETWO 'A', 'N'          \                FRONT VIEW{cr}
 ETWO 'T', 'I'          \                {lower case}F1{sentence case}{tab 6}
 ECHR '-'               \                REAR VIEW{cr}
 ECHR 'C'               \                {lower case}F2{sentence case}{tab 6}
 ETWO 'L', 'O'          \                LEFT VIEW{cr}
 ECHR 'C'               \                {lower case}F3{sentence case}{tab 6}
 ECHR 'K'               \                RIGHT VIEW{cr}"
 ECHR 'W'               \
 ECHR 'I'               \ Encoded as:   "{12}FLIGHT C<223>TROLS<215><{8}<255>
 ETWO 'S', 'E'          \                <251>-C<224>CKWI<218> ROLL{12}>{8}C
 ECHR ' '               \                <224>CKWI<218> ROLL{12}S{8}<241><250>
 ECHR 'R'               \                {12}X{8}CLIMB{12}{1}SPC{2}{8}<240>C
 ECHR 'O'               \                <242>A<218> SPE<252>{12}?{8}DEC<242>A
 ECHR 'L'               \                <218> SPE<252>{12}{1}T<216>{2}{8}HYP
 ECHR 'L'               \                <244>SPA<233> <237>CAPE{12}{1}<237>C{2}
 EJMP 12                \                {8}<237>CAPE CAPSU<229>{12}F{8}TOGG
 ECHR '>'               \                <229> COMPASS{12}V{8}DOCK[195]COMPUT
 EJMP 8                 \                <244>S <223>{12}P{8}DOCK[195]COMPUT
 ECHR 'C'               \                <244>S OFF{12}J{8}MICROJUMP{12}{13}F0
 ETWO 'L', 'O'          \                {2}{8}FR<223>T VIEW{12}{13}F1{2}{8}
 ECHR 'C'               \                <242><238> VIEW{12}{13}F2{2}{8}<229>FT
 ECHR 'K'               \                 VIEW{12}{13}F3{2}{8}RIGHT VIEW{12}"
 ECHR 'W'
 ECHR 'I'
 ETWO 'S', 'E'
 ECHR ' '
 ECHR 'R'
 ECHR 'O'
 ECHR 'L'
 ECHR 'L'
 EJMP 12
 ECHR 'S'
 EJMP 8
 ETWO 'D', 'I'
 ETWO 'V', 'E'
 EJMP 12
 ECHR 'X'
 EJMP 8
 ECHR 'C'
 ECHR 'L'
 ECHR 'I'
 ECHR 'M'
 ECHR 'B'
 EJMP 12
 EJMP 1
 ECHR 'S'
 ECHR 'P'
 ECHR 'C'
 EJMP 2
 EJMP 8
 ETWO 'I', 'N'
 ECHR 'C'
 ETWO 'R', 'E'
 ECHR 'A'
 ETWO 'S', 'E'
 ECHR ' '
 ECHR 'S'
 ECHR 'P'
 ECHR 'E'
 ETWO 'E', 'D'
 EJMP 12
 ECHR '?'
 EJMP 8
 ECHR 'D'
 ECHR 'E'
 ECHR 'C'
 ETWO 'R', 'E'
 ECHR 'A'
 ETWO 'S', 'E'
 ECHR ' '
 ECHR 'S'
 ECHR 'P'
 ECHR 'E'
 ETWO 'E', 'D'
 EJMP 12
 EJMP 1
 ECHR 'T'
 ETWO 'A', 'B'
 EJMP 2
 EJMP 8
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ETWO 'E', 'S'
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'E'
 EJMP 12
 EJMP 1
 ETWO 'E', 'S'
 ECHR 'C'
 EJMP 2
 EJMP 8
 ETWO 'E', 'S'
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'E'
 ECHR ' '
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'S'
 ECHR 'U'
 ETWO 'L', 'E'
 EJMP 12
 ECHR 'F'
 EJMP 8
 ECHR 'T'
 ECHR 'O'
 ECHR 'G'
 ECHR 'G'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'P'
 ECHR 'A'
 ECHR 'S'
 ECHR 'S'
 EJMP 12
 ECHR 'V'
 EJMP 8
 ECHR 'D'
 ECHR 'O'
 ECHR 'C'
 ECHR 'K'
 ETOK 195
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'P'
 ECHR 'U'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR ' '
 ETWO 'O', 'N'
 EJMP 12
 ECHR 'P'
 EJMP 8
 ECHR 'D'
 ECHR 'O'
 ECHR 'C'
 ECHR 'K'
 ETOK 195
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'P'
 ECHR 'U'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR 'F'
 EJMP 12
 ECHR 'J'
 EJMP 8
 ECHR 'M'
 ECHR 'I'
 ECHR 'C'
 ECHR 'R'
 ECHR 'O'
 ECHR 'J'
 ECHR 'U'
 ECHR 'M'
 ECHR 'P'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '0'
 EJMP 2
 EJMP 8
 ECHR 'F'
 ECHR 'R'
 ETWO 'O', 'N'
 ECHR 'T'
 ECHR ' '
 ECHR 'V'
 ECHR 'I'
 ECHR 'E'
 ECHR 'W'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '1'
 EJMP 2
 EJMP 8
 ETWO 'R', 'E'
 ETWO 'A', 'R'
 ECHR ' '
 ECHR 'V'
 ECHR 'I'
 ECHR 'E'
 ECHR 'W'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '2'
 EJMP 2
 EJMP 8
 ETWO 'L', 'E'
 ECHR 'F'
 ECHR 'T'
 ECHR ' '
 ECHR 'V'
 ECHR 'I'
 ECHR 'E'
 ECHR 'W'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '3'
 EJMP 2
 EJMP 8
 ECHR 'R'
 ECHR 'I'
 ECHR 'G'
 ECHR 'H'
 ECHR 'T'
 ECHR ' '
 ECHR 'V'
 ECHR 'I'
 ECHR 'E'
 ECHR 'W'
 EJMP 12
 EQUB VE

 EJMP 12                \ Token 88:     "{cr}
 ECHR 'C'               \                COMBAT CONTROLS{crlf}
 ECHR 'O'               \                A{tab 6}FIRE LASER{cr}
 ECHR 'M'               \                T{tab 6}TARGET MISSILES{cr}
 ECHR 'B'               \                M{tab 6}FIRE MISSILES{cr}
 ETWO 'A', 'T'          \                U{tab 6}UNARM MISSILES{cr}
 ECHR ' '               \                E{tab 6}TRIGGER E.C.M.{cr}
 ECHR 'C'               \                {cr}
 ETWO 'O', 'N'          \                I.F.F. COLOUR CODES{crlf}
 ECHR 'T'               \                WHITE      OFFICIAL SHIP{cr}
 ECHR 'R'               \                BLUE       LEGAL SHIP{cr}
 ECHR 'O'               \                BLUE/{single cap}WHITE DEBRIS{cr}
 ECHR 'L'               \                WHITE/{single cap}RED  MISSILES{cr}"
 ECHR 'S'               \
 ETWO '-', '-'          \ Encoded as:   "{12}COMB<245> C<223>TROLS<215>A{8}FI
 ECHR 'A'               \                <242> <249><218>R{12}ENDIFT{8}T<238>G
 EJMP 8                 \                <221> MISS<220><237>{12}M{8}FI<242> MIS
 ECHR 'F'               \                S<220><237>{12}U{8}UN<238>M MISS<220>
 ECHR 'I'               \                <237>{12}E{8}TRIG<231>R E.C.M.{12}{12}I
 ETWO 'R', 'E'          \                .F.F. COL<217>R COD<237><215>WH<219>E
 ECHR ' '               \                      OFFICI<228> [207]{12}BLUE
 ETWO 'L', 'A'          \                       <229>G<228> [207]{12}BLUE/{19}
 ETWO 'S', 'E'          \                WH<219>E DEBRIS{12}BLUE/{19}<242>D
 ECHR 'R'               \                   N<223>-R<237>P<223>D<246>T{12}WH
 EJMP 12                \                <219>E/{19}<242>D  MISS<220><237>{12}"
 ECHR 'T'
 EJMP 8
 ECHR 'T'
 ETWO 'A', 'R'
 ECHR 'G'
 ETWO 'E', 'T'
 ECHR ' '
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ETWO 'I', 'L'
 ETWO 'E', 'S'
 EJMP 12
 ECHR 'M'
 EJMP 8
 ECHR 'F'
 ECHR 'I'
 ETWO 'R', 'E'
 ECHR ' '
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ETWO 'I', 'L'
 ETWO 'E', 'S'
 EJMP 12
 ECHR 'U'
 EJMP 8
 ECHR 'U'
 ECHR 'N'
 ETWO 'A', 'R'
 ECHR 'M'
 ECHR ' '
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ETWO 'I', 'L'
 ETWO 'E', 'S'
 EJMP 12
 ECHR 'E'
 EJMP 8
 ECHR 'T'
 ECHR 'R'
 ECHR 'I'
 ECHR 'G'
 ETWO 'G', 'E'
 ECHR 'R'
 ECHR ' '
 ECHR 'E'
 ECHR '.'
 ECHR 'C'
 ECHR '.'
 ECHR 'M'
 ECHR '.'
 EJMP 12
 EJMP 12
 ECHR 'I'
 ECHR '.'
 ECHR 'F'
 ECHR '.'
 ECHR 'F'
 ECHR '.'
 ECHR ' '
 ECHR 'C'
 ECHR 'O'
 ECHR 'L'
 ETWO 'O', 'U'
 ECHR 'R'
 ECHR ' '
 ECHR 'C'
 ECHR 'O'
 ECHR 'D'
 ETWO 'E', 'S'
 ETWO '-', '-'
 ECHR 'W'
 ECHR 'H'
 ETWO 'I', 'T'
 ECHR 'E'
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR 'F'
 ECHR 'I'
 ECHR 'C'
 ECHR 'I'
 ETWO 'A', 'L'
 ECHR ' '
 ETOK 207
 EJMP 12
 ECHR 'B'
 ECHR 'L'
 ECHR 'U'
 ECHR 'E'
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ETWO 'L', 'E'
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR ' '
 ETOK 207
 EJMP 12
 ECHR 'B'
 ECHR 'L'
 ECHR 'U'
 ECHR 'E'
 ECHR '/'
 EJMP 19
 ECHR 'W'
 ECHR 'H'
 ETWO 'I', 'T'
 ECHR 'E'
 ECHR ' '
 ECHR 'D'
 ECHR 'E'
 ECHR 'B'
 ECHR 'R'
 ECHR 'I'
 ECHR 'S'
 EJMP 12
 ECHR 'B'
 ECHR 'L'
 ECHR 'U'
 ECHR 'E'
 ECHR '/'
 EJMP 19
 ETWO 'R', 'E'
 ECHR 'D'
 ECHR ' '
 ECHR ' '
 ECHR ' '
 ECHR 'N'
 ETWO 'O', 'N'
 ECHR '-'
 ECHR 'R'
 ETWO 'E', 'S'
 ECHR 'P'
 ETWO 'O', 'N'
 ECHR 'D'
 ETWO 'E', 'N'
 ECHR 'T'
 EJMP 12
 ECHR 'W'
 ECHR 'H'
 ETWO 'I', 'T'
 ECHR 'E'
 ECHR '/'
 EJMP 19
 ETWO 'R', 'E'
 ECHR 'D'
 ECHR ' '
 ECHR ' '
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ETWO 'I', 'L'
 ETWO 'E', 'S'
 EJMP 12
 EQUB VE

 EJMP 12                \ Token 89:     "{cr}
 ECHR 'N'               \                NAVIGATION CONTROLS{crlf}
 ECHR 'A'               \                H{tab 6}HYPERSPACE JUMP{cr}
 ECHR 'V'               \                C-{single cap}H{tab 6}GALACTIC
 ECHR 'I'               \                HYPERSPACE JUMP
 ECHR 'G'               \                CURSOR KEYS{cr}
 ETWO 'A', 'T'          \                {tab 6}HYPERSPACE CURSOR CONTROL{cr}
 ECHR 'I'               \                D{tab 6}DISTANCE TO SYSTEM{cr}
 ETWO 'O', 'N'          \                O{tab 6}HOME CURSOR{cr}
 ECHR ' '               \                F{tab 6}FIND SYSTEM ({single cap}DOCKED
 ECHR 'C'               \                ){cr}
 ETWO 'O', 'N'          \                W{tab 6}FIND DESTINATION SYSTEM{cr}
 ECHR 'T'               \                {lower case}F4{sentence case}{tab 6}
 ECHR 'R'               \                GALACTIC MAP{cr}
 ECHR 'O'               \                {lower case}F5{sentence case}{tab 6}
 ECHR 'L'               \                SHORT RANGE MAP{cr}
 ECHR 'S'               \                {lower case}F6{sentence case}{tab 6}
 ETWO '-', '-'          \                DATA ON PLANET{cr}"
 ECHR 'H'               \
 EJMP 8                 \ Encoded as:   "{12}NAVIG<245>I<223> C<223>TROLS<215>H
 ECHR 'H'               \                {8}HYP<244>SPA<233> JUMP{12}C-{19}H{8}G
 ECHR 'Y'               \                <228>AC<251>C HYP<244>SPA<233> JUMP{12}
 ECHR 'P'               \                CUR<235>R KEYS{12}{8}HYP<244>SPA<233> C
 ETWO 'E', 'R'          \                UR<235>R C<223>TROL{12}D{8}<241><222>
 ECHR 'S'               \                <255><233>[201]SY<222>EM{12}O{8}HOME CU
 ECHR 'P'               \                R<235>R{12}F{8}F<240>D SY<222>EM ({19}
 ECHR 'A'               \                [205]){12}W{8}F<240>D DE<222><240><245>
 ETWO 'C', 'E'          \                I<223> SY<222>EM{12}{13}F4{2}{8}G<228>A
 ECHR ' '               \                C<251>C <239>P{12}{13}F5{2}{8}SH<253>T
 ECHR 'J'               \                 <248>N<231> <239>P{12}{13}F6{2}{8}D
 ECHR 'U'               \                <245>A <223> [145]{12}"
 ECHR 'M'
 ECHR 'P'
 EJMP 12
 ECHR 'C'
 ECHR '-'
 EJMP 19
 ECHR 'H'
 EJMP 8
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'C'
 ECHR ' '
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'J'
 ECHR 'U'
 ECHR 'M'
 ECHR 'P'
 EJMP 12
 ECHR 'C'
 ECHR 'U'
 ECHR 'R'
 ETWO 'S', 'O'
 ECHR 'R'
 ECHR ' '
 ECHR 'K'
 ECHR 'E'
 ECHR 'Y'
 ECHR 'S'
 EJMP 12
 EJMP 8
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'C'
 ECHR 'U'
 ECHR 'R'
 ETWO 'S', 'O'
 ECHR 'R'
 ECHR ' '
 ECHR 'C'
 ETWO 'O', 'N'
 ECHR 'T'
 ECHR 'R'
 ECHR 'O'
 ECHR 'L'
 EJMP 12
 ECHR 'D'
 EJMP 8
 ETWO 'D', 'I'
 ETWO 'S', 'T'
 ETWO 'A', 'N'
 ETWO 'C', 'E'
 ETOK 201
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 EJMP 12
 ECHR 'O'
 EJMP 8
 ECHR 'H'
 ECHR 'O'
 ECHR 'M'
 ECHR 'E'
 ECHR ' '
 ECHR 'C'
 ECHR 'U'
 ECHR 'R'
 ETWO 'S', 'O'
 ECHR 'R'
 EJMP 12
 ECHR 'F'
 EJMP 8
 ECHR 'F'
 ETWO 'I', 'N'
 ECHR 'D'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR ' '
 ECHR '('
 EJMP 19
 ETOK 205
 ECHR ')'
 EJMP 12
 ECHR 'W'
 EJMP 8
 ECHR 'F'
 ETWO 'I', 'N'
 ECHR 'D'
 ECHR ' '
 ECHR 'D'
 ECHR 'E'
 ETWO 'S', 'T'
 ETWO 'I', 'N'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '4'
 EJMP 2
 EJMP 8
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'C'
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'P'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '5'
 EJMP 2
 EJMP 8
 ECHR 'S'
 ECHR 'H'
 ETWO 'O', 'R'
 ECHR 'T'
 ECHR ' '
 ETWO 'R', 'A'
 ECHR 'N'
 ETWO 'G', 'E'
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'P'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '6'
 EJMP 2
 EJMP 8
 ECHR 'D'
 ETWO 'A', 'T'
 ECHR 'A'
 ECHR ' '
 ETWO 'O', 'N'
 ECHR ' '
 ETOK 145
 EJMP 12
 EQUB VE

 EJMP 12                \ Token 90:     "{cr}
 ECHR 'T'               \                TRADING CONTROLS{crlf}
 ETWO 'R', 'A'          \                {lower case}F0{sentence case}{tab 6}
 ECHR 'D'               \                LAUNCH FROM STATION{cr}
 ETOK 195               \                C-F0{sentence case}{tab 6}REMAIN DOCKED
 ECHR 'C'               \                {cr}
 ETWO 'O', 'N'          \                {lower case}F1{sentence case}{tab 6}BUY
 ECHR 'T'               \                CARGO{cr}
 ECHR 'R'               \                C-F1{tab 6}BUY SPECIAL CARGO{cr}
 ECHR 'O'               \                {lower case}F2{sentence case}{tab 6}
 ECHR 'L'               \                SELL CARGO{cr}
 ECHR 'S'               \                C-F2{tab 6}SELL EQUIPMENT{cr}
 ETWO '-', '-'          \                {lower case}F3{sentence case}{tab 6}
 EJMP 13                \                EQUIP SHIP{cr}
 ECHR 'F'               \                C-F3{tab 6}BUY SHIP{cr}
 ECHR '0'               \                C-F6{tab 6}ENCYCLOPEDIA{cr}
 EJMP 2                 \                {lower case}F7{sentence case}{tab 6}
 EJMP 8                 \                MARKET PRICES{cr}
 ETWO 'L', 'A'          \                {lower case}F8{sentence case}{tab 6}
 ECHR 'U'               \                STATUS PAGE{cr}
 ECHR 'N'               \                {lower case}F9{sentence case}{tab 6}
 ECHR 'C'               \                INVENTORY{cr}"
 ECHR 'H'               \
 ECHR ' '               \ Encoded as:   "{12}T<248>D[195]C<223>TROLS<215>{13}F0
 ECHR 'F'               \                {2}{8}<249>UNCH FROM <222><245>I<223>
 ECHR 'R'               \                {12}C-F0{2}{8}<242><239><240> [205]{12}
 ECHR 'O'               \                {13}F1{2}{8}BUY C<238>GO{12}C-F1{8}BUY
 ECHR 'M'               \                 SPECI<228> C<238>GO{12}{13}F2{2}{8}
 ECHR ' '               \                <218>LL C<238>GO{12}C-F2{8}<218>LL EQUI
 ETWO 'S', 'T'          \                PMENT{12}{13}F3{2}{8}EQUIP [207]{12}C-F
 ETWO 'A', 'T'          \                3{8}BUY [207]{12}C-F6{8}<246>CYC<224>P
 ECHR 'I'               \                <252>IA{12}{13}F7{2}{8}M<238>K<221> PRI
 ETWO 'O', 'N'          \                <233>S{12}{13}F8{2}{8}<222><245><236> P
 EJMP 12                \                A<231>{12}{13}F9{2}{8}<240>V<246>T<253>
 ECHR 'C'               \                Y{12}"
 ECHR '-'
 ECHR 'F'
 ECHR '0'
 EJMP 2
 EJMP 8
 ETWO 'R', 'E'
 ETWO 'M', 'A'
 ETWO 'I', 'N'
 ECHR ' '
 ETOK 205
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '1'
 EJMP 2
 EJMP 8
 ECHR 'B'
 ECHR 'U'
 ECHR 'Y'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'R'
 ECHR 'G'
 ECHR 'O'
 EJMP 12
 ECHR 'C'
 ECHR '-'
 ECHR 'F'
 ECHR '1'
 EJMP 8
 ECHR 'B'
 ECHR 'U'
 ECHR 'Y'
 ECHR ' '
 ECHR 'S'
 ECHR 'P'
 ECHR 'E'
 ECHR 'C'
 ECHR 'I'
 ETWO 'A', 'L'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'R'
 ECHR 'G'
 ECHR 'O'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '2'
 EJMP 2
 EJMP 8
 ETWO 'S', 'E'
 ECHR 'L'
 ECHR 'L'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'R'
 ECHR 'G'
 ECHR 'O'
 EJMP 12
 ECHR 'C'
 ECHR '-'
 ECHR 'F'
 ECHR '2'
 EJMP 8
 ETWO 'S', 'E'
 ECHR 'L'
 ECHR 'L'
 ECHR ' '
 ECHR 'E'
 ECHR 'Q'
 ECHR 'U'
 ECHR 'I'
 ECHR 'P'
 ECHR 'M'
 ECHR 'E'
 ECHR 'N'
 ECHR 'T'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '3'
 EJMP 2
 EJMP 8
 ECHR 'E'
 ECHR 'Q'
 ECHR 'U'
 ECHR 'I'
 ECHR 'P'
 ECHR ' '
 ETOK 207
 EJMP 12
 ECHR 'C'
 ECHR '-'
 ECHR 'F'
 ECHR '3'
 EJMP 8
 ECHR 'B'
 ECHR 'U'
 ECHR 'Y'
 ECHR ' '
 ETOK 207
 EJMP 12
 ECHR 'C'
 ECHR '-'
 ECHR 'F'
 ECHR '6'
 EJMP 8
 ETWO 'E', 'N'
 ECHR 'C'
 ECHR 'Y'
 ECHR 'C'
 ETWO 'L', 'O'
 ECHR 'P'
 ETWO 'E', 'D'
 ECHR 'I'
 ECHR 'A'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '7'
 EJMP 2
 EJMP 8
 ECHR 'M'
 ETWO 'A', 'R'
 ECHR 'K'
 ETWO 'E', 'T'
 ECHR ' '
 ECHR 'P'
 ECHR 'R'
 ECHR 'I'
 ETWO 'C', 'E'
 ECHR 'S'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '8'
 EJMP 2
 EJMP 8
 ETWO 'S', 'T'
 ETWO 'A', 'T'
 ETWO 'U', 'S'
 ECHR ' '
 ECHR 'P'
 ECHR 'A'
 ETWO 'G', 'E'
 EJMP 12
 EJMP 13
 ECHR 'F'
 ECHR '9'
 EJMP 2
 EJMP 8
 ETWO 'I', 'N'
 ECHR 'V'
 ETWO 'E', 'N'
 ECHR 'T'
 ETWO 'O', 'R'
 ECHR 'Y'
 EJMP 12
 EQUB VE

 ECHR 'F'               \ Token 91:     "FLIGHT"
 ECHR 'L'               \
 ECHR 'I'               \ Encoded as:   "FLIGHT"
 ECHR 'G'
 ECHR 'H'
 ECHR 'T'
 EQUB VE

 ECHR 'C'               \ Token 92:     "COMBAT"
 ECHR 'O'               \
 ECHR 'M'               \ Encoded as:   "COMB<245>"
 ECHR 'B'
 ETWO 'A', 'T'
 EQUB VE

 ECHR 'N'               \ Token 93:     "NAVIGATION"
 ECHR 'A'               \
 ECHR 'V'               \ Encoded as:   "NAVIG<245>I<223>"
 ECHR 'I'
 ECHR 'G'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 EQUB VE

 ECHR 'T'               \ Token 94:     "TRADING"
 ETWO 'R', 'A'          \
 ECHR 'D'               \ Encoded as:   "T<248>D<240>G"
 ETWO 'I', 'N'
 ECHR 'G'
 EQUB VE

 ECHR 'M'               \ Token 95:     "MISSILES"
 ECHR 'I'               \
 ECHR 'S'               \ Encoded as:   "MISS<220><237>"
 ECHR 'S'
 ETWO 'I', 'L'
 ETWO 'E', 'S'
 EQUB VE

 EJMP 1                 \ Token 96:     "{all caps}I.F.F.{lower case} SYSTEM"
 ECHR 'I'               \
 ECHR '.'               \ Encoded as:   "{1}I.F.F.{13} SY<222>EM"
 ECHR 'F'
 ECHR '.'
 ECHR 'F'
 ECHR '.'
 EJMP 13
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 EQUB VE

 EJMP 1                 \ Token 97:     "{all caps}E.C.M.{lower case} SYSTEM"
 ECHR 'E'               \
 ECHR '.'               \ Encoded as:   "{1}E.C.M.{13} SY<222>EM"
 ECHR 'C'
 ECHR '.'
 ECHR 'M'
 ECHR '.'
 EJMP 13
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 EQUB VE

 ECHR 'P'               \ Token 98:     "PULSE LASERS"
 ECHR 'U'               \
 ECHR 'L'               \ Encoded as:   "PUL<218> <249><218>RS"
 ETWO 'S', 'E'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 EQUB VE

 ETWO 'B', 'E'          \ Token 99:     "BEAM LASERS"
 ECHR 'A'               \
 ECHR 'M'               \ Encoded as:   "<247>AM <249><218>RS"
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 EQUB VE

 ECHR 'F'               \ Token 100:    "FUEL SCOOPS"
 ECHR 'U'               \
 ECHR 'E'               \ Encoded as:   "FUEL SCOOPS"
 ECHR 'L'
 ECHR ' '
 ECHR 'S'
 ECHR 'C'
 ECHR 'O'
 ECHR 'O'
 ECHR 'P'
 ECHR 'S'
 EQUB VE

 ETWO 'E', 'S'          \ Token 101:    "ESCAPE POD"
 ECHR 'C'               \
 ECHR 'A'               \ Encoded as:   "<237>CAPE POD"
 ECHR 'P'
 ECHR 'E'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'D'
 EQUB VE

 ECHR 'H'               \ Token 102:    "HYPERSPACE UNIT"
 ECHR 'Y'               \
 ECHR 'P'               \ Encoded as:   "HYP<244>SPA<233> UN<219>"
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'U'
 ECHR 'N'
 ETWO 'I', 'T'
 EQUB VE

 ETWO 'E', 'N'          \ Token 103:    "ENERGY UNIT"
 ETWO 'E', 'R'          \
 ECHR 'G'               \ Encoded as:   "<246><244>GY UN<219>"
 ECHR 'Y'
 ECHR ' '
 ECHR 'U'
 ECHR 'N'
 ETWO 'I', 'T'
 EQUB VE

 ECHR 'D'               \ Token 104:    "DOCKING COMPUTERS"
 ECHR 'O'               \
 ECHR 'C'               \ Encoded as:   "DOCK[195]COMPUT<244>S"
 ECHR 'K'
 ETOK 195
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'P'
 ECHR 'U'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'S'
 EQUB VE

 ECHR 'G'               \ Token 105:    "GALACTIC HYPERDRIVE"
 ETWO 'A', 'L'          \
 ECHR 'A'               \ Encoded as:   "G<228>AC<251>C HYP<244>[151]"
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'C'
 ECHR ' '
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ETOK 151
 EQUB VE

 ECHR 'M'               \ Token 106:    "MILITARY LASERS"
 ETWO 'I', 'L'          \
 ETWO 'I', 'T'          \ Encoded as:   "M<220><219><238>Y <249><218>RS"
 ETWO 'A', 'R'
 ECHR 'Y'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 EQUB VE

 ECHR 'M'               \ Token 107:    "MINING LASERS"
 ETWO 'I', 'N'          \
 ETOK 195               \ Encoded as:   "M<240>[195]<249><218>RS"
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 EQUB VE

 EJMP 14                \ Token 108:    "{justify}{single cap}SELF HOMING
 EJMP 19                \                MISSILES MAY BE BOUGHT AT ANY SYSTEM.
 ETWO 'S', 'E'          \                {crlf}
 ECHR 'L'               \                {single cap}BEFORE A MISSILE CAN BE
 ECHR 'F'               \                FIRED IT MUST BE LOCKED ONTO A TARGET.
 ECHR ' '               \                {crlf}
 ECHR 'H'               \                {single cap}WHEN FIRED, IT WILL HOME IN
 ECHR 'O'               \                TO THE TARGET UNLESS THE TARGET CAN
 ECHR 'M'               \                OUTMANOEUVRE THE MISSILE, SHOOT IT, OR
 ETOK 195               \                USE ELECTRONIC COUNTER MEASURES ON IT.
 ECHR 'M'               \                {cr}
 ECHR 'I'               \                {left align}"
 ECHR 'S'               \
 ECHR 'S'               \ Encoded as:   "{14}{19}<218>LF HOM[195]MISS<220><237>
 ETWO 'I', 'L'          \                 <239>Y <247> B<217>GHT <245> <255>Y SY
 ETWO 'E', 'S'          \                <222>EM.<215>{19}<247>FO<242>[208]MISS
 ECHR ' '               \                <220>E C<255> <247> FIR[196]<219> MU
 ETWO 'M', 'A'          \                <222> <247> <224>CK[196]<223>TO A T
 ECHR 'Y'               \                <238>G<221>.<215>{19}WH<246> FI<242>D,
 ECHR ' '               \                 <219> W<220>L HOME <240>[201][147]T
 ETWO 'B', 'E'          \                <238>G<221> UN<229>SS [147]T<238>G<221>
 ECHR ' '               \                 C<255> <217>T<239><227>EUV<242> [147]M
 ECHR 'B'               \                ISS<220>E, SHOOT <219>, <253> U<218> E
 ETWO 'O', 'U'          \                <229>CTR<223>IC C<217>NT<244> MEASUR
 ECHR 'G'               \                <237> <223> <219>[177]"
 ECHR 'H'
 ECHR 'T'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ETWO 'A', 'N'
 ECHR 'Y'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ETWO 'B', 'E'
 ECHR 'F'
 ECHR 'O'
 ETWO 'R', 'E'
 ETOK 208
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ETWO 'I', 'L'
 ECHR 'E'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'N'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'F'
 ECHR 'I'
 ECHR 'R'
 ETOK 196
 ETWO 'I', 'T'
 ECHR ' '
 ECHR 'M'
 ECHR 'U'
 ETWO 'S', 'T'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ETWO 'L', 'O'
 ECHR 'C'
 ECHR 'K'
 ETOK 196
 ETWO 'O', 'N'
 ECHR 'T'
 ECHR 'O'
 ECHR ' '
 ECHR 'A'
 ECHR ' '
 ECHR 'T'
 ETWO 'A', 'R'
 ECHR 'G'
 ETWO 'E', 'T'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'W'
 ECHR 'H'
 ETWO 'E', 'N'
 ECHR ' '
 ECHR 'F'
 ECHR 'I'
 ETWO 'R', 'E'
 ECHR 'D'
 ECHR ','
 ECHR ' '
 ETWO 'I', 'T'
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ECHR 'H'
 ECHR 'O'
 ECHR 'M'
 ECHR 'E'
 ECHR ' '
 ETWO 'I', 'N'
 ETOK 201
 ETOK 147
 ECHR 'T'
 ETWO 'A', 'R'
 ECHR 'G'
 ETWO 'E', 'T'
 ECHR ' '
 ECHR 'U'
 ECHR 'N'
 ETWO 'L', 'E'
 ECHR 'S'
 ECHR 'S'
 ECHR ' '
 ETOK 147
 ECHR 'T'
 ETWO 'A', 'R'
 ECHR 'G'
 ETWO 'E', 'T'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'N'
 ECHR ' '
 ETWO 'O', 'U'
 ECHR 'T'
 ETWO 'M', 'A'
 ETWO 'N', 'O'
 ECHR 'E'
 ECHR 'U'
 ECHR 'V'
 ETWO 'R', 'E'
 ECHR ' '
 ETOK 147
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ETWO 'I', 'L'
 ECHR 'E'
 ECHR ','
 ECHR ' '
 ECHR 'S'
 ECHR 'H'
 ECHR 'O'
 ECHR 'O'
 ECHR 'T'
 ECHR ' '
 ETWO 'I', 'T'
 ECHR ','
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'U'
 ETWO 'S', 'E'
 ECHR ' '
 ECHR 'E'
 ETWO 'L', 'E'
 ECHR 'C'
 ECHR 'T'
 ECHR 'R'
 ETWO 'O', 'N'
 ECHR 'I'
 ECHR 'C'
 ECHR ' '
 ECHR 'C'
 ETWO 'O', 'U'
 ECHR 'N'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR ' '
 ECHR 'M'
 ECHR 'E'
 ECHR 'A'
 ECHR 'S'
 ECHR 'U'
 ECHR 'R'
 ETWO 'E', 'S'
 ECHR ' '
 ETWO 'O', 'N'
 ECHR ' '
 ETWO 'I', 'T'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 109:    "{justify}{single cap}AN IDENTIFICATION
 EJMP 19                \                FRIEND OR FOE SYSTEM CAN BE OBTAINED AT
 ETWO 'A', 'N'          \                TECH LEVEL 2 OR ABOVE.{crlf}
 ECHR ' '               \                {single cap}AN {all caps}I.F.F.{lower
 ECHR 'I'               \                case} SYSTEM WILL DISPLAY DIFFERENT
 ECHR 'D'               \                TYPES OF OBJECT IN DIFFERENT COLOURS ON
 ETWO 'E', 'N'          \                THE RADAR DISPLAY.{crlf}
 ETWO 'T', 'I'          \                {single cap}SEE {single cap}CONTROLS
 ECHR 'F'               \                ({single cap}COMBAT).{cr}
 ECHR 'I'               \                {left align}"
 ECHR 'C'               \
 ETWO 'A', 'T'          \ Encoded as:   "{14}{19}<255> ID<246><251>FIC<245>I
 ECHR 'I'               \                <223> FRI<246>D <253> FOE SY<222>EM C
 ETWO 'O', 'N'          \                <255> <247> OBTA<240>[196]<245> TECH
 ECHR ' '               \                 <229><250>L 2 <253> <216>O<250>.<215>
 ECHR 'F'               \                {19}<255> {1}I.F.F.{13} SY<222>EM W
 ECHR 'R'               \                <220>L <241>SP<249>Y <241>FFE<242>NT TY
 ECHR 'I'               \                P<237> OF OBJECT <240> <241>FFE<242>NT
 ETWO 'E', 'N'          \                 COL<217>RS <223> [147]<248>D<238>
 ECHR 'D'               \                 <241>SP<249>Y.<215>{19}<218>E {19}C
 ECHR ' '               \                <223>TROLS ({19}COMB<245>)[177]"
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'F'
 ECHR 'O'
 ECHR 'E'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'N'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'O'
 ECHR 'B'
 ECHR 'T'
 ECHR 'A'
 ETWO 'I', 'N'
 ETOK 196
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '2'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'A', 'B'
 ECHR 'O'
 ETWO 'V', 'E'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ETWO 'A', 'N'
 ECHR ' '
 EJMP 1
 ECHR 'I'
 ECHR '.'
 ECHR 'F'
 ECHR '.'
 ECHR 'F'
 ECHR '.'
 EJMP 13
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'D', 'I'
 ECHR 'S'
 ECHR 'P'
 ETWO 'L', 'A'
 ECHR 'Y'
 ECHR ' '
 ETWO 'D', 'I'
 ECHR 'F'
 ECHR 'F'
 ECHR 'E'
 ETWO 'R', 'E'
 ECHR 'N'
 ECHR 'T'
 ECHR ' '
 ECHR 'T'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'O'
 ECHR 'B'
 ECHR 'J'
 ECHR 'E'
 ECHR 'C'
 ECHR 'T'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR ' '
 ETWO 'D', 'I'
 ECHR 'F'
 ECHR 'F'
 ECHR 'E'
 ETWO 'R', 'E'
 ECHR 'N'
 ECHR 'T'
 ECHR ' '
 ECHR 'C'
 ECHR 'O'
 ECHR 'L'
 ETWO 'O', 'U'
 ECHR 'R'
 ECHR 'S'
 ECHR ' '
 ETWO 'O', 'N'
 ECHR ' '
 ETOK 147
 ETWO 'R', 'A'
 ECHR 'D'
 ETWO 'A', 'R'
 ECHR ' '
 ETWO 'D', 'I'
 ECHR 'S'
 ECHR 'P'
 ETWO 'L', 'A'
 ECHR 'Y'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ETWO 'S', 'E'
 ECHR 'E'
 ECHR ' '
 EJMP 19
 ECHR 'C'
 ETWO 'O', 'N'
 ECHR 'T'
 ECHR 'R'
 ECHR 'O'
 ECHR 'L'
 ECHR 'S'
 ECHR ' '
 ECHR '('
 EJMP 19
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'B'
 ETWO 'A', 'T'
 ECHR ')'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 110:    "{justify}{single cap}AN ELECTRONIC
 EJMP 19                \                COUNTER MEASURES SYSTEM MAY BE BOUGHT
 ETWO 'A', 'N'          \                AT ANY SYSTEM OF TECH LEVEL 3 OR
 ECHR ' '               \                HIGHER.{crlf}
 ECHR 'E'               \                {single cap}WHEN ACTIVATED, THE {all
 ETWO 'L', 'E'          \                caps}E.C.M.{lower case} SYSTEM WILL
 ECHR 'C'               \                DISRUPT THE GUIDANCE SYSTEMS OF ALL
 ECHR 'T'               \                MISSILES IN THE VICINITY, MAKING THEM
 ECHR 'R'               \                SELF DESTRUCT.{cr}
 ETWO 'O', 'N'          \                {left align}"
 ECHR 'I'               \
 ECHR 'C'               \ Encoded as:   "{14}{19}<255> E<229>CTR<223>IC C<217>NT
 ECHR ' '               \                <244> MEASUR<237> SY<222>EM <239>Y
 ECHR 'C'               \                 <247> B<217>GHT <245> <255>Y SY<222>EM
 ETWO 'O', 'U'          \                 OF TECH <229><250>L 3 <253> HIGH<244>.
 ECHR 'N'               \                <215>{19}WH<246> AC<251>V<245><252>,
 ECHR 'T'               \                 [147]{1}E.C.M.{13} SY<222>EM W<220>L
 ETWO 'E', 'R'          \                 <241>SRUPT [147]GUID<255><233> SY<222>
 ECHR ' '               \                EMS OF <228>L MISS<220><237> <240>
 ECHR 'M'               \                 [147]VIC<240><219>Y, <239>K[195]<226>E
 ECHR 'E'               \                M <218>LF DE<222>RUCT[177]"
 ECHR 'A'
 ECHR 'S'
 ECHR 'U'
 ECHR 'R'
 ETWO 'E', 'S'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'Y'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'B'
 ETWO 'O', 'U'
 ECHR 'G'
 ECHR 'H'
 ECHR 'T'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ETWO 'A', 'N'
 ECHR 'Y'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '3'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'H'
 ECHR 'I'
 ECHR 'G'
 ECHR 'H'
 ETWO 'E', 'R'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'W'
 ECHR 'H'
 ETWO 'E', 'N'
 ECHR ' '
 ECHR 'A'
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'V'
 ETWO 'A', 'T'
 ETWO 'E', 'D'
 ECHR ','
 ECHR ' '
 ETOK 147
 EJMP 1
 ECHR 'E'
 ECHR '.'
 ECHR 'C'
 ECHR '.'
 ECHR 'M'
 ECHR '.'
 EJMP 13
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'D', 'I'
 ECHR 'S'
 ECHR 'R'
 ECHR 'U'
 ECHR 'P'
 ECHR 'T'
 ECHR ' '
 ETOK 147
 ECHR 'G'
 ECHR 'U'
 ECHR 'I'
 ECHR 'D'
 ETWO 'A', 'N'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ETWO 'A', 'L'
 ECHR 'L'
 ECHR ' '
 ECHR 'M'
 ECHR 'I'
 ECHR 'S'
 ECHR 'S'
 ETWO 'I', 'L'
 ETWO 'E', 'S'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR ' '
 ETOK 147
 ECHR 'V'
 ECHR 'I'
 ECHR 'C'
 ETWO 'I', 'N'
 ETWO 'I', 'T'
 ECHR 'Y'
 ECHR ','
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'K'
 ETOK 195
 ETWO 'T', 'H'
 ECHR 'E'
 ECHR 'M'
 ECHR ' '
 ETWO 'S', 'E'
 ECHR 'L'
 ECHR 'F'
 ECHR ' '
 ECHR 'D'
 ECHR 'E'
 ETWO 'S', 'T'
 ECHR 'R'
 ECHR 'U'
 ECHR 'C'
 ECHR 'T'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 111:    "{justify}{single cap}PULSE LASERS ARE
 EJMP 19                \                FOR SALE AT TECH LEVEL 4 OR ABOVE.
 ECHR 'P'               \                {crlf}
 ECHR 'U'               \                {single cap}PULSE LASERS FIRE
 ECHR 'L'               \                INTERMITTENT LASER BEAMS.{cr}
 ETWO 'S', 'E'          \                {left align}"
 ECHR ' '               \
 ETWO 'L', 'A'          \ Encoded as:   "{14}{19}PUL<218> <249><218>RS <238>E
 ETWO 'S', 'E'          \                 F<253> S<228>E <245> TECH <229><250>L
 ECHR 'R'               \                 4 <253> <216>O<250>.<215>{19}PUL<218>
 ECHR 'S'               \                 <249><218>RS FI<242> <240>T<244>M<219>
 ECHR ' '               \                T<246>T <249><218>R <247>AMS[177]"
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'S'
 ETWO 'A', 'L'
 ECHR 'E'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '4'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'A', 'B'
 ECHR 'O'
 ETWO 'V', 'E'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'P'
 ECHR 'U'
 ECHR 'L'
 ETWO 'S', 'E'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 ECHR ' '
 ECHR 'F'
 ECHR 'I'
 ETWO 'R', 'E'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'M'
 ETWO 'I', 'T'
 ECHR 'T'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR 'A'
 ECHR 'M'
 ECHR 'S'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 112:    "{justify}{single cap}BEAM LASERS ARE
 EJMP 19                \                AVAILABLE AT SYSTEMS OF TECH LEVEL 5 OR
 ETWO 'B', 'E'          \                HIGHER.{crlf}
 ECHR 'A'               \                {single cap}BEAM LASERS FIRE CONTINUOUS
 ECHR 'M'               \                LASER STRANDS, WITH MANY STRANDS IN
 ECHR ' '               \                PARALLEL.{crlf}
 ETWO 'L', 'A'          \                {single cap}BEAM LASERS OVERHEAT MORE
 ETWO 'S', 'E'          \                RAPIDLY THAN PULSE LASERS.{cr}
 ECHR 'R'               \                {left align}"
 ECHR 'S'               \
 ECHR ' '               \ Encoded as:   "{14}{19}<247>AM <249><218>RS <238>E AVA
 ETWO 'A', 'R'          \                <220><216><229> <245> SY<222>EMS OF TEC
 ECHR 'E'               \                H <229><250>L 5 <253> HIGH<244>.<215>
 ECHR ' '               \                {19}<247>AM <249><218>RS FI<242> C<223>
 ECHR 'A'               \                <251><225><217>S <249><218>R <222><248>
 ECHR 'V'               \                NDS, W<219>H <239>NY <222><248>NDS
 ECHR 'A'               \                 <240> P<238><228><229>L.<215>{19}<247>
 ETWO 'I', 'L'          \                AM <249><218>RS OV<244>HE<245> MO<242>
 ETWO 'A', 'B'          \                 <248>PIDLY <226><255> PUL<218> <249>
 ETWO 'L', 'E'          \                <218>RS[177]"
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '5'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'H'
 ECHR 'I'
 ECHR 'G'
 ECHR 'H'
 ETWO 'E', 'R'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ETWO 'B', 'E'
 ECHR 'A'
 ECHR 'M'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 ECHR ' '
 ECHR 'F'
 ECHR 'I'
 ETWO 'R', 'E'
 ECHR ' '
 ECHR 'C'
 ETWO 'O', 'N'
 ETWO 'T', 'I'
 ETWO 'N', 'U'
 ETWO 'O', 'U'
 ECHR 'S'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR ' '
 ETWO 'S', 'T'
 ETWO 'R', 'A'
 ECHR 'N'
 ECHR 'D'
 ECHR 'S'
 ECHR ','
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'T'
 ECHR 'H'
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'N'
 ECHR 'Y'
 ECHR ' '
 ETWO 'S', 'T'
 ETWO 'R', 'A'
 ECHR 'N'
 ECHR 'D'
 ECHR 'S'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR ' '
 ECHR 'P'
 ETWO 'A', 'R'
 ETWO 'A', 'L'
 ETWO 'L', 'E'
 ECHR 'L'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ETWO 'B', 'E'
 ECHR 'A'
 ECHR 'M'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'V'
 ETWO 'E', 'R'
 ECHR 'H'
 ECHR 'E'
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'M'
 ECHR 'O'
 ETWO 'R', 'E'
 ECHR ' '
 ETWO 'R', 'A'
 ECHR 'P'
 ECHR 'I'
 ECHR 'D'
 ECHR 'L'
 ECHR 'Y'
 ECHR ' '
 ETWO 'T', 'H'
 ETWO 'A', 'N'
 ECHR ' '
 ECHR 'P'
 ECHR 'U'
 ECHR 'L'
 ETWO 'S', 'E'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 113:    "{justify}{single cap}FUEL SCOOPS ENABLE
 EJMP 19                \                A SHIP TO OBTAIN FREE HYPERSPACE FUEL
 ECHR 'F'               \                BY 'SUN-SKIMMING' - FLYING CLOSE TO THE
 ECHR 'U'               \                SUN.{crlf}
 ECHR 'E'               \                {single cap}FUEL SCOOPS CAN ALSO BE
 ECHR 'L'               \                USED TO PICK UP SPACE DEBRIS, SUCH AS
 ECHR ' '               \                CARGO BARRELS OR ASTEROID FRAGMENTS.
 ECHR 'S'               \                {crlf}
 ECHR 'C'               \                {single cap}FUEL SCOOPS ARE AVAILABLE
 ECHR 'O'               \                FROM SYSTEMS OF TECH LEVEL 6 OR ABOVE.
 ECHR 'O'               \                {cr}
 ECHR 'P'               \                {left align}"
 ECHR 'S'               \
 ECHR ' '               \ Encoded as:   "{14}{19}FUEL SCOOPS <246><216><229>
 ETWO 'E', 'N'          \                [208][207][201]OBTA<240> F<242>E HYP
 ETWO 'A', 'B'          \                <244>SPA<233> FUEL BY 'SUN-SKIMM<240>G'
 ETWO 'L', 'E'          \                 - FLY[195]C<224><218>[201][147]SUN.
 ETOK 208               \                <215>{19}FUEL SCOOPS C<255> <228><235>
 ETOK 207               \                 <247> <236>[196]TO PICK UP SPA<233> DE
 ETOK 201               \                BRIS, SUCH AS C<238>GO B<238><242>LS
 ECHR 'O'               \                 <253> A<222><244>OID F<248>GM<246>TS.
 ECHR 'B'               \                <215>{19}FUEL SCOOPS <238>E AVA<220>
 ECHR 'T'               \                <216><229> FROM SY<222>EMS OF TECH
 ECHR 'A'               \                 <229><250>L 6 <253> <216>O<250>[177]"
 ETWO 'I', 'N'
 ECHR ' '
 ECHR 'F'
 ETWO 'R', 'E'
 ECHR 'E'
 ECHR ' '
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'F'
 ECHR 'U'
 ECHR 'E'
 ECHR 'L'
 ECHR ' '
 ECHR 'B'
 ECHR 'Y'
 ECHR ' '
 ECHR '`'
 ECHR 'S'
 ECHR 'U'
 ECHR 'N'
 ECHR '-'
 ECHR 'S'
 ECHR 'K'
 ECHR 'I'
 ECHR 'M'
 ECHR 'M'
 ETWO 'I', 'N'
 ECHR 'G'
 ECHR '`'
 ECHR ' '
 ECHR '-'
 ECHR ' '
 ECHR 'F'
 ECHR 'L'
 ECHR 'Y'
 ETOK 195
 ECHR 'C'
 ETWO 'L', 'O'
 ETWO 'S', 'E'
 ETOK 201
 ETOK 147
 ECHR 'S'
 ECHR 'U'
 ECHR 'N'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'F'
 ECHR 'U'
 ECHR 'E'
 ECHR 'L'
 ECHR ' '
 ECHR 'S'
 ECHR 'C'
 ECHR 'O'
 ECHR 'O'
 ECHR 'P'
 ECHR 'S'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'N'
 ECHR ' '
 ETWO 'A', 'L'
 ETWO 'S', 'O'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ETWO 'U', 'S'
 ETOK 196
 ECHR 'T'
 ECHR 'O'
 ECHR ' '
 ECHR 'P'
 ECHR 'I'
 ECHR 'C'
 ECHR 'K'
 ECHR ' '
 ECHR 'U'
 ECHR 'P'
 ECHR ' '
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'D'
 ECHR 'E'
 ECHR 'B'
 ECHR 'R'
 ECHR 'I'
 ECHR 'S'
 ECHR ','
 ECHR ' '
 ECHR 'S'
 ECHR 'U'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ECHR 'A'
 ECHR 'S'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'R'
 ECHR 'G'
 ECHR 'O'
 ECHR ' '
 ECHR 'B'
 ETWO 'A', 'R'
 ETWO 'R', 'E'
 ECHR 'L'
 ECHR 'S'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'A'
 ETWO 'S', 'T'
 ETWO 'E', 'R'
 ECHR 'O'
 ECHR 'I'
 ECHR 'D'
 ECHR ' '
 ECHR 'F'
 ETWO 'R', 'A'
 ECHR 'G'
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR 'S'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'F'
 ECHR 'U'
 ECHR 'E'
 ECHR 'L'
 ECHR ' '
 ECHR 'S'
 ECHR 'C'
 ECHR 'O'
 ECHR 'O'
 ECHR 'P'
 ECHR 'S'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ECHR 'A'
 ECHR 'V'
 ECHR 'A'
 ETWO 'I', 'L'
 ETWO 'A', 'B'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '6'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'A', 'B'
 ECHR 'O'
 ETWO 'V', 'E'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 114:    "{justify}{single cap}AN ESCAPE POD IS
 EJMP 19                \                AN ESSENTIAL PIECE OF EQUIPMENT FOR
 ETWO 'A', 'N'          \                MOST SPACESHIPS.{crlf}
 ECHR ' '               \                {single cap}WHEN EJECTED, THE CAPSULE
 ETWO 'E', 'S'          \                WILL BE TRACKED TO THE NEAREST SPACE
 ECHR 'C'               \                STATION.{crlf}
 ECHR 'A'               \                {single cap}MOST ESCAPE PODS COME WITH
 ECHR 'P'               \                INSURANCE POLICIES TO REPLACE THE SHIP
 ECHR 'E'               \                AND EQUIPMENT.{crlf}
 ECHR ' '               \                {single cap}PENALTIES FOR INTERFERING
 ECHR 'P'               \                WITH ESCAPE PODS ARE SEVERE IN MOST
 ECHR 'O'               \                PLANETARY SYSTEMS.{crlf}
 ECHR 'D'               \                {single cap}ESCAPE PODS MAY BE BOUGHT
 ETOK 202               \                AT SYSTEMS OF TECH LEVEL 7 OR HIGHER.
 ETWO 'A', 'N'          \                {cr}
 ECHR ' '               \                {left align}"
 ETWO 'E', 'S'          \
 ETWO 'S', 'E'          \ Encoded as:   "{14}{19}<255> <237>CAPE POD[202]<255>
 ECHR 'N'               \                 <237><218>N<251><228> PIE<233> OF EQUI
 ETWO 'T', 'I'          \                PM<246>T F<253> MO<222> SPA<233>[207]S.
 ETWO 'A', 'L'          \                <215>{19}WH<246> EJECT<252>, [147]CAPSU
 ECHR ' '               \                <229> W<220>L <247> T<248>CK[196]TO
 ECHR 'P'               \                 [147]NE<238>E<222> SPA<233> <222><245>
 ECHR 'I'               \                I<223>.<215>{19}MO<222> <237>CAPE PODS
 ECHR 'E'               \                 COME W<219>H <240>SU<248>N<233> POLICI
 ETWO 'C', 'E'          \                <237>[201]<242>P<249><233> [147][207]
 ECHR ' '               \                [178]EQUIPM<246>T.<215>{19}P<246><228>
 ECHR 'O'               \                <251><237> F<253> <240>T<244>F<244>
 ECHR 'F'               \                [195]W<219>H <237>CAPE PODS <238>E
 ECHR ' '               \                <218><250><242> <240> MO<222> [145]
 ECHR 'E'               \                <238>Y SY<222>EMS.<215>{19}<237>CAPE PO
 ECHR 'Q'               \                DS <239>Y <247> B<217>GHT <245> SY<222>
 ECHR 'U'               \                EMS OF TECH <229><250>L 7 <253> HIGH
 ECHR 'I'               \                <244>[177]"
 ECHR 'P'
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'M'
 ECHR 'O'
 ETWO 'S', 'T'
 ECHR ' '
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ETOK 207
 ECHR 'S'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'W'
 ECHR 'H'
 ETWO 'E', 'N'
 ECHR ' '
 ECHR 'E'
 ECHR 'J'
 ECHR 'E'
 ECHR 'C'
 ECHR 'T'
 ETWO 'E', 'D'
 ECHR ','
 ECHR ' '
 ETOK 147
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'S'
 ECHR 'U'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'T'
 ETWO 'R', 'A'
 ECHR 'C'
 ECHR 'K'
 ETOK 196
 ECHR 'T'
 ECHR 'O'
 ECHR ' '
 ETOK 147
 ECHR 'N'
 ECHR 'E'
 ETWO 'A', 'R'
 ECHR 'E'
 ETWO 'S', 'T'
 ECHR ' '
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ETWO 'S', 'T'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'M'
 ECHR 'O'
 ETWO 'S', 'T'
 ECHR ' '
 ETWO 'E', 'S'
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'E'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'D'
 ECHR 'S'
 ECHR ' '
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'E'
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'T'
 ECHR 'H'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR 'S'
 ECHR 'U'
 ETWO 'R', 'A'
 ECHR 'N'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'L'
 ECHR 'I'
 ECHR 'C'
 ECHR 'I'
 ETWO 'E', 'S'
 ETOK 201
 ETWO 'R', 'E'
 ECHR 'P'
 ETWO 'L', 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ETOK 147
 ETOK 207
 ETOK 178
 ECHR 'E'
 ECHR 'Q'
 ECHR 'U'
 ECHR 'I'
 ECHR 'P'
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'P'
 ETWO 'E', 'N'
 ETWO 'A', 'L'
 ETWO 'T', 'I'
 ETWO 'E', 'S'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'F'
 ETWO 'E', 'R'
 ETOK 195
 ECHR 'W'
 ETWO 'I', 'T'
 ECHR 'H'
 ECHR ' '
 ETWO 'E', 'S'
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'E'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'D'
 ECHR 'S'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ETWO 'S', 'E'
 ETWO 'V', 'E'
 ETWO 'R', 'E'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR ' '
 ECHR 'M'
 ECHR 'O'
 ETWO 'S', 'T'
 ECHR ' '
 ETOK 145
 ETWO 'A', 'R'
 ECHR 'Y'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR 'S'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ETWO 'E', 'S'
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'E'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'D'
 ECHR 'S'
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'Y'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'B'
 ETWO 'O', 'U'
 ECHR 'G'
 ECHR 'H'
 ECHR 'T'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '7'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'H'
 ECHR 'I'
 ECHR 'G'
 ECHR 'H'
 ETWO 'E', 'R'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 115:    "{justify}{single cap}A RECENT
 EJMP 19                \                INVENTION, THE HYPERSPACE UNIT IS AN
 ECHR 'A'               \                ALTERNATIVE TO THE ESCAPE POD FOR MANY
 ECHR ' '               \                TRADERS.{crlf}
 ETWO 'R', 'E'          \                {single cap}WHEN TRIGGERED, THE
 ETWO 'C', 'E'          \                HYPERSPACE UNIT WILL USE ITS POWER IN
 ECHR 'N'               \                EXECUTING A HYPERJUMP AWAY FROM THE
 ECHR 'T'               \                CURRENT POSITION.{crlf}
 ECHR ' '               \                {single cap}UNFORTUNATELY, BECAUSE THE
 ETWO 'I', 'N'          \                HYPERJUMP IS INSTANTANEOUS, THERE IS NO
 ECHR 'V'               \                CONTROL OF THE DESTINATION POSITION.
 ETWO 'E', 'N'          \                {crlf}
 ETWO 'T', 'I'          \                {single cap}A HYPERSPACE UNIT IS
 ETWO 'O', 'N'          \                AVAILABLE AT TECH LEVEL 8 OR ABOVE.{cr}
 ECHR ','               \                {left align}"
 ECHR ' '               \
 ETOK 147               \ Encoded as:   "{14}{19}A <242><233>NT <240>V<246><251>
 ECHR 'H'               \                <223>, [147]HYP<244>SPA<233> UN<219>
 ECHR 'Y'               \                [202]<255> <228>T<244>N<245>I<250> TO
 ECHR 'P'               \                 [147]<237>CAPE POD F<253> <239>NY T
 ETWO 'E', 'R'          \                <248>D<244>S.<215>{19}WH<246> TRIG<231>
 ECHR 'S'               \                <242>D, [147]HYP<244>SPA<233> UN<219> W
 ECHR 'P'               \                <220>L U<218> <219>S POW<244> <240> E
 ECHR 'A'               \                <230>CUT[195]A HYP<244>JUMP AWAY FROM
 ETWO 'C', 'E'          \                 [147]CUR<242>NT POS<219>I<223>.<215>
 ECHR ' '               \                {19}UNF<253>TUN<245>ELY, <247>CAU<218>
 ECHR 'U'               \                 [147]HYP<244>JUMP[202]<240><222><255>T
 ECHR 'N'               \                <255>E<217>S, <226>E<242>[202]<227> C
 ETWO 'I', 'T'          \                <223>TROL OF [147]DE<222><240><245>I
 ETOK 202               \                <223> POS<219>I<223>.<215>{19}A HYP
 ETWO 'A', 'N'          \                <244>SPA<233> UN<219>[202]AVA<220><216>
 ECHR ' '               \                <229> <245> TECH <229><250>L 8 <253>
 ETWO 'A', 'L'          \                 <216>O<250>[177]"
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'N'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'V', 'E'
 ECHR ' '
 ECHR 'T'
 ECHR 'O'
 ECHR ' '
 ETOK 147
 ETWO 'E', 'S'
 ECHR 'C'
 ECHR 'A'
 ECHR 'P'
 ECHR 'E'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'D'
 ECHR ' '
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'M', 'A'
 ECHR 'N'
 ECHR 'Y'
 ECHR ' '
 ECHR 'T'
 ETWO 'R', 'A'
 ECHR 'D'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'W'
 ECHR 'H'
 ETWO 'E', 'N'
 ECHR ' '
 ECHR 'T'
 ECHR 'R'
 ECHR 'I'
 ECHR 'G'
 ETWO 'G', 'E'
 ETWO 'R', 'E'
 ECHR 'D'
 ECHR ','
 ECHR ' '
 ETOK 147
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'U'
 ECHR 'N'
 ETWO 'I', 'T'
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ECHR 'U'
 ETWO 'S', 'E'
 ECHR ' '
 ETWO 'I', 'T'
 ECHR 'S'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'W'
 ETWO 'E', 'R'
 ECHR ' '
 ETWO 'I', 'N'
 ECHR ' '
 ECHR 'E'
 ETWO 'X', 'E'
 ECHR 'C'
 ECHR 'U'
 ECHR 'T'
 ETOK 195
 ECHR 'A'
 ECHR ' '
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'J'
 ECHR 'U'
 ECHR 'M'
 ECHR 'P'
 ECHR ' '
 ECHR 'A'
 ECHR 'W'
 ECHR 'A'
 ECHR 'Y'
 ECHR ' '
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ETOK 147
 ECHR 'C'
 ECHR 'U'
 ECHR 'R'
 ETWO 'R', 'E'
 ECHR 'N'
 ECHR 'T'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'S'
 ETWO 'I', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'U'
 ECHR 'N'
 ECHR 'F'
 ETWO 'O', 'R'
 ECHR 'T'
 ECHR 'U'
 ECHR 'N'
 ETWO 'A', 'T'
 ECHR 'E'
 ECHR 'L'
 ECHR 'Y'
 ECHR ','
 ECHR ' '
 ETWO 'B', 'E'
 ECHR 'C'
 ECHR 'A'
 ECHR 'U'
 ETWO 'S', 'E'
 ECHR ' '
 ETOK 147
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'J'
 ECHR 'U'
 ECHR 'M'
 ECHR 'P'
 ETOK 202
 ETWO 'I', 'N'
 ETWO 'S', 'T'
 ETWO 'A', 'N'
 ECHR 'T'
 ETWO 'A', 'N'
 ECHR 'E'
 ETWO 'O', 'U'
 ECHR 'S'
 ECHR ','
 ECHR ' '
 ETWO 'T', 'H'
 ECHR 'E'
 ETWO 'R', 'E'
 ETOK 202
 ETWO 'N', 'O'
 ECHR ' '
 ECHR 'C'
 ETWO 'O', 'N'
 ECHR 'T'
 ECHR 'R'
 ECHR 'O'
 ECHR 'L'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ETOK 147
 ECHR 'D'
 ECHR 'E'
 ETWO 'S', 'T'
 ETWO 'I', 'N'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'S'
 ETWO 'I', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'A'
 ECHR ' '
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR 'P'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'U'
 ECHR 'N'
 ETWO 'I', 'T'
 ETOK 202
 ECHR 'A'
 ECHR 'V'
 ECHR 'A'
 ETWO 'I', 'L'
 ETWO 'A', 'B'
 ETWO 'L', 'E'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '8'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ETWO 'A', 'B'
 ECHR 'O'
 ETWO 'V', 'E'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 116:    "{justify}{single cap}AN ENERGY UNIT
 EJMP 19                \                INCREASES THE RATE OF RECHARGING OF THE
 ETWO 'A', 'N'          \                ENERGY BANKS FROM SURFACE RADIATION
 ECHR ' '               \                ABSORPTION.{crlf}
 ETWO 'E', 'N'          \                {single cap}ENERGY UNITS ARE AVAILABLE
 ETWO 'E', 'R'          \                FROM TECH LEVEL 9 UPWARDS.{cr}
 ECHR 'G'               \                {left align}"
 ECHR 'Y'               \
 ECHR ' '               \ Encoded as:   "{14}{19}<255> <246><244>GY UN<219>
 ECHR 'U'               \                 <240>C<242>A<218>S [147]R<245>E OF
 ECHR 'N'               \                 <242>CH<238>G[195]OF [147]<246><244>GY
 ETWO 'I', 'T'          \                 B<255>KS FROM SURFA<233> <248><241>
 ECHR ' '               \                <245>I<223> <216><235>RP<251><223>.
 ETWO 'I', 'N'          \                <215>{19}<246><244>GY UN<219>S <238>E
 ECHR 'C'               \                 AVA<220><216><229> FROM TECH <229>
 ETWO 'R', 'E'          \                <250>L 9 UPW<238>DS[177]"
 ECHR 'A'
 ETWO 'S', 'E'
 ECHR 'S'
 ECHR ' '
 ETOK 147
 ECHR 'R'
 ETWO 'A', 'T'
 ECHR 'E'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ETWO 'R', 'E'
 ECHR 'C'
 ECHR 'H'
 ETWO 'A', 'R'
 ECHR 'G'
 ETOK 195
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ETOK 147
 ETWO 'E', 'N'
 ETWO 'E', 'R'
 ECHR 'G'
 ECHR 'Y'
 ECHR ' '
 ECHR 'B'
 ETWO 'A', 'N'
 ECHR 'K'
 ECHR 'S'
 ECHR ' '
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ECHR 'S'
 ECHR 'U'
 ECHR 'R'
 ECHR 'F'
 ECHR 'A'
 ETWO 'C', 'E'
 ECHR ' '
 ETWO 'R', 'A'
 ETWO 'D', 'I'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR ' '
 ETWO 'A', 'B'
 ETWO 'S', 'O'
 ECHR 'R'
 ECHR 'P'
 ETWO 'T', 'I'
 ETWO 'O', 'N'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ETWO 'E', 'N'
 ETWO 'E', 'R'
 ECHR 'G'
 ECHR 'Y'
 ECHR ' '
 ECHR 'U'
 ECHR 'N'
 ETWO 'I', 'T'
 ECHR 'S'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ECHR 'A'
 ECHR 'V'
 ECHR 'A'
 ETWO 'I', 'L'
 ETWO 'A', 'B'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '9'
 ECHR ' '
 ECHR 'U'
 ECHR 'P'
 ECHR 'W'
 ETWO 'A', 'R'
 ECHR 'D'
 ECHR 'S'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 117:    "{justify}{single cap}DOCKING COMPUTERS
 EJMP 19                \                ARE RECOMMENDED BY ALL PLANETARY
 ECHR 'D'               \                GOVERNMENTS AS A SAFE WAY OF REDUCING
 ECHR 'O'               \                THE NUMBER OF DOCKING ACCIDENTS.{crlf}
 ECHR 'C'               \                {single cap}DOCKING COMPUTERS WILL
 ECHR 'K'               \                AUTOMATICALLY DOCK A SHIP WHEN TURNED
 ETOK 195               \                ON.{crlf}
 ECHR 'C'               \                {single cap}DOCKING COMPUTERS CAN BE
 ECHR 'O'               \                BOUGHT AT SYSTEMS OF TECH LEVEL 10 OR
 ECHR 'M'               \                MORE.{cr}
 ECHR 'P'               \                {left align}"
 ECHR 'U'               \
 ECHR 'T'               \ Encoded as:   "{14}{19}DOCK[195]COMPUT<244>S <238>E
 ETWO 'E', 'R'          \                 <242>COMM<246>D[196]BY <228>L [145]
 ECHR 'S'               \                <238>Y GOV<244>NM<246>TS AS[208]SAFE WA
 ECHR ' '               \                Y OF <242>DUC[195][147]<225>MB<244> OF
 ETWO 'A', 'R'          \                 DOCK[195]ACCID<246>TS.<215>{19}DOCK
 ECHR 'E'               \                [195]COMPUT<244>S W<220>L AUTO<239>
 ECHR ' '               \                <251>C<228>LY DOCK[208][207] WH<246> TU
 ETWO 'R', 'E'          \                RN[196]<223>.<215>{19}DOCK[195]COMPUT
 ECHR 'C'               \                <244>S C<255> <247> B<217>GHT <245> SY
 ECHR 'O'               \                <222>EMS OF TECH <229><250>L 10 <253> M
 ECHR 'M'               \                O<242>[177]"
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'D'
 ETOK 196
 ECHR 'B'
 ECHR 'Y'
 ECHR ' '
 ETWO 'A', 'L'
 ECHR 'L'
 ECHR ' '
 ETOK 145
 ETWO 'A', 'R'
 ECHR 'Y'
 ECHR ' '
 ECHR 'G'
 ECHR 'O'
 ECHR 'V'
 ETWO 'E', 'R'
 ECHR 'N'
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR 'S'
 ECHR ' '
 ECHR 'A'
 ECHR 'S'
 ETOK 208
 ECHR 'S'
 ECHR 'A'
 ECHR 'F'
 ECHR 'E'
 ECHR ' '
 ECHR 'W'
 ECHR 'A'
 ECHR 'Y'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ETWO 'R', 'E'
 ECHR 'D'
 ECHR 'U'
 ECHR 'C'
 ETOK 195
 ETOK 147
 ETWO 'N', 'U'
 ECHR 'M'
 ECHR 'B'
 ETWO 'E', 'R'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'D'
 ECHR 'O'
 ECHR 'C'
 ECHR 'K'
 ETOK 195
 ECHR 'A'
 ECHR 'C'
 ECHR 'C'
 ECHR 'I'
 ECHR 'D'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR 'S'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'D'
 ECHR 'O'
 ECHR 'C'
 ECHR 'K'
 ETOK 195
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'P'
 ECHR 'U'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR ' '
 ECHR 'W'
 ETWO 'I', 'L'
 ECHR 'L'
 ECHR ' '
 ECHR 'A'
 ECHR 'U'
 ECHR 'T'
 ECHR 'O'
 ETWO 'M', 'A'
 ETWO 'T', 'I'
 ECHR 'C'
 ETWO 'A', 'L'
 ECHR 'L'
 ECHR 'Y'
 ECHR ' '
 ECHR 'D'
 ECHR 'O'
 ECHR 'C'
 ECHR 'K'
 ETOK 208
 ETOK 207
 ECHR ' '
 ECHR 'W'
 ECHR 'H'
 ETWO 'E', 'N'
 ECHR ' '
 ECHR 'T'
 ECHR 'U'
 ECHR 'R'
 ECHR 'N'
 ETOK 196
 ETWO 'O', 'N'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'D'
 ECHR 'O'
 ECHR 'C'
 ECHR 'K'
 ETOK 195
 ECHR 'C'
 ECHR 'O'
 ECHR 'M'
 ECHR 'P'
 ECHR 'U'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'S'
 ECHR ' '
 ECHR 'C'
 ETWO 'A', 'N'
 ECHR ' '
 ETWO 'B', 'E'
 ECHR ' '
 ECHR 'B'
 ETWO 'O', 'U'
 ECHR 'G'
 ECHR 'H'
 ECHR 'T'
 ECHR ' '
 ETWO 'A', 'T'
 ECHR ' '
 ECHR 'S'
 ECHR 'Y'
 ETWO 'S', 'T'
 ECHR 'E'
 ECHR 'M'
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '1'
 ECHR '0'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'M'
 ECHR 'O'
 ETWO 'R', 'E'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 118:    "{justify}{single cap}GALACTIC
 EJMP 19                \                HYPERSPACE DRIVES ARE OBTAINABLE FROM
 ECHR 'G'               \                PLANETS OF TECH LEVEL 11 UPWARDS.{crlf}
 ETWO 'A', 'L'          \                {single cap}WHEN THE INTERGALACTIC
 ECHR 'A'               \                HYPERDRIVE IS ENGAGED, THE SHIP IS
 ECHR 'C'               \                HYPERJUMPED INTO THE PRE-PROGRAMMED
 ETWO 'T', 'I'          \                GALAXY.{cr}
 ECHR 'C'               \                {left align}"
 ECHR ' '               \
 ECHR 'H'               \ Encoded as:   "{14}{19}G<228>AC<251>C HYP<244>SPA<233>
 ECHR 'Y'               \                 [151]S <238>E OBTA<240><216><229> FROM
 ECHR 'P'               \                 [145]S OF TECH <229><250>L 11 UPW<238>
 ETWO 'E', 'R'          \                DS.<215>{19}WH<246> [147]<240>T<244>G
 ECHR 'S'               \                <228>AC<251>C HYP<244>[151] IS <246>GA
 ECHR 'P'               \                <231>D, [147][207][202]HYP<244>JUMP
 ECHR 'A'               \                [196]<240>TO [147]P<242>-PROG<248>MM
 ETWO 'C', 'E'          \                [196]G<228>AXY[177]"
 ECHR ' '
 ETOK 151
 ECHR 'S'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ECHR 'O'
 ECHR 'B'
 ECHR 'T'
 ECHR 'A'
 ETWO 'I', 'N'
 ETWO 'A', 'B'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ETOK 145
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '1'
 ECHR '1'
 ECHR ' '
 ECHR 'U'
 ECHR 'P'
 ECHR 'W'
 ETWO 'A', 'R'
 ECHR 'D'
 ECHR 'S'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'W'
 ECHR 'H'
 ETWO 'E', 'N'
 ECHR ' '
 ETOK 147
 ETWO 'I', 'N'
 ECHR 'T'
 ETWO 'E', 'R'
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'C'
 ETWO 'T', 'I'
 ECHR 'C'
 ECHR ' '
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ETOK 151
 ECHR ' '
 ECHR 'I'
 ECHR 'S'
 ECHR ' '
 ETWO 'E', 'N'
 ECHR 'G'
 ECHR 'A'
 ETWO 'G', 'E'
 ECHR 'D'
 ECHR ','
 ECHR ' '
 ETOK 147
 ETOK 207
 ETOK 202
 ECHR 'H'
 ECHR 'Y'
 ECHR 'P'
 ETWO 'E', 'R'
 ECHR 'J'
 ECHR 'U'
 ECHR 'M'
 ECHR 'P'
 ETOK 196
 ETWO 'I', 'N'
 ECHR 'T'
 ECHR 'O'
 ECHR ' '
 ETOK 147
 ECHR 'P'
 ETWO 'R', 'E'
 ECHR '-'
 ECHR 'P'
 ECHR 'R'
 ECHR 'O'
 ECHR 'G'
 ETWO 'R', 'A'
 ECHR 'M'
 ECHR 'M'
 ETOK 196
 ECHR 'G'
 ETWO 'A', 'L'
 ECHR 'A'
 ECHR 'X'
 ECHR 'Y'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 119:    "{justify}{single cap}MILITARY LASERS
 EJMP 19                \                ARE THE HEIGHT OF LASER SOPHISTICATION.
 ECHR 'M'               \                {crlf}
 ETWO 'I', 'L'          \                {single cap}THEY USE HIGH ENERGY LASERS
 ETWO 'I', 'T'          \                FIRING CONTINUOUSLY TO PRODUCE
 ETWO 'A', 'R'          \                DEVASTATING EFFECTS, BUT ARE PRONE TO
 ECHR 'Y'               \                OVERHEATING.{crlf}
 ECHR ' '               \                {single cap}MILITARY LASERS ARE
 ETWO 'L', 'A'          \                AVAILABLE FROM PLANETS OF TECH LEVEL 12
 ETWO 'S', 'E'          \                OR MORE.{cr}
 ECHR 'R'               \                {left align}"
 ECHR 'S'               \
 ECHR ' '               \ Encoded as:   "{14}{19}M<220><219><238>Y <249><218>RS
 ETWO 'A', 'R'          \                 <238>E [147]HEIGHT OF <249><218>R
 ECHR 'E'               \                 <235>PHI<222>IC<245>I<223>.<215>{19}
 ECHR ' '               \                <226>EY U<218> HIGH <246><244>GY <249>
 ETOK 147               \                <218>RS FIR[195]C<223><251><225><217>SL
 ECHR 'H'               \                Y[201]PRODU<233> DEVA<222><245>[195]EFF
 ECHR 'E'               \                ECTS, BUT <238>E PR<223>E[201]OV<244>HE
 ECHR 'I'               \                <245><240>G.<215>{19}M<220><219><238>Y
 ECHR 'G'               \                 <249><218>RS <238>E AVA<220><216><229>
 ECHR 'H'               \                 FROM [145]S OF TECH <229><250>L 12
 ECHR 'T'               \                 <253> MO<242>[177]"
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR ' '
 ETWO 'S', 'O'
 ECHR 'P'
 ECHR 'H'
 ECHR 'I'
 ETWO 'S', 'T'
 ECHR 'I'
 ECHR 'C'
 ETWO 'A', 'T'
 ECHR 'I'
 ETWO 'O', 'N'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ETWO 'T', 'H'
 ECHR 'E'
 ECHR 'Y'
 ECHR ' '
 ECHR 'U'
 ETWO 'S', 'E'
 ECHR ' '
 ECHR 'H'
 ECHR 'I'
 ECHR 'G'
 ECHR 'H'
 ECHR ' '
 ETWO 'E', 'N'
 ETWO 'E', 'R'
 ECHR 'G'
 ECHR 'Y'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 ECHR ' '
 ECHR 'F'
 ECHR 'I'
 ECHR 'R'
 ETOK 195
 ECHR 'C'
 ETWO 'O', 'N'
 ETWO 'T', 'I'
 ETWO 'N', 'U'
 ETWO 'O', 'U'
 ECHR 'S'
 ECHR 'L'
 ECHR 'Y'
 ETOK 201
 ECHR 'P'
 ECHR 'R'
 ECHR 'O'
 ECHR 'D'
 ECHR 'U'
 ETWO 'C', 'E'
 ECHR ' '
 ECHR 'D'
 ECHR 'E'
 ECHR 'V'
 ECHR 'A'
 ETWO 'S', 'T'
 ETWO 'A', 'T'
 ETOK 195
 ECHR 'E'
 ECHR 'F'
 ECHR 'F'
 ECHR 'E'
 ECHR 'C'
 ECHR 'T'
 ECHR 'S'
 ECHR ','
 ECHR ' '
 ECHR 'B'
 ECHR 'U'
 ECHR 'T'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ECHR 'P'
 ECHR 'R'
 ETWO 'O', 'N'
 ECHR 'E'
 ETOK 201
 ECHR 'O'
 ECHR 'V'
 ETWO 'E', 'R'
 ECHR 'H'
 ECHR 'E'
 ETWO 'A', 'T'
 ETWO 'I', 'N'
 ECHR 'G'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'M'
 ETWO 'I', 'L'
 ETWO 'I', 'T'
 ETWO 'A', 'R'
 ECHR 'Y'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ECHR 'A'
 ECHR 'V'
 ECHR 'A'
 ETWO 'I', 'L'
 ETWO 'A', 'B'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ETOK 145
 ECHR 'S'
 ECHR ' '
 ECHR 'O'
 ECHR 'F'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '1'
 ECHR '2'
 ECHR ' '
 ETWO 'O', 'R'
 ECHR ' '
 ECHR 'M'
 ECHR 'O'
 ETWO 'R', 'E'
 ETOK 177
 EQUB VE

 EJMP 14                \ Token 120:    "{justify}{single cap}MINING LASERS ARE
 EJMP 19                \                HIGHLY POWERED, SLOW FIRING PULSE
 ECHR 'M'               \                LASERS WHICH ARE TUNED TO FRAGMENT
 ETWO 'I', 'N'          \                ASTEROIDS.{crlf}
 ETOK 195               \                {single cap}MINING LASERS ARE AVAILABLE
 ETWO 'L', 'A'          \                FROM TECH LEVEL 12 UPWARDS.{cr}
 ETWO 'S', 'E'          \                {left align}"
 ECHR 'R'               \
 ECHR 'S'               \ Encoded as:   "{14}{19}M<240>[195]<249><218>RS <238>E
 ECHR ' '               \                 HIGHLY POWE<242>D, S<224>W FIR[195]PUL
 ETWO 'A', 'R'          \                <218> <249><218>RS WHICH <238>E TUN
 ECHR 'E'               \                [196]TO F<248>GM<246>T A<222><244>OIDS.
 ECHR ' '               \                <215>{19}M<240>[195]<249><218>RS <238>E
 ECHR 'H'               \                 AVA<220><216><229> FROM TECH <229>
 ECHR 'I'               \                <250>L 12 UPW<238>DS[177]"
 ECHR 'G'
 ECHR 'H'
 ECHR 'L'
 ECHR 'Y'
 ECHR ' '
 ECHR 'P'
 ECHR 'O'
 ECHR 'W'
 ECHR 'E'
 ETWO 'R', 'E'
 ECHR 'D'
 ECHR ','
 ECHR ' '
 ECHR 'S'
 ETWO 'L', 'O'
 ECHR 'W'
 ECHR ' '
 ECHR 'F'
 ECHR 'I'
 ECHR 'R'
 ETOK 195
 ECHR 'P'
 ECHR 'U'
 ECHR 'L'
 ETWO 'S', 'E'
 ECHR ' '
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 ECHR ' '
 ECHR 'W'
 ECHR 'H'
 ECHR 'I'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ECHR 'T'
 ECHR 'U'
 ECHR 'N'
 ETOK 196
 ECHR 'T'
 ECHR 'O'
 ECHR ' '
 ECHR 'F'
 ETWO 'R', 'A'
 ECHR 'G'
 ECHR 'M'
 ETWO 'E', 'N'
 ECHR 'T'
 ECHR ' '
 ECHR 'A'
 ETWO 'S', 'T'
 ETWO 'E', 'R'
 ECHR 'O'
 ECHR 'I'
 ECHR 'D'
 ECHR 'S'
 ECHR '.'
 ETWO '-', '-'
 EJMP 19
 ECHR 'M'
 ETWO 'I', 'N'
 ETOK 195
 ETWO 'L', 'A'
 ETWO 'S', 'E'
 ECHR 'R'
 ECHR 'S'
 ECHR ' '
 ETWO 'A', 'R'
 ECHR 'E'
 ECHR ' '
 ECHR 'A'
 ECHR 'V'
 ECHR 'A'
 ETWO 'I', 'L'
 ETWO 'A', 'B'
 ETWO 'L', 'E'
 ECHR ' '
 ECHR 'F'
 ECHR 'R'
 ECHR 'O'
 ECHR 'M'
 ECHR ' '
 ECHR 'T'
 ECHR 'E'
 ECHR 'C'
 ECHR 'H'
 ECHR ' '
 ETWO 'L', 'E'
 ETWO 'V', 'E'
 ECHR 'L'
 ECHR ' '
 ECHR '1'
 ECHR '2'
 ECHR ' '
 ECHR 'U'
 ECHR 'P'
 ECHR 'W'
 ETWO 'A', 'R'
 ECHR 'D'
 ECHR 'S'
 ETOK 177
 EQUB VE

\ ******************************************************************************
\
\       Name: CHAR
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for characters in the recursive token table
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the recursive token table:
\
\   CHAR 'x'            Insert ASCII character "x"
\
\ To include an apostrophe, use a backtick character, as in CHAR '`'.
\
\ See the deep dive on "Printing text tokens" for details on how characters are
\ stored in the recursive token table.
\
\ Arguments:
\
\   'x'                 The character to insert into the table
\
\ ******************************************************************************

MACRO CHAR x

 IF x = '`'
   EQUB 39 EOR RE
 ELSE
   EQUB x EOR RE
 ENDIF

ENDMACRO

\ ******************************************************************************
\
\       Name: TWOK
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for two-letter tokens in the token table
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the recursive token table:
\
\   TWOK 'x', 'y'       Insert two-letter token "xy"
\
\ See the deep dive on "Printing text tokens" for details on how two-letter
\ tokens are stored in the recursive token table.
\
\ Arguments:
\
\   'x'                 The first letter of the two-letter token to insert into
\                       the table
\
\   'y'                 The second letter of the two-letter token to insert into
\                       the table
\
\ ******************************************************************************

MACRO TWOK t, k

 IF t = 'A' AND k = 'L' : EQUB 128 EOR RE : ENDIF
 IF t = 'L' AND k = 'E' : EQUB 129 EOR RE : ENDIF
 IF t = 'X' AND k = 'E' : EQUB 130 EOR RE : ENDIF
 IF t = 'G' AND k = 'E' : EQUB 131 EOR RE : ENDIF
 IF t = 'Z' AND k = 'A' : EQUB 132 EOR RE : ENDIF
 IF t = 'C' AND k = 'E' : EQUB 133 EOR RE : ENDIF
 IF t = 'B' AND k = 'I' : EQUB 134 EOR RE : ENDIF
 IF t = 'S' AND k = 'O' : EQUB 135 EOR RE : ENDIF
 IF t = 'U' AND k = 'S' : EQUB 136 EOR RE : ENDIF
 IF t = 'E' AND k = 'S' : EQUB 137 EOR RE : ENDIF
 IF t = 'A' AND k = 'R' : EQUB 138 EOR RE : ENDIF
 IF t = 'M' AND k = 'A' : EQUB 139 EOR RE : ENDIF
 IF t = 'I' AND k = 'N' : EQUB 140 EOR RE : ENDIF
 IF t = 'D' AND k = 'I' : EQUB 141 EOR RE : ENDIF
 IF t = 'R' AND k = 'E' : EQUB 142 EOR RE : ENDIF
 IF t = 'A' AND k = '?' : EQUB 143 EOR RE : ENDIF
 IF t = 'E' AND k = 'R' : EQUB 144 EOR RE : ENDIF
 IF t = 'A' AND k = 'T' : EQUB 145 EOR RE : ENDIF
 IF t = 'E' AND k = 'N' : EQUB 146 EOR RE : ENDIF
 IF t = 'B' AND k = 'E' : EQUB 147 EOR RE : ENDIF
 IF t = 'R' AND k = 'A' : EQUB 148 EOR RE : ENDIF
 IF t = 'L' AND k = 'A' : EQUB 149 EOR RE : ENDIF
 IF t = 'V' AND k = 'E' : EQUB 150 EOR RE : ENDIF
 IF t = 'T' AND k = 'I' : EQUB 151 EOR RE : ENDIF
 IF t = 'E' AND k = 'D' : EQUB 152 EOR RE : ENDIF
 IF t = 'O' AND k = 'R' : EQUB 153 EOR RE : ENDIF
 IF t = 'Q' AND k = 'U' : EQUB 154 EOR RE : ENDIF
 IF t = 'A' AND k = 'N' : EQUB 155 EOR RE : ENDIF
 IF t = 'T' AND k = 'E' : EQUB 156 EOR RE : ENDIF
 IF t = 'I' AND k = 'S' : EQUB 157 EOR RE : ENDIF
 IF t = 'R' AND k = 'I' : EQUB 158 EOR RE : ENDIF
 IF t = 'O' AND k = 'N' : EQUB 159 EOR RE : ENDIF

ENDMACRO

\ ******************************************************************************
\
\       Name: CONT
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for control codes in the recursive token table
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the recursive token table:
\
\   CONT n              Insert control code token {n}
\
\ See the deep dive on "Printing text tokens" for details on how characters are
\ stored in the recursive token table.
\
\ Arguments:
\
\   n                   The control code to insert into the table
\
\ ******************************************************************************

MACRO CONT n

 EQUB n EOR RE

ENDMACRO

\ ******************************************************************************
\
\       Name: RTOK
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for recursive tokens in the recursive token table
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the recursive token table:
\
\   RTOK n              Insert recursive token [n]
\
\                         * Tokens 0-95 get stored as n + 160
\
\                         * Tokens 128-145 get stored as n - 114
\
\                         * Tokens 96-127 get stored as n
\
\ See the deep dive on "Printing text tokens" for details on how recursive
\ tokens are stored in the recursive token table.
\
\ Arguments:
\
\   n                   The number of the recursive token to insert into the
\                       table, in the range 0 to 145
\
\ ******************************************************************************

MACRO RTOK n

 IF n >= 0 AND n <= 95
  t = n + 160
 ELIF n >= 128
  t = n - 114
 ELSE
  t = n
 ENDIF

 EQUB t EOR RE

ENDMACRO

\ ******************************************************************************
\
\       Name: QQ18
\       Type: Variable
\   Category: Text
\    Summary: The recursive token table for tokens 0-148
\  Deep dive: Printing text tokens
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   new_name            This part of token 132 is updated with our current
\                       ship's type by routine n_load, so printing token 132
\                       will always show the correct type of our ship
\
\ ******************************************************************************

.QQ18

 RTOK 111               \ Token 0:      "FUEL SCOOPS ON {beep}"
 RTOK 131               \
 CONT 7                 \ Encoded as:   "[111][131]{7}"
 EQUB 0

 CHAR ' '               \ Token 1:      " CHART"
 CHAR 'C'               \
 CHAR 'H'               \ Encoded as:   " CH<138>T"
 TWOK 'A', 'R'
 CHAR 'T'
 EQUB 0

 CHAR 'G'               \ Token 2:      "GOVERNMENT"
 CHAR 'O'               \
 TWOK 'V', 'E'          \ Encoded as:   "GO<150>RNM<146>T"
 CHAR 'R'
 CHAR 'N'
 CHAR 'M'
 TWOK 'E', 'N'
 CHAR 'T'
 EQUB 0

 CHAR 'D'               \ Token 3:      "DATA ON {selected system name}"
 TWOK 'A', 'T'          \
 CHAR 'A'               \ Encoded as:   "D<145>A[131]{3}"
 RTOK 131
 CONT 3
 EQUB 0

 TWOK 'I', 'N'          \ Token 4:      "INVENTORY{cr}
 TWOK 'V', 'E'          \               "
 CHAR 'N'               \
 CHAR 'T'               \ Encoded as:   "<140><150>NT<153>Y{12}"
 TWOK 'O', 'R'
 CHAR 'Y'
 CONT 12
 EQUB 0

 CHAR 'S'               \ Token 5:      "SYSTEM"
 CHAR 'Y'               \
 CHAR 'S'               \ Encoded as:   "SYS<156>M"
 TWOK 'T', 'E'
 CHAR 'M'
 EQUB 0

 CHAR 'P'               \ Token 6:      "PRICE"
 TWOK 'R', 'I'          \
 TWOK 'C', 'E'          \ Encoded as:   "P<158><133>"
 EQUB 0

 CONT 2                 \ Token 7:      "{current system name} MARKET PRICES"
 CHAR ' '               \
 TWOK 'M', 'A'          \ Encoded as:   "{2} <139>RKET [6]S"
 CHAR 'R'
 CHAR 'K'
 CHAR 'E'
 CHAR 'T'
 CHAR ' '
 RTOK 6
 CHAR 'S'
 EQUB 0

 TWOK 'I', 'N'          \ Token 8:      "INDUSTRIAL"
 CHAR 'D'               \
 TWOK 'U', 'S'          \ Encoded as:   "<140>D<136>T<158><128>"
 CHAR 'T'
 TWOK 'R', 'I'
 TWOK 'A', 'L'
 EQUB 0

 CHAR 'A'               \ Token 9:      "AGRICULTURAL"
 CHAR 'G'               \
 TWOK 'R', 'I'          \ Encoded as:   "AG<158>CULTU<148>L"
 CHAR 'C'
 CHAR 'U'
 CHAR 'L'
 CHAR 'T'
 CHAR 'U'
 TWOK 'R', 'A'
 CHAR 'L'
 EQUB 0

 TWOK 'R', 'I'          \ Token 10:     "RICH "
 CHAR 'C'               \
 CHAR 'H'               \ Encoded as:   "<158>CH "
 CHAR ' '
 EQUB 0

 CHAR 'A'               \ Token 11:     "AVERAGE "
 TWOK 'V', 'E'          \
 TWOK 'R', 'A'          \ Encoded as:   "A<150><148><131> "
 TWOK 'G', 'E'
 CHAR ' '
 EQUB 0

 CHAR 'P'               \ Token 12:     "POOR "
 CHAR 'O'               \
 TWOK 'O', 'R'          \ Encoded as:   "PO<153> "
 CHAR ' '
 EQUB 0

 TWOK 'M', 'A'          \ Token 13:     "MAINLY "
 TWOK 'I', 'N'          \
 CHAR 'L'               \ Encoded as:   "<139><140>LY "
 CHAR 'Y'
 CHAR ' '
 EQUB 0

 CHAR 'U'               \ Token 14:     "UNIT"
 CHAR 'N'               \
 CHAR 'I'               \ Encoded as:   "UNIT"
 CHAR 'T'
 EQUB 0

 CHAR 'V'               \ Token 15:     "VIEW "
 CHAR 'I'               \
 CHAR 'E'               \ Encoded as:   "VIEW "
 CHAR 'W'
 CHAR ' '
 EQUB 0

 TWOK 'Q', 'U'          \ Token 16:     "QUANTITY"
 TWOK 'A', 'N'          \
 TWOK 'T', 'I'          \ Encoded as:   "<154><155><151>TY"
 CHAR 'T'
 CHAR 'Y'
 EQUB 0

 TWOK 'A', 'N'          \ Token 17:     "ANARCHY"
 TWOK 'A', 'R'          \
 CHAR 'C'               \ Encoded as:   "<155><138>CHY"
 CHAR 'H'
 CHAR 'Y'
 EQUB 0

 CHAR 'F'               \ Token 18:     "FEUDAL"
 CHAR 'E'               \
 CHAR 'U'               \ Encoded as:   "FEUD<128>"
 CHAR 'D'
 TWOK 'A', 'L'
 EQUB 0

 CHAR 'M'               \ Token 19:     "MULTI-GOVERNMENT"
 CHAR 'U'               \
 CHAR 'L'               \ Encoded as:   "MUL<151>-[2]"
 TWOK 'T', 'I'
 CHAR '-'
 RTOK 2
 EQUB 0

 TWOK 'D', 'I'          \ Token 20:     "DICTATORSHIP"
 CHAR 'C'               \
 CHAR 'T'               \ Encoded as:   "<141>CT<145><153>[25]"
 TWOK 'A', 'T'
 TWOK 'O', 'R'
 RTOK 25
 EQUB 0

 RTOK 91                \ Token 21:     "COMMUNIST"
 CHAR 'M'               \
 CHAR 'U'               \ Encoded as:   "[91]MUN<157>T"
 CHAR 'N'
 TWOK 'I', 'S'
 CHAR 'T'
 EQUB 0

 CHAR 'C'               \ Token 22:     "CONFEDERACY"
 TWOK 'O', 'N'          \
 CHAR 'F'               \ Encoded as:   "C<159>F<152><144>ACY"
 TWOK 'E', 'D'
 TWOK 'E', 'R'
 CHAR 'A'
 CHAR 'C'
 CHAR 'Y'
 EQUB 0

 CHAR 'D'               \ Token 23:     "DEMOCRACY"
 CHAR 'E'               \
 CHAR 'M'               \ Encoded as:   "DEMOC<148>CY"
 CHAR 'O'
 CHAR 'C'
 TWOK 'R', 'A'
 CHAR 'C'
 CHAR 'Y'
 EQUB 0

 CHAR 'C'               \ Token 24:     "CORPORATE STATE"
 TWOK 'O', 'R'          \
 CHAR 'P'               \ Encoded as:   "C<153>P<153><145>E [43]<145>E"
 TWOK 'O', 'R'
 TWOK 'A', 'T'
 CHAR 'E'
 CHAR ' '
 RTOK 43
 TWOK 'A', 'T'
 CHAR 'E'
 EQUB 0

 CHAR 'S'               \ Token 25:     "SHIP"
 CHAR 'H'               \
 CHAR 'I'               \ Encoded as:   "SHIP"
 CHAR 'P'
 EQUB 0

 CHAR 'P'               \ Token 26:     "PRODUCT"
 RTOK 94                \
 CHAR 'D'               \ Encoded as:   "P[94]]DUCT"
 CHAR 'U'
 CHAR 'C'
 CHAR 'T'
 EQUB 0

 CHAR ' '               \ Token 27:     " LASER"
 TWOK 'L', 'A'          \
 CHAR 'S'               \ Encoded as:   " <149>S<144>"
 TWOK 'E', 'R'
 EQUB 0

 CHAR 'H'               \ Token 28:     "HUMAN COLONIAL"
 CHAR 'U'               \
 CHAR 'M'               \ Encoded as:   "HUM<155> COL<159>I<128>"
 TWOK 'A', 'N'
 CHAR ' '
 CHAR 'C'
 CHAR 'O'
 CHAR 'L'
 TWOK 'O', 'N'
 CHAR 'I'
 TWOK 'A', 'L'
 EQUB 0

 CHAR 'H'               \ Token 29:     "HYPERSPACE "
 CHAR 'Y'               \
 CHAR 'P'               \ Encoded as:   "HYP<144>[128] "
 TWOK 'E', 'R'
 RTOK 128
 CHAR ' '
 EQUB 0

 CHAR 'S'               \ Token 30:     "SHORT RANGE CHART"
 CHAR 'H'               \
 TWOK 'O', 'R'          \ Encoded as:   "SH<153>T [42][1]"
 CHAR 'T'
 CHAR ' '
 RTOK 42
 RTOK 1
 EQUB 0

 TWOK 'D', 'I'          \ Token 31:     "DISTANCE"
 RTOK 43                \
 TWOK 'A', 'N'          \ Encoded as:   "<141>[43]<155><133>"
 TWOK 'C', 'E'
 EQUB 0

 CHAR 'P'               \ Token 32:     "POPULATION"
 CHAR 'O'               \
 CHAR 'P'               \ Encoded as:   "POPUL<145>I<159>"
 CHAR 'U'
 CHAR 'L'
 TWOK 'A', 'T'
 CHAR 'I'
 TWOK 'O', 'N'
 EQUB 0

 CHAR 'G'               \ Token 33:     "GROSS PRODUCTIVITY"
 RTOK 94                \
 CHAR 'S'               \ Encoded as:   "G[94]SS [26]IVITY"
 CHAR 'S'
 CHAR ' '
 RTOK 26
 CHAR 'I'
 CHAR 'V'
 CHAR 'I'
 CHAR 'T'
 CHAR 'Y'
 EQUB 0

 CHAR 'E'               \ Token 34:     "ECONOMY"
 CHAR 'C'               \
 TWOK 'O', 'N'          \ Encoded as:   "EC<159>OMY"
 CHAR 'O'
 CHAR 'M'
 CHAR 'Y'
 EQUB 0

 CHAR ' '               \ Token 35:     " LIGHT YEARS"
 CHAR 'L'               \
 CHAR 'I'               \ Encoded as:   " LIGHT YE<138>S"
 CHAR 'G'
 CHAR 'H'
 CHAR 'T'
 CHAR ' '
 CHAR 'Y'
 CHAR 'E'
 TWOK 'A', 'R'
 CHAR 'S'
 EQUB 0

 TWOK 'T', 'E'          \ Token 36:     "TECH.LEVEL"
 CHAR 'C'               \
 CHAR 'H'               \ Encoded as:   "<156>CH.<129><150>L"
 CHAR '.'
 TWOK 'L', 'E'
 TWOK 'V', 'E'
 CHAR 'L'
 EQUB 0

 CHAR 'C'               \ Token 37:     "CASH"
 CHAR 'A'               \
 CHAR 'S'               \ Encoded as:   "CASH"
 CHAR 'H'
 EQUB 0

 CHAR ' '               \ Token 38:     " BILLION"
 TWOK 'B', 'I'          \
 RTOK 129               \ Encoded as:   " <134>[129]I<159>"
 CHAR 'I'
 TWOK 'O', 'N'
 EQUB 0

 RTOK 122               \ Token 39:     "GALACTIC CHART{galaxy number}"
 RTOK 1                 \
 CONT 1                 \ Encoded as:   "[122][1]{1}"
 EQUB 0

 CHAR 'T'               \ Token 40:     "TARGET LOST"
 TWOK 'A', 'R'          \
 TWOK 'G', 'E'          \ Encoded as:   "T<138><131>T LO[43]"
 CHAR 'T'
 CHAR ' '
 CHAR 'L'
 CHAR 'O'
 RTOK 43
 EQUB 0

 RTOK 106               \ Token 41:     "MISSILE JAMMED"
 CHAR ' '               \
 CHAR 'J'               \ Encoded as:   "[106] JAMM<152>"
 CHAR 'A'
 CHAR 'M'
 CHAR 'M'
 TWOK 'E', 'D'
 EQUB 0

 CHAR 'R'               \ Token 42:     "RANGE"
 TWOK 'A', 'N'          \
 TWOK 'G', 'E'          \ Encoded as:   "R<155><131>"
 EQUB 0

 CHAR 'S'               \ Token 43:     "ST"
 CHAR 'T'               \
 EQUB 0                 \ Encoded as:   "ST"

 RTOK 16                \ Token 44:     "QUANTITY OF "
 CHAR ' '               \
 CHAR 'O'               \ Encoded as:   "[16] OF "
 CHAR 'F'
 CHAR ' '
 EQUB 0

 CHAR 'S'               \ Token 45:     "SELL"
 CHAR 'E'               \
 RTOK 129               \ Encoded as:   "SE[129]"
 EQUB 0

 CHAR ' '               \ Token 46:     " CARGO{sentence case}"
 CHAR 'C'               \
 TWOK 'A', 'R'          \ Encoded as:   " C<138>GO{6}"
 CHAR 'G'
 CHAR 'O'
 CONT 6
 EQUB 0

 CHAR 'E'               \ Token 47:     "EQUIP"
 TWOK 'Q', 'U'          \
 CHAR 'I'               \ Encoded as:   "E<154>IP"
 CHAR 'P'
 EQUB 0

 CHAR 'F'               \ Token 48:     "FOOD"
 CHAR 'O'               \
 CHAR 'O'               \ Encoded as:   "FOOD"
 CHAR 'D'
 EQUB 0

 TWOK 'T', 'E'          \ Token 49:     "TEXTILES"
 CHAR 'X'               \
 TWOK 'T', 'I'          \ Encoded as:   "<156>X<151>L<137>"
 CHAR 'L'
 TWOK 'E', 'S'
 EQUB 0

 TWOK 'R', 'A'          \ Token 50:     "RADIOACTIVES"
 TWOK 'D', 'I'          \
 CHAR 'O'               \ Encoded as:   "<148><141>OAC<151><150>S"
 CHAR 'A'
 CHAR 'C'
 TWOK 'T', 'I'
 TWOK 'V', 'E'
 CHAR 'S'
 EQUB 0

 CHAR 'S'               \ Token 51:     "SLAVES"
 TWOK 'L', 'A'          \
 TWOK 'V', 'E'          \ Encoded as:   "S<149><150>S"
 CHAR 'S'
 EQUB 0

 CHAR 'L'               \ Token 52:     "LIQUOR/WINES"
 CHAR 'I'               \
 TWOK 'Q', 'U'          \ Encoded as:   "LI<154><153>/W<140><137>"
 TWOK 'O', 'R'
 CHAR '/'
 CHAR 'W'
 TWOK 'I', 'N'
 TWOK 'E', 'S'
 EQUB 0

 CHAR 'L'               \ Token 53:     "LUXURIES"
 CHAR 'U'               \
 CHAR 'X'               \ Encoded as:   "LUXU<158><137>"
 CHAR 'U'
 TWOK 'R', 'I'
 TWOK 'E', 'S'
 EQUB 0

 CHAR 'N'               \ Token 54:     "NARCOTICS"
 TWOK 'A', 'R'          \
 CHAR 'C'               \ Encoded as:   "N<138>CO<151>CS"
 CHAR 'O'
 TWOK 'T', 'I'
 CHAR 'C'
 CHAR 'S'
 EQUB 0

 RTOK 91                \ Token 55:     "COMPUTERS"
 CHAR 'P'               \
 CHAR 'U'               \ Encoded as:   "[91]PUT<144>S"
 CHAR 'T'
 TWOK 'E', 'R'
 CHAR 'S'
 EQUB 0

 TWOK 'M', 'A'          \ Token 56:     "MACHINERY"
 CHAR 'C'               \
 CHAR 'H'               \ Encoded as:   "<139>CH<140><144>Y"
 TWOK 'I', 'N'
 TWOK 'E', 'R'
 CHAR 'Y'
 EQUB 0

 CHAR 'A'               \ Token 57:     "ALLOYS"
 RTOK 129               \
 CHAR 'O'               \ Encoded as:   "A[129]OYS"
 CHAR 'Y'
 CHAR 'S'
 EQUB 0

 CHAR 'F'               \ Token 58:     "FIREARMS"
 CHAR 'I'               \
 TWOK 'R', 'E'          \ Encoded as:   "FI<142><138>MS"
 TWOK 'A', 'R'
 CHAR 'M'
 CHAR 'S'
 EQUB 0

 CHAR 'F'               \ Token 59:     "FURS"
 CHAR 'U'               \
 CHAR 'R'               \ Encoded as:   "FURS"
 CHAR 'S'
 EQUB 0

 CHAR 'M'               \ Token 60:     "MINERALS"
 TWOK 'I', 'N'          \
 TWOK 'E', 'R'          \ Encoded as:   "M<140><144><128>S"
 TWOK 'A', 'L'
 CHAR 'S'
 EQUB 0

 CHAR 'G'               \ Token 61:     "GOLD"
 CHAR 'O'               \
 CHAR 'L'               \ Encoded as:   "GOLD"
 CHAR 'D'
 EQUB 0

 CHAR 'P'               \ Token 62:     "PLATINUM"
 CHAR 'L'               \
 TWOK 'A', 'T'          \ Encoded as:   "PL<145><140>UM"
 TWOK 'I', 'N'
 CHAR 'U'
 CHAR 'M'
 EQUB 0

 TWOK 'G', 'E'          \ Token 63:     "GEM-STONES"
 CHAR 'M'               \
 CHAR '-'               \ Encoded as:   "<131>M-[43]<159><137>"
 RTOK 43
 TWOK 'O', 'N'
 TWOK 'E', 'S'
 EQUB 0

 TWOK 'A', 'L'          \ Token 64:     "ALIEN ITEMS"
 CHAR 'I'               \
 TWOK 'E', 'N'          \ Encoded as:   "<128>I<146> [127]S"
 CHAR ' '
 RTOK 127
 CHAR 'S'
 EQUB 0

 CONT 12                \ Token 65:     "{cr}
 CHAR '1'               \                10{cash} CR5{cash} CR"
 CHAR '0'               \
 CONT 0                 \ Encoded as:   "{12}10{0}5{0}"
 CHAR '5'
 CONT 0
 EQUB 0

 CHAR ' '               \ Token 66:     " CR"
 CHAR 'C'               \
 CHAR 'R'               \ Encoded as:   " CR"
 EQUB 0

 CHAR 'L'               \ Token 67:     "LARGE"
 TWOK 'A', 'R'          \
 TWOK 'G', 'E'          \ Encoded as:   "L<138><131>"
 EQUB 0

 CHAR 'F'               \ Token 68:     "FIERCE"
 CHAR 'I'               \
 TWOK 'E', 'R'          \ Encoded as:   "FI<144><133>"
 TWOK 'C', 'E'
 EQUB 0

 CHAR 'S'               \ Token 69:     "SMALL"
 TWOK 'M', 'A'          \
 RTOK 129               \ Encoded as:   "S<139>[129]"
 EQUB 0

 CHAR 'G'               \ Token 70:     "GREEN"
 TWOK 'R', 'E'          \
 TWOK 'E', 'N'          \ Encoded as:   "G<142><146>"
 EQUB 0

 CHAR 'R'               \ Token 71:     "RED"
 TWOK 'E', 'D'          \
 EQUB 0                 \ Encoded as:   "R<152>"

 CHAR 'Y'               \ Token 72:     "YELLOW"
 CHAR 'E'               \
 RTOK 129               \ Encoded as:   "YE[129]OW"
 CHAR 'O'
 CHAR 'W'
 EQUB 0

 CHAR 'B'               \ Token 73:     "BLUE"
 CHAR 'L'               \
 CHAR 'U'               \ Encoded as:   "BLUE"
 CHAR 'E'
 EQUB 0

 CHAR 'B'               \ Token 74:     "BLACK"
 TWOK 'L', 'A'          \
 CHAR 'C'               \ Encoded as:   "B<149>CK"
 CHAR 'K'
 EQUB 0

 RTOK 136               \ Token 75:     "HARMLESS"
 EQUB 0                 \
                        \ Encoded as:   "[136]"

 CHAR 'S'               \ Token 76:     "SLIMY"
 CHAR 'L'               \
 CHAR 'I'               \ Encoded as:   "SLIMY"
 CHAR 'M'
 CHAR 'Y'
 EQUB 0

 CHAR 'B'               \ Token 77:     "BUG-EYED"
 CHAR 'U'               \
 CHAR 'G'               \ Encoded as:   "BUG-EY<152>"
 CHAR '-'
 CHAR 'E'
 CHAR 'Y'
 TWOK 'E', 'D'
 EQUB 0

 CHAR 'H'               \ Token 78:     "HORNED"
 TWOK 'O', 'R'          \
 CHAR 'N'               \ Encoded as:   "H<153>N<152>"
 TWOK 'E', 'D'
 EQUB 0

 CHAR 'B'               \ Token 79:     "BONY"
 TWOK 'O', 'N'          \
 CHAR 'Y'               \ Encoded as:   "B<159>Y"
 EQUB 0

 CHAR 'F'               \ Token 80:     "FAT"
 TWOK 'A', 'T'          \
 EQUB 0                 \ Encoded as:   "F<145>"

 CHAR 'F'               \ Token 81:     "FURRY"
 CHAR 'U'               \
 CHAR 'R'               \ Encoded as:   "FURRY"
 CHAR 'R'
 CHAR 'Y'
 EQUB 0

 RTOK 94                \ Token 82:     "RODENT"
 CHAR 'D'               \
 TWOK 'E', 'N'          \ Encoded as:   "[94]D<146>T"
 CHAR 'T'
 EQUB 0

 CHAR 'F'               \ Token 83:     "FROG"
 RTOK 94                \
 CHAR 'G'               \ Encoded as:   "F[94]G"
 EQUB 0

 CHAR 'L'               \ Token 84:     "LIZARD"
 CHAR 'I'               \
 TWOK 'Z', 'A'          \ Encoded as:   "LI<132>RD"
 CHAR 'R'
 CHAR 'D'
 EQUB 0

 CHAR 'L'               \ Token 85:     "LOBSTER"
 CHAR 'O'               \
 CHAR 'B'               \ Encoded as:   "LOB[43]<144>"
 RTOK 43
 TWOK 'E', 'R'
 EQUB 0

 TWOK 'B', 'I'          \ Token 86:     "BIRD"
 CHAR 'R'               \
 CHAR 'D'               \ Encoded as:   "<134>RD"
 EQUB 0

 CHAR 'H'               \ Token 87:     "HUMANOID"
 CHAR 'U'               \
 CHAR 'M'               \ Encoded as:   "HUM<155>OID"
 TWOK 'A', 'N'
 CHAR 'O'
 CHAR 'I'
 CHAR 'D'
 EQUB 0

 CHAR 'F'               \ Token 88:     "FELINE"
 CHAR 'E'               \
 CHAR 'L'               \ Encoded as:   "FEL<140>E"
 TWOK 'I', 'N'
 CHAR 'E'
 EQUB 0

 TWOK 'I', 'N'          \ Token 89:     "INSECT"
 CHAR 'S'               \
 CHAR 'E'               \ Encoded as:   "<140>SECT"
 CHAR 'C'
 CHAR 'T'
 EQUB 0

 RTOK 11                \ Token 90:     "AVERAGE RADIUS"
 TWOK 'R', 'A'          \
 TWOK 'D', 'I'          \ Encoded as:   "[11]<148><141><136>"
 TWOK 'U', 'S'
 EQUB 0

 CHAR 'C'               \ Token 91:     "COM"
 CHAR 'O'               \
 CHAR 'M'               \ Encoded as:   "COM"
 EQUB 0

 RTOK 91                \ Token 92:     "COMMANDER"
 CHAR 'M'               \
 TWOK 'A', 'N'          \ Encoded as:   "[91]M<155>D<144>"
 CHAR 'D'
 TWOK 'E', 'R'
 EQUB 0

 CHAR ' '               \ Token 93:     " DESTROYED"
 CHAR 'D'               \
 TWOK 'E', 'S'          \ Encoded as:   " D<137>T[94]Y<152>"
 CHAR 'T'
 RTOK 94
 CHAR 'Y'
 TWOK 'E', 'D'
 EQUB 0

 CHAR 'R'               \ Token 94:     "RO"
 CHAR 'O'               \
 EQUB 0                 \ Encoded as:   "RO"

 RTOK 14                \ Token 95:     "UNIT  QUANTITY{cr}
 CHAR ' '               \                 PRODUCT   UNIT PRICE FOR SALE{cr}{lf}
 CHAR ' '               \               "
 RTOK 16                \
 CONT 12                \ Encoded as:   "[14]  [16]{13} [26]   [14] [6] F<153>
 CHAR ' '               \                 SA<129>{12}{10}"
 RTOK 26
 CHAR ' '
 CHAR ' '
 CHAR ' '
 RTOK 14
 CHAR ' '
 RTOK 6
 CHAR ' '
 CHAR 'F'
 TWOK 'O', 'R'
 CHAR ' '
 CHAR 'S'
 CHAR 'A'
 TWOK 'L', 'E'
 CONT 12
 CONT 10
 EQUB 0

 CHAR 'F'               \ Token 96:     "FRONT"
 CHAR 'R'               \
 TWOK 'O', 'N'          \ Encoded as:   "FR<159>T"
 CHAR 'T'
 EQUB 0

 TWOK 'R', 'E'          \ Token 97:     "REAR"
 TWOK 'A', 'R'          \
 EQUB 0                 \ Encoded as:   "<142><138>"

 TWOK 'L', 'E'          \ Token 98:     "LEFT"
 CHAR 'F'               \
 CHAR 'T'               \ Encoded as:   "<129>FT"
 EQUB 0

 TWOK 'R', 'I'          \ Token 99:     "RIGHT"
 CHAR 'G'               \
 CHAR 'H'               \ Encoded as:   "<158>GHT"
 CHAR 'T'
 EQUB 0

 RTOK 121               \ Token 100:    "ENERGY LOW{beep}"
 CHAR 'L'               \
 CHAR 'O'               \ Encoded as:   "[121]LOW{7}"
 CHAR 'W'
 CONT 7
 EQUB 0

 RTOK 99                \ Token 101:    "RIGHT ON COMMANDER!"
 RTOK 131               \
 RTOK 92                \ Encoded as:   "[99][131][92]!"
 CHAR '!'
 EQUB 0

 CHAR 'E'               \ Token 102:    "EXTRA "
 CHAR 'X'               \
 CHAR 'T'               \ Encoded as:   "EXT<148> "
 TWOK 'R', 'A'
 CHAR ' '
 EQUB 0

 CHAR 'P'               \ Token 103:    "PULSE LASER"
 CHAR 'U'               \
 CHAR 'L'               \ Encoded as:   "PULSE[27]"
 CHAR 'S'
 CHAR 'E'
 RTOK 27
 EQUB 0

 TWOK 'B', 'E'          \ Token 104:    "BEAM LASER"
 CHAR 'A'               \
 CHAR 'M'               \ Encoded as:   "<147>AM[27]"
 RTOK 27
 EQUB 0

 CHAR 'F'               \ Token 105:    "FUEL"
 CHAR 'U'               \
 CHAR 'E'               \ Encoded as:   "FUEL"
 CHAR 'L'
 EQUB 0

 CHAR 'M'               \ Token 106:    "MISSILE"
 TWOK 'I', 'S'          \
 CHAR 'S'               \ Encoded as:   "M<157>SI<129>"
 CHAR 'I'
 TWOK 'L', 'E'
 EQUB 0

 CHAR 'I'               \ Token 107:    "I.F.F.SYSTEM"
 CHAR '.'               \
 CHAR 'F'               \ Encoded as:   "I.F.F.[5]"
 CHAR '.'
 CHAR 'F'
 CHAR '.'
 RTOK 5
 EQUB 0

 CHAR 'E'               \ Token 108:    "E.C.M.SYSTEM"
 CHAR '.'               \
 CHAR 'C'               \ Encoded as:   "E.C.M.[5]"
 CHAR '.'
 CHAR 'M'
 CHAR '.'
 RTOK 5
 EQUB 0

 RTOK 102               \ Token 109:    "EXTRA PULSE LASERS"
 RTOK 103               \
 CHAR 'S'               \ Encoded as:   "[102][103]S"
 EQUB 0

 RTOK 102               \ Token 110:    "EXTRA BEAM LASERS"
 RTOK 104               \
 CHAR 'S'               \ Encoded as:   "[102][104]S"
 EQUB 0

 RTOK 105               \ Token 111:    "FUEL SCOOPS"
 CHAR ' '               \
 CHAR 'S'               \ Encoded as:   "[105] SCOOPS"
 CHAR 'C'
 CHAR 'O'
 CHAR 'O'
 CHAR 'P'
 CHAR 'S'
 EQUB 0

 TWOK 'E', 'S'          \ Token 112:    "ESCAPE POD"
 CHAR 'C'               \
 CHAR 'A'               \ Encoded as:   "<137>CAPE POD"
 CHAR 'P'
 CHAR 'E'
 CHAR ' '
 CHAR 'P'
 CHAR 'O'
 CHAR 'D'
 EQUB 0

 RTOK 29                \ Token 113:    "HYPERSPACE UNIT"
 RTOK 14                \
 EQUB 0                 \ Encoded as:   "[29][14]"

 RTOK 121               \ Token 114:    "ENERGY UNIT"
 RTOK 14                \
 EQUB 0                 \ Encoded as:   "[121][14]"

 CHAR 'D'               \ Token 115:    "DOCKING COMPUTERS"
 CHAR 'O'               \
 CHAR 'C'               \ Encoded as:   "DOCK<140>G [55]"
 CHAR 'K'
 TWOK 'I', 'N'
 CHAR 'G'
 CHAR ' '
 RTOK 55
 EQUB 0

 RTOK 122               \ Token 116:    "GALACTIC HYPERSPACE "
 CHAR ' '               \
 RTOK 29                \ Encoded as:   "[122] [29]"
 EQUB 0

 CHAR 'M'               \ Token 117:    "MILITARY LASER"
 CHAR 'I'               \
 CHAR 'L'               \ Encoded as:   "MILIT<138>Y[27]"
 CHAR 'I'
 CHAR 'T'
 TWOK 'A', 'R'
 CHAR 'Y'
 RTOK 27
 EQUB 0

 CHAR 'M'               \ Token 118:    "MINING LASER"
 TWOK 'I', 'N'          \
 TWOK 'I', 'N'          \ Encoded as:   "M<140><140>G[27]"
 CHAR 'G'
 RTOK 27
 EQUB 0

 RTOK 37                \ Token 119:    "CASH:{cash} CR{cr}
 CHAR ':'               \               "
 CONT 0                 \
 EQUB 0                 \ Encoded as:   "[37]:{0}"

 TWOK 'I', 'N'          \ Token 120:    "INCOMING MISSILE"
 RTOK 91                \
 TWOK 'I', 'N'          \ Encoded as:   "<140>[91]<140>G [106]"
 CHAR 'G'
 CHAR ' '
 RTOK 106
 EQUB 0

 TWOK 'E', 'N'          \ Token 121:    "ENERGY "
 TWOK 'E', 'R'          \
 CHAR 'G'               \ Encoded as:   "<146><144>GY "
 CHAR 'Y'
 CHAR ' '
 EQUB 0

 CHAR 'G'               \ Token 122:    "GALACTIC"
 CHAR 'A'               \
 TWOK 'L', 'A'          \ Encoded as:   "GA<149>C<151>C"
 CHAR 'C'
 TWOK 'T', 'I'
 CHAR 'C'
 EQUB 0

 RTOK 115               \ Token 123:    "DOCKING COMPUTERS ON"
 CHAR ' '               \
 TWOK 'O', 'N'          \ Encoded as:   "[115] <159>"
 EQUB 0

 CHAR 'A'               \ Token 124:    "ALL"
 RTOK 129               \
 EQUB 0                 \ Encoded as:   "A[129]"

 CONT 5                 \ Token 125:    "FUEL: {fuel level} LIGHT YEARS{cr}
 TWOK 'L', 'E'          \                CASH:{cash} CR{cr}
 CHAR 'G'               \                LEGAL STATUS:"
 TWOK 'A', 'L'          \
 CHAR ' '               \ Encoded as:   "{5}<129>G<128> [43]<145><136>:"
 RTOK 43
 TWOK 'A', 'T'
 TWOK 'U', 'S'
 CHAR ':'
 EQUB 0

 RTOK 92                \ Token 126:    "COMMANDER {commander name}{cr}
 CHAR ' '               \                {cr}
 CONT 4                 \                {cr}
 CONT 12                \                {sentence case}PRESENT SYSTEM{tab to
 CONT 12                \                column 21}:{current system name}{cr}
 CONT 12                \                HYPERSPACE SYSTEM{tab to column 21}:
 CONT 6                 \                {selected system name}{cr}
 RTOK 145               \                CONDITION{tab to column 21}:"
 CHAR ' '               \
 RTOK 5                 \ Encoded as:   "[92] {4}{12}{12}{12}{6}[145] [5]{9}{2}
 CONT 9                 \                {12}[29][5]{9}{3}{13}C<159><141><151>
 CONT 2                 \                <159>{9}"
 CONT 12
 RTOK 29
 RTOK 5
 CONT 9
 CONT 3
 CONT 12
 CHAR 'C'
 TWOK 'O', 'N'
 TWOK 'D', 'I'
 TWOK 'T', 'I'
 TWOK 'O', 'N'
 CONT 9
 EQUB 0

 CHAR 'I'               \ Token 127:    "ITEM"
 TWOK 'T', 'E'          \
 CHAR 'M'               \ Encoded as:   "I<156>M"
 EQUB 0

 CHAR 'S'               \ Token 128:    "SPACE"
 CHAR 'P'               \
 CHAR 'A'               \ Encoded as:   "SPA<133>"
 TWOK 'C', 'E'
 EQUB 0

 CHAR 'L'               \ Token 129:    "LL"
 CHAR 'L'               \
 EQUB 0                 \ Encoded as:   "LL"

 TWOK 'R', 'A'          \ Token 130:    "RATING:"
 TWOK 'T', 'I'          \
 CHAR 'N'               \ Encoded as:   "<148><151>NG:"
 CHAR 'G'
 CHAR ':'
 EQUB 0

 CHAR ' '               \ Token 131:    " ON "
 TWOK 'O', 'N'          \
 CHAR ' '               \ Encoded as:   " <159> "
 EQUB 0

 CONT 12                \ Token 132:    "{cr}
 RTOK 25                \                SHIP:          "
 CHAR ':'               \
 CHAR ' '               \ Encoded as:   "{12}[25]:          "

.new_name

 CHAR ' '               \ This part is updated with our current ship's type in
 CHAR ' '               \ the n_load routine, so printing token 132 will always
 CHAR ' '               \ show the correct type of our ship
 CHAR ' '
 CHAR ' '
 CHAR ' '
 CHAR ' '
 CHAR ' '
 CHAR ' '
 EQUB 0

 CHAR 'C'               \ Token 133:    "CLEAN"
 TWOK 'L', 'E'          \
 TWOK 'A', 'N'          \ Encoded as:   "C<129><155>"
 EQUB 0

 CHAR 'O'               \ Token 134:    "OFFENDER"
 CHAR 'F'               \
 CHAR 'F'               \ Encoded as:   "OFF<146>D<144>"
 TWOK 'E', 'N'
 CHAR 'D'
 TWOK 'E', 'R'
 EQUB 0

 CHAR 'F'               \ Token 135:    "FUGITIVE"
 CHAR 'U'               \
 CHAR 'G'               \ Encoded as:   "FUGI<151><150>"
 CHAR 'I'
 TWOK 'T', 'I'
 TWOK 'V', 'E'
 EQUB 0

 CHAR 'H'               \ Token 136:    "HARMLESS"
 TWOK 'A', 'R'          \
 CHAR 'M'               \ Encoded as:   "H<138>M<129>SS"
 TWOK 'L', 'E'
 CHAR 'S'
 CHAR 'S'
 EQUB 0

 CHAR 'M'               \ Token 137:    "MOSTLY HARMLESS"
 CHAR 'O'               \
 RTOK 43                \ Encoded as:   "MO[43]LY [136]"
 CHAR 'L'
 CHAR 'Y'
 CHAR ' '
 RTOK 136
 EQUB 0

 RTOK 12                \ Token 138:    "POOR "
 EQUB 0                 \
                        \ Encoded as:   "[12]"

 RTOK 11                \ Token 139:    "AVERAGE "
 EQUB 0                 \
                        \ Encoded as:   "[11]"

 CHAR 'A'               \ Token 140:    "ABOVE AVERAGE "
 CHAR 'B'               \
 CHAR 'O'               \ Encoded as:   "ABO<150> [11]"
 TWOK 'V', 'E'
 CHAR ' '
 RTOK 11
 EQUB 0

 RTOK 91                \ Token 141:    "COMPETENT"
 CHAR 'P'               \
 CHAR 'E'               \ Encoded as:   "[91]PET<146>T"
 CHAR 'T'
 TWOK 'E', 'N'
 CHAR 'T'
 EQUB 0

 CHAR 'D'               \ Token 142:    "DANGEROUS"
 TWOK 'A', 'N'          \
 TWOK 'G', 'E'          \ Encoded as:   "D<155><131>[94]<136>"
 RTOK 94
 TWOK 'U', 'S'
 EQUB 0

 CHAR 'D'               \ Token 143:    "DEADLY"
 CHAR 'E'               \
 CHAR 'A'               \ Encoded as:   "DEADLY"
 CHAR 'D'
 CHAR 'L'
 CHAR 'Y'
 EQUB 0

 CHAR '-'               \ Token 144:    "---- E L I T E ----"
 CHAR '-'               \
 CHAR '-'               \ Encoded as:   "---- E L I T E ----"
 CHAR '-'
 CHAR ' '
 CHAR 'E'
 CHAR ' '
 CHAR 'L'
 CHAR ' '
 CHAR 'I'
 CHAR ' '
 CHAR 'T'
 CHAR ' '
 CHAR 'E'
 CHAR ' '
 CHAR '-'
 CHAR '-'
 CHAR '-'
 CHAR '-'
 EQUB 0

 CHAR 'P'               \ Token 145:    "PRESENT"
 TWOK 'R', 'E'          \
 CHAR 'S'               \ Encoded as:   "P<142>S<146>T"
 TWOK 'E', 'N'
 CHAR 'T'
 EQUB 0

 CONT 8                 \ Token 146:    "{all caps}GAME OVER"
 CHAR 'G'               \
 CHAR 'A'               \ Encoded as:   "{8}GAME O<150>R"
 CHAR 'M'
 CHAR 'E'
 CHAR ' '
 CHAR 'O'
 TWOK 'V', 'E'
 CHAR 'R'
 EQUB 0

 SKIP 5                 \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: SNE
\       Type: Variable
\   Category: Maths (Geometry)
\    Summary: Sine/cosine table
\  Deep dive: The sine, cosine and arctan tables
\             Drawing circles
\             Drawing ellipses
\
\ ------------------------------------------------------------------------------
\
\ This lookup table contains sine values for the first half of a circle, from 0
\ to 180 degrees (0 to PI radians). In terms of circle or ellipse line segments,
\ there are 64 segments in a circle, so this contains sine values for segments
\ 0 to 31.
\
\ In terms of segments, to calculate the sine of the angle at segment x, we look
\ up the value in SNE + x, and to calculate the cosine of the angle we look up
\ the value in SNE + ((x + 16) mod 32).
\
\ In terms of radians, to calculate the following:
\
\   sin(theta) * 256
\
\ where theta is in radians, we look up the value in:
\
\   SNE + (theta * 10)
\
\ To calculate the following:
\
\   cos(theta) * 256
\
\ where theta is in radians, look up the value in:
\
\   SNE + ((theta * 10) + 16) mod 32
\
\ Theta must be between 0 and 3.1 radians, so theta * 10 is between 0 and 31.
\
\ ******************************************************************************

.SNE

 FOR I%, 0, 31

  N = ABS(SIN((I% / 64) * 2 * PI))

  IF N >= 1
   B% = 255
  ELSE
   B% = INT(256 * N + 0.5)
  ENDIF

  EQUB B%

 NEXT

\ ******************************************************************************
\
\       Name: ACT
\       Type: Variable
\   Category: Maths (Geometry)
\    Summary: Arctan table
\  Deep dive: The sine, cosine and arctan tables
\
\ ------------------------------------------------------------------------------
\
\ This table contains lookup values for arctangent calculations involving angles
\ in the range 0 to 45 degrees (or 0 to PI / 4 radians).
\
\ To calculate the value of theta in the following:
\
\   theta = arctan(t)
\
\ where 0 <= t < 1, we look up the value in:
\
\   ACT + (t * 32)
\
\ The result will be an integer representing the angle in radians, where 256
\ represents a full circle of 360 degrees (2 * PI radians). The result of the
\ lookup will therefore be an integer in the range 0 to 31, as this represents
\ 0 to 45 degrees (0 to PI / 4 radians).
\
\ The table does not support values of t >= 1 or t < 0 directly, so if we need
\ to calculate the arctangent for an angle greater than 45 degrees, we can apply
\ the following calculation to the result from the table:
\
\   * For t > 1, arctan(t) = 64 - arctan(1 / t)
\
\ For negative values of t where -1 < t < 0, we can apply the following
\ calculation to the result from the table:
\
\   * For t < 0, arctan(-t) = 128 - arctan(t)
\
\ Finally, if t < -1, we can do the first calculation to get arctan(|t|), and
\ the second to get arctan(-|t|).
\
\ ******************************************************************************

.ACT

 FOR I%, 0, 31

  EQUB INT((128 / PI) * ATN(I% / 32) + 0.5)

 NEXT

\ ******************************************************************************
\
\ Save ELTH.bin
\
\ ******************************************************************************

 PRINT "ELITE H"
 PRINT "Assembled at ", ~CODE_H%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_H%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_H%

 PRINT "S.2.ELTH ", ~CODE_H%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_H%
\SAVE "versions/disc/3-assembled-output/2.ELTH.bin", CODE_H%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE I FILE
\
\ ******************************************************************************

 CODE_I% = P%
 LOAD_I% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: encyclopedia
\       Type: Subroutine
\   Category: Encyclopedia
\    Summary: Show the Encyclopedia screen
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.encyclopedia

 LDX #0                 \ Call menu with X = 0 to show menu 0, the main menu for
 JSR menu               \ the Encyclopedia Galactica, and return the choice in A

 CMP #1                 \ If A <> 1, skip the following instruction to check the
 BNE n_shipsag          \ other options

 JMP ships_ag           \ Option 1 was chosen, so jump to ships_ag with A = 1 to
                        \ show the Ships A-G menu

.n_shipsag

 CMP #2                 \ If A <> 2, skip the following instruction to check the
 BNE n_shipskw          \ other options

 JMP ships_kw           \ Option 2 was chosen, so jump to ships_kw with A = 2 to
                        \ show the Ships K-W menu

.n_shipskw

 CMP #3                 \ If A <> 3, skip the following instruction to check the
 BNE n_equipdat         \ other options

 JMP equip_data         \ Option 3 was chosen, so jump to equip_data to show the
                        \ Equipment menu

.n_equipdat

 CMP #4                 \ If A <> 4, skip the following instruction to check the
 BNE n_controls         \ other options

 JMP controls           \ Option 4 was chosen, so jump to controls to show the
                        \ Controls menu

.n_controls

 CMP #5                 \ If A <> 5, skip the following instruction
 BNE P%+5

 JMP trading            \ Option 5 was chosen, so jump to trading to pause and
                        \ show the main menu (there is no option 5 in the main
                        \ menu, so this code is never reached and is presumably
                        \ a remnant of a fifth menu about trading that was
                        \ removed)

 JMP dn2                \ Jump to dn2 to make a short, high beep and delay for 1
                        \ second, returning from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: ships_ag
\       Type: Subroutine
\   Category: Encyclopedia
\    Summary: Show the Ships A-G or Ships K-W menu and display the chosen ship
\             card
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The menu to show:
\
\                         * 1 = Show the Ships A-G menu
\
\                         * 2 = Show the Ships K-W menu
\
\   C flag              Set if this is the second menu (Ships K-W)
\
\ Other entry points:
\
\   ships_kw            Does exactly the same as a call to ships_kw
\
\ ******************************************************************************

.ships_ag

.ships_kw

 PHA                    \ Store the menu number on the stack

 TAX                    \ Call menu with X = A to show the correct menu, so A
 JSR menu               \ is now set to the type of ship card we need to show,
                        \ depending on which ships menu we just displayed:
                        \
                        \   * 1 for Adder to 14 for Ghavial
                        \   * 1 for Iguana to 14 for Worm

 SBC #0                 \ Decrement A so it is now in the range 0 to 13 (as menu
                        \ clears the C flag when the number entered is within
                        \ range), so we now have:
                        \
                        \   * 0 for Adder to 13 for Ghavial
                        \   * 0 for Iguana to 13 for Worm

 PLP                    \ Pull the menu number from the stack into the processor
                        \ flags, which will set the C flag to bit 0 of the value
                        \ on the stack (so if we called the routine with A = 1,
                        \ the C flag will be set, and if we called it with A = 2
                        \ it will be clear)

 BCS ship_over          \ If the C flag is set, then we called the routine with
                        \ A = 1, so jump to ship_over as the choice number is
                        \ already correct (i.e. 0 for Adder to 13 for Ghavial)

 ADC menu_entry+1       \ We just showed the second menu, so the choice number
                        \ is currently:
                        \
                        \   * 0 for Iguana to 13 for Worm
                        \
                        \ which is not right - we want the range to follow on
                        \ from the end of the first menu. To fix this, we need
                        \ to add the number of entries in the first menu to A
                        \ to get the correct choice number. The menu_entry table
                        \ contains the menu sizes, and menu_entry+1 contains the
                        \ size of menu 1 (the Ships A-G menu), so this adds the
                        \ number of entries in the first menu to give the
                        \ correct choice range, as follows:
                        \
                        \   * 14 for Iguana to 27 for Worm

.ship_over

 STA TYPE               \ A contains the ship that we just chose from the Ships
                        \ menu, so store it in TYPE, so TYPE is now:
                        \
                        \   * 0 for Adder to 27 for Worm

 CLC                    \ Store type + 7 on the stack, to give the token number
 ADC #7                 \ of the title to show for the relevant ship card, from
 PHA                    \ Adder (token 7) to Worm (token 34)

 LDA #32                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32

 JSR MT1                \ Switch to ALL CAPS when printing extended tokens

 LDX TYPE               \ Set X to the number of this ship type within the
 LDA ship_posn,X        \ ship_list table, so we can pass it to the install_ship
 TAX                    \ routine

 LDY #0                 \ Install this ship into blueprint position 0 so we can
 JSR install_ship       \ show it on the ship card

 LDX TYPE               \ Set A to the card's title x-coordinate (fetched from
 LDA ship_centre,X      \ the ship_centre table)

 STA XC                 \ Move the text cursor to the correct column for the
                        \ title

 PLA                    \ Pull the token number for the title from the stack
 JSR write_msg3         \ (type + 7) and print it

 JSR NLIN4              \ Draw a horizontal line at pixel row 19 to box in the
                        \ title

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace, so we can
                        \ spawn a rotating ship to display in the centre of the
                        \ ship card

 LDA #&60               \ Set byte #14 (nosev_z_hi) to 1 (&60), so the ship will
 STA INWK+14            \ be pointing away from us

 LDA #176               \ Set z_hi = 176 (very far away)
 STA INWK+7

 LDX #127               \ Set roll counter = 127, so don't dampen the roll
 STX INWK+29

 STX INWK+30            \ Set pitch counter = 127, so don't dampen the pitch

 INX                    \ Set X = 128

 STA QQ17               \ Set QQ17 = %10110000, which has bit 7 set, to
                        \ switch standard tokens to Sentence Case

 LDA TYPE               \ Call write_card to display the ship card for the ship
 JSR write_card         \ type in TYPE

 LDA #0                 \ Add a new ship of type 0 to the local bubble (or, in
 JSR NWSHP              \ this case, the encyclopedia ship card), which will
                        \ spawn the correct shop for this ship card, as we
                        \ installed the correct blueprint into position 0 with
                        \ the call to install_ship above

 JSR l_release          \ Call l_release so if a key is currently being pressed,
                        \ we wait until it is released before continuing

.l_395a

 LDX TYPE               \ Set A to the closest distance that we want to show the
 LDA ship_dist,X        \ ship (fetched from the ship_dist table)

 CMP INWK+7             \ If z_hi (the ship's distance) is equal to A, skip the
 BEQ P%+4               \ following decrement, as the ship is already close
                        \ enough

 DEC INWK+7             \ Decrement the ship's distance, to bring the ship
                        \ a bit closer to us

 JSR MVEIT              \ Move the ship in space according to the orientation
                        \ vectors and the new value in z_hi

 LDA #128               \ Set z_lo = 128, so the closest the ship gets to us is
 STA INWK+6             \ z_hi * 256 + 128 (where z_hi is the value in the
                        \ ship_dist table)

 ASL A                  \ Set A = 0

 STA INWK               \ Set x_lo = 0, so the ship remains in the screen centre

 STA INWK+3             \ Set y_lo = 0, so the ship remains in the screen centre

 JSR LL9                \ Call LL9 to display the ship

 DEC MCNT               \ Decrement the main loop counter

 JSR check_keys         \ Call check_keys to wait until a key is pressed,
                        \ quitting the game if the game if COPY (pause) and
                        \ ESCAPE are pressed

 CPX #0                 \ If check_keys returns with X = 0, then we paused the
 BEQ l_395a             \ game with COPY and then unpaused it with DELETE, in
                        \ which case loop back to l_395a to keep rotating the
                        \ ship

 JMP BAY                \ Otherwise a key was pressed, so jump to BAY to go to
                        \ the docking bay (i.e. show the Encyclopedia screen)

\ ******************************************************************************
\
\       Name: controls
\       Type: Subroutine
\   Category: Encyclopedia
\    Summary: Show the Controls menu and display the chosen page
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.controls

 LDX #3                 \ Call menu with X = 3 to show menu 3, the Controls
 JSR menu               \ menu, and return the choice in A, so A is now:
                        \
                        \   * 1 = Flight
                        \   * 2 = Combat
                        \   * 3 = Navigation
                        \   * 4 = Trading

 ADC #86                \ Store the choice + 86 on the stack, to give the token
 PHA                    \ number of the body to show for the relevant choice,
                        \ from flight controls (token 87) to trading controls
                        \ (token 90)

 ADC #4                 \ Store the choice + 90 on the stack, to give the token
 PHA                    \ number of the title to show for the relevant choice,
                        \ from flight controls (token 91) to trading controls
                        \ (token 94)

 LDA #32                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32

 JSR MT1                \ Switch to ALL CAPS when printing extended tokens

 LDA #11                \ Move the text cursor to column 11
 STA XC

 PLA                    \ Pull the token number for the title from the stack
 JSR write_msg3         \ (choice + 90) and print it

 JSR NLIN4              \ Draw a horizontal line at pixel row 19 to box in the
                        \ title

 JSR MT2                \ Switch to Sentence Case when printing extended tokens

 INC YC                 \ Move the text cursor down one line

 PLA                    \ Pull the token number for the body from the stack
 JSR write_msg3         \ (choice + 86) and print it

 JMP l_restart          \ Jump to l_restart to wait until a key is pressed and
                        \ show the Encyclopedia screen

\ ******************************************************************************
\
\       Name: equip_data
\       Type: Subroutine
\   Category: Encyclopedia
\    Summary: Show the Equipment menu and display the chosen page
\
\ ******************************************************************************

.equip_data

 LDX #4                 \ Call menu with X = 4 to show menu 4, the Equipment
 JSR menu               \ menu, and return the choice in A, so A is now:
                        \
                        \   *  1 = Missiles
                        \   *  2 = I.F.F. system
                        \   *  3 = E.C.M. system
                        \   *  4 = Pulse lasers
                        \   *  5 = Beam lasers
                        \   *  6 = Fuel scoops
                        \   *  7 = Escape pod
                        \   *  8 = Hyperspace unit
                        \   *  9 = Energy unit
                        \   * 10 = Docking computers
                        \   * 11 = Galactic hyperdrive
                        \   * 12 = Military lasers
                        \   * 13 = Mining lasers

 ADC #107               \ Store the choice + 107 on the stack, to give the token
 PHA                    \ number of the body to show for the relevant choice,
                        \ from missiles (token 108) to mining lasers (token 120)

 SBC #12                \ Store the choice + 94 on the stack, to give the token
 PHA                    \ number of the title to show for the relevant choice,
                        \ from missiles (token 95) to mining lasers (token 107)

 LDA #32                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32

 JSR MT1                \ Switch to ALL CAPS when printing extended tokens

 LDA #11                \ Move the text cursor to column 11
 STA XC

 PLA                    \ Pull the token number for the title from the stack
 JSR write_msg3         \ (choice + 95) and print it

 JSR NLIN4              \ Draw a horizontal line at pixel row 19 to box in the
                        \ title

 JSR MT2                \ Switch to Sentence Case when printing extended tokens
                        \ (though this gets overridden by the following
                        \ instruction, so this has no effect)

 JSR MT13               \ Switch to lower case when printing extended tokens, so
                        \ the text is shown in justified paragraphs of lower
                        \ case text

 INC YC                 \ Move the text cursor down two lines
 INC YC

 LDA #1                 \ Move the text cursor to column 1
 STA XC

 PLA                    \ Pull the token number for the body from the stack
 JSR write_msg3         \ (choice + 107) and print it

 JMP l_restart          \ Jump to l_restart to wait until a key is pressed and
                        \ show the Encyclopedia screen

\ ******************************************************************************
\
\       Name: trading
\       Type: Subroutine
\   Category: Encyclopedia
\    Summary: Wait until a key is pressed and show the Encyclopedia screen
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   l_restart           Does exactly the same as a call to trading
\
\ ******************************************************************************

.trading

.l_restart

 JSR check_keys         \ Call check_keys to wait until a key is pressed,
                        \ quitting the game if the game if COPY (pause) and
                        \ ESCAPE are pressed

 TXA                    \ Copy the number of the key pressed into A

 BEQ l_restart          \ If check_keys returned with X = 0, then we paused the
                        \ game with COPY and then unpaused it with DELETE, in
                        \ which case loop back to l_restart to keep checking for
                        \ key presses

 JMP BAY                \ Jump to BAY to go to the docking bay (i.e. show the
                        \ Encyclopedia screen)

\ ******************************************************************************
\
\       Name: check_keys
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Wait until a key is pressed, quitting the game if the game is
\             paused and ESCAPE is pressed
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   The key that was pressed, or 0 if we paused the game
\                       (COPY) and unpaused it again (DELETE)
\
\ Other entry points:
\
\   l_release           If a key is currently being pressed, wait until it is
\                       released
\
\ ******************************************************************************

.check_keys

 JSR WSCAN              \ Call WSCAN to wait for the vertical sync

 JSR RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press)

 CPX #&69               \ If COPY is not being pressed, jump to not_freeze to
 BNE not_freeze         \ return the key pressed in X

.freeze_loop

 JSR WSCAN              \ Call WSCAN to wait for the vertical sync

 JSR RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press)

 CPX #&70               \ If ESCAPE is not being pressed, jump to dont_quit to
 BNE dont_quit          \ skip the next

 JMP DEATH2             \ ESCAPE is being pressed, so jump to DEATH2 to end the
                        \ game

.dont_quit

\CPX #&37               \ These instructions are commented out in the original
\BNE dont_dump          \ source
\JSR printer
\.dont_dump

 CPX #&59               \ If DELETE is not being pressed, we are still paused,
 BNE freeze_loop        \ so loop back up to keep listening for configuration
                        \ keys, otherwise fall through into the rest of the
                        \ key detection code, which waits for the key to be
                        \ released before unpausing the game

.l_release

 JSR RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press)

 BNE l_release          \ If a key is being pressed, loop back to l_release
                        \ until it is released

 LDX #0                 \ Set X = 0 to indicate no key is being pressed

.not_freeze

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: write_card
\       Type: Subroutine
\   Category: Encyclopedia
\    Summary: Display a ship card in the encyclopedia
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of the ship whose card we want to display,
\                       in the range 0 to 27 (see card_addr for a list of
\                       ship numbers)
\
\ ******************************************************************************

.write_card

 ASL A                  \ Set Y = A * 2, so we can use it as an index into the
 TAY                    \ card_addr table (which has two bytes per entry)

 LDA card_addr,Y        \ Set V(1 0) to the Y-th entry from card_addr, so it
 STA V                  \ points to the data for the ship card that we want to
 LDA card_addr+1,Y      \ show
 STA V+1

.card_repeat

                        \ We now loop around card_repeat, with each iteration
                        \ printing a different section of the ship card. We
                        \ update V(1 0) so it always points to the data to print
                        \ in the ship card, and we look up the corresponding
                        \ section of the card_pattern table to see how to lay
                        \ out the card (card_pattern contains text coordinates
                        \ and label data that describe the layout of the ship
                        \ cards)

 JSR MT1                \ Switch to ALL CAPS when printing extended tokens

 LDY #0                 \ Fetch the byte at V(1 0) into X, which will either be
 LDA (V),Y              \ the number of a card section (e.g. 1 for inservice
 TAX                    \ date, 2 for combat factor and so on), or a 0 if we
                        \ have reached the end of the card data

 BEQ quit_card          \ If the byte we just fetched is a zero, jump to
                        \ quit_card to return from the subroutine, as we have
                        \ reached the end of the card data

 BNE card_check         \ Otherwise we have found a valid card section, so jump
                        \ to card_check to start looking for the corresponding
                        \ layout pattern in card_pattern (the BNE is effectively
                        \ a JMP as we just passed through a BEQ)

.card_find

                        \ If we get here than we want to increment Y until it
                        \ points to the start of the next pattern that comes
                        \ after our current position of card_pattern + Y

 INY                    \ Increment Y by 3 to step to the next line of data (as
 INY                    \ the card_pattern table is made up of lines of 3 bytes
 INY                    \ each)

 LDA card_pattern-1,Y   \ Fetch the last byte of the previous 3-byte line

 BNE card_find          \ If it is non-zero then we are still in the same
                        \ pattern as in the previous iteration, so loop back to
                        \ move onto the next line of 3 bytes

                        \ Otherwise we have moved onto the next pattern, so now
                        \ we check whether we have reached the pattern we seek

.card_check

                        \ When we first jump here from above, we want to search
                        \ through the card_pattern table for the pattern that
                        \ corresponds to card section X, where X starts at 1. We
                        \ also jump here with Y set to 0
                        \
                        \ We find what we are looking for by stepping through
                        \ each pattern, decreasing X as we go past each pattern,
                        \ and increasing Y so that Y points to the start of the
                        \ next pattern to check (as an offset from card_pattern)
                        \
                        \ So as we iterate round the loop, at any one point, we
                        \ want to skip over X - 1 more patterns, starting from
                        \ the pattern at card_pattern + Y

 DEX                    \ Decrement the section number in X

 BNE card_find          \ If X hasn't reached 0, then we haven't stepped through
                        \ the right number of patterns yet, so jump to card_find
                        \ to increment Y so that it points to the start of the
                        \ next pattern in card_pattern

.card_found

                        \ When we get here, we have stepped through the correct
                        \ number of patterns for the card section we want to
                        \ print, and Y will point to the pattern within the
                        \ card_pattern table that corresponds to the section we
                        \ want to print, so we now fetch the pattern from
                        \ card_pattern and print the data in that pattern
                        \
                        \ The pattern for each section is made up of multiple
                        \ lines of 3 bytes each, with each line consisting of:
                        \
                        \   * Text column
                        \   * Text row
                        \   * What to print (i.e. a label or ship data)

 LDA card_pattern,Y     \ The first byte of each 3-byte line in the pattern is
 STA XC                 \ the x-coordinate where we should print the text, so
                        \ move the text cursor to the correct column

 LDA card_pattern+1,Y   \ The second byte of each 3-byte line in the pattern
 STA YC                 \ is the y-coordinate where we should print the text, so
                        \ move the text cursor to the correct row

 LDA card_pattern+2,Y   \ The third byte of each 3-byte line in the pattern is
                        \ either a text token to print for the label (if it's
                        \ non-zero) or it denotes that we should print the
                        \ relevant ship data (if it's zero), so fetch the value
                        \ into A

 BEQ card_details       \ If A = 0 then we should print the relevant ship data,
                        \ so jump to card_details to do just that

 JSR write_msg3         \ Otherwise this is a label, so print the text token in
                        \ A, which prints the label in the right place

 INY                    \ We now need to fetch the next line of the pattern, so
 INY                    \ we increment Y by 3 to step to the next 3-byte line of
 INY                    \ pattern data

 BNE card_found         \ Loop back to card_found to move onto the next line in
                        \ the pattern (the BNE is effectively a JMP as Y is
                        \ never zero)

.card_details

                        \ If we get here, then we have printed all the labels in
                        \ the pattern, and it's time to print the ship data,
                        \ which is at V(1 0) (the first time we get here, V(1 0)
                        \ points to the start of the ship data, and as we loop
                        \ through each bit of data, we update V(1 0) so that it
                        \ always points to the next bit of data to print)

 JSR MT2                \ Switch to Sentence Case when printing extended tokens

 LDY #0                 \ We now loop through each character or token in the
                        \ ship data, which is stored as a recursive token, so
                        \ set a counter in Y for each character or token in the
                        \ ship data (we start this at 0 and increment it
                        \ straight away, as the first byte in the ship data at
                        \ V(1 0) is the section number, rather than the data
                        \ itself

.card_loop

 INY                    \ Increment the character counter to point to the next
                        \ character or token in the ship data

 LDA (V),Y              \ Set A to the next character or token to print

 BEQ card_end           \ If A = 0 then we have reached the end of this bit of
                        \ ship data, so jump to card_end to move onto the next
                        \ one

 BMI card_msg           \ If A > 127 then this is a recursive token, so jump to
                        \ card_msg to print it

 CMP #32                \ If A < 32 then this is a jump token, so jump to
 BCC card_macro         \ card_macro to print it

 JSR DTS                \ Otherwise this is a character rather than a token, so
                        \ call DTS to print it in the correct case

 JMP card_loop          \ Jump back to card_loop to print the next token in the
                        \ ship data

.card_macro

 JSR DT3                \ Call DT3 to print the jump token given in A

 JMP card_loop          \ Jump back to card_loop to print the next token in the
                        \ ship data

.card_msg

 CMP #215               \ If A >= 215, then this is a two-letter token, so jump
 BCS card_pairs         \ to card_pairs to print it

 AND #%01111111         \ This is a recursive token and A is in the range 128 to
                        \ 214, so clear bit 7 to reduce it to the range 0 to 86,
                        \ which corresponds to tokens in the msg_3 table (as we
                        \ set bit 7 when inserting msg_3 tokens into the ship
                        \ data with the CTOK macro)

 JSR write_msg3         \ Print the extended token in A

 JMP card_loop          \ Jump back to card_loop to print the next token in the
                        \ ship data

.card_pairs

 JSR msg_pairs          \ Print the extended two-letter token in A

 JMP card_loop          \ Jump back to card_loop to print the next token in the
                        \ ship data

.card_end

                        \ We have now printed this bit of ship data and the last
                        \ character we printed was at V(1 0) + Y, so we now
                        \ update V(1 0) so that it points to the first byte of
                        \ the next bit of ship data, by doing this:
                        \
                        \   V(1 0) = V(1 0) + Y + 1

 TYA                    \ First we add the low bytes, setting the C flag to add
 SEC                    \ an extra 1
 ADC V
 STA V

 BCC card_repeat        \ If the above addition didn't overflow, we are done, so
                        \ loop back to card_repeat to move onto the next bit of
                        \ ship data

 INC V+1                \ The addition overflowed, so increment the high byte,
                        \ as V(1 0) just passed a page boundary

 BCS card_repeat        \ Loop back to card_repeat to move onto the next bit of
                        \ ship data (this BCS is effectively a JMP as we passed
                        \ through the BCC above)

.quit_card

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ship_posn
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Table containing the number of this ship in the ship_list table
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.ship_posn

 EQUB 20                \ Adder
 EQUB 13                \ Anaconda
 EQUB 23                \ Asp Mk II
 EQUB 12                \ Boa
 EQUB 33                \ Bushmaster
 EQUB 37                \ Chameleon
 EQUB 22                \ Cobra Mk I
 EQUB 10                \ Cobra Mk III
 EQUB 1                 \ Coriolis station
 EQUB 0                 \ Dodo station
 EQUB 2                 \ Escape Pod
 EQUB 24                \ Fer-de-Lance
 EQUB 21                \ Gecko
 EQUB 32                \ Ghavial
 EQUB 35                \ Iguana
 EQUB 19                \ Krait
 EQUB 18                \ Mamba
 EQUB 30                \ Monitor
 EQUB 25                \ Moray
 EQUB 31                \ Ophidian
 EQUB 11                \ Python
 EQUB 8                 \ Shuttle
 EQUB 17                \ Sidewinder
 EQUB 26                \ Thargoid
 EQUB 27                \ Thargon
 EQUB 9                 \ Transporter
 EQUB 16                \ Viper
 EQUB 14                \ Worm

\ ******************************************************************************
\
\       Name: ship_dist
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Table containing the closest distance to show the ship for each
\             ship card
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.ship_dist

 EQUB 1                 \ Adder
 EQUB 2                 \ Anaconda
 EQUB 1                 \ Asp Mk II
 EQUB 2                 \ Boa
 EQUB 1                 \ Bushmaster
 EQUB 1                 \ Chameleon
 EQUB 1                 \ Cobra Mk I
 EQUB 2                 \ Cobra Mk III
 EQUB 4                 \ Coriolis station
 EQUB 4                 \ Dodo station
 EQUB 1                 \ Escape Pod
 EQUB 1                 \ Fer-de-Lance
 EQUB 1                 \ Gecko
 EQUB 2                 \ Ghavial
 EQUB 1                 \ Iguana
 EQUB 2                 \ Krait
 EQUB 1                 \ Mamba
 EQUB 2                 \ Monitor
 EQUB 1                 \ Moray
 EQUB 1                 \ Ophidian
 EQUB 2                 \ Python
 EQUB 1                 \ Shuttle
 EQUB 1                 \ Sidewinder
 EQUB 3                 \ Thargoid
 EQUB 1                 \ Thargon
 EQUB 1                 \ Transporter
 EQUB 1                 \ Viper
 EQUB 1                 \ Worm

\ ******************************************************************************
\
\       Name: menu
\       Type: Subroutine
\   Category: Encyclopedia
\    Summary: Display a menu and ask for a choice
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the menu to display (0 to 4)
\
\ Returns:
\
\   A                   The number entered
\
\   R                   Also contains the number entered
\
\   C flag              Set if the number is too large, clear otherwise
\
\ ******************************************************************************

.menu

 LDA menu_entry,X       \ Store the menu's size (i.e. the number of entries) in
 STA QQ25               \ QQ25

 LDA menu_offset,X      \ Store the token number of the menu's first item in
 STA QQ29               \ QQ29

 LDA menu_query,X       \ Store the menu's query token number on the stack,
 PHA                    \ which contains the query prompt we show at the bottom
                        \ of the menu

 LDA menu_title,X       \ Store the menu's title token number on the stack
 PHA

 LDA menu_titlex,X      \ Store the menu's title x-coordinate on the stack
 PHA

 LDA #32                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32

 JSR MT1                \ Switch to ALL CAPS when printing extended tokens

 PLA                    \ Retrieve the menu's title x-coordinate from the stack
 STA XC                 \ and move the text cursor to it

 PLA                    \ Retrieve the menu's title token number from the stack
 JSR write_msg3         \ and print it (the menu tokens are in the msg_3 table)

 JSR NLIN4              \ Draw a horizontal line at pixel row 19 to box in the
                        \ title

 INC YC                 \ Move the text cursor down a line

 LDX #0                 \ We are now going to work our way through the items in
                        \ the menu, printing as we go, so set a counter in X to
                        \ hold the number of the current item (starting from 0)

.menu_loop

 STX XX13               \ Store the current menu item number in XX13

 JSR TT67               \ Print a newline

 LDX XX13               \ Print the current item number + 1 to 3 digits, left-
 INX                    \ padding with spaces, and with no decimal point, so the
 CLC                    \ items are numbered from 1
 JSR pr2

 JSR TT162              \ Print a space

 JSR MT2                \ Switch to Sentence Case when printing extended tokens

 LDA #%10000000         \ Set bit 7 of QQ17 to switch standard tokens to
 STA QQ17               \ Sentence Case

 CLC                    \ Set A = XX13 + QQ29
 LDA XX13               \
 ADC QQ29               \ This will contain the token number for the first entry
                        \ in this menu, as QQ29 contains the number of the first
                        \ token in this menu, and XX13 contains the number of
                        \ this entry within the menu

 JSR write_msg3         \ Print the extended token for this menu item (the menu
                        \ tokens are in the msg_3 table)

 LDX XX13               \ Fetch the menu item number from XX13

 INX                    \ Increment the menu item number to point to the next
                        \ item

 CPX QQ25               \ Loop back to menu_loop until we have shown all QQ25
 BCC menu_loop          \ menu items

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

 PLA                    \ Retrieve the menu's query token number from the stack
 JSR write_msg3         \ and print it

 LDA #'?'               \ Print a question mark
 JSR DASC

 JSR gnum               \ Call gnum to get a number from the keyboard, which
                        \ will be the menu item number of the menu item we want
                        \ to show, returning the number entered in A and R, and
                        \ setting the C flag if the number is bigger than the
                        \ highest menu item number in QQ25

 BEQ menu_start         \ If no number was entered, jump to menu_start to show
                        \ the cargo bay

 BCS menu_start         \ If the number entered was too big, jump to menu_start
                        \ show the cargo bay

 RTS                    \ Return from the subroutine

.menu_start

 JMP BAY                \ Jump to BAY to go to the docking bay (i.e. show the
                        \ Encyclopedia screen)

\ ******************************************************************************
\
\       Name: menu_title
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Table containing text token numbers for each menu's title
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Text tokens for the menu system can be found in the msg_3 table.
\
\ The menus are as follows:
\
\   0 = Encyclopedia Galactica
\   1 = Ships A-G
\   2 = Ships I-W
\   3 = Controls
\   4 = Equipment
\
\ ******************************************************************************

.menu_title

 EQUB 1                 \ Menu 0: Title is text token 1:
                        \
                        \   "ENCYCLOPEDIA GALACTICA"

 EQUB 2                 \ Menu 1: Title is text token 2:
                        \
                        \   "SHIPS {all caps}A-G{sentence case}"

 EQUB 3                 \ Menu 2: Title is text token 3:
                        \
                        \   "SHIPS {all caps}I-W{sentence case}"

 EQUB 5                 \ Menu 3: Title is text token 5:
                        \
                        \   "CONTROLS"

 EQUB 4                 \ Menu 4: Title is text token 4:
                        \
                        \   "EQUIPMENT"

\ ******************************************************************************
\
\       Name: menu_titlex
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Table containing column positions for each menu's title
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Text tokens for the menu system can be found in the msg_3 table.
\
\ The menus are as follows:
\
\   0 = Encyclopedia Galactica
\   1 = Ships A-G
\   2 = Ships I-W
\   3 = Controls
\   4 = Equipment
\
\ ******************************************************************************

.menu_titlex

 EQUB 5                 \ Menu 0: Show menu title at column 5

 EQUB 12                \ Menu 1: Show menu title at column 12

 EQUB 12                \ Menu 2: Show menu title at column 12

 EQUB 12                \ Menu 3: Show menu title at column 12

 EQUB 11                \ Menu 4: Show menu title at column 11

\ ******************************************************************************
\
\       Name: menu_offset
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Table containing token numbers for the first item in each menu
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Text tokens for the menu system can be found in the msg_3 table.
\
\ The menus are as follows:
\
\   0 = Encyclopedia Galactica
\   1 = Ships A-G
\   2 = Ships I-W
\   3 = Controls
\   4 = Equipment
\
\ ******************************************************************************

.menu_offset

 EQUB 2                 \ Menu 0: First item is text token 2:
                        \
                        \   "SHIPS {all caps}A-G{sentence case}"

 EQUB 7                 \ Menu 1: First item is text token 7:
                        \
                        \   "ADDER"

 EQUB 21                \ Menu 2: First item is text token 21:
                        \
                        \   "KRAIT"

 EQUB 91                \ Menu 3: First item is text token 91:
                        \
                        \   "FLIGHT"

 EQUB 95                \ Menu 4: First item is text token 95:
                        \
                        \   "{standard tokens, sentence case}
                        \    MISSILE{extended tokens}"

\ ******************************************************************************
\
\       Name: menu_entry
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Table containing the number of entries in each menu
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Text tokens for the menu system can be found in the msg_3 table.
\
\ The menus are as follows:
\
\   0 = Encyclopedia Galactica
\   1 = Ships A-G
\   2 = Ships I-W
\   3 = Controls
\   4 = Equipment
\
\ ******************************************************************************

.menu_entry

 EQUB 4                 \ Menu 0: Contains 4 entries

 EQUB 14                \ Menu 1: Contains 14 entries

 EQUB 14                \ Menu 2: Contains 14 entries

 EQUB 4                 \ Menu 3: Contains 4 entries

 EQUB 13                \ Menu 4: Contains 13 entries

\ ******************************************************************************
\
\       Name: menu_query
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Table containing token numbers for each menu's query prompt
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Text tokens for the menu system can be found in the msg_3 table.
\
\ The menus are as follows:
\
\   0 = Encyclopedia Galactica
\   1 = Ships A-G
\   2 = Ships I-W
\   3 = Controls
\   4 = Equipment
\
\ ******************************************************************************

.menu_query

 EQUB 6                 \ Menu 0: Query prompt is text token 6:
                        \
                        \   "INFORMATION"

 EQUB 67                \ Menu 1: Query prompt is text token 67:
                        \
                        \   " SHIP"

 EQUB 67                \ Menu 2: Query prompt is text token 67:
                        \
                        \   " SHIP"

 EQUB 5                 \ Menu 3: Query prompt is text token 5:
                        \
                        \   "CONTROLS"

 EQUB 4                 \ Menu 4: Query prompt is text token 4:
                        \
                        \   "EQUIPMENT"

\ ******************************************************************************
\
\       Name: ship_centre
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Table containing column positions for each ship card's title
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.ship_centre

 EQUB 13                \ Adder
 EQUB 12                \ Anaconda
 EQUB 12                \ Asp Mk II
 EQUB 11                \ Boa
 EQUB 13                \ Bushmaster
 EQUB 12                \ Chameleon
 EQUB 11                \ Cobra Mk I
 EQUB 11                \ Cobra Mk III
 EQUB 8                 \ Coriolis station
 EQUB 7                 \ Dodo station
 EQUB 9                 \ Escape Pod
 EQUB 10                \ Fer-de-Lance
 EQUB 13                \ Gecko
 EQUB 12                \ Ghavial
 EQUB 13                \ Iguana
 EQUB 13                \ Krait
 EQUB 13                \ Mamba
 EQUB 12                \ Monitor
 EQUB 13                \ Moray
 EQUB 12                \ Ophidian
 EQUB 13                \ Python
 EQUB 12                \ Shuttle
 EQUB 11                \ Sidewinder
 EQUB 12                \ Thargoid
 EQUB 12                \ Thargon
 EQUB 10                \ Transporter
 EQUB 13                \ Viper
 EQUB 14                \ Worm

\ ******************************************************************************
\
\       Name: card_pattern
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Layout pattern for the encyclopedia's ship cards
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ Each ship card in the encyclopedia consists of multiple sections, each of
\ which consists of one or more text labels, plus the corresponding ship data.
\ The card pattern table defines these sections and how they are laid out on
\ screen - in other words, this table contains a set of patterns, one for each
\ section, that define how to lay out that section on-screen.
\
\ Each line in the table below defines a screen position and something to print
\ there. The first two numbers are the text column and row, and the third number
\ specifies a text token from the msg_3 table (when non-zero) or the actual data
\ (when zero).
\
\ So, for example, the "cargo space" section looks like this:
\
\   EQUB  1, 12, 61
\   EQUB  1, 13, 45
\   EQUB  1, 14,  0
\
\ which defines the following layout pattern:
\
\   * Token 61 ("CARGO") at column 1, row 12
\   * Token 45 ("SPACE:") at column 1, row 13
\   * The relevant ship data (the ship's cargo capacity) at column 1, row 14
\
\ The data itself comes from the card data for the specific ship - see the table
\ at card_addr for a list of card data blocks. Each section corresponds to the
\ same section number in the card data, so the cargo space section is number 7,
\ for example.
\
\ As well as the ship data, the ship cards show the ship itself, rotating in the
\ middle of the card.
\
\ ******************************************************************************

.card_pattern

 EQUB  1,  3, 37        \ 1: Inservice date           "INSERVICE DATE:" @ (1, 3)
 EQUB  1,  4,  0        \                                          Data @ (1, 4)

 EQUB 24,  6, 38        \ 2: Combat factor                    "COMBAT" @ (24, 6)
 EQUB 24,  7, 47        \                                    "FACTOR:" @ (24, 7)
 EQUB 24,  8, 65        \                                         "CF" @ (24, 8)
 EQUB 26,  8,  0        \                                         Data @ (26, 8)

 EQUB  1,  6, 43        \ 3: Dimensions                   "DIMENSIONS:" @ (1, 6)
 EQUB  1,  7,  0        \                                          Data @ (1, 7)

 EQUB  1,  9, 36        \ 4: Speed                            "SPEED:" @ (1,  9)
 EQUB  1, 10,  0        \                                         Data @ (1, 10)

 EQUB 24, 10, 39        \ 5: Crew                             "CREW:" @ (24, 10)
 EQUB 24, 11,  0        \                                        Data @ (24, 11)

 EQUB 24, 13, 41        \ 6: Range                           "RANGE:" @ (24, 13)
 EQUB 24, 14,  0        \                                        Data @ (24, 14)

 EQUB  1, 12, 61        \ 7: Cargo space                       "CARGO" @ (1, 12)
 EQUB  1, 13, 45        \                                     "SPACE:" @ (1, 13)
 EQUB  1, 14,  0        \                                        Data  @ (1, 14)

 EQUB  1, 16, 35        \ 8: Armaments                    "ARMAMENTS:" @ (1, 16)
 EQUB  1, 17,  0        \                                         Data @ (1, 17)

 EQUB 23, 20, 44        \ 9: Hull                             "HULL:" @ (23, 20)
 EQUB 23, 21,  0        \                                        Data @ (23, 21)

 EQUB  1, 20, 40        \ 10: Drive motors             "DRIVE MOTORS:" @ (1, 20)
 EQUB  1, 21,  0        \                                         Data @ (1, 21)

 EQUB  1, 20, 45        \ 11: Space                           "SPACE:" @ (1, 20)
 EQUB  1, 21,  0        \                                         Data @ (1, 21)

\ ******************************************************************************
\
\       Name: card_addr
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Lookup table for the encyclopedia's ship cards
\  Deep dive: The Encyclopedia Galactica
\
\ ------------------------------------------------------------------------------
\
\ The numbers in the table below give the ship type that can be passed to
\ routines like write_card.
\
\ ******************************************************************************

.card_addr

 EQUW adder             \  0: Adder
 EQUW anaconda          \  1: Anaconda
 EQUW asp_2             \  2: Asp Mk II
 EQUW boa               \  3: Boa
 EQUW bushmaster        \  4: Bushmaster
 EQUW chameleon         \  5: Chameleon
 EQUW cobra_1           \  6: Cobra Mk I
 EQUW cobra_3           \  7: Cobra Mk III
 EQUW coriolis          \  8: Coriolis station
 EQUW dodecagon         \  9: Dodo station
 EQUW escape_pod        \ 10: Escape pod
 EQUW fer_de_lance      \ 11: Fer-de-Lance
 EQUW gecko             \ 12: Gecko
 EQUW ghavial           \ 13: Ghavial
 EQUW iguana            \ 14: Iguana
 EQUW krait             \ 15: Krait
 EQUW mamba             \ 16: Mamba
 EQUW monitor           \ 17: Monitor
 EQUW moray             \ 18: Moray
 EQUW ophidian          \ 19: Ophidian
 EQUW python            \ 20: Python
 EQUW shuttle           \ 21: Shuttle
 EQUW sidewinder        \ 22: Sidewinder
 EQUW thargoid          \ 23: Thargoid
 EQUW thargon           \ 24: Thargon
 EQUW transporter       \ 25: Transporter
 EQUW viper             \ 26: Viper
 EQUW worm              \ 27: Worm

\ ******************************************************************************
\
\       Name: CTOK
\       Type: Macro
\   Category: Text
\    Summary: Macro definition for ship data in the encyclopedia's ship cards
\  Deep dive: Extended text tokens
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used when building the ship data:
\
\   CTOK n              Insert recursive token [n]
\
\                         * Tokens 0-127 get stored as n + 128
\
\ The ship data tables work differently to the recursive token tables. Data is
\ stored in the table as follows:
\
\   Value        Contents                                                  Macro
\   -----        --------                                                  -----
\   0-31         Jump tokens                                               EJMP
\   32-127       ASCII characters with no obfuscation                      EQUS
\   128-214      Recursive msg_3 text tokens (subtract 128 to get 0-86)    CTOK
\   215-255      Extended two-letter tokens (subtract 215 to get 0-40)     ETWO
\
\ Printing of ship data is handled by the write_card routine.
\
\ Arguments:
\
\   n                   The number of the recursive token to insert into the
\                       table, in the range 0 to 127
\
\ ******************************************************************************

MACRO CTOK n

 EQUB n + 128

ENDMACRO

\ ******************************************************************************
\
\       Name: adder
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Adder
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.adder

 EQUB 1                 \ 1: Inservice date:  "2914 ({single cap}OUTWORLD
 EQUS "2914"            \                      WORKSHOPS)"
 CTOK 85                \
 CTOK 69                \ Encoded as:         "2914[85][69][81]"
 CTOK 81
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "6"
 EQUS "6"               \
 EQUB 0                 \ Encoded as:         "6"

 EQUB 3                 \ 3: Dimensions:      "45/8/30FT"
 EQUS "45/8/30"         \
 CTOK 42                \ Encoded as:         "45/8/30[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.24{all caps}LM{sentence case}"
 EQUS "0.24"            \
 CTOK 64                \ Encoded as:         "0.24[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1"
 EQUS "1"               \
 EQUB 0                 \ Encoded as:         "1"

 EQUB 6                 \ 6: Range:           "6{all caps}LY{sentence case}"
 EQUS "6"               \
 CTOK 63                \ Encoded as:         "6[63]"
 EQUB 0

IF _RELEASED OR _SOURCE_DISC

 EQUB 7                 \ 7: Cargo space:     "4{all caps}TC{sentence case}"
 EQUS "4"               \
 CTOK 62                \ Encoded as:         "4[62]"
 EQUB 0

ELIF _BUG_FIX

 EQUB 7                 \ 7: Cargo space:     "8{all caps}TC{sentence case}"
 EQUS "8"               \
 CTOK 62                \ Encoded as:         "8[62]"
 EQUB 0

ENDIF

 EQUB 8                 \ 8: Armaments:       "INGRAM 1928 AZ BEAM LASER{cr}
 CTOK 56                \                      GERET STARSEEKER MISSILES"
 EQUS " 1928 AZ "       \
 ETWO 'B', 'E'          \ Encoded as:         "[56] 1928 AZ <247>am[49]{12}[48]
 EQUS "am"              \                      [46]"
 CTOK 49
 EJMP 12
 CTOK 48
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "D4-18{all caps}/2L{sentence
 EQUS "D4-18"           \                      case}"
 CTOK 83                \
 EQUB 0                 \ Encoded as:         "D4-18[83]"

 EQUB 10                \ 10: Drive motors:   "AM 18 BI THRUST"
 EQUS "AM 18 "          \
 ETWO 'B', 'I'          \ Encoded as:         "AM 18 <234> [66]"
 EQUS " "
 CTOK 66
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: anaconda
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Anaconda
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.anaconda

 EQUB 1                 \ 1: Inservice date:  "2856 ({single cap}RIMLINER
 EQUS "2856"            \                      GALACTIC)"
 CTOK 85                \
 EQUS "Riml"            \ Encoded as:         "2856[85]Riml<240><244> G<228>ac
 ETWO 'I', 'N'          \                      <251>c)"
 ETWO 'E', 'R'
 EQUS " G"
 ETWO 'A', 'L'
 EQUS "ac"
 ETWO 'T', 'I'
 EQUS "c)"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "3"
 EQUS "3"               \
 EQUB 0                 \ Encoded as:         "3"

 EQUB 3                 \ 3: Dimensions:      "170/60/75FT"
 EQUS "170/60/75"       \
 CTOK 42                \ Encoded as:         "170/60/75[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.14{all caps}LM{sentence case}"
 EQUS "0.14"            \
 CTOK 64                \ Encoded as:         "0.14[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "2-10"
 EQUS "2-10"            \
 EQUB 0                 \ Encoded as:         "2-10"

 EQUB 6                 \ 6: Range:           "10{all caps}LY{sentence case}"
 EQUS "10"              \
 CTOK 63                \ Encoded as:         "10[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "245{all caps}TC{sentence case}"
 EQUS "245"             \
 CTOK 62                \ Encoded as:         "245[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "HASSONI HI-RAD PULSE LASER{cr}
 CTOK 59                \                      GERET STARSEEKER MISSILES"
 EQUS " Hi-"            \
 ETWO 'R', 'A'          \ Encoded as:         "[59] Hi-<248>d[50][49]{12}[48]
 EQUS "d"               \                      [46]"
 CTOK 50
 CTOK 49
 EJMP 12
 CTOK 48
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "M8-**{all caps}/4L{sentence
 EQUS "M8-**"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "M8-**[84]"

 EQUB 10                \ 10: Drive motors:   "V & K 32.24{cr}
 CTOK 73                \                      ERGMASTERS"
 EQUS "32.24"           \
 EJMP 12                \ Encoded as:         "[73]32.24{12}<244>g<239><222>
 ETWO 'E', 'R'          \                      <244>s"
 EQUS "g"
 ETWO 'M', 'A'
 ETWO 'S', 'T'
 ETWO 'E', 'R'
 EQUS "s"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: asp_2
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Asp Mk II
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.asp_2

 EQUB 1                 \ 1: Inservice date:  "2878 ({single cap}GALCOP
 EQUS "2878"            \                      WORKSHOPS)"
 CTOK 85                \
 EQUS "G"               \ Encoded as:         "2878[85]G<228>cop[81]"
 ETWO 'A', 'L'
 EQUS "cop"
 CTOK 81
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "6"
 EQUS "6"               \
 EQUB 0                 \ Encoded as:         "6"

 EQUB 3                 \ 3: Dimensions:      "70/20/65FT"
 EQUS "70/20/65"        \
 CTOK 42                \ Encoded as:         "70/20/65[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.40{all caps}LM{sentence case}"
 EQUS "0.40"            \
 CTOK 64                \ Encoded as:         "0.40[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1"
 EQUS "1"               \
 EQUB 0                 \ Encoded as:         "1"

 EQUB 6                 \ 6: Range:           "12.5{all caps}LY{sentence case}"
 EQUS "12.5"            \
 CTOK 63                \ Encoded as:         "12.5[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "0{all caps}TC{sentence case}"
 EQUS "0"               \
 CTOK 62                \ Encoded as:         "0[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "HASSONI-{single cap}KRUGER BURST
 CTOK 59                \                      LASER{cr}
 EQUS "-"               \                      GERET STARSEEKER MISSILES"
 CTOK 58                \
 EQUS "Bur"             \ Encoded as:         "[59]-[58]Bur<222>[49]{12}[48]
 ETWO 'S', 'T'          \                      [46]"
 CTOK 49
 EJMP 12
 CTOK 48
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "J6-31{all caps}/1L{sentence
 EQUS "J6-31"           \                      case}"
 CTOK 82                \
 EQUB 0                 \ Encoded as:         "J6-31[82]"

 EQUB 10                \ 10: Drive motors:   "VOLTAIRE WHIPLASH{cr}
 CTOK 60                \                      {all caps}HK{sentence case}
 EQUS " Whip"           \                      PULSEDRIVE"
 ETWO 'L', 'A'          \
 EQUS "sh"              \ Encoded as:         "[60] Whip<249>sh{12}{all caps}HK
 EJMP 12                \                      {sentence case} [50][53]"
 EJMP 1
 EQUS "HK"
 EJMP 2
 EQUS " "
 CTOK 50
 CTOK 53
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: boa
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Boa
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.boa

 EQUB 1                 \ 1: Inservice date:  "3017 ({single cap}GEREGE
 EQUS "3017"            \                      FEDERATION)"
 CTOK 85                \
 ETWO 'G', 'E'          \ Encoded as:         "3017[85]<231><242><231> [76])"
 ETWO 'R', 'E'
 ETWO 'G', 'E'
 EQUS " "
 CTOK 76
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "4"
 EQUS "4"               \
 EQUB 0                 \ Encoded as:         "4"

 EQUB 3                 \ 3: Dimensions:      "115/60/65FT"
 EQUS "115/60/65"       \
 CTOK 42                \ Encoded as:         "115/60/65[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.24{all caps}LM{sentence case}"
 EQUS "0.24"            \
 CTOK 64                \ Encoded as:         "0.24[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "2-6"
 EQUS "2-6"             \
 EQUB 0                 \ Encoded as:         "2-6"

 EQUB 6                 \ 6: Range:           "9{all caps}LY{sentence case}"
 EQUS "9"               \
 CTOK 63                \ Encoded as:         "9[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "125{all caps}TC{sentence case}"
 EQUS "125"             \
 CTOK 62                \ Encoded as:         "125[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "ERGON LASER SYSTEM{cr}
 CTOK 52                \                      {all caps}IFS{sentence case} SEEK
 CTOK 49                \                      & HUNT MISSILES"
 CTOK 51                \
 EJMP 12                \ Encoded as:         "[52][49][51]{12}[86][54] & [79]
 CTOK 86                \                      [46]"
 CTOK 54
 EQUS " & "
 CTOK 79
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "J7-24{all caps}/2L{sentence
 EQUS "J7-24"           \                      case}"
 CTOK 83                \
 EQUB 0                 \ Encoded as:         "J7-24[83]"

 EQUB 10                \ 10: Drive motors:   "{all caps}4*C40KV{sentence case}
 CTOK 72                \                      AMES DRIVE{cr}
 EJMP 12                \                      SEEKLIGHT THRUSTERS"
 CTOK 54                \
 CTOK 55                \ Encoded as:         "[72]{12}[54][55] [66]<244>s"
 EQUS " "
 CTOK 66
 ETWO 'E', 'R'
 EQUS "s"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: bushmaster
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Bushmaster
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.bushmaster

 EQUB 1                 \ 1: Inservice date:  "3001 ({single cap}ONRIRA
 EQUS "3001"            \                      ORBITAL)"
 CTOK 85                \
 ETWO 'O', 'N'          \ Encoded as:         "3001[85]<223>ri<248> <253>b<219>
 EQUS "ri"              \                      <228>)"
 ETWO 'R', 'A'
 EQUS " "
 ETWO 'O', 'R'
 EQUS "b"
 ETWO 'I', 'T'
 ETWO 'A', 'L'
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "8"
 EQUS "8"               \
 EQUB 0                 \ Encoded as:         "8"

 EQUB 3                 \ 3: Dimensions:      "50/20/50FT"
 EQUS "50/20/50"        \
 CTOK 42                \ Encoded as:         "50/20/50[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.35{all caps}LM{sentence case}"
 EQUS "0.35"            \
 CTOK 64                \ Encoded as:         "0.35[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-2"
 EQUS "1-2"             \
 EQUB 0                 \ Encoded as:         "1-2"

 EQUB 8                 \ 8: Armaments:       "DUAL 22-18 LASER{cr}
 EQUS "Du"              \                      GERET STARSEEKER MISSILES"
 ETWO 'A', 'L'          \
 EQUS " 22-18"          \ Encoded as:         "Du<228> 22-18[49]{12}[48][46]"
 CTOK 49
 EJMP 12
 CTOK 48
 CTOK 46
 EQUB 0

\EQUB 9                 \ This data is commented out in the original source
\EQUS "3"               \
\CTOK 82                \ It would show the hull as "3{all caps}/1L{sentence
\EQUB 0                 \ case}"

 EQUB 10                \ 10: Drive motors:   "VOLTAIRE WHIPLASH{cr}
 CTOK 60                \                      {all caps}HT{sentence case}
 EQUS " Whip"           \                      PULSEDRIVE"
 ETWO 'L', 'A'          \
 EQUS "sh"              \ Encoded as:         "[60] Whip<249>sh{12}{all caps}HT
 EJMP 12                \                      {sentence case} [50][53]"
 EJMP 1
 EQUS "HT"
 EJMP 2
 EQUS " "
 CTOK 50
 CTOK 53
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: chameleon
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Chameleon
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.chameleon

 EQUB 1                 \ 1: Inservice date:  "3122 ({single cap}ARDEN
 EQUS "3122"            \                      CO-OPERATIVE)"
 CTOK 85                \
 ETWO 'A', 'R'          \ Encoded as:         "3122[85]<238>d<246> Co-op<244>a
 EQUS "d"               \                      <251><250>)"
 ETWO 'E', 'N'
 EQUS " Co-op"
 ETWO 'E', 'R'
 EQUS "a"
 ETWO 'T', 'I'
 ETWO 'V', 'E'
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "6"
 EQUS "6"               \
 EQUB 0                 \ Encoded as:         "6"

 EQUB 3                 \ 3: Dimensions:      "75/24/40FT"
 EQUS "75/24/40"        \
 CTOK 42                \ Encoded as:         "75/24/40[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.29{all caps}LM{sentence case}"
 EQUS "0.29"            \
 CTOK 64                \ Encoded as:         "0.29[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-4"
 EQUS "1-4"             \
 EQUB 0                 \ Encoded as:         "1-4"

 EQUB 6                 \ 6: Range:           "8{all caps}LY{sentence case}"
 EQUS "8"               \
 CTOK 63                \ Encoded as:         "8[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "30{all caps}TC{sentence case}"
 EQUS "30"              \
 CTOK 62                \ Encoded as:         "30[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "INGRAM MEGABLAST PULSE LASER{cr}
 CTOK 56                \                      SEEKER X3 MISSILES"
 EQUS " Mega"           \
 CTOK 74                \ Encoded as:         "[56] Mega[74][50][49]{12}[54]
 CTOK 50                \                      <244> X3[46]"
 CTOK 49
 EJMP 12
 CTOK 54
 ETWO 'E', 'R'
 EQUS " X3"
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "H5-23{all caps}/2L{sentence
 EQUS "H5-23"           \                      case}"
 CTOK 83                \
 EQUB 0                 \ Encoded as:         "H5-23[83]"

 EQUB 10                \ 10: Drive motors:   "VOLTAIRE STINGER{cr}
 CTOK 60                \                      PULSEDRIVE"
 EQUS " "               \
 ETWO 'S', 'T'          \ Encoded as:         "[60] <222><240>g<244>{12}Pul<218>
 ETWO 'I', 'N'          \                      [53]"
 EQUS "g"
 ETWO 'E', 'R'
 EJMP 12
 EQUS "Pul"
 ETWO 'S', 'E'
 CTOK 53
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: cobra_1
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Cobra Mk I
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.cobra_1

 EQUB 1                 \ 1: Inservice date:  "2855 ({single cap}PAYNOU, PROSSET
 EQUS "2855"            \                      & SALEM)"
 CTOK 85                \
 EQUS "Payn"            \ Encoded as:         "2855[85]Payn[89], [80]& S<228>
 ETWO 'O', 'U'          \                      em)"
 EQUS ", "
 CTOK 80
 EQUS "& S"
 ETWO 'A', 'L'
 EQUS "em)"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "5"
 EQUS "5"               \
 EQUB 0                 \ Encoded as:         "5"

 EQUB 3                 \ 3: Dimensions:      "55/15/70FT"
 EQUS "55/15/70"        \
 CTOK 42                \ Encoded as:         "55/15/70[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.26{all caps}LM{sentence case}"
 EQUS "0.26"            \
 CTOK 64                \ Encoded as:         "0.26[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1"
 EQUS "1"               \
 EQUB 0                 \ Encoded as:         "1"

 EQUB 6                 \ 6: Range:           "6{all caps}LY{sentence case}"
 EQUS "6"               \
 CTOK 63                \ Encoded as:         "6[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "10{all caps}TC{sentence case}"
 EQUS "10"              \
 CTOK 62                \ Encoded as:         "10[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "HASSONI VARISCAN LASER{cr}
 CTOK 59                \                      LANCE & FERMAN MISSILES"
 EQUS " V"              \
 ETWO 'A', 'R'          \ Encoded as:         "[59] V<238>isc<255>[49]{12}[57]
 EQUS "isc"             \                      [46]"
 ETWO 'A', 'N'
 CTOK 49
 EJMP 12
 CTOK 57
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "E4-20{all caps}/4L{sentence
 EQUS "E4-20"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "E4-20[84]"

 EQUB 10                \ 10: Drive motors:   "PROSSET DRIVE"
 CTOK 80                \
 CTOK 53                \ Encoded as:         "[80][53]"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: cobra_3
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Cobra Mk III
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.cobra_3

 EQUB 1                 \ 1: Inservice date:  "3100 ({single cap}COWELL &
 EQUS "3100"            \                      MG{all caps}RATH, LAVE)"
 CTOK 85                \
 EQUS "Cowell & Mg"     \ Encoded as:         "3100[85]Cowell & Mg{single cap}
 EJMP 19                \                      <248><226>, <249><250>)"
 ETWO 'R', 'A'
 ETWO 'T', 'H'
 EQUS ", "
 ETWO 'L', 'A'
 ETWO 'V', 'E'
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "7"
 EQUS "7"               \
 EQUB 0                 \ Encoded as:         "7"

 EQUB 3                 \ 3: Dimensions:      "65/30/130FT"
 EQUS "65/30/130"       \
 CTOK 42                \ Encoded as:         "65/30/130[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.28{all caps}LM{sentence case}"
 EQUS "0.28"            \
 CTOK 64                \ Encoded as:         "0.28[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-3"
 EQUS "1-3"             \
 EQUB 0                 \ Encoded as:         "1-3"

 EQUB 6                 \ 6: Range:           "7{all caps}LY{sentence case}"
 EQUS "7"               \
 CTOK 63                \ Encoded as:         "7[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "35{all caps}TC{sentence case}"
 EQUS "35"              \
 CTOK 62                \ Encoded as:         "35[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "INGRAM LASER SYSTEM{cr}
 CTOK 56                \                      LANCE & FERMAN MISSILES"
 CTOK 49                \
 CTOK 51                \ Encoded as:         "[56][49][51]{12}[57][46]"
 EJMP 12
 CTOK 57
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "G7-24{all caps}/4L{sentence
 EQUS "G7-24"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "G7-24[84]"

 EQUB 10                \ 10: Drive motors:   "{single cap}KRUGER LIGHTFAST{cr}
 CTOK 58                \                      IRRIKAN THRUSPACE"
 CTOK 55                \
 EQUS "fa"              \ Encoded as:         "[58][55]fa<222>{12}Irrik<255> Thr
 ETWO 'S', 'T'          \                      u[77]"
 EJMP 12
 EQUS "Irrik"
 ETWO 'A', 'N'
 EQUS " Thru"
 CTOK 77
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: coriolis
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Coriolis station
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.coriolis

 EQUB 1                 \ 1: Inservice date:  "2752 ({single cap}GASEC LABS,
 EQUS "2752"            \                      VETITICE)"
 CTOK 75                \
 EQUB 0                 \ Encoded as:         "2752[75]"

 EQUB 3                 \ 3: Dimensions:      "1/1/1km"
 EQUS "1/1/1km"         \
 EQUB 0                 \ Encoded as:         "1/1/1km"

 EQUB 11                \ 11: Space:          "2000 SHIPS"
 EQUS "2000"            \
 CTOK 67                \ Encoded as:         "2000[67]s"
 EQUS "s"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: dodecagon
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Dodo station
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.dodecagon

 EQUB 1                 \ 1: Inservice date:  "3152 ({single cap}GASEC LABS,
 EQUS "3152"            \                      VETITICE)"
 CTOK 75                \
 EQUB 0                 \ Encoded as:         "3152[75]"

 EQUB 3                 \ 3: Dimensions:      "1/1/1km"
 EQUS "1/1/1km"         \
 EQUB 0                 \ Encoded as:         "1/1/1km"

 EQUB 11                \ 11: Space:          "2700 SHIPS"
 EQUS "2700"            \
 CTOK 67                \ Encoded as:         "2700[67]s"
 EQUS "s"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: escape_pod
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the escape pod
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.escape_pod

 EQUB 1                 \ 1: Inservice date:  "PRE-2500"
 EQUS "p"               \
 ETWO 'R', 'E'          \ Encoded as:         "p<242>-2500"
 EQUS "-2500"
 EQUB 0

 EQUB 3                 \ 3: Dimensions:      "10/5/5FT"
 EQUS "10/5/5"          \
 CTOK 42                \ Encoded as:         "10/5/5[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.08{all caps}LM{sentence case}"
 EQUS "0.08"            \
 CTOK 64                \ Encoded as:         "0.08[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-2"
 EQUS "1-2"             \
 EQUB 0                 \ Encoded as:         "1-2"

 EQUB 0

\ ******************************************************************************
\
\       Name: fer_de_lance
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Fer-de-Lance
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.fer_de_lance

 EQUB 1                 \ 1: Inservice date:  "3100 ({single cap}ZORGON
 EQUS "3100"            \                      PETTERSON)"
 CTOK 85                \
 CTOK 70                \ Encoded as:         "3100[85][70]"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "6"
 EQUS "6"               \
 EQUB 0                 \ Encoded as:         "6"

 EQUB 3                 \ 3: Dimensions:      "85/20/45FT"
 EQUS "85/20/45"        \
 CTOK 42                \ Encoded as:         "85/20/45[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.30{all caps}LM{sentence case}"
 EQUS "0.30"            \
 CTOK 64                \ Encoded as:         "0.30[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-3"
 EQUS "1-3"             \
 EQUB 0                 \ Encoded as:         "1-3"

 EQUB 6                 \ 6: Range:           "8.5{all caps}LY{sentence case}"
 EQUS "8.5"             \
 CTOK 63                \ Encoded as:         "8.5[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "2{all caps}TC{sentence case}"
 EQUS "2"               \
 CTOK 62                \ Encoded as:         "2[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "ERGON LASER SYSTEM{cr}
 CTOK 52                \                      {all caps}IFS{sentence case} SEEK
 CTOK 49                \                      & HUNT MISSILES"
 CTOK 51                \
 EJMP 12                \ Encoded as:         "[52][49][51]{12}[86][54] & [79]
 CTOK 86                \                      [46]"
 CTOK 54
 EQUS " & "
 CTOK 79
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "H7-28{all caps}/4L{sentence
 EQUS "H7-28"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "H7-28[84]"

 EQUB 10                \ 10: Drive motors:   "TITRONIX INTERSUN{cr}
 EQUS "T"               \                      {all caps}LT{sentence case}
 ETWO 'I', 'T'          \                      {single cap}IONIC"
 EQUS "r"               \
 ETWO 'O', 'N'          \ Encoded as:         "T<219>r<223>ix <240>t<244>sun{12}
 EQUS "ix "             \                      {all caps}LT{sentence case} [78]"
 ETWO 'I', 'N'
 EQUS "t"
 ETWO 'E', 'R'
 EQUS "sun"
 EJMP 12
 EJMP 1
 EQUS "LT"
 EJMP 2
 EQUS " "
 CTOK 78
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: gecko
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Gecko
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.gecko

 EQUB 1                 \ 1: Inservice date:  "2852 ({single cap}ACE & FABER,
 EQUS "2852"            \                      LERELACE)"
 CTOK 85                \
 EQUS "A"               \ Encoded as:         "2852[85]A<233> & F[88]<244>,
 ETWO 'C', 'E'          \                       <229><242><249><233>)"
 EQUS " & F"
 ETWO 'A', 'B'
 ETWO 'E', 'R'
 EQUS ", "
 ETWO 'L', 'E'
 ETWO 'R', 'E'
 ETWO 'L', 'A'
 ETWO 'C', 'E'
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "7"
 EQUS "7"               \
 EQUB 0                 \ Encoded as:         "7"

 EQUB 3                 \ 3: Dimensions:      "40/12/65FT"
 EQUS "40/12/65"        \
 CTOK 42                \ Encoded as:         "40/12/65[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.30{all caps}LM{sentence case}"
 EQUS "0.30"            \
 CTOK 64                \ Encoded as:         "0.30[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-2"
 EQUS "1-2"             \
 EQUB 0                 \ Encoded as:         "1-2"

 EQUB 6                 \ 6: Range:           "7{all caps}LY{sentence case}"
 EQUS "7"               \
 CTOK 63                \ Encoded as:         "7[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "3{all caps}TC{sentence case}"
 EQUS "3"               \
 CTOK 62                \ Encoded as:         "3[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "INGRAM 1919 A4 LASER{cr}
 CTOK 56                \                      {all caps}LM{sentence case}
 EQUS " 1919 A4"        \                      HOMING MISSILES"
 CTOK 49                \
 EJMP 12                \ Encoded as:         "[56] 1919 A4[49]{12}[64] Hom<240>
 CTOK 64                \                      g[46]"
 EQUS " Hom"
 ETWO 'I', 'N'
 EQUS "g"
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "E6-19{all caps}/2L{sentence
 EQUS "E6-19"           \                      case}"
 CTOK 83                \
 EQUB 0                 \ Encoded as:         "E6-19[83]"

 EQUB 10                \ 10: Drive motors:   "BREAM PULSELIGHT {all caps}XL
 EQUS "B"               \                      {sentence case}"
 ETWO 'R', 'E'          \
 EQUS "am"              \ Encoded as:         "B<242>am[50][55] {all caps}XL
 CTOK 50                \                      {sentence case}"
 CTOK 55
 EQUS " "
 EJMP 1
 EQUS "XL"
 EJMP 2
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: ghavial
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Ghavial
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.ghavial

 EQUB 1                 \ 1: Inservice date:  "3077 ({single cap}ARDEN
 EQUS "3077"            \                      CO-OPERATIVE)"
 CTOK 85                \
 ETWO 'A', 'R'          \ Encoded as:         "3077[85]<238>d<246> Co-op<244>a
 EQUS "d"               \                      <251><250>)"
 ETWO 'E', 'N'
 EQUS " Co-op"
 ETWO 'E', 'R'
 EQUS "a"
 ETWO 'T', 'I'
 ETWO 'V', 'E'
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "5"
 EQUS "5"               \
 EQUB 0                 \ Encoded as:         "5"

 EQUB 3                 \ 3: Dimensions:      "80/30/60FT"
 EQUS "80/30/60"        \
 CTOK 42                \ Encoded as:         "80/30/60[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.25{all caps}LM{sentence case}"
 EQUS "0.25"            \
 CTOK 64                \ Encoded as:         "0.25[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "2-7"
 EQUS "2-7"             \
 EQUB 0                 \ Encoded as:         "2-7"

 EQUB 6                 \ 6: Range:           "8{all caps}LY{sentence case}"
 EQUS "8"               \
 CTOK 63                \ Encoded as:         "8[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "50{all caps}TC{sentence case}"
 EQUS "50"              \
 CTOK 62                \ Encoded as:         "50[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "FAIREY PULSE LASER{cr}
 EQUS "Fai"             \                      LANCE & FERMAN MISSILES"
 ETWO 'R', 'E'          \
 EQUS "y"               \ Encoded as:         "Fai<242>y[50][49]{12}[57][46]"
 CTOK 50
 CTOK 49
 EJMP 12
 CTOK 57
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "I5-25{all caps}/4L{sentence
 EQUS "I5-25"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "I5-25[84]"

 EQUB 10                \ 10: Drive motors:   "SPALDER & PRIME {all caps}TT1
 EQUS "Sp"              \                      {sentence case}"
 ETWO 'A', 'L'          \
 EQUS "d"               \ Encoded as:         "Sp<228>d<244> & Prime {all caps}
 ETWO 'E', 'R'          \                      TT1{sentence case}"
 EQUS " & Prime "
 EJMP 1
 EQUS "TT1"
 EJMP 2
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: iguana
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Iguana
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.iguana

 EQUB 1                 \ 1: Inservice date:  "3095 ({single cap}FAULCON
 EQUS "3095"            \                      MANSPACE)"
 CTOK 85                \
 EQUS "Faulc"           \ Encoded as:         "3095[85]Faulc<223> <239>n[77])"
 ETWO 'O', 'N'
 EQUS " "
 ETWO 'M', 'A'
 EQUS "n"
 CTOK 77
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "6"
 EQUS "6"               \
 EQUB 0                 \ Encoded as:         "6"

 EQUB 3                 \ 3: Dimensions:      "65/20/40FT"
 EQUS "65/20/40"        \
 CTOK 42                \ Encoded as:         "65/20/40[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.33{all caps}LM{sentence case}"
 EQUS "0.33"            \
 CTOK 64                \ Encoded as:         "0.33[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-3"
 EQUS "1-3"             \
 EQUB 0                 \ Encoded as:         "1-3"

 EQUB 6                 \ 6: Range:           "7.5{all caps}LY{sentence case}"
 EQUS "7.5"             \
 CTOK 63                \ Encoded as:         "7.5[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "15{all caps}TC{sentence case}"
 EQUS "15"              \
 CTOK 62                \ Encoded as:         "15[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "LANCE & FERMAN LASER{cr}
 CTOK 57                \                      SEEKER X1 MISSILES"
 CTOK 49                \
 EJMP 12                \ Encoded as:         "[57][49]{12}[54]<244> X1[46]"
 CTOK 54
 ETWO 'E', 'R'
 EQUS " X1"
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "G6-20{all caps}/4L{sentence
 EQUS "G6-20"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "G6-20[84]"

 EQUB 10                \ 10: Drive motors:   "DE{single cap}LACY SUPER
 CTOK 71                \                       THRUST{cr}
 EQUS " Sup"            \                      {all caps}VC{sentence case}9"
 ETWO 'E', 'R'          \
 EQUS " "               \ Encoded as:         "[71] Sup<244> [66]{12}{all caps}V
 CTOK 66                \                      C{sentence case}9"
 EJMP 12
 EJMP 1
 EQUS "VC"
 EJMP 2
 EQUS "9"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: krait
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Krait
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.krait

 EQUB 1                 \ 1: Inservice date:  "3027 ({single cap}DE{single cap}
 EQUS "3027"            \                      LACY SHIPWORKS, ININES)"
 CTOK 85                \
 CTOK 71                \ Encoded as:         "3027[85][71][67]W<253>ks, <240>
 CTOK 67                \                      <240><237>)"
 EQUS "W"
 ETWO 'O', 'R'
 EQUS "ks, "
 ETWO 'I', 'N'
 ETWO 'I', 'N'
 ETWO 'E', 'S'
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "7"
 EQUS "7"               \
 EQUB 0                 \ Encoded as:         "7"

 EQUB 3                 \ 3: Dimensions:      "80/20/90FT"
 EQUS "80/20/90"        \
 CTOK 42                \ Encoded as:         "80/20/90[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.30{all caps}LM{sentence case}"
 EQUS "0.30"            \
 CTOK 64                \ Encoded as:         "0.30[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1"
 EQUS "1"               \
 EQUB 0                 \ Encoded as:         "1"

 EQUB 7                 \ 7: Cargo space:     "10{all caps}TC{sentence case}"
 EQUS "10"              \
 CTOK 62                \ Encoded as:         "10[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "ERGON LASER SYSTEM"
 CTOK 52                \
 CTOK 49                \ Encoded as:         "[52][49][51]"
 CTOK 51
 EQUB 0

\EQUB 9                 \ This data is commented out in the original source
\EQUS "8"               \
\CTOK 83                \ It would show the hull as "8{all caps}/2L{sentence
\EQUB 0                 \ case}"

 EQUB 10                \ 10: Drive motors:   "DE{single cap}LACY SPIN{single
 CTOK 71                \                      cap}IONIC ZX14"
 EQUS " Sp"             \
 ETWO 'I', 'N'          \ Encoded as:         "[71] Sp<240>[78] ZX14"
 CTOK 78
 EQUS " ZX14"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: mamba
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Mamba
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.mamba

 EQUB 1                 \ 1: Inservice date:  "3110 ({single cap}REORTE SHIP
 EQUS "3110"            \                      FEDERATION)"
 CTOK 85                \
 ETWO 'R', 'E'          \ Encoded as:         "3110[85]<242><253>te[67] [76])"
 ETWO 'O', 'R'
 EQUS "te"
 CTOK 67
 EQUS " "
 CTOK 76
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "8"
 EQUS "8"               \
 EQUB 0                 \ Encoded as:         "8"

 EQUB 3                 \ 3: Dimensions:      "55/12/65FT"
 EQUS "55/12/65"        \
 CTOK 42                \ Encoded as:         "55/12/65[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.30{all caps}LM{sentence case}"
 EQUS "0.30"            \
 CTOK 64                \ Encoded as:         "0.30[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-2"
 EQUS "1-2"             \
 EQUB 0                 \ Encoded as:         "1-2"

 EQUB 7                 \ 7: Cargo space:     "10{all caps}TC{sentence case}"
 EQUS "10"              \
 CTOK 62                \ Encoded as:         "10[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "ERGON LASER SYSTEM{cr}
 CTOK 52                \                      {all caps}IFS{sentence case} SEEK
 CTOK 49                \                      & HUNT MISSILES"
 CTOK 51                \
 EJMP 12                \ Encoded as:         "[52][49][51]{12}[86][54] & [79]
 CTOK 86                \                      [46]"
 CTOK 54
 EQUS " & "
 CTOK 79
 CTOK 46
 EQUB 0

\EQUB 9                 \ This data is commented out in the original source
\EQUS "7"               \
\CTOK 82                \ It would show the hull as "7{all caps}/1L{sentence
\EQUB 0                 \ case}"

 EQUB 10                \ 10: Drive motors:   "SEEKLIGHT {all caps}HV{sentence
 CTOK 54                \                      case}THRUST"
 CTOK 55                \
 EQUS " "               \ Encoded as:         "[54][55] {all caps}HV{sentence
 EJMP 1                 \                      case}[66]"
 EQUS "HV"
 EJMP 2
 EQUS " "
 CTOK 66
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: monitor
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Monitor
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.monitor

 EQUB 1                 \ 1: Inservice date:  "3112 ({single cap}ZORGON
 EQUS "3112"            \                      PETTERSON)"
 CTOK 85                \
 CTOK 70                \ Encoded as:         "3112[85][70]"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "4"
 EQUS "4"               \
 EQUB 0                 \ Encoded as:         "4"

 EQUB 3                 \ 3: Dimensions:      "100/40/50FT"
 EQUS "100/40/50"       \
 CTOK 42                \ Encoded as:         "100/40/50[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.16{all caps}LM{sentence case}"
 EQUS "0.16"            \
 CTOK 64                \ Encoded as:         "0.16[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "7-19"
 EQUS "7-19"            \
 EQUB 0                 \ Encoded as:         "7-19"

 EQUB 6                 \ 6: Range:           "11{all caps}LY{sentence case}"
 EQUS "11"              \
 CTOK 63                \ Encoded as:         "11[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "75{all caps}TC{sentence case}"
 EQUS "75"              \
 CTOK 62                \ Encoded as:         "75[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "{single cap}KRUGER {all caps}HMB
 CTOK 58                \                      {sentence case} LASER{cr}
 EJMP 1                 \                      GERET STARSEEKER MISSILE"
 EQUS "HMB"             \
 EJMP 2                 \ Encoded as:         "[58]{all caps}HMB{sentence case}
 CTOK 49                \                      [49]{12}[48][46]"
 EJMP 12
 CTOK 48
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "J6-28{all caps}/4L{sentence
 EQUS "J6-28"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "J6-28[84]"

 EQUB 10                \ 10: Drive motors:   "V & K 29.01{cr}LIGHT BLASTERS"
 CTOK 73                \
 EQUS "29.01"           \ Encoded as:         "[73]29.01{12}[55] [74]<244>s"
 EJMP 12
 CTOK 55
 EQUS " "
 CTOK 74
 ETWO 'E', 'R'
 EQUS "s"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: moray
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Moray
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.moray

 EQUB 1                 \ 1: Inservice date:  "3028 ({single cap}MARINE TRENCH
 EQUS "3028"            \                      CO.)"
 CTOK 85                \
 EQUS "M"               \ Encoded as:         "3028[85]M<238><240>e T<242>nch C
 ETWO 'A', 'R'          \                      o.)"
 ETWO 'I', 'N'
 EQUS "e T"
 ETWO 'R', 'E'
 EQUS "nch Co.)"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "7"
 EQUS "7"               \
 EQUB 0                 \ Encoded as:         "7"

 EQUB 3                 \ 3: Dimensions:      "60/25/60FT"
 EQUS "60/25/60"        \
 CTOK 42                \ Encoded as:         "60/25/60[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.25{all caps}LM{sentence case}"
 EQUS "0.25"            \
 CTOK 64                \ Encoded as:         "0.25[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-4"
 EQUS "1-4"             \
 EQUB 0                 \ Encoded as:         "1-4"

 EQUB 6                 \ 6: Range:           "8{all caps}LY{sentence case}"
 EQUS "8"               \
 CTOK 63                \ Encoded as:         "8[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "7{all caps}TC{sentence case}"
 EQUS "7"               \
 CTOK 62                \ Encoded as:         "7[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "INGRAM LASER SYSTEM{cr}
 CTOK 56                \                      GERET STARSEEKER MISSILES"
 CTOK 49                \
 CTOK 51                \ Encoded as:         "[56][49][51]{12}[48][46]"
 EJMP 12
 CTOK 48
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "F4-22{all caps}/4L{sentence
 EQUS "F4-22"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "F4-22[84]"

 EQUB 10                \ 10: Drive motors:   "TURBULEN QUARK{cr}RE-CHARGER
 EQUS "Turbul"          \                      1287"
 ETWO 'E', 'N'          \
 EQUS " "               \ Encoded as:         "Turbul<246> <254><238>k{12}<242>-
 ETWO 'Q', 'U'          \                      ch<238>g<244> 1287"
 ETWO 'A', 'R'
 EQUS "k"
 EJMP 12
 ETWO 'R', 'E'
 EQUS "-ch"
 ETWO 'A', 'R'
 EQUS "g"
 ETWO 'E', 'R'
 EQUS " 1287"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: ophidian
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Ophidian
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.ophidian

 EQUB 1                 \ 1: Inservice date:  "2981 ({single cap}OUTWORLD
 EQUS "2981"            \                      WORKSHOPS)"
 CTOK 85                \
 CTOK 69                \ Encoded as:         "2981[85][69][81]"
 CTOK 81
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "8"
 EQUS "8"               \
 EQUB 0                 \ Encoded as:         "8"

 EQUB 3                 \ 3: Dimensions:      "65/15/30FT"
 EQUS "65/15/30"        \
 CTOK 42                \ Encoded as:         "65/15/30[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.34{all caps}LM{sentence case}"
 EQUS "0.34"            \
 CTOK 64                \ Encoded as:         "0.34[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-3"
 EQUS "1-3"             \
 EQUB 0                 \ Encoded as:         "1-3"

 EQUB 6                 \ 6: Range:           "7{all caps}LY{sentence case}"
 EQUS "7"               \
 CTOK 63                \ Encoded as:         "7[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "20{all caps}TC{sentence case}"
 EQUS "20"              \
 CTOK 62                \ Encoded as:         "20[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "LANCE & FERMAN LASER{cr}
 CTOK 57                \                      SEEKER X1 MISSILES"
 CTOK 49                \
 EJMP 12                \ Encoded as:         "[57][49]{12}[54]<244> X1[46]"
 CTOK 54
 ETWO 'E', 'R'
 EQUS " X1"
 CTOK 46
 EQUB 0

 EQUB 9                 \ 9: Hull:            "D4-16{all caps}/1L{sentence
 EQUS "D4-16"           \                      case}"
 CTOK 82                \
 EQUB 0                 \ Encoded as:         "D4-16[82]"

 EQUB 10                \ 10: Drive motors:   "VOLTAIRE STINGER{cr}
 CTOK 60                \                      PULSEDRIVE"
 EQUS " "               \
 ETWO 'S', 'T'          \ Encoded as:         "[60] <222><240>g<244>{12}Pul<218>
 ETWO 'I', 'N'          \                      [53]"
 EQUS "g"
 ETWO 'E', 'R'
 EJMP 12
 EQUS "Pul"
 ETWO 'S', 'E'
 CTOK 53
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: python
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Python
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.python

 EQUB 1                 \ 1: Inservice date:  "2700 ({single cap}WHATT & PRITNEY
 EQUS "2700"            \                      SC)"
 CTOK 85                \
 EQUS "Wh"              \ Encoded as:         "2700[85]Wh<245>t & Pr<219>ney S
 ETWO 'A', 'T'          \                      C)"
 EQUS "t & Pr"
 ETWO 'I', 'T'
 EQUS "ney SC)"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "3"
 EQUS "3"               \
 EQUB 0                 \ Encoded as:         "3"

 EQUB 3                 \ 3: Dimensions:      "130/40/80FT"
 EQUS "130/40/80"       \
 CTOK 42                \ Encoded as:         "130/40/80[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.20{all caps}LM{sentence case}"
 EQUS "0.20"            \
 CTOK 64                \ Encoded as:         "0.20[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "2-9"
 EQUS "2-9"             \
 EQUB 0                 \ Encoded as:         "2-9"

 EQUB 6                 \ 6: Range:           "8{all caps}LY{sentence case}"
 EQUS "8"               \
 CTOK 63                \ Encoded as:         "8[63]"
 EQUB 0

 EQUB 7                 \ 7: Cargo space:     "100{all caps}TC{sentence case}"
 EQUS "100"             \
 CTOK 62                \ Encoded as:         "100[62]"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "VOLT-{all caps}VARISCAN PULSE
 EQUS "Volt-"           \                      LASER"
 EJMP 19                \
 EQUS "V"               \ Encoded as:         "Volt-{single cap}V<238>isc<255>
 ETWO 'A', 'R'          \                      [50][49]"
 EQUS "isc"
 ETWO 'A', 'N'
 CTOK 50
 CTOK 49
 EQUB 0

 EQUB 9                 \ 9: Hull:            "K6-27{all caps}/4L{sentence
 EQUS "K6-27"           \                      case}"
 CTOK 84                \
 EQUB 0                 \ Encoded as:         "K6-27[84]"

 EQUB 10                \ 10: Drive motors:   "{all caps}4*C40KV{sentence case}
 CTOK 72                \                      AMES DRIVE{cr}
 EJMP 12                \                      EXLON 76NN MODEL"
 EQUS "Exl"             \
 ETWO 'O', 'N'          \ Encoded as:         "[72]{12}Exl<223> 76NN Model"
 EQUS " 76NN Model"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: shuttle
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Shuttle
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.shuttle

 EQUB 1                 \ 1: Inservice date:  "2856 ({single cap}SAUD-{single
 EQUS "2856"            \                      cap}KRUGER ASTRO)"
 CTOK 85                \
 EQUS "Saud-"           \ Encoded as:         "2856[85]Saud-[58]A<222>ro)"
 CTOK 58
 EQUS "A"
 ETWO 'S', 'T'
 EQUS "ro)"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "4"
 EQUS "4"               \
 EQUB 0                 \ Encoded as:         "4"

 EQUB 3                 \ 3: Dimensions:      "35/20/20FT"
 EQUS "35/20/20"        \
 CTOK 42                \ Encoded as:         "35/20/20[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.08{all caps}LM{sentence case}"
 EQUS "0.08"            \
 CTOK 64                \ Encoded as:         "0.08[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "2"
 EQUS "2"               \
 EQUB 0                 \ Encoded as:         "2"

 EQUB 7                 \ 7: Cargo space:     "60{all caps}TC{sentence case}"
 EQUS "60"              \
 CTOK 62                \ Encoded as:         "60[62]"
 EQUB 0

 EQUB 10                \ 10: Drive motors:   "V & K 20.20{cr}
 CTOK 73                \                      STARMAT DRIVE"
 EQUS "20.20"           \
 EJMP 12                \ Encoded as:         "[73]20.20{12}<222><238><239>t
 ETWO 'S', 'T'          \                       [53]"
 ETWO 'A', 'R'
 ETWO 'M', 'A'
 EQUS "t "
 CTOK 53
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: sidewinder
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Sidewinder
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.sidewinder

 EQUB 1                 \ 1: Inservice date:  "2982 ({single cap}ONRIRA
 EQUS "2982"            \                      ORBITAL)"
 CTOK 85                \
 ETWO 'O', 'N'          \ Encoded as:         "2982[85]<223>ri<248> <253>b<219>
 EQUS "ri"              \                      <228>)"
 ETWO 'R', 'A'
 EQUS " "
 ETWO 'O', 'R'
 EQUS "b"
 ETWO 'I', 'T'
 ETWO 'A', 'L'
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "9"
 EQUS "9"               \
 EQUB 0                 \ Encoded as:         "9"

 EQUB 3                 \ 3: Dimensions:      "35/15/65FT"
 EQUS "35/15/65"        \
 CTOK 42                \ Encoded as:         "35/15/65[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.37{all caps}LM{sentence case}"
 EQUS "0.37"            \
 CTOK 64                \ Encoded as:         "0.37[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1"
 EQUS "1"               \
 EQUB 0                 \ Encoded as:         "1"

 EQUB 8                 \ 8: Armaments:       "DUAL 22-18 LASER"
 EQUS "Du"              \
 ETWO 'A', 'L'          \ Encoded as:         "Du<228> 22-18[49]"
 EQUS " 22-18"
 CTOK 49
 EQUB 0

\EQUB 0, 9              \ This data is commented out in the original source
\EQUA "3|!R"

 EQUB 10                \ 10: Drive motors:   "DE{single cap}LACY SPIN{single
 CTOK 71                \                      cap}IONIC {all caps}MV{sentence
 EQUS " Sp"             \                      case}"
 ETWO 'I', 'N'          \
 CTOK 78                \ Encoded as:         "[71] Sp<240>[78] {all caps}MV
 EQUS " "               \                      {sentence case}"
 EJMP 1
 EQUS "MV"
 EJMP 2
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: thargoid
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Thargoid
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.thargoid

 EQUB 2                 \ 2: Combat factor:   "6"
 EQUS "6"               \
 EQUB 0                 \ Encoded as:         "6"

 EQUB 3                 \ 3: Dimensions:      "180/40/180FT"
 EQUS "180/40/180"      \
 CTOK 42                \ Encoded as:         "180/40/180[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.39{all caps}LM{sentence case}"
 EQUS "0.39"            \
 CTOK 64                \ Encoded as:         "0.39[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "50"
 EQUS "50"              \
 EQUB 0                 \ Encoded as:         "50"

 EQUB 6                 \ 6: Range:           "UNKNOWN"
 EQUS "Unk"             \
 ETWO 'N', 'O'          \ Encoded as:         "Unk<227>wn"
 EQUS "wn"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "WIDELY VARYING"
 EQUS "Widely v"        \
 ETWO 'A', 'R'          \ Encoded as:         "Widely v<238>y<240>g"
 EQUS "y"
 ETWO 'I', 'N'
 EQUS "g"
 EQUB 0

\EQUB 9                 \ This data is commented out in the original source
\EQUS "Unk"             \
\TWOK 'N', 'O'          \ It would show the hull as "UNKNOWN"
\EQUS "wn"
\EQUB 0

 EQUB 10                \ 10: Drive motors:   "THARGOID INVENTION"
 CTOK 30                \
 EQUS " "               \ Encoded as:         "[30] [68]"
 CTOK 68
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: thargon
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Thargon
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.thargon

 EQUB 2                 \ 2: Combat factor:   "6"
 EQUS "6"               \
 EQUB 0                 \ Encoded as:         "6"

 EQUB 3                 \ 3: Dimensions:      "40/10/35FT"
 EQUS "40/10/35"        \
 CTOK 42                \ Encoded as:         "40/10/35[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.30{all caps}LM{sentence case}"
 EQUS "0.30"            \
 CTOK 64                \ Encoded as:         "0.30[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "NONE"
 ETWO 'N', 'O'          \
 EQUS "ne"              \ Encoded as:         "<227>ne"
 EQUB 0

 EQUB 8                 \ 8: Armaments:       "THARGOID LASER"
 CTOK 30                \
 CTOK 49                \ Encoded as:         "[30][49]"
 EQUB 0

\EQUB 9                 \ This data is commented out in the original source
\TWOK 'N', 'O'          \
\EQUS "ne"              \ It would show the hull as "NONE"
\EQUB 0

 EQUB 10                \ 10: Drive motors:   "THARGOID INVENTION"
 CTOK 30                \
 EQUS " "               \ Encoded as:         "[30] [68]"
 CTOK 68
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: transporter
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Transporter
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.transporter

 EQUB 1                 \ 1: Inservice date:  "PRE-2500 ({single cap}SPACELINK
 EQUS "p"               \                      SHIPYARDS)"
 ETWO 'R', 'E'          \
 EQUS "-2500"           \ Encoded as:         "p<242>-2500[85][77]L<240>k[67]y
 CTOK 85                \                      <238>ds)"
 CTOK 77
 EQUS "L"
 ETWO 'I', 'N'
 EQUS "k"
 CTOK 67
 EQUS "y"
 ETWO 'A', 'R'
 EQUS "ds)"
 EQUB 0

 EQUB 3                 \ 3: Dimensions:      "35/10/30FT"
 EQUS "35/10/30"        \
 CTOK 42                \ Encoded as:         "35/10/30[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.10{all caps}LM{sentence case}"
 EQUS "0.10"            \
 CTOK 64                \ Encoded as:         "0.10[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "5"
 EQUS "5"               \
 EQUB 0                 \ Encoded as:         "5"

 EQUB 7                 \ 7: Cargo space:     "10{all caps}TC{sentence case}"
 EQUS "10"              \
 CTOK 62                \ Encoded as:         "10[62]"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: viper
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Viper
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.viper

 EQUB 1                 \ 1: Inservice date:  "2762 ({single cap}FAULCON
 EQUS "2762"            \                      MANSPACE)"
 CTOK 85                \
 EQUS "Faulc"           \ Encoded as:         "2762[85]Faulc<223> <239>n[77])"
 ETWO 'O', 'N'
 EQUS " "
 ETWO 'M', 'A'
 EQUS "n"
 CTOK 77
 EQUS ")"
 EQUB 0

 EQUB 2                 \ 2: Combat factor:   "7"
 EQUS "7"               \
 EQUB 0                 \ Encoded as:         "7"

 EQUB 3                 \ 3: Dimensions:      "55/20/50FT"
 EQUS "55/20/50"        \
 CTOK 42                \ Encoded as:         "55/20/50[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.32{all caps}LM{sentence case}"
 EQUS "0.32"            \
 CTOK 64                \ Encoded as:         "0.32[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1-10"
 EQUS "1-10"            \
 EQUB 0                 \ Encoded as:         "1-10"

 EQUB 8                 \ 8: Armaments:       "INGRAM MEGABLAST PULSE LASER{cr}
 CTOK 56                \                      SEEKER X3 MISSILES"
 EQUS " Mega"           \
 CTOK 74                \ Encoded as:         "[56] Mega[74][50][49]{12}[54]
 CTOK 50                \                      <244> X3[46]"
 CTOK 49
 EJMP 12
 CTOK 54
 ETWO 'E', 'R'
 EQUS " X3"
 CTOK 46
 EQUB 0

\EQUB 9                 \ This data is commented out in the original source
\EQUS "9"               \
\CTOK 82                \ It would show the hull as "9{all caps}/1L{sentence
\EQUB 0                 \ case}"

 EQUB 10                \ 10: Drive motors:   "DE{single cap}LACY SUPER
 CTOK 71                \                      THRUST{cr}
 EQUS " Sup"            \                      {all caps}VC{sentence case}10"
 ETWO 'E', 'R'          \
 EQUS " "               \ Encoded as:         "[71] Sup<244> [66]{12}{all caps}V
 CTOK 66                \                      C{sentence case}10"
 EJMP 12
 EJMP 1
 EQUS "VC"
 EJMP 2
 EQUS "10"
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: worm
\       Type: Variable
\   Category: Encyclopedia
\    Summary: Ship card data for the encyclopedia entry for the Worm
\  Deep dive: The Encyclopedia Galactica
\
\ ******************************************************************************

.worm

 EQUB 1                 \ 1: Inservice date:  "3101"
 EQUS "3101"            \
 EQUB 0                 \ Encoded as:         "3101"

 EQUB 2                 \ 2: Combat factor:   "6"
 EQUS "6"               \
 EQUB 0                 \ Encoded as:         "6"

 EQUB 3                 \ 3: Dimensions:      "35/12/35FT"
 EQUS "35/12/35"        \
 CTOK 42                \ Encoded as:         "35/12/35[42]"
 EQUB 0

 EQUB 4                 \ 4: Speed:           "0.23{all caps}LM{sentence case}"
 EQUS "0.23"            \
 CTOK 64                \ Encoded as:         "0.23[64]"
 EQUB 0

 EQUB 5                 \ 5: Crew:            "1"
 EQUS "1"               \
 EQUB 0                 \ Encoded as:         "1"

 EQUB 8                 \ 8: Armaments:       "INGRAM PULSE LASER"
 CTOK 56                \
 CTOK 50                \ Encoded as:         "[56][50][49]"
 CTOK 49
 EQUB 0

\EQUB 9                 \ This data is commented out in the original source
\EQUS "3"               \
\CTOK 82                \ It would show the hull as "3{all caps}/1L{sentence
\EQUB 0                 \ case}"

 EQUB 10                \ 10: Drive motors:   "SEEKLIGHT {all caps}HV{sentence
 CTOK 54                \                      case} THRUST"
 CTOK 55                \
 EQUS " "               \ Encoded as:         "[54][55] {all caps}HV{sentence
 EJMP 1                 \                      case} [66]"
 EQUS "HV"
 EJMP 2
 EQUS " "
 CTOK 66
 EQUB 0

 EQUB 0

\ ******************************************************************************
\
\       Name: install_ship
\       Type: Subroutine
\   Category: Universe
\    Summary: Install a ship blueprint into the ship blueprints lookup table
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The type of the ship to install, with the number being
\                       taken from the full list of available blueprints in the
\                       ship_list table, so that's:
\
\                         * 0 = Dodo station
\                         * 1 = Coriolis station
\                         * 2 = Escape pod
\
\                           ...
\
\                         * 35 = Iguana
\                         * 36 = Shuttle Mk II
\                         * 37 = Chameleon
\
\   Y                   The position in which to install the ship blueprint in
\                       the ship blueprints lookup table at ship_data, so
\                       that's:
\
\                         * 0 = Our current ship
\                         * 1 = Missile
\                         * 2 = Space station
\
\                           ...
\
\                         * 29 = Thargoid
\                         * 30 = Thargon
\                         * 31 = Constrictor
\
\ ******************************************************************************

.install_ship

 TXA                    \ Store X * 2 on the stack so we can use it below as an
 ASL A                  \ index into the ship_list table, which has 2 bytes per
 PHA                    \ entry

 ASL A                  \ Set X = X * 4, so we can use it as an index into the
 TAX                    \ ship_bytes table, which has 4 bytes per entry

 LDA ship_flags,Y       \ Fetch the ship_flags byte for this ship position, i.e.
                        \ the Y-th entry in the ship_flags table, where the NEWB
                        \ flags live, so this sets A to the default NEWB flags
                        \ for the ship position that we are filling

 AND #%01111111         \ Set bit 7 of the NEWB flags to that of the second byte
 ORA ship_bytes+1,X     \ in this ship type's entry in the ship_bytes table, so
                        \ this determines whether this ship type has an escape
                        \ pod fitted as standard (if the second ship_byte is
                        \ %10000000) or not (if the second ship_byte is
                        \ %00000000)

 STA ship_flags,Y       \ Update the Y-th entry in the ship_flags table with the
                        \ updated bit 7, so when we spawn a ship from this
                        \ blueprint position, it correctly spawns with or
                        \ without an escape pod, depending on the ship type

 TYA                    \ Set Y = Y * 2, so we can use it as an index into the
 ASL A                  \ ship_data table, which has 2 bytes per entry
 TAY

 PLA                    \ Retrieve the value of X * 2 that we stored above, so
 TAX                    \ we can use it as an index into the ship_list table,
                        \ which has 2 bytes per entry

 LDA ship_list,X        \ Set the address at position Y in the ship_data table
 STA ship_data,Y        \ to the blueprint address for ship number X in the
 LDA ship_list+1,X      \ ship_list table (i.e. install ship number X into
 STA ship_data+1,Y      \ position Y)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: printer
\       Type: Subroutine
\   Category: Text
\    Summary: This routine is commented out in the original source
\
\ ******************************************************************************

\.printer               \ These instructions are commented out in the original
\TXA                    \ source
\PHA
\LDA #&9C
\JSR tube_write
\JSR tube_read
\PLA
\TAX
\RTS

\ ******************************************************************************
\
\       Name: DOENTRYS
\       Type: Subroutine
\   Category: Loader
\    Summary: Dock at the space station, show the ship hangar and work out any
\             mission progression
\
\ ******************************************************************************

.DOENTRYS

 JSR RES2               \ Reset a number of flight variables and workspaces

 JMP DOENTRY            \ Jump to DOENTRY to dock at the space station

\ ******************************************************************************
\
\       Name: DEATH2
\       Type: Subroutine
\   Category: Start and end
\    Summary: Reset most of the game and restart from the title screen
\
\ ------------------------------------------------------------------------------
\
\ This routine is called following death, and when the game is quit by pressing
\ ESCAPE when paused.
\
\ ******************************************************************************

.DEATH2

 JSR RES2               \ Reset a number of flight variables and workspaces
                        \ and fall through into the entry code for the game
                        \ to restart from the title screen

 JMP INBAY              \ Jump to INBAY to restart the game following death

\ ******************************************************************************
\
\ Save ELTI.bin
\
\ ******************************************************************************

 PRINT "ELITE I"
 PRINT "Assembled at ", ~CODE_I%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_I%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_I%

 PRINT "S.2.ELTI ", ~CODE_I%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_I%
\SAVE "versions/disc/3-assembled-output/2.ELTI.bin", CODE_I%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE J FILE
\
\ ******************************************************************************

 CODE_J% = P%
 LOAD_J% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: Main flight loop (Part 1 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Seed the random number generator
\  Deep dive: Program flow of the main game loop
\             Generating random numbers
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Seed the random number generator
\
\ Other entry points:
\
\   M%                  The entry point for the main flight loop
\
\ ******************************************************************************

.M%

 LDA K%                 \ We want to seed the random number generator with a
                        \ pretty random number, so fetch the contents of K%,
                        \ which is the x_lo coordinate of the planet. This value
                        \ will be fairly unpredictable, so it's a pretty good
                        \ candidate

 STA RAND               \ Store the seed in the first byte of the four-byte
                        \ random number seed that's stored in RAND

\ ******************************************************************************
\
\       Name: Main flight loop (Part 2 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Calculate the alpha and beta angles from the current pitch and
\             roll of our ship
\  Deep dive: Program flow of the main game loop
\             Pitching and rolling
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Calculate the alpha and beta angles from the current pitch and roll
\
\ Here we take the current rate of pitch and roll, as set by the joystick or
\ keyboard, and convert them into alpha and beta angles that we can use in the
\ matrix functions to rotate space around our ship. The alpha angle covers
\ roll, while the beta angle covers pitch (there is no yaw in this version of
\ Elite). The angles are in radians, which allows us to use the small angle
\ approximation when moving objects in the sky (see the MVEIT routine for more
\ on this). Also, the signs of the two angles are stored separately, in both
\ the sign and the flipped sign, as this makes calculations easier.
\
\ ******************************************************************************

 LDX JSTX               \ Set X to the current rate of roll in JSTX

 CPX new_max            \ If X < new_max (where new_max is our current ship's
 BCC n_highx            \ maximum roll rate), then jump to n_highx to skip the
                        \ following instruction

 LDX new_max            \ X is at least new_max, so set X to new_max so it is
                        \ never higher than our current ship's maximum roll rate

.n_highx

 CPX new_min            \ If X >= new_min (where new_min is our current ship's
 BCS n_lowx             \ minimum roll rate), then jump to n_lowx to skip the
                        \ following instruction

 LDX new_min            \ X is less than new_min, so set X to new_min so it is
                        \ never lower than our current ship's minimum roll rate

.n_lowx

 JSR cntr               \ Apply keyboard damping twice (if enabled) so the roll
 JSR cntr               \ rate in X creeps towards the centre by 2

                        \ The roll rate in JSTX increases if we press ">" (and
                        \ the RL indicator on the dashboard goes to the right).
                        \ This rolls our ship to the right (clockwise), but we
                        \ actually implement this by rolling everything else
                        \ to the left (anti-clockwise), so a positive roll rate
                        \ in JSTX translates to a negative roll angle alpha

 TXA                    \ Set A and Y to the roll rate but with the sign bit
 EOR #%10000000         \ flipped (i.e. set them to the sign we want for alpha)
 TAY

 AND #%10000000         \ Extract the flipped sign of the roll rate and store
 STA ALP2               \ in ALP2 (so ALP2 contains the sign of the roll angle
                        \ alpha)

 STX JSTX               \ Update JSTX with the damped value that's still in X

 EOR #%10000000         \ Extract the correct sign of the roll rate and store
 STA ALP2+1             \ in ALP2+1 (so ALP2+1 contains the flipped sign of the
                        \ roll angle alpha)

 TYA                    \ Set A to the roll rate but with the sign bit flipped

 BPL P%+7               \ If the value of A is positive, skip the following
                        \ three instructions

 EOR #%11111111         \ A is negative, so change the sign of A using two's
 CLC                    \ complement so that A is now positive and contains
 ADC #1                 \ the absolute value of the roll rate, i.e. |JSTX|

 LSR A                  \ Divide the (positive) roll rate in A by 4
 LSR A

 CMP #8                 \ If A >= 8, skip the following instruction
 BCS P%+3

 LSR A                  \ A < 8, so halve A again

 STA ALP1               \ Store A in ALP1, so we now have:
                        \
                        \   ALP1 = |JSTX| / 8    if |JSTX| < 32
                        \
                        \   ALP1 = |JSTX| / 4    if |JSTX| >= 32
                        \
                        \ This means that at lower roll rates, the roll angle is
                        \ reduced closer to zero than at higher roll rates,
                        \ which gives us finer control over the ship's roll at
                        \ lower roll rates
                        \
                        \ Because JSTX is in the range -127 to +127, ALP1 is
                        \ in the range 0 to 31

 ORA ALP2               \ Store A in ALPHA, but with the sign set to ALP2 (so
 STA ALPHA              \ ALPHA has a different sign to the actual roll rate)

 LDX JSTY               \ Set X to the current rate of pitch in JSTY

 CPX new_max            \ If X < new_max (where new_max is our current ship's
 BCC n_highy            \ maximum pitch rate), then jump to n_highy to skip the
                        \ following instruction

 LDX new_max            \ X is at least new_max, so set X to new_max so it is
                        \ never higher than our current ship's maximum pitch
                        \ rate

.n_highy

 CPX new_min            \ If X >= new_min (where new_min is our current ship's
 BCS n_lowy             \ minimum pitch rate), then jump to n_lowy to skip the
                        \ following instruction

 LDX new_min            \ X is less than new_min, so set X to new_min so it is
                        \ never lower than our current ship's minimum pitch rate

.n_lowy

 JSR cntr               \ Apply keyboard damping so the pitch rate in X creeps
                        \ towards the centre by 1

 TXA                    \ Set A and Y to the pitch rate but with the sign bit
 EOR #%10000000         \ flipped
 TAY

 AND #%10000000         \ Extract the flipped sign of the pitch rate into A

 STX JSTY               \ Update JSTY with the damped value that's still in X

 STA BET2+1             \ Store the flipped sign of the pitch rate in BET2+1

 EOR #%10000000         \ Extract the correct sign of the pitch rate and store
 STA BET2               \ it in BET2

 TYA                    \ Set A to the pitch rate but with the sign bit flipped

 BPL P%+4               \ If the value of A is positive, skip the following
                        \ instruction

 EOR #%11111111         \ A is negative, so flip the bits

 ADC #4                 \ Add 4 to the (positive) pitch rate, so the maximum
                        \ value is now up to 131 (rather than 127)

 LSR A                  \ Divide the (positive) pitch rate in A by 16
 LSR A
 LSR A
 LSR A

 CMP #3                 \ If A >= 3, skip the following instruction
 BCS P%+3

 LSR A                  \ A < 3, so halve A again

 STA BET1               \ Store A in BET1, so we now have:
                        \
                        \   BET1 = |JSTY| / 32    if |JSTY| < 48
                        \
                        \   BET1 = |JSTY| / 16    if |JSTY| >= 48
                        \
                        \ This means that at lower pitch rates, the pitch angle
                        \ is reduced closer to zero than at higher pitch rates,
                        \ which gives us finer control over the ship's pitch at
                        \ lower pitch rates
                        \
                        \ Because JSTY is in the range -131 to +131, BET1 is in
                        \ the range 0 to 8

 ORA BET2               \ Store A in BETA, but with the sign set to BET2 (so
 STA BETA               \ BETA has the same sign as the actual pitch rate)

\ ******************************************************************************
\
\       Name: Main flight loop (Part 3 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Scan for flight keys and process the results
\  Deep dive: Program flow of the main game loop
\             The key logger
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Scan for flight keys and process the results
\
\ Flight keys are logged in the key logger at location KY1 onwards, with a
\ non-zero value in the relevant location indicating a key press. See the deep
\ dive on "The key logger" for more details.
\
\ The key presses that are processed are as follows:
\
\   * Space and "?" to speed up and slow down
\   * "U", "T" and "M" to disarm, arm and fire missiles
\   * TAB to activate the hyperspace unit
\   * ESCAPE to launch an escape pod
\   * "J" to initiate an in-system jump
\   * "E" to deploy E.C.M. anti-missile countermeasures
\   * "C" to use the docking computer
\   * "A" to fire lasers
\
\ ******************************************************************************

 LDA KY2                \ If Space is being pressed, keep going, otherwise jump
 BEQ MA17               \ down to MA17 to skip the following

 LDA DELTA              \ The "go faster" key is being pressed, so first we
 CMP new_speed          \ fetch the current speed from DELTA into A, and if
 BCC speed_up           \ A < new_speed (the maximum speed of our current ship),
                        \ then we can go a bit faster, so jump to speed_up to
                        \ accelerate

.MA17

 LDA KY1                \ If "?" is being pressed, keep going, otherwise jump
 BEQ MA4                \ down to MA4 to skip the following

 DEC DELTA              \ The "slow down" key is being pressed, so we decrement
                        \ the current ship speed in DELTA

 BNE MA4                \ If the speed is still greater than zero, jump to MA4

.speed_up

 INC DELTA              \ Otherwise we just braked a little too hard, so bump
                        \ the speed back up to the minimum value of 1

.MA4

 LDA KY15               \ If "U" is being pressed and the number of missiles
 AND NOMSL              \ in NOMSL is non-zero, keep going, otherwise jump down
 BEQ MA20               \ to MA20 to skip the following

 LDY #&EE               \ The "disarm missiles" key is being pressed, so call
 JSR ABORT              \ ABORT to disarm the missile and update the missile
                        \ indicators on the dashboard to green/cyan (Y = &EE)

 JSR WA1                \ Call the WA1 routine to make a low, long beep to
                        \ indicate the missile is now disarmed

 LDA #0                 \ Set MSAR to 0 to indicate that no missiles are
 STA MSAR               \ currently armed

.MA20

 LDA MSTG               \ If MSTG is positive (i.e. it does not have bit 7 set),
 BPL MA25               \ then it indicates we already have a missile locked on
                        \ a target (in which case MSTG contains the ship number
                        \ of the target), so jump to MA25 to skip targeting. Or
                        \ to put it another way, if MSTG = &FF, which means
                        \ there is no current target lock, keep going

 LDA KY14               \ If "T" is being pressed, keep going, otherwise jump
 BEQ MA25               \ down to MA25 to skip the following

 LDX NOMSL              \ If the number of missiles in NOMSL is zero, jump down
 BEQ MA25               \ to MA25 to skip the following

 STA MSAR               \ The "target missile" key is being pressed and we have
                        \ at least one missile, so set MSAR = &FF to denote that
                        \ our missile is currently armed (we know A has the
                        \ value &FF, as we just loaded it from MSTG and checked
                        \ that it was negative)

 LDY #&E0               \ Change the leftmost missile indicator to yellow/white
 DEX                    \ on the missile bar (this call changes the leftmost
 JSR MSBARS             \ indicator because we set X to the number of missiles
                        \ in NOMSL above, and the indicators are numbered from
                        \ right to left, starting at 0, so X - 1 is the number
                        \ of the leftmost indicator)

.MA25

 LDA KY16               \ If "M" is being pressed, keep going, otherwise jump
 BEQ MA24               \ down to MA24 to skip the following

 LDA MSTG               \ If MSTG = &FF then there is no target lock, so jump to
 BMI MA64               \ MA64 to skip the following (also skipping the checks
                        \ for TAB, ESCAPE, "J" and "E")

 JSR FRMIS              \ The "fire missile" key is being pressed and we have
                        \ a missile lock, so call the FRMIS routine to fire
                        \ the missile

.MA24

 LDA KY12               \ If TAB is not being pressed (i.e. KY12 = 0) and we do
 AND BOMB               \ not have a hyperspace unit fitted (i.e. BOMB = 0),
 BEQ MA76               \ jump down to MA76 to skip the following

 INC BOMB               \ The "hyperspace unit" key is being pressed and we have
                        \ a hyperspace unit fitted, so increment BOMB from &FF
                        \ (hyperspace unit fitted) to 0 (hyperspace unit not
                        \ fitted), as it is a single-use item and we are now
                        \ using it

 INC new_hold           \ Free up one tonne of space in the hold, as we have
                        \ just used up the hyperspace unit

 JSR DORND              \ Set A and X to random numbers

 STA QQ9                \ Set (QQ9, QQ10) to (A, X), so we jump to a random
 STX QQ10               \ point in the galaxy

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 JSR hyper_snap         \ Call hyper_snap to perform a hyperspace, but without
                        \ using up any fuel

.MA76

 LDA KY19               \ If "C" is being pressed, and we have a docking
 AND DKCMP              \ computer fitted, then KY19 and DKCMP will both be &FF,
 BNE dock_toggle        \ so jump down to dock_toggle with A set to &FF

 LDA KY20               \ If "P" is being pressed, keep going, otherwise skip
 BEQ MA78               \ the next two instructions

 LDA #0                 \ The "cancel docking computer" key is bring pressed,
                        \ so turn it off by setting A to 0, so we set auto to 0
                        \ in the next instruction

.dock_toggle

 STA auto               \ Set auto to the value in A, which will be &FF if we
                        \ just turned on the docking computer, or 0 if we just
                        \ turned it off

.MA78

 LDA KY13               \ If ESCAPE is being pressed and we have an escape pod
 AND ESCP               \ fitted, keep going, otherwise jump to noescp to skip
 BEQ noescp             \ the following instructions

 JMP ESCAPE             \ The "launch escape pod" button is being pressed and
                        \ we have an escape pod fitted, so jump to ESCAPE to
                        \ launch it, and exit the main flight loop using a tail
                        \ call

.noescp

 LDA KY18               \ If "J" is being pressed, keep going, otherwise skip
 BEQ P%+5               \ the next instruction

 JSR WARP               \ Call the WARP routine to do an in-system jump

 LDA KY17               \ If "E" is being pressed and we have an E.C.M. fitted,
 AND ECM                \ keep going, otherwise jump down to MA64 to skip the
 BEQ MA64               \ following

 LDA ECMA               \ If ECMA is non-zero, that means an E.C.M. is already
 BNE MA64               \ operating and is counting down (this can be either
                        \ our E.C.M. or an opponent's), so jump down to MA64 to
                        \ skip the following (as we can't have two E.C.M.
                        \ systems operating at the same time)

 DEC ECMP               \ The "E.C.M." button is being pressed and nobody else
                        \ is operating their E.C.M., so decrease the value of
                        \ ECMP to make it non-zero, to denote that our E.C.M.
                        \ is now on

 JSR ECBLB2             \ Call ECBLB2 to light up the E.C.M. indicator bulb on
                        \ the dashboard, set the E.C.M. countdown timer to 32,
                        \ and start making the E.C.M. sound

.MA64

.MA68

 LDA #0                 \ Set LAS = 0, to switch the laser off while we do the
 STA LAS                \ following logic

 STA DELT4              \ Take the 16-bit value (DELTA 0) - i.e. a two-byte
 LDA DELTA              \ number with DELTA as the high byte and 0 as the low
 LSR A                  \ byte - and divide it by 4, storing the 16-bit result
 ROR DELT4              \ in DELT4(1 0). This has the effect of storing the
 LSR A                  \ current speed * 64 in the 16-bit location DELT4(1 0)
 ROR DELT4
 STA DELT4+1

 JSR read_0346          \ Get the value of the I/O processor's copy of LASCT

 BNE MA3                \ If LASCT is zero, keep going, otherwise the laser is
                        \ a pulse laser that is between pulses, so jump down to
                        \ MA3 to skip the following

 LDA KY7                \ If "A" is being pressed, keep going, otherwise jump
 BEQ MA3                \ down to MA3 to skip the following

 LDA GNTMP              \ If the laser temperature >= 242 then the laser has
 CMP #242               \ overheated, so jump down to MA3 to skip the following
 BCS MA3

 LDX VIEW               \ If the current space view has a laser fitted (i.e. the
 LDA LASER,X            \ laser power for this view is greater than zero), then
 BEQ MA3                \ keep going, otherwise jump down to MA3 to skip the
                        \ following

                        \ If we get here, then the "fire" button is being
                        \ pressed, our laser hasn't overheated and isn't already
                        \ being fired, and we actually have a laser fitted to
                        \ the current space view, so it's time to hit me with
                        \ those laser beams

 PHA                    \ Store the current view's laser power on the stack

 AND #%01111111         \ Set LAS and LAS2 to bits 0-6 of the laser power
 STA LAS2
 STA LAS

 LDA #0                 \ Call the NOISE routine with A = 0 to make the sound
 JSR NOISE              \ of our laser firing

 JSR LASLI              \ Call LASLI to draw the laser lines

 PLA                    \ Restore the current view's laser power into A

 BPL ma1                \ If the laser power has bit 7 set, then it's an "always
                        \ on" laser rather than a pulsing laser, so keep going,
                        \ otherwise jump down to ma1 to skip the following
                        \ instruction

 LDA #0                 \ This is an "always on" laser (i.e. a beam laser,
                        \ as the cassette version of Elite doesn't have military
                        \ lasers), so set A = 0, which will be stored in LASCT
                        \ to denote that this is not a pulsing laser

.ma1

 JSR write_0346         \ Tell the I/O processor to set its copy of LASCT to A,
                        \ which will be 0 for beam lasers, or the laser power
                        \ (15) for pulse lasers. See MS23 below for more on
                        \ laser pulsing and LASCT

\ ******************************************************************************
\
\       Name: Main flight loop (Part 4 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: For each nearby ship: Copy the ship's data block from K% to the
\             zero-page workspace at INWK
\  Deep dive: Program flow of the main game loop
\             Ship data blocks
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Start looping through all the ships in the local bubble, and for each
\     one:
\
\     * Copy the ship's data block from K% to INWK
\
\     * Set XX0 to point to the ship's blueprint (if this is a ship)
\
\ Other entry points:
\
\   MAL1                Marks the beginning of the ship analysis loop, so we
\                       can jump back here from part 12 of the main flight loop
\                       to work our way through each ship in the local bubble.
\                       We also jump back here when a ship is removed from the
\                       bubble, so we can continue processing from the next ship
\
\ ******************************************************************************

.MA3

 LDX #0                 \ We're about to work our way through all the ships in
                        \ our local bubble of universe, so set a counter in X,
                        \ starting from 0, to refer to each ship slot in turn

.MAL1

 STX XSAV               \ Store the current slot number in XSAV

 LDA FRIN,X             \ Fetch the contents of this slot into A. If it is 0
 BNE P%+5               \ then this slot is empty and we have no more ships to
 JMP MA18               \ process, so jump to MA18 below, otherwise A contains
                        \ the type of ship that's in this slot, so skip over the
                        \ JMP MA18 instruction and keep going

 STA TYPE               \ Store the ship type in TYPE

 JSR GINF               \ Call GINF to fetch the address of the ship data block
                        \ for the ship in slot X and store it in INF. The data
                        \ block is in the K% workspace, which is where all the
                        \ ship data blocks are stored

                        \ Next we want to copy the ship data block from INF to
                        \ the zero-page workspace at INWK, so we can process it
                        \ more efficiently

 LDY #NI%-1             \ There are NI% bytes in each ship data block (and in
                        \ the INWK workspace, so we set a counter in Y so we can
                        \ loop through them

.MAL2

 LDA (INF),Y            \ Load the Y-th byte of INF and store it in the Y-th
 STA INWK,Y             \ byte of INWK

 DEY                    \ Decrement the loop counter

 BPL MAL2               \ Loop back for the next byte until we have copied the
                        \ last byte from INF to INWK

 LDA TYPE               \ If the ship type is negative then this indicates a
 BMI MA21               \ planet or sun, so jump down to MA21, as the next bit
                        \ sets up a pointer to the ship blueprint, which doesn't
                        \ apply to planets and suns

 ASL A                  \ Set Y = ship type * 2
 TAY

 LDA XX21-2,Y           \ The ship blueprints at XX21 start with a lookup
 STA XX0                \ table that points to the individual ship blueprints,
                        \ so this fetches the low byte of this particular ship
                        \ type's blueprint and stores it in XX0

 LDA XX21-1,Y           \ Fetch the high byte of this particular ship type's
 STA XX0+1              \ blueprint and store it in XX0+1

                        \ We now go straight to part 6, omitting part 5 from the
                        \ original disc version, as part 5 implements the energy
                        \ bomb, and Elite-A replaces the energy bomb with the
                        \ hyperspace unit

\ ******************************************************************************
\
\       Name: Main flight loop (Part 6 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: For each nearby ship: Move the ship in space and copy the updated
\             INWK data block back to K%
\  Deep dive: Program flow of the main game loop
\             Program flow of the ship-moving routine
\             Ship data blocks
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Move the ship in space
\
\     * Copy the updated ship's data block from INWK back to K%
\
\ ******************************************************************************

.MA21

 JSR MVEIT_FLIGHT       \ Call MVEIT_FLIGHT to move the ship we are processing
                        \ in space

                        \ Now that we are done processing this ship, we need to
                        \ copy the ship data back from INWK to the correct place
                        \ in the K% workspace. We already set INF in part 4 to
                        \ point to the ship's data block in K%, so we can simply
                        \ do the reverse of the copy we did before, this time
                        \ copying from INWK to INF

 LDY #NI%-1             \ Set a counter in Y so we can loop through the NI%
                        \ bytes in the ship data block

.MAL3

 LDA INWK,Y             \ Load the Y-th byte of INWK and store it in the Y-th
 STA (INF),Y            \ byte of INF

 DEY                    \ Decrement the loop counter

 BPL MAL3               \ Loop back for the next byte, until we have copied the
                        \ last byte from INWK back to INF

\ ******************************************************************************
\
\       Name: Main flight loop (Part 7 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: For each nearby ship: Check whether we are docking, scooping or
\             colliding with it
\  Deep dive: Program flow of the main game loop
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Check how close we are to this ship and work out if we are docking,
\       scooping or colliding with it
\
\ ******************************************************************************

 LDA INWK+31            \ Fetch the status of this ship from bits 5 (is ship
 AND #%10100000         \ exploding?) and bit 7 (has ship been killed?) from
                        \ ship byte #31 into A

 JSR MAS4               \ Or this value with x_hi, y_hi and z_hi

 BNE MA65               \ If this value is non-zero, then either the ship is
                        \ far away (i.e. has a non-zero high byte in at least
                        \ one of the three axes), or it is already exploding,
                        \ or has been flagged as being killed - in which case
                        \ jump to MA65 to skip the following, as we can't dock
                        \ scoop or collide with it

 LDA INWK               \ Set A = (x_lo OR y_lo OR z_lo), and if bit 7 of the
 ORA INWK+3             \ result is set, the ship is still a fair distance
 ORA INWK+6             \ away (further than 127 in at least one axis), so jump
 BMI MA65               \ to MA65 to skip the following, as it's too far away to
                        \ dock, scoop or collide with

 LDX TYPE               \ If the current ship type is negative then it's either
 BMI MA65               \ a planet or a sun, so jump down to MA65 to skip the
                        \ following, as we can't dock with it or scoop it

 CPX #SST               \ If this ship is the space station, jump to ISDK to
 BEQ ISDK               \ check whether we are docking with it

 AND #%11000000         \ If bit 6 of (x_lo OR y_lo OR z_lo) is set, then the
 BNE MA65               \ ship is still a reasonable distance away (further than
                        \ 63 in at least one axis), so jump to MA65 to skip the
                        \ following, as it's too far away to dock, scoop or
                        \ collide with

 CPX #MSL               \ If this ship is a missile, jump down to MA65 to skip
 BEQ MA65               \ the following, as we can't scoop or dock with a
                        \ missile, and it has its own dedicated collision
                        \ checks in the TACTICS routine

 LDA BST                \ If we have fuel scoops fitted then BST will be &FF,
                        \ otherwise it will be 0

 AND INWK+5             \ Ship byte #5 contains the y_sign of this ship, so a
                        \ negative value here means the canister is below us,
                        \ which means the result of the AND will be negative if
                        \ the canister is below us and we have a fuel scoop
                        \ fitted

 BPL MA58               \ If the result is positive, then we either have no
                        \ scoop or the canister is above us, and in both cases
                        \ this means we can't scoop the item, so jump to MA58
                        \ to process a collision

\ ******************************************************************************
\
\       Name: Main flight loop (Part 8 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: For each nearby ship: Process us potentially scooping this item
\  Deep dive: Program flow of the main game loop
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Process us potentially scooping this item
\
\ ******************************************************************************

 CPX #OIL               \ If this is a cargo canister, jump to oily to randomly
 BEQ oily               \ decide the canister's contents

 LDY #0                 \ Fetch byte #0 of the ship's blueprint
 LDA (XX0),Y

 LSR A                  \ Shift it right four times, so A now contains the high
 LSR A                  \ nibble (i.e. bits 4-7)
 LSR A
 LSR A

 BEQ MA58               \ If A = 0, jump to MA58 to skip all the docking and
                        \ scooping checks

                        \ Only the Thargon, alloy plate, splinter and escape pod
                        \ have non-zero upper nibbles in their blueprint byte #0
                        \ so if we get here, our ship is one of those, and the
                        \ upper nibble gives the market item number of the item
                        \ when scooped, less 1

 ADC #1                 \ Add 1 to the upper nibble to get the market item
                        \ number

 BNE slvy2              \ Skip to slvy2 so we scoop the ship as a market item

.oily

 JSR DORND              \ Set A and X to random numbers and reduce A to a
 AND #15                \ random number in the range 0-15

.slvy2

                        \ By the time we get here, we are scooping, and A
                        \ contains the type of item we are scooping (a random
                        \ number 0-15 if we are scooping a cargo canister, 3 if
                        \ we are scooping an escape pod, or 16 if we are
                        \ scooping a Thargon). These numbers correspond to the
                        \ relevant market items (see QQ23 for a list), so a
                        \ cargo canister can contain anything from food to
                        \ gem-stones, while escape pods contain slaves, and
                        \ Thargons become alien items when scooped

 TAX                    \ Copy the type of cargo we are scooping into X

 JSR tnpr1              \ Call tnpr1 to work out whether we have room in the
                        \ hold for the scooped item (the C flag contains the
                        \ result)

 BCS MA58               \ If the C flag is set then we have no room in the hold
                        \ for the scooped item, so jump down to MA58 to skip all
                        \ the docking and scooping checks

 INC QQ20,X             \ Scooping was successful, so increment the number of
                        \ items of type X that we have in the hold

 TXA                    \ Print recursive token 48 + X as an in-flight token,
 ADC #208               \ which will be in the range 48 ("FOOD") to 64 ("ALIEN
 JSR MESS               \ ITEMS"), so this prints the scooped item's name

 JSR top_6a             \ The item has now been scooped, so call top_6a to set
                        \ bit 7 of its NEWB flags to indicate this

.MA65

 JMP MA26               \ If we get here, then the ship we are processing was
                        \ too far away to be scooped, docked or collided with,
                        \ so jump to MA26 to skip over the collision routines
                        \ and move on to missile targeting

\ ******************************************************************************
\
\       Name: Main flight loop (Part 9 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: For each nearby ship: If it is a space station, check whether we
\             are successfully docking with it
\  Deep dive: Program flow of the main game loop
\             Docking checks
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Process docking with a space station
\
\ For details on the various docking checks in this routine, see the deep dive
\ on "Docking checks".
\
\ Other entry points:
\
\   GOIN                We jump here from part 3 of the main flight loop if the
\                       docking computer is activated by pressing "C"
\
\ ******************************************************************************

.ISDK

 LDA K%+NI%+36          \ 1. Fetch the NEWB flags (byte #36) of the second ship
 AND #%00000100         \ in the ship data workspace at K%, which is reserved
 BNE MA62               \ for the sun or the space station (in this case it's
                        \ the latter), and if bit 2 is set, meaning the station
                        \ is hostile, jump down to MA62 to fail docking (so
                        \ trying to dock at a station that we have annoyed does
                        \ not end well)

 LDA INWK+14            \ 2. If nosev_z_hi < 214, jump down to MA62 to fail
 CMP #214               \ docking, as the angle of approach is greater than 26
 BCC MA62               \ degrees

 LDY #NI%               \ Set Y = NI% so the following call to SPS1 calculates
                        \ the vector to the space station rather than the planet

 JSR SPS1               \ Call SPS1 to calculate the vector to the space station
                        \ and store it in XX15

 LDA XX15+2             \ Set A to the z-axis of the vector

                        \ This version of Elite omits check 3 (which would check
                        \ the sign of the z-axis)

 CMP #86                \ 4. If z-axis < 86, jump to MA62 to fail docking, as
 BCC MA62               \ we are not in the 26.3 degree safe cone of approach

 LDA INWK+16            \ 5. If |roofv_x_hi| < 80, jump to MA62 to fail docking,
 AND #%01111111         \ as the slot is more than 36.6 degrees from horizontal
 CMP #80
 BCC MA62

.GOIN

                        \ If we arrive here, we just docked successfully

 JSR RES2               \ Reset a number of flight variables and workspaces

 LDA #8                 \ Set the step size for the launch tunnel rings to 8, so
                        \ there are fewer sections in the rings and they are
                        \ quite polygonal (compared to the step size of 4 used
                        \ in the much rounder hyperspace rings)

 JSR HFS2               \ Call HFS2 to draw the launch tunnel rings

 JMP DOENTRYS           \ Go to the docking bay (i.e. show the ship hangar)

.MA62

                        \ If we arrive here, docking has just failed

 LDA DELTA              \ If the ship's speed is >= 5, jump to n_crunch to
 CMP #5                 \ register a fair amount of damage to our shields (128)
 BCS n_crunch

                        \ Otherwise we have just crashed gently into the
                        \ station, so we need to check whether it's our fault or
                        \ the docking computer

\ ******************************************************************************
\
\       Name: Main flight loop (Part 10 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: For each nearby ship: Remove if scooped, or process collisions
\  Deep dive: Program flow of the main game loop
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Remove scooped item after both successful and failed scooping attempts
\
\     * Process collisions
\
\ ******************************************************************************

 LDA auto               \ If the docking computer is on, then auto will be &FF,
 AND #%00000100         \ so this will set A = 1, a tiny amount of damage
 EOR #%00000101         \
                        \ If the docking computer is off, then auto will be 0,
                        \ so this will set A = 5, a small amount of damage

 BNE MA63               \ Jump to MA63 to process the damage in A (this BNE is
                        \ effectively a JMP as A will never be zero)

.MA58

                        \ If we get here, we have collided with something in a
                        \ potentially fatal way

 LDA #64                \ Call n_hit to apply a hit of strength 64 to the ship
 JSR n_hit              \ we just collided with

 JSR anger_8c           \ Call anger_8c to make the ship angry

.n_crunch

                        \ If we get here, we have collided with something, so we
                        \ need to take a hit to our shields

 LDA #128               \ Set A = 128 to indicate a fairly large amount of
                        \ damage

.MA63

 JSR OOPS               \ The amount of damage is in A, so call OOPS to reduce
                        \ our shields, and if the shields are gone, there's a
                        \ chance of cargo loss or even death

 JSR EXNO3              \ Make the sound of colliding with the other ship and
                        \ fall through into MA26 to try targeting a missile

\ ******************************************************************************
\
\       Name: Main flight loop (Part 11 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: For each nearby ship: Process missile lock and firing our laser
\  Deep dive: Program flow of the main game loop
\             Flipping axes between space views
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * If this is not the front space view, flip the axes of the ship's
\        coordinates in INWK
\
\     * Process missile lock
\
\     * Process our laser firing
\
\ ******************************************************************************

.MA26

 LDA NEWB               \ If bit 7 of the ship's NEWB flags is clear, skip the
 BPL P%+5               \ following instruction

 JSR SCAN               \ Bit 7 of the ship's NEWB flags is set, which means the
                        \ ship has docked or been scooped, so we draw the ship
                        \ on the scanner, which has the effect of removing it

 LDA QQ11               \ If this is not a space view, jump to MA15 to skip
 BNE MA15               \ missile and laser locking

 LDX VIEW               \ Load the current view into X

 BEQ P%+5               \ If the current view is the front view, skip the
                        \ following instruction, as the geometry in INWK is
                        \ already correct

 JSR PU1                \ Call PU1 to update the geometric axes in INWK to
                        \ match the view (front, rear, left, right)

 JSR HITCH              \ Call HITCH to see if this ship is in the crosshairs,
 BCC MA8                \ in which case the C flag will be set (so if there is
                        \ no missile or laser lock, we jump to MA8 to skip the
                        \ following)

 LDA MSAR               \ We have missile lock, so check whether the leftmost
 BEQ MA47               \ missile is currently armed, and if not, jump to MA47
                        \ to process laser fire, as we can't lock an unarmed
                        \ missile

 JSR BEEP               \ We have missile lock and an armed missile, so call
                        \ the BEEP subroutine to make a short, high beep

 LDX XSAV               \ Call ABORT2 to store the details of this missile
 LDY #&0E               \ lock, with the targeted ship's slot number in X
 JSR ABORT2             \ (which we stored in XSAV at the start of this ship's
                        \ loop at MAL1), and set the colour of the missile
                        \ indicator to the colour in Y (red = &0E)

.MA47

                        \ If we get here then the ship is in our sights, but
                        \ we didn't lock a missile, so let's see if we're
                        \ firing the laser

 LDA LAS                \ If we are firing the laser then LAS will contain the
 BEQ MA8                \ laser power (which we set in MA68 above), so if this
                        \ is zero, jump down to MA8 to skip the following

 LDX #15                \ We are firing our laser and the ship in INWK is in
 JSR EXNO               \ the crosshairs, so call EXNO to make the sound of
                        \ us making a laser strike on another ship

 LDA LAS                \ Set A to the power of the laser we just used to hit
                        \ the ship (i.e. the laser in the current view)

 LDY TYPE               \ Did we just hit the space station? If so, jump to
 CPY #SST               \ MA14 to make it angry
 BEQ MA14

 CPY #CON               \ If the ship we hit is not a Constrictor, jump to BURN
 BNE BURN               \ to skip the following

 LSR A                  \ Divide the laser power of the current view by 2, so
                        \ the damage inflicted on the Constrictor is half of the
                        \ damage our military lasers would inflict on a normal
                        \ ship

.BURN

 LSR A                  \ Divide the laser power of the current view by 2

 JSR n_hit              \ Call n_hit to apply a laser strike of strength A to
                        \ the enemy ship

 BCS MA14               \ If the C flag is set then the enemy ship survived the
                        \ hit, so jump down to MA14 to make it angry

 LDA TYPE               \ Did we just kill an asteroid? If not, jump to nosp,
 CMP #AST               \ otherwise keep going
 BNE nosp

 LDA LAS                \ Did we kill the asteroid using mining lasers? If so,
 CMP new_mining         \ then our current laser strength in LAS will match the
 BNE nosp               \ strength of mining lasers when fitted to our current
                        \ ship type, which is stored in new_mining. If they
                        \ don't match, which means we didn't use mining lasers,
                        \ then jump to nosp, otherwise keep going

 JSR DORND              \ Set A and X to random numbers

 LDX #SPL               \ Set X to the ship type for a splinter

 AND #3                 \ Reduce the random number in A to the range 0-3

 JSR SPIN2              \ Call SPIN2 to spawn A items of type X (i.e. spawn
                        \ 0-3 splinters)

.nosp

 LDY #PLT               \ Randomly spawn some alloy plates
 JSR SPIN

 LDY #OIL               \ Randomly spawn some cargo canisters
 JSR SPIN

 JSR EXNO2              \ Call EXNO2 to process the fact that we have killed a
                        \ ship (so increase the kill tally, make an explosion
                        \ sound and so on)

.MA14

 JSR anger_8c           \ Call anger_8c to make this ship hostile angry, now
                        \ that we have hit it

\ ******************************************************************************
\
\       Name: Main flight loop (Part 12 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: For each nearby ship: Draw the ship, remove if killed, loop back
\  Deep dive: Program flow of the main game loop
\             Drawing ships
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Draw the ship
\
\     * Process removal of killed ships
\
\   * Loop back up to MAL1 to move onto the next ship in the local bubble
\
\ ******************************************************************************

.MA8

 JSR LL9_FLIGHT         \ Call LL9 to draw the ship we're processing on-screen

.MA15

 LDY #35                \ Fetch the ship's energy from byte #35 and copy it to
 LDA INWK+35            \ byte #35 in INF (so the ship's data in K% gets
 STA (INF),Y            \ updated)

 LDA NEWB               \ If bit 7 of the ship's NEWB flags is set, which means
 BMI KS1S               \ the ship has docked or been scooped, jump to KS1S to
                        \ skip the following, as we can't get a bounty for a
                        \ ship that's no longer around

 LDA INWK+31            \ If bit 7 of the ship's byte #31 is clear, then the
 BPL MAC1               \ ship hasn't been killed by collision or laser fire,
                        \ so jump to MAC1 to skip the following

 AND #%00100000         \ If bit 5 of the ship's byte #31 is clear then the
 BEQ MAC1               \ ship is no longer exploding, so jump to MAC1 to skip
                        \ the following

                        \ We now update our FIST flag ("fugitive/innocent
                        \ status") by 1 if we didn't kill a cop, or by a large
                        \ amount if we did - specifically, if we killed a cop,
                        \ then the most significant bit in FIST that is
                        \ currently clear will be set, which means we increase
                        \ FIST by the highest multiple of 2 that we can add and
                        \ still fit the result in a byte
                        \
                        \ Also, at this point, we know that A = %00100000 (as we
                        \ didn't take the BEQ branch)

 BIT NEWB               \ If bit 6 of the ship's NEWB flags is set, then this
 BVS n_badboy           \ ship is a cop, so jump to n_badboy as we just killed a
                        \ policeman

 BEQ n_goodboy          \ The BIT NEWB instruction sets the Z flag according to
                        \ the result of:
                        \
                        \   A AND NEWB = %00100000 AND NEWB
                        \
                        \ so this jumps to n_goodboy if bit 5 of NEWB is clear,
                        \ so in other words, if the ship is no longer exploding,
                        \ we don't update FIST

 LDA #%10000000         \ Set A so that the shift and rotate instructions we're
                        \ about to do set A = %00000001, so we increase our FIST
                        \ status by just 1

.n_badboy

                        \ We get here with two possible values of A:
                        \
                        \   * A = %00100000 if we just killed a cop
                        \   * A = %10000000 otherwise

 ASL A                  \ Shift and rotate A so that we get:
 ROL A                  \
                        \   * A = %10000000 if we just killed a cop
                        \   * A = %00000001 otherwise

.n_bitlegal

 LSR A                  \ We now shift A to the right and AND it with FIST,
 BIT FIST               \ repeating the process until the single set bit in A
 BNE n_bitlegal         \ matches a clear bit in FIST, so this shifts A right
                        \ so that the set bit matches the highest clear bit in
                        \ FIST (if we just killed a cop), or it sets A to 0 and
                        \ sets the C flag (if we didn't)

 ADC FIST               \ Set A = A + C + FIST, so:
                        \
                        \   * A = A + 0 + FIST if we just killed a cop
                        \   * A = 0 + 1 + FIST otherwise
                        \
                        \ so if we just killed a cop, this will effectively set
                        \ the highest clear bit in FIST, otherwise we just add 1
                        \ to FIST

 BCS KS1S               \ If the addition overflowed, jump to KS1S to skip
                        \ showing an on-screen bounty for this kill, and without
                        \ updating FIST first (as we are too bad to get any
                        \ worse)

 STA FIST               \ Otherwise update the value of FIST to the new value

 BCC KS1S               \ Jump to KS1S to skip showing an on-screen bounty for
                        \ this kill (the BCC is effectively a JMP as we just
                        \ passed through a BCS)

.n_goodboy

 LDA DLY                \ If we already have an in-flight message on-screen (in
 ORA MJ                 \ which case DLY > 0), or we are in witchspace (in
 BNE KS1S               \ which case MJ > 0), jump to KS1S to skip showing an
                        \ on-screen bounty for this kill

 LDY #10                \ Fetch byte #10 of the ship's blueprint, which is the
 LDA (XX0),Y            \ low byte of the bounty awarded when this ship is
                        \ killed (in Cr * 10)

 TAX                    \ Put the low byte of the bounty into X

 INY                    \ Fetch byte #11 of the ship's blueprint, which is the
 LDA (XX0),Y            \ high byte of the bounty awarded (in Cr * 10), and put
 TAY                    \ it into Y

 JSR MCASH              \ Call MCASH to add (Y X) to the cash pot

 LDA #0                 \ Print control code 0 (current cash, right-aligned to
 JSR MESS               \ width 9, then " CR", newline) as an in-flight message

.KS1S

 JMP KS1                \ Process the killing of this ship (which removes this
                        \ ship from its slot and shuffles all the other ships
                        \ down to close up the gap)

.n_hit

                        \ If we get here then we need to apply a hit of strength
                        \ A to the enemy ship

 STA T                  \ Store the strength of the hit in T

 SEC                    \ Set the C flag so we can do some subtraction

 LDY #14                \ Fetch byte #14 of the enemy ship's blueprint into A,
 LDA (XX0),Y            \ which gives the ship's maximum energy/shields

 AND #7                 \ Reduce the maximum energy/shields figure to the range
                        \ 0-7

 SBC T                  \ Subtract the hit strength from the maximum shields, so
                        \ A = ship energy - hit strength

 BCS n_kill             \ If the subtraction didn't underflow, then the hit was
                        \ weaker than the ship's shields, so jump to n_kill
                        \ with the C flag set to indicate that the ship has
                        \ survived the attack

\BCC n_defense          \ These instructions are commented out in the original
\LDA #&FF               \ source
\.n_defense

 CLC                    \ Otherwise the hit was stronger than the enemy shields,
 ADC INWK+35            \ so the ship's energy level needs to register some
 STA INWK+35            \ damage. A contains a negative number whose magnitude
                        \ is the amount by which the attack is greater than the
                        \ shield defence, so we can simply add this figure to
                        \ the ship's energy levels in the ship's byte #35 to
                        \ reduce the energy by the amount that the attack was
                        \ stronger than the defence (i.e. the shields absorb the
                        \ amount of energy that is defined in the blueprint, and
                        \ the rest of the hit makes it through to damage the
                        \ energy levels)

 BCS n_kill             \ Adding this negative number is the same as subtracting
                        \ a positive number, so having the C flag set indicates
                        \ that the subtraction didn't underflow - in other words
                        \ the damage isn't greater than the energy levels, and
                        \ the ship has survived the hit. In this case we jump to
                        \ n_kill with the C flag set to indicate that the ship
                        \ has survived the attack

 JSR TA87+3             \ If we get here then the ship has not survived the
                        \ attack, so call TA87+3 to set bit 7 of the ship's byte
                        \ #31, which marks the ship as being killed

.n_kill

 RTS                    \ Return from the subroutine with the C flag set if the
                        \ ship has survived the onslaught, or clear if it has
                        \ been destroyed

.MAC1

 LDA TYPE               \ If the ship we are processing is a planet or sun,
 BMI MA27               \ jump to MA27 to skip the following two instructions

 JSR FAROF              \ If the ship we are processing is a long way away (its
 BCC KS1S               \ distance in any one direction is > 224, jump to KS1S
                        \ to remove the ship from our local bubble, as it's just
                        \ left the building

.MA27

 LDY #31                \ Fetch the ship's explosion/killed state from byte #31
 LDA INWK+31            \ and copy it to byte #31 in INF (so the ship's data in
 STA (INF),Y            \ K% gets updated)

 LDX XSAV               \ We're done processing this ship, so fetch the ship's
                        \ slot number, which we saved in XSAV back at the start
                        \ of the loop

 INX                    \ Increment the slot number to move on to the next slot

 JMP MAL1               \ And jump back up to the beginning of the loop to get
                        \ the next ship in the local bubble for processing

\ ******************************************************************************
\
\       Name: Main flight loop (Part 13 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Charge shields and energy banks
\  Deep dive: Program flow of the main game loop
\             Scheduling tasks with the main loop counter
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Charge shields and energy banks (every 7 iterations of the main loop)
\
\ ******************************************************************************

.MA18

.MA77

 LDA MCNT               \ Fetch the main loop counter and calculate MCNT mod 7,
 AND #7                 \ jumping to MA22 if it is non-zero (so the following
 BNE MA22               \ code only runs every 8 iterations of the main loop)

 LDX ENERGY             \ Fetch our ship's energy levels and skip to b if bit 7
 BPL b                  \ is not set, i.e. only charge the shields from the
                        \ energy banks if they are at more than 50% charge

 LDX ASH                \ Call SHD to recharge our aft shield and update the
 JSR SHD                \ shield status in ASH
 STX ASH

 LDX FSH                \ Call SHD to recharge our forward shield and update
 JSR SHD                \ the shield status in FSH
 STX FSH

.b

 SEC                    \ Set A = ENERGY + ENGY + 1, so our ship's energy
 LDA ENGY               \ level goes up by the correct amount for our current
 ADC ENERGY             \ ship, depending on whether we have an energy unit
                        \ fitted

 BCS P%+5               \ If the value of A did not overflow (the maximum
 STA ENERGY             \ energy level is &FF), then store A in ENERGY

\ ******************************************************************************
\
\       Name: Main flight loop (Part 14 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Spawn a space station if we are close enough to the planet
\  Deep dive: Program flow of the main game loop
\             Scheduling tasks with the main loop counter
\             Ship data blocks
\             The space station safe zone
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Spawn a space station if we are close enough to the planet (every 32
\     iterations of the main loop)
\
\ ******************************************************************************

 LDA MJ                 \ If we are in witchspace, jump down to MA23S to skip
 BNE MA23S              \ the following, as there are no space stations in
                        \ witchspace

 LDA MCNT               \ Fetch the main loop counter and calculate MCNT mod 32,
 AND #31                \ jumping to MA93 if it is on-zero (so the following
 BNE MA93               \ code only runs every 32 iterations of the main loop)

 LDA SSPR               \ If we are inside the space station safe zone, jump to
 BNE MA23S              \ MA23S to skip the following, as we already have a
                        \ space station and don't need another

 TAY                    \ Set Y = A = 0 (A is 0 as we didn't branch with the
                        \ previous BNE instruction)

 JSR MAS2               \ Call MAS2 to calculate the largest distance to the
 BNE MA23S              \ planet in any of the three axes, and if it's
                        \ non-zero, jump to MA23S to skip the following, as we
                        \ are too far from the planet to bump into a space
                        \ station

                        \ We now want to spawn a space station, so first we
                        \ need to set up a ship data block for the station in
                        \ INWK that we can then pass to NWSPS to add a new
                        \ station to our bubble of universe. We do this by
                        \ copying the planet data block from K% to INWK so we
                        \ can work on it, but we only need the first 29 bytes,
                        \ as we don't need to worry about bytes #29 to #35
                        \ for planets (as they don't have rotation counters,
                        \ AI, explosions, missiles, a ship line heap or energy
                        \ levels)

 LDX #28                \ So we set a counter in X to copy 29 bytes from K%+0
                        \ to K%+28

.MAL4

 LDA K%,X               \ Load the X-th byte of K% and store in the X-th byte
 STA INWK,X             \ of the INWK workspace

 DEX                    \ Decrement the loop counter

 BPL MAL4               \ Loop back for the next byte until we have copied the
                        \ first 28 bytes of K% to INWK

                        \ We now check the distance from our ship (at the
                        \ origin) towards the point where we will spawn the
                        \ space station if we are close enough
                        \
                        \ This point is calculated by starting at the planet's
                        \ centre and adding 2 * nosev, which takes us to a point
                        \ above the planet's surface, at an altitude that
                        \ matches the planet's radius
                        \
                        \ This point pitches and rolls around the planet as the
                        \ nosev vector rotates with the planet, and if our ship
                        \ is within a distance of (192 0) from this point in all
                        \ three axes, then we spawn the space station at this
                        \ point, with the station's slot facing towards the
                        \ planet, along the nosev vector
                        \
                        \ This works because in the following, we calculate the
                        \ station's coordinates one axis at a time, and store
                        \ the results in the INWK block, so by the time we have
                        \ calculated and checked all three, the ship data block
                        \ is set up with the correct spawning coordinates

 INX                    \ Set X = 0 (as we ended the above loop with X as &FF)

 LDY #9                 \ Call MAS1 with X = 0, Y = 9 to do the following:
 JSR MAS1               \
                        \   (x_sign x_hi x_lo) += (nosev_x_hi nosev_x_lo) * 2
                        \
                        \   A = |x_sign|

 BNE MA23S              \ If A > 0, jump to MA23S to skip the following, as we
                        \ are too far from the planet in the x-direction to
                        \ bump into a space station

 LDX #3                 \ Call MAS1 with X = 3, Y = 11 to do the following:
 LDY #11                \
 JSR MAS1               \   (y_sign y_hi y_lo) += (nosev_y_hi nosev_y_lo) * 2
                        \
                        \   A = |y_sign|

 BNE MA23S              \ If A > 0, jump to MA23S to skip the following, as we
                        \ are too far from the planet in the y-direction to
                        \ bump into a space station

 LDX #6                 \ Call MAS1 with X = 6, Y = 13 to do the following:
 LDY #13                \
 JSR MAS1               \   (z_sign z_hi z_lo) += (nosev_z_hi nosev_z_lo) * 2
                        \
                        \   A = |z_sign|

 BNE MA23S              \ If A > 0, jump to MA23S to skip the following, as we
                        \ are too far from the planet in the z-direction to
                        \ bump into a space station

 LDA #192               \ Call FAROF2 to compare x_hi, y_hi and z_hi with 192,
 JSR FAROF2             \ which will set the C flag if all three are < 192, or
                        \ clear the C flag if any of them are >= 192

 BCC MA23S              \ Jump to MA23S if any one of x_hi, y_hi or z_hi are
                        \ >= 192 (i.e. they must all be < 192 for us to be near
                        \ enough to the planet to bump into a space station)

 JSR WPLS               \ Call WPLS to remove the sun from the screen, as we
                        \ can't have both the sun and the space station at the
                        \ same time

 JSR NWSPS              \ Add a new space station to our local bubble of
                        \ universe

.MA23S

 JMP MA23               \ Jump to MA23 to skip the following planet and sun
                        \ altitude checks

\ ******************************************************************************
\
\       Name: Main flight loop (Part 15 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Perform altitude checks with the planet and sun and process fuel
\             scooping if appropriate
\  Deep dive: Program flow of the main game loop
\             Scheduling tasks with the main loop counter
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Perform an altitude check with the planet (every 32 iterations of the main
\     loop, on iteration 10 of each 32)
\
\   * Perform an altitude check with the sun and process fuel scooping (every
\     32 iterations of the main loop, on iteration 20 of each 32)
\
\ ******************************************************************************

.MA22

 LDA MJ                 \ If we are in witchspace, jump down to MA23S to skip
 BNE MA23S              \ the following, as there are no planets or suns to
                        \ bump into in witchspace

 LDA MCNT               \ Fetch the main loop counter and calculate MCNT mod 32,
 AND #31                \ which tells us the position of this loop in each block
                        \ of 32 iterations

.MA93

 CMP #10                \ If this is the tenth iteration in this block of 32,
 BNE MA29               \ do the following, otherwise jump to MA29 to skip the
                        \ planet altitude check and move on to the sun distance
                        \ check

 LDA #50                \ If our energy bank status in ENERGY is >= 50, skip
 CMP ENERGY             \ printing the following message (so the message is
 BCC P%+6               \ only shown if our energy is low)

 ASL A                  \ Print recursive token 100 ("ENERGY LOW{beep}") as an
 JSR MESS               \ in-flight message

 LDY #&FF               \ Set our altitude in ALTIT to &FF, the maximum
 STY ALTIT

 INY                    \ Set Y = 0

 JSR m                  \ Call m to calculate the maximum distance to the
                        \ planet in any of the three axes, returned in A

 BNE MA23               \ If A > 0 then we are a fair distance away from the
                        \ planet in at least one axis, so jump to MA23 to skip
                        \ the rest of the altitude check

 JSR MAS3               \ Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
                        \ we now know that A now contains the square of the
                        \ distance between our ship (at the origin) and the
                        \ centre of the planet at (x_hi, y_hi, z_hi)

 BCS MA23               \ If the C flag was set by MAS3, then the result
                        \ overflowed (was greater than &FF) and we are still a
                        \ fair distance from the planet, so jump to MA23 as we
                        \ haven't crashed into the planet

 SBC #36                \ Subtract 36 from x_hi^2 + y_hi^2 + z_hi^2. The radius
                        \ of the planet is defined as 6 units and 6^2 = 36, so
                        \ A now contains the high byte of our altitude above
                        \ the planet surface, squared

 BCC MA28               \ If A < 0 then jump to MA28 as we have crashed into
                        \ the planet

 STA R                  \ We are getting close to the planet, so we need to
 JSR LL5                \ work out how close. We know from the above that A
                        \ contains our altitude squared, so we store A in R
                        \ and call LL5 to calculate:
                        \
                        \   Q = SQRT(R Q) = SQRT(A Q)
                        \
                        \ Interestingly, Q doesn't appear to be set to 0 for
                        \ this calculation, so presumably this doesn't make a
                        \ difference

 LDA Q                  \ Store the result in ALTIT, our altitude
 STA ALTIT

 BNE MA23               \ If our altitude is non-zero then we haven't crashed,
                        \ so jump to MA23 to skip to the next section

.MA28

 JMP DEATH              \ If we get here then we just crashed into the planet
                        \ or got too close to the sun, so jump to DEATH to start
                        \ the funeral preparations and return from the main
                        \ flight loop using a tail call

.MA29

 CMP #15                \ If this is the 15th iteration in this block of 32,
 BNE MA33               \ do the following, otherwise jump to MA33 to skip the
                        \ docking computer manoeuvring

 LDA auto               \ If auto is zero, then the docking computer is not
 BEQ MA23               \ activated, so jump to MA33 to skip the
                        \ docking computer manoeuvring

 LDA #123               \ Set A = 123 and jump down to MA34 to print token 123
 BNE MA34               \ ("DOCKING COMPUTERS ON") as an in-flight message

.MA33

 CMP #20                \ If this is the 20th iteration in this block of 32,
 BNE MA23               \ do the following, otherwise jump to MA23 to skip the
                        \ sun altitude check

 LDA #30                \ Set CABTMP to 30, the cabin temperature in deep space
 STA CABTMP             \ (i.e. one notch on the dashboard bar)

 LDA SSPR               \ If we are inside the space station safe zone, jump to
 BNE MA23               \ MA23 to skip the following, as we can't have both the
                        \ sun and space station at the same time, so we clearly
                        \ can't be flying near the sun

 LDY #NI%               \ Set Y to NI%, which is the offset in K% for the sun's
                        \ data block, as the second block at K% is reserved for
                        \ the sun (or space station)

 JSR MAS2               \ Call MAS2 to calculate the largest distance to the
 BNE MA23               \ sun in any of the three axes, and if it's non-zero,
                        \ jump to MA23 to skip the following, as we are too far
                        \ from the sun for scooping or temperature changes

 JSR MAS3               \ Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
                        \ we now know that A now contains the square of the
                        \ distance between our ship (at the origin) and the
                        \ heart of the sun at (x_hi, y_hi, z_hi)

 EOR #%11111111         \ Invert A, so A is now small if we are far from the
                        \ sun and large if we are close to the sun, in the
                        \ range 0 = far away to &FF = extremely close, ouch,
                        \ hot, hot, hot!

 ADC #30                \ Add the minimum cabin temperature of 30, so we get
                        \ one of the following:
                        \
                        \   * If the C flag is clear, A contains the cabin
                        \     temperature, ranging from 30 to 255, that's hotter
                        \     the closer we are to the sun
                        \
                        \   * If the C flag is set, the addition has rolled over
                        \     and the cabin temperature is over 255

 STA CABTMP             \ Store the updated cabin temperature

 BCS MA28               \ If the C flag is set then jump to MA28 to die, as
                        \ our temperature is off the scale

 CMP #224               \ If the cabin temperature < 224 then jump to MA23 to
 BCC MA23               \ skip fuel scooping, as we aren't close enough

 LDA BST                \ If we don't have fuel scoops fitted, jump to BA23 to
 BEQ MA23               \ skip fuel scooping, as we can't scoop without fuel
                        \ scoops

 LDA DELT4+1            \ We are now successfully fuel scooping, so it's time
 LSR A                  \ to work out how much fuel we're scooping. Fetch the
                        \ high byte of DELT4, which contains our current speed
                        \ divided by 4, and halve it to get our current speed
                        \ divided by 8 (so it's now a value between 1 and 5, as
                        \ our speed is normally between 1 and 40). This gives
                        \ us the amount of fuel that's being scooped in A, so
                        \ the faster we go, the more fuel we scoop, and because
                        \ the fuel levels are stored as 10 * the fuel in light
                        \ years, that means we just scooped between 0.1 and 0.5
                        \ light years of free fuel

 ADC QQ14               \ Set A = A + the current fuel level * 10 (from QQ14)

 CMP new_range          \ If A > new_range then set A = new_range (as new_range
 BCC P%+5               \ is the maximum fuel level for our current ship
 LDA new_range

 STA QQ14               \ Store the updated fuel level in QQ14

 LDA #160               \ Set A to token 160 ("FUEL SCOOPS ON")

.MA34

 JSR MESS               \ Print the token in A as an in-flight message

\ ******************************************************************************
\
\       Name: Main flight loop (Part 16 of 16)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Process laser pulsing, E.C.M. energy drain, call stardust routine
\  Deep dive: Program flow of the main game loop
\
\ ------------------------------------------------------------------------------
\
\ The main flight loop covers most of the flight-specific aspects of Elite. This
\ section covers the following:
\
\   * Process laser pulsing
\
\   * Process E.C.M. energy drain
\
\   * Jump to the stardust routine if we are in a space view
\
\   * Return from the main flight loop
\
\ ******************************************************************************

.MA23

 LDA LAS2               \ If the current view has no laser, jump to MA16 to skip
 BEQ MA16               \ the following

 JSR read_0346          \ Get the value of the I/O processor's copy of LASCT

 CMP #8                 \ If LASCT >= 8, jump to MA16 to skip the following, so
 BCS MA16               \ for a pulse laser with a LASCT between 8 and 10, the
                        \ laser stays on, but for a LASCT of 7 or less it gets
                        \ turned off and stays off until LASCT reaches zero and
                        \ the next pulse can start (if the fire button is still
                        \ being pressed)

                        \
                        \ For pulse lasers, LASCT gets set to 10 in ma1 above,
                        \ and it decrements every vertical sync (50 times a
                        \ second), so this means it pulses five times a second,
                        \ with the laser being on for the first 3/10 of each
                        \ pulse and off for the rest of the pulse
                        \
                        \ If this is a beam laser, LASCT is 0 so we always keep
                        \ going here. This means the laser doesn't pulse, but it
                        \ does get drawn and removed every cycle, in a slightly
                        \ different place each time, so the beams still flicker
                        \ around the screen

 JSR LASLI2             \ Redraw the existing laser lines, which has the effect
                        \ of removing them from the screen

 LDA #0                 \ Set LAS2 to 0 so if this is a pulse laser, it will
 STA LAS2               \ skip over the above until the next pulse (this has no
                        \ effect if this is a beam laser)

.MA16

 LDA ECMP               \ If our E.C.M is not on, skip to MA69, otherwise keep
 BEQ MA69               \ going to drain some energy

 JSR DENGY              \ Call DENGY to deplete our energy banks by 1

 BEQ MA70               \ If we have no energy left, jump to MA70 to turn our
                        \ E.C.M. off

.MA69

 LDA ECMA               \ If an E.C.M is going off (ours or an opponent's) then
 BEQ MA66               \ keep going, otherwise skip to MA66

 DEC ECMA               \ Decrement the E.C.M. countdown timer, and if it has
 BNE MA66               \ reached zero, keep going, otherwise skip to MA66

.MA70

 JSR ECMOF              \ If we get here then either we have either run out of
                        \ energy, or the E.C.M. timer has run down, so switch
                        \ off the E.C.M.

.MA66

 LDA QQ11               \ If this is not a space view (i.e. QQ11 is non-zero)
 BNE oh                 \ then jump to oh to return from the main flight loop
                        \ (as oh is an RTS)

 JMP STARS              \ This is a space view, so jump to the STARS routine to
                        \ process the stardust, and return from the main flight
                        \ loop using a tail call

\ ******************************************************************************
\
\       Name: SPIN
\       Type: Subroutine
\   Category: Universe
\    Summary: Randomly spawn cargo from a destroyed ship
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The type of cargo to consider spawning (typically #PLT
\                       or #OIL)
\
\ Other entry points:
\
\   oh                  Contains an RTS
\
\   SPIN2               Remove any randomness: spawn cargo of a specific type
\                       (given in X), and always spawn the number given in A
\
\ ******************************************************************************

.SPIN

 JSR DORND              \ Fetch a random number, and jump to oh if it is
 BPL oh                 \ positive (50% chance)

 PHA                    \ Store A on the stack so we can restore it after the
                        \ following transfers

 TYA                    \ Copy the cargo type from Y into A and X
 TAX

 PLA                    \ Restore A from the stack

 LDY #0                 \ Fetch the first byte of the hit ship's blueprint,
 AND (XX0),Y            \ which determines the maximum number of bits of
                        \ debris shown when the ship is destroyed, and AND
                        \ with the random number we just fetched

 AND #15                \ Reduce the random number in A to the range 0-15

.SPIN2

 STA CNT                \ Store the result in CNT, so CNT contains a random
                        \ number between 0 and the maximum number of bits of
                        \ debris that this ship will release when destroyed
                        \ (to a maximum of 15 bits of debris)

.spl

 BEQ oh                 \ We're going to go round a loop using CNT as a counter
                        \ so this checks whether the counter is zero and jumps
                        \ to oh when it gets there (which might be straight
                        \ away)

 LDA #0                 \ Call SFS1 to spawn the specified cargo from the now
 JSR SFS1               \ deceased parent ship, giving the spawned canister an
                        \ AI flag of 0 (no AI, no E.C.M., non-hostile)

 DEC CNT                \ Decrease the loop counter

 BNE spl+2              \ Jump back up to the LDA &0 instruction above (this BPL
                        \ is effectively a JMP as CNT will never be negative)

.oh

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PIX1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (YY+1 SYL+Y) = (A P) + (S R) and draw stardust particle
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   (YY+1 SYL+Y) = (A P) + (S R)
\
\ and draw a stardust particle at (X1,Y1) with distance ZZ.
\
\ Arguments:
\
\   (A P)               A is the angle ALPHA or BETA, P is always 0
\
\   (S R)               YY(1 0) or YY(1 0) + Q * A
\
\   Y                   Stardust particle number
\
\   X1                  The x-coordinate offset
\
\   Y1                  The y-coordinate offset
\
\   ZZ                  The distance of the point (further away = smaller point)
\
\ ******************************************************************************

.PIX1

 JSR ADD                \ Set (A X) = (A P) + (S R)

 STA YY+1               \ Set YY+1 to A, the high byte of the result

 TXA                    \ Set SYL+Y to X, the low byte of the result
 STA SYL,Y

                        \ Fall through into PIX1 to draw the stardust particle
                        \ at (X1,Y1)

\ ******************************************************************************
\
\       Name: PIXEL2
\       Type: Subroutine
\   Category: Drawing pixels
\    Summary: Draw a stardust particle relative to the screen centre
\
\ ------------------------------------------------------------------------------
\
\ Draw a point (X1, Y1) from the middle of the screen with a size determined by
\ a distance value. Used to draw stardust particles.
\
\ Arguments:
\
\   X1                  The x-coordinate offset
\
\   Y1                  The y-coordinate offset (positive means up the screen
\                       from the centre, negative means down the screen)
\
\   ZZ                  The distance of the point (further away = smaller point)
\
\ ******************************************************************************

.PIXEL2

 LDA X1                 \ Fetch the x-coordinate offset into A

 BPL PX1                \ If the x-coordinate offset is positive, jump to PX1
                        \ to skip the following negation

 EOR #%01111111         \ The x-coordinate offset is negative, so flip all the
 CLC                    \ bits apart from the sign bit and add 1, to convert it
 ADC #1                 \ from a sign-magnitude number to a signed number

.PX1

 EOR #%10000000         \ Set X = X1 + 128
 TAX                    \
                        \ So X is now the offset converted to an x-coordinate,
                        \ centred on x-coordinate 128

 LDA Y1                 \ Fetch the y-coordinate offset into A and clear the
 AND #%01111111         \ sign bit, so A = |Y1|

 CMP #96                \ If |Y1| >= 96 then it's off the screen (as 96 is half
 BCS PX4                \ the screen height), so return from the subroutine (as
                        \ PX4 contains an RTS)

 LDA Y1                 \ Fetch the y-coordinate offset into A

 BPL PX2                \ If the y-coordinate offset is positive, jump to PX2
                        \ to skip the following negation

 EOR #%01111111         \ The y-coordinate offset is negative, so flip all the
 ADC #1                 \ bits apart from the sign bit and subtract 1, to negate
                        \ it to a positive number, i.e. A is now |Y1|

.PX2

 STA T                  \ Set A = 97 - Y1
 LDA #97                \
 SBC T                  \ So if Y is positive we display the point up from the
                        \ centre at y-coordinate 97, while a negative Y means
                        \ down from the centre

 JMP PIXEL              \ Jump to PIXEL to draw the stardust at the screen
                        \ coordinates in (X, A), returning from the subroutine
                        \ using a tail call

.PX4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FLIP
\       Type: Subroutine
\   Category: Stardust
\    Summary: Reflect the stardust particles in the screen diagonal and redraw
\             the stardust field
\
\ ------------------------------------------------------------------------------
\
\ Swap the x- and y-coordinates of all the stardust particles and draw the new
\ set of particles. Called by LOOK1 when we switch views.
\
\ This is a quick way of making the stardust field in the new view feel
\ different without having to generate a whole new field. If you look carefully
\ at the stardust field when you switch views, you can just about see that the
\ new field is a reflection of the previous field in the screen diagonal, i.e.
\ in the line from bottom left to top right. This is the line where x = y when
\ the origin is in the middle of the screen, and positive x and y are right and
\ up, which is the coordinate system we use for stardust).
\
\ ******************************************************************************

.FLIP

 LDY NOSTM              \ Set Y to the current number of stardust particles, so
                        \ we can use it as a counter through all the stardust

.FLL1

 LDX SY,Y               \ Copy the Y-th particle's y-coordinate from SY+Y into X

 LDA SX,Y               \ Copy the Y-th particle's x-coordinate from SX+Y into
 STA Y1                 \ both Y1 and the particle's y-coordinate
 STA SY,Y

 TXA                    \ Copy the Y-th particle's original y-coordinate into
 STA X1                 \ both X1 and the particle's x-coordinate, so the x- and
 STA SX,Y               \ y-coordinates are now swapped and (X1, Y1) contains
                        \ the particle's new coordinates

 LDA SZ,Y               \ Fetch the Y-th particle's distance from SZ+Y into ZZ
 STA ZZ

 JSR PIXEL2             \ Draw a stardust particle at (X1,Y1) with distance ZZ

 DEY                    \ Decrement the counter to point to the next particle of
                        \ stardust

 BNE FLL1               \ Loop back to FLL1 until we have moved all the stardust
                        \ particles

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: STARS
\       Type: Subroutine
\   Category: Stardust
\    Summary: The main routine for processing the stardust
\
\ ------------------------------------------------------------------------------
\
\ Called at the very end of the main flight loop.
\
\ ******************************************************************************

.STARS

 LDX VIEW               \ Load the current view into X:
                        \
                        \   0 = front
                        \   1 = rear
                        \   2 = left
                        \   3 = right

 BEQ STARS1             \ If this 0, jump to STARS1 to process the stardust for
                        \ the front view

 DEX                    \ If this is view 2 or 3, jump to STARS2 (via ST11) to
 BNE ST11               \ process the stardust for the left or right views

 JMP STARS6             \ Otherwise this is the rear view, so jump to STARS6 to
                        \ process the stardust for the rear view

.ST11

 JMP STARS2             \ Jump to STARS2 for the left or right views, as it's
                        \ too far for the branch instruction above

\ ******************************************************************************
\
\       Name: STARS1
\       Type: Subroutine
\   Category: Stardust
\    Summary: Process the stardust for the front view
\  Deep dive: Stardust in the front view
\
\ ------------------------------------------------------------------------------
\
\ This moves the stardust towards us according to our speed (so the dust rushes
\ past us), and applies our current pitch and roll to each particle of dust, so
\ the stardust moves correctly when we steer our ship.
\
\ When a stardust particle rushes past us and falls off the side of the screen,
\ its memory is recycled as a new particle that's positioned randomly on-screen.
\
\ These are the calculations referred to in the commentary:
\
\   1. q = 64 * speed / z_hi
\   2. z = z - speed * 64
\   3. y = y + |y_hi| * q
\   4. x = x + |x_hi| * q
\
\   5. y = y + alpha * x / 256
\   6. x = x - alpha * y / 256
\
\   7. x = x + 2 * (beta * y / 256) ^ 2
\   8. y = y - beta * 256
\
\ For more information see the deep dive on "Stardust in the front view".
\
\ ******************************************************************************

.STARS1

 LDY NOSTM              \ Set Y to the current number of stardust particles, so
                        \ we can use it as a counter through all the stardust

                        \ In the following, we're going to refer to the 16-bit
                        \ space coordinates of the current particle of stardust
                        \ (i.e. the Y-th particle) like this:
                        \
                        \   x = (x_hi x_lo)
                        \   y = (y_hi y_lo)
                        \   z = (z_hi z_lo)
                        \
                        \ These values are stored in (SX+Y SXL+Y), (SY+Y SYL+Y)
                        \ and (SZ+Y SZL+Y) respectively

.STL1

 JSR DV42               \ Call DV42 to set the following:
                        \
                        \   (P R) = 256 * DELTA / z_hi
                        \         = 256 * speed / z_hi
                        \
                        \ The maximum value returned is P = 2 and R = 128 (see
                        \ DV42 for an explanation)

 LDA R                  \ Set A = R, so now:
                        \
                        \   (P A) = 256 * speed / z_hi

 LSR P                  \ Rotate (P A) right by 2 places, which sets P = 0 (as P
 ROR A                  \ has a maximum value of 2) and leaves:
 LSR P                  \
 ROR A                  \   A = 64 * speed / z_hi

 ORA #1                 \ Make sure A is at least 1, and store it in Q, so we
 STA Q                  \ now have result 1 above:
                        \
                        \   Q = 64 * speed / z_hi

 LDA SZL,Y              \ We now calculate the following:
 SBC DELT4              \
 STA SZL,Y              \  (z_hi z_lo) = (z_hi z_lo) - DELT4(1 0)
                        \
                        \ starting with the low bytes

 LDA SZ,Y               \ And then we do the high bytes
 STA ZZ                 \
 SBC DELT4+1            \ We also set ZZ to the original value of z_hi, which we
 STA SZ,Y               \ use below to remove the existing particle
                        \
                        \ So now we have result 2 above:
                        \
                        \   z = z - DELT4(1 0)
                        \     = z - speed * 64

 JSR MLU1               \ Call MLU1 to set:
                        \
                        \   Y1 = y_hi
                        \
                        \   (A P) = |y_hi| * Q
                        \
                        \ So Y1 contains the original value of y_hi, which we
                        \ use below to remove the existing particle

                        \ We now calculate:
                        \
                        \   (S R) = YY(1 0) = (A P) + y

 STA YY+1               \ First we do the low bytes with:
 LDA P                  \
 ADC SYL,Y              \   YY+1 = A
 STA YY                 \   R = YY = P + y_lo
 STA R                  \
                        \ so we get this:
                        \
                        \   (? R) = YY(1 0) = (A P) + y_lo

 LDA Y1                 \ And then we do the high bytes with:
 ADC YY+1               \
 STA YY+1               \   S = YY+1 = y_hi + YY+1
 STA S                  \
                        \ so we get our result:
                        \
                        \   (S R) = YY(1 0) = (A P) + (y_hi y_lo)
                        \                   = |y_hi| * Q + y
                        \
                        \ which is result 3 above, and (S R) is set to the new
                        \ value of y

 LDA SX,Y               \ Set X1 = A = x_hi
 STA X1                 \
                        \ So X1 contains the original value of x_hi, which we
                        \ use below to remove the existing particle

 JSR MLU2               \ Set (A P) = |x_hi| * Q

                        \ We now calculate:
                        \
                        \   XX(1 0) = (A P) + x

 STA XX+1               \ First we do the low bytes:
 LDA P                  \
 ADC SXL,Y              \   XX(1 0) = (A P) + x_lo
 STA XX

 LDA X1                 \ And then we do the high bytes:
 ADC XX+1               \
 STA XX+1               \   XX(1 0) = XX(1 0) + (x_hi 0)
                        \
                        \ so we get our result:
                        \
                        \   XX(1 0) = (A P) + x
                        \           = |x_hi| * Q + x
                        \
                        \ which is result 4 above, and we also have:
                        \
                        \   A = XX+1 = (|x_hi| * Q + x) / 256
                        \
                        \ i.e. A is the new value of x, divided by 256

 EOR ALP2+1             \ EOR with the flipped sign of the roll angle alpha, so
                        \ A has the opposite sign to the flipped roll angle
                        \ alpha, i.e. it gets the same sign as alpha

 JSR MLS1               \ Call MLS1 to calculate:
                        \
                        \   (A P) = A * ALP1
                        \         = (x / 256) * alpha

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = (x / 256) * alpha + y
                        \         = y + alpha * x / 256

 STA YY+1               \ Set YY(1 0) = (A X) to give:
 STX YY                 \
                        \   YY(1 0) = y + alpha * x / 256
                        \
                        \ which is result 5 above, and we also have:
                        \
                        \   A = YY+1 = y + alpha * x / 256
                        \
                        \ i.e. A is the new value of y, divided by 256

 EOR ALP2               \ EOR A with the correct sign of the roll angle alpha,
                        \ so A has the opposite sign to the roll angle alpha

 JSR MLS2               \ Call MLS2 to calculate:
                        \
                        \   (S R) = XX(1 0)
                        \         = x
                        \
                        \   (A P) = A * ALP1
                        \         = -y / 256 * alpha

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = -y / 256 * alpha + x

 STA XX+1               \ Set XX(1 0) = (A X), which gives us result 6 above:
 STX XX                 \
                        \   x = x - alpha * y / 256

 LDX BET1               \ Fetch the pitch magnitude into X

 LDA YY+1               \ Set A to y_hi and set it to the flipped sign of beta
 EOR BET2+1

 JSR MULTS-2            \ Call MULTS-2 to calculate:
                        \
                        \   (A P) = X * A
                        \         = -beta * y_hi

 STA Q                  \ Store the high byte of the result in Q, so:
                        \
                        \   Q = -beta * y_hi / 256

 JSR MUT2               \ Call MUT2 to calculate:
                        \
                        \   (S R) = XX(1 0) = x
                        \
                        \   (A P) = Q * A
                        \         = (-beta * y_hi / 256) * (-beta * y_hi / 256)
                        \         = (beta * y / 256) ^ 2

 ASL P                  \ Double (A P), store the top byte in A and set the C
 ROL A                  \ flag to bit 7 of the original A, so this does:
 STA T                  \
                        \   (T P) = (A P) << 1
                        \         = 2 * (beta * y / 256) ^ 2

 LDA #0                 \ Set bit 7 in A to the sign bit from the A in the
 ROR A                  \ calculation above and apply it to T, so we now have:
 ORA T                  \
                        \   (A P) = (A P) * 2
                        \         = 2 * (beta * y / 256) ^ 2
                        \
                        \ with the doubling retaining the sign of (A P)

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = 2 * (beta * y / 256) ^ 2 + x

 STA XX+1               \ Store the high byte A in XX+1

 TXA
 STA SXL,Y              \ Store the low byte X in x_lo

                        \ So (XX+1 x_lo) now contains:
                        \
                        \   x = x + 2 * (beta * y / 256) ^ 2
                        \
                        \ which is result 7 above

 LDA YY                 \ Set (S R) = YY(1 0) = y
 STA R
 LDA YY+1
 STA S

 LDA #0                 \ Set P = 0
 STA P

 LDA BETA               \ Set A = -beta, so:
 EOR #%10000000         \
                        \   (A P) = (-beta 0)
                        \         = -beta * 256

 JSR PIX1               \ Call PIX1 to calculate the following:
                        \
                        \   (YY+1 y_lo) = (A P) + (S R)
                        \               = -beta * 256 + y
                        \
                        \ i.e. y = y - beta * 256, which is result 8 above
                        \
                        \ PIX1 also draws a particle at (X1, Y1) with distance
                        \ ZZ, which will remove the old stardust particle, as we
                        \ set X1, Y1 and ZZ to the original values for this
                        \ particle during the calculations above

                        \ We now have our newly moved stardust particle at
                        \ x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
                        \ and distance z_hi, so we draw it if it's still on
                        \ screen, otherwise we recycle it as a new bit of
                        \ stardust and draw that

 LDA XX+1               \ Set X1 and x_hi to the high byte of XX in XX+1, so
 STA X1                 \ the new x-coordinate is in (x_hi x_lo) and the high
 STA SX,Y               \ byte is in X1

 AND #%01111111         \ If |x_hi| >= 120 then jump to KILL1 to recycle this
 CMP #120               \ particle, as it's gone off the side of the screen,
 BCS KILL1              \ and re-join at STC1 with the new particle

 LDA YY+1               \ Set Y1 and y_hi to the high byte of YY in YY+1, so
 STA SY,Y               \ the new x-coordinate is in (y_hi y_lo) and the high
 STA Y1                 \ byte is in Y1

 AND #%01111111         \ If |y_hi| >= 120 then jump to KILL1 to recycle this
 CMP #120               \ particle, as it's gone off the top or bottom of the
 BCS KILL1              \ screen, and re-join at STC1 with the new particle

 LDA SZ,Y               \ If z_hi < 16 then jump to KILL1 to recycle this
 CMP #16                \ particle, as it's so close that it's effectively gone
 BCC KILL1              \ past us, and re-join at STC1 with the new particle

 STA ZZ                 \ Set ZZ to the z-coordinate in z_hi

.STC1

 JSR PIXEL2             \ Draw a stardust particle at (X1,Y1) with distance ZZ,
                        \ i.e. draw the newly moved particle at (x_hi, y_hi)
                        \ with distance z_hi

 DEY                    \ Decrement the loop counter to point to the next
                        \ stardust particle

 BEQ P%+5               \ If we have just done the last particle, skip the next
                        \ instruction to return from the subroutine

 JMP STL1               \ We have more stardust to process, so jump back up to
                        \ STL1 for the next particle

 RTS                    \ Return from the subroutine

.KILL1

                        \ Our particle of stardust just flew past us, so let's
                        \ recycle that particle, starting it at a random
                        \ position that isn't too close to the centre point

 JSR DORND              \ Set A and X to random numbers

 ORA #4                 \ Make sure A is at least 4 and store it in Y1 and y_hi,
 STA Y1                 \ so the new particle starts at least 4 pixels above or
 STA SY,Y               \ below the centre of the screen

 JSR DORND              \ Set A and X to random numbers

 ORA #8                 \ Make sure A is at least 8 and store it in X1 and x_hi,
 STA X1                 \ so the new particle starts at least 8 pixels either
 STA SX,Y               \ side of the centre of the screen

 JSR DORND              \ Set A and X to random numbers

 ORA #144               \ Make sure A is at least 144 and store it in ZZ and
 STA SZ,Y               \ z_hi so the new particle starts in the far distance
 STA ZZ

 LDA Y1                 \ Set A to the new value of y_hi. This has no effect as
                        \ STC1 starts with a jump to PIXEL2, which starts with a
                        \ LDA instruction

 JMP STC1               \ Jump up to STC1 to draw this new particle

\ ******************************************************************************
\
\       Name: STARS6
\       Type: Subroutine
\   Category: Stardust
\    Summary: Process the stardust for the rear view
\
\ ------------------------------------------------------------------------------
\
\ This routine is very similar to STARS1, which processes stardust for the front
\ view. The main difference is that the direction of travel is reversed, so the
\ signs in the calculations are different, as well as the order of the first
\ batch of calculations.
\
\ When a stardust particle falls away into the far distance, it is removed from
\ the screen and its memory is recycled as a new particle, positioned randomly
\ along one of the four edges of the screen.
\
\ These are the calculations referred to in the commentary:
\
\   1. q = 64 * speed / z_hi
\   2. z = z - speed * 64
\   3. y = y + |y_hi| * q
\   4. x = x + |x_hi| * q
\
\   5. y = y + alpha * x / 256
\   6. x = x - alpha * y / 256
\
\   7. x = x + 2 * (beta * y / 256) ^ 2
\   8. y = y - beta * 256
\
\ For more information see the deep dive on "Stardust in the front view".
\
\ ******************************************************************************

.STARS6

 LDY NOSTM              \ Set Y to the current number of stardust particles, so
                        \ we can use it as a counter through all the stardust

.STL6

 JSR DV42               \ Call DV42 to set the following:
                        \
                        \   (P R) = 256 * DELTA / z_hi
                        \         = 256 * speed / z_hi
                        \
                        \ The maximum value returned is P = 2 and R = 128 (see
                        \ DV42 for an explanation)

 LDA R                  \ Set A = R, so now:
                        \
                        \   (P A) = 256 * speed / z_hi

 LSR P                  \ Rotate (P A) right by 2 places, which sets P = 0 (as P
 ROR A                  \ has a maximum value of 2) and leaves:
 LSR P                  \
 ROR A                  \   A = 64 * speed / z_hi

 ORA #1                 \ Make sure A is at least 1, and store it in Q, so we
 STA Q                  \ now have result 1 above:
                        \
                        \   Q = 64 * speed / z_hi

 LDA SX,Y               \ Set X1 = A = x_hi
 STA X1                 \
                        \ So X1 contains the original value of x_hi, which we
                        \ use below to remove the existing particle

 JSR MLU2               \ Set (A P) = |x_hi| * Q

                        \ We now calculate:
                        \
                        \   XX(1 0) = x - (A P)

 STA XX+1               \ First we do the low bytes:
 LDA SXL,Y              \
 SBC P                  \   XX(1 0) = x_lo - (A P)
 STA XX

 LDA X1                 \ And then we do the high bytes:
 SBC XX+1               \
 STA XX+1               \   XX(1 0) = (x_hi 0) - XX(1 0)
                        \
                        \ so we get our result:
                        \
                        \   XX(1 0) = x - (A P)
                        \           = x - |x_hi| * Q
                        \
                        \ which is result 2 above, and we also have:

 JSR MLU1               \ Call MLU1 to set:
                        \
                        \   Y1 = y_hi
                        \
                        \   (A P) = |y_hi| * Q
                        \
                        \ So Y1 contains the original value of y_hi, which we
                        \ use below to remove the existing particle

                        \ We now calculate:
                        \
                        \   (S R) = YY(1 0) = y - (A P)

 STA YY+1               \ First we do the low bytes with:
 LDA SYL,Y              \
 SBC P                  \   YY+1 = A
 STA YY                 \   R = YY = y_lo - P
 STA R                  \
                        \ so we get this:
                        \
                        \   (? R) = YY(1 0) = y_lo - (A P)

 LDA Y1                 \ And then we do the high bytes with:
 SBC YY+1               \
 STA YY+1               \   S = YY+1 = y_hi - YY+1
 STA S                  \
                        \ so we get our result:
                        \
                        \   (S R) = YY(1 0) = (y_hi y_lo) - (A P)
                        \                   = y - |y_hi| * Q
                        \
                        \ which is result 3 above, and (S R) is set to the new
                        \ value of y

 LDA SZL,Y              \ We now calculate the following:
 ADC DELT4              \
 STA SZL,Y              \  (z_hi z_lo) = (z_hi z_lo) + DELT4(1 0)
                        \
                        \ starting with the low bytes

 LDA SZ,Y               \ And then we do the high bytes
 STA ZZ                 \
 ADC DELT4+1            \ We also set ZZ to the original value of z_hi, which we
 STA SZ,Y               \ use below to remove the existing particle
                        \
                        \ So now we have result 4 above:
                        \
                        \   z = z + DELT4(1 0)
                        \     = z + speed * 64

 LDA XX+1               \ EOR x with the correct sign of the roll angle alpha,
 EOR ALP2               \ so A has the opposite sign to the roll angle alpha

 JSR MLS1               \ Call MLS1 to calculate:
                        \
                        \   (A P) = A * ALP1
                        \         = (-x / 256) * alpha

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = (-x / 256) * alpha + y
                        \         = y - alpha * x / 256

 STA YY+1               \ Set YY(1 0) = (A X) to give:
 STX YY                 \
                        \   YY(1 0) = y - alpha * x / 256
                        \
                        \ which is result 5 above, and we also have:
                        \
                        \   A = YY+1 = y - alpha * x / 256
                        \
                        \ i.e. A is the new value of y, divided by 256

 EOR ALP2+1             \ EOR with the flipped sign of the roll angle alpha, so
                        \ A has the opposite sign to the flipped roll angle
                        \ alpha, i.e. it gets the same sign as alpha

 JSR MLS2               \ Call MLS2 to calculate:
                        \
                        \   (S R) = XX(1 0)
                        \         = x
                        \
                        \   (A P) = A * ALP1
                        \         = y / 256 * alpha

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = y / 256 * alpha + x

 STA XX+1               \ Set XX(1 0) = (A X), which gives us result 6 above:
 STX XX                 \
                        \   x = x + alpha * y / 256

 LDA YY+1               \ Set A to y_hi and set it to the flipped sign of beta
 EOR BET2+1

 LDX BET1               \ Fetch the pitch magnitude into X

 JSR MULTS-2            \ Call MULTS-2 to calculate:
                        \
                        \   (A P) = X * A
                        \         = beta * y_hi

 STA Q                  \ Store the high byte of the result in Q, so:
                        \
                        \   Q = beta * y_hi / 256

 LDA XX+1               \ Set S = x_hi
 STA S

 EOR #%10000000         \ Flip the sign of A, so A now contains -x

 JSR MUT1               \ Call MUT1 to calculate:
                        \
                        \   R = XX = x_lo
                        \
                        \   (A P) = Q * A
                        \         = (beta * y_hi / 256) * (-beta * y_hi / 256)
                        \         = (-beta * y / 256) ^ 2

 ASL P                  \ Double (A P), store the top byte in A and set the C
 ROL A                  \ flag to bit 7 of the original A, so this does:
 STA T                  \
                        \   (T P) = (A P) << 1
                        \         = 2 * (-beta * y / 256) ^ 2

 LDA #0                 \ Set bit 7 in A to the sign bit from the A in the
 ROR A                  \ calculation above and apply it to T, so we now have:
 ORA T                  \
                        \   (A P) = -2 * (beta * y / 256) ^ 2
                        \
                        \ with the doubling retaining the sign of (A P)

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = -2 * (beta * y / 256) ^ 2 + x

 STA XX+1               \ Store the high byte A in XX+1

 TXA
 STA SXL,Y              \ Store the low byte X in x_lo

                        \ So (XX+1 x_lo) now contains:
                        \
                        \   x = x - 2 * (beta * y / 256) ^ 2
                        \
                        \ which is result 7 above

 LDA YY                 \ Set (S R) = YY(1 0) = y
 STA R
 LDA YY+1
 STA S

 LDA #0                 \ Set P = 0
 STA P

 LDA BETA               \ Set A = beta, so (A P) = (beta 0) = beta * 256

 JSR PIX1               \ Call PIX1 to calculate the following:
                        \
                        \   (YY+1 y_lo) = (A P) + (S R)
                        \               = beta * 256 + y
                        \
                        \ i.e. y = y + beta * 256, which is result 8 above
                        \
                        \ PIX1 also draws a particle at (X1, Y1) with distance
                        \ ZZ, which will remove the old stardust particle, as we
                        \ set X1, Y1 and ZZ to the original values for this
                        \ particle during the calculations above

                        \ We now have our newly moved stardust particle at
                        \ x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
                        \ and distance z_hi, so we draw it if it's still on
                        \ screen, otherwise we recycle it as a new bit of
                        \ stardust and draw that

 LDA XX+1               \ Set X1 and x_hi to the high byte of XX in XX+1, so
 STA X1                 \ the new x-coordinate is in (x_hi x_lo) and the high
 STA SX,Y               \ byte is in X1

 LDA YY+1               \ Set Y1 and y_hi to the high byte of YY in YY+1, so
 STA SY,Y               \ the new x-coordinate is in (y_hi y_lo) and the high
 STA Y1                 \ byte is in Y1

 AND #%01111111         \ If |y_hi| >= 110 then jump to KILL6 to recycle this
 CMP #110               \ particle, as it's gone off the top or bottom of the
 BCS KILL6              \ screen, and re-join at STC6 with the new particle

 LDA SZ,Y               \ If z_hi >= 160 then jump to KILL6 to recycle this
 CMP #160               \ particle, as it's so far away that it's too far to
 BCS KILL6              \ see, and re-join at STC1 with the new particle

 STA ZZ                 \ Set ZZ to the z-coordinate in z_hi

.STC6

 JSR PIXEL2             \ Draw a stardust particle at (X1,Y1) with distance ZZ,
                        \ i.e. draw the newly moved particle at (x_hi, y_hi)
                        \ with distance z_hi

 DEY                    \ Decrement the loop counter to point to the next
                        \ stardust particle

 BEQ MA9                \ If we have just done the last particle, return from
                        \ the subroutine (as MA9 contains an RTS)

 JMP STL6               \ We have more stardust to process, so jump back up to
                        \ STL6 for the next particle

.KILL6

 JSR DORND              \ Set A and X to random numbers

 AND #%01111111         \ Clear the sign bit of A to get |A|

 ADC #10                \ Make sure A is at least 10 and store it in z_hi and
 STA SZ,Y               \ ZZ, so the new particle starts close to us
 STA ZZ

 LSR A                  \ Divide A by 2 and randomly set the C flag

 BCS ST4                \ Jump to ST4 half the time

 LSR A                  \ Randomly set the C flag again

 LDA #252               \ Set A to either +126 or -126 (252 >> 1) depending on
 ROR A                  \ the C flag, as this is a sign-magnitude number with
                        \ the C flag rotated into its sign bit

 STA X1                 \ Set x_hi and X1 to A, so this particle starts on
 STA SX,Y               \ either the left or right edge of the screen

 JSR DORND              \ Set A and X to random numbers

 STA Y1                 \ Set y_hi and Y1 to random numbers, so the particle
 STA SY,Y               \ starts anywhere along either the left or right edge

 JMP STC6               \ Jump up to STC6 to draw this new particle

.ST4

 JSR DORND              \ Set A and X to random numbers

 STA X1                 \ Set x_hi and X1 to random numbers, so the particle
 STA SX,Y               \ starts anywhere along the x-axis

 LSR A                  \ Randomly set the C flag

 LDA #230               \ Set A to either +115 or -115 (230 >> 1) depending on
 ROR A                  \ the C flag, as this is a sign-magnitude number with
                        \ the C flag rotated into its sign bit

 STA Y1                 \ Set y_hi and Y1 to A, so the particle starts anywhere
 STA SY,Y               \ along either the top or bottom edge of the screen

 BNE STC6               \ Jump up to STC6 to draw this new particle (this BNE is
                        \ effectively a JMP as A will never be zero)

\ ******************************************************************************
\
\       Name: MAS1
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Add an orientation vector coordinate to an INWK coordinate
\  Deep dive: The space station safe zone
\
\ ------------------------------------------------------------------------------
\
\ Add a doubled nosev vector coordinate, e.g. (nosev_y_hi nosev_y_lo) * 2, to
\ an INWK coordinate, e.g. (x_sign x_hi x_lo), storing the result in the INWK
\ coordinate. The axes used in each side of the addition are specified by the
\ arguments X and Y.
\
\ In the comments below, we document the routine as if we are doing the
\ following, i.e. if X = 0 and Y = 11:
\
\   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (nosev_y_hi nosev_y_lo) * 2
\
\ as that way the variable names in the comments contain "x" and "y" to match
\ the registers that specify the vector axis to use.
\
\ Arguments:
\
\   X                   The coordinate to add, as follows:
\
\                         * If X = 0, add (x_sign x_hi x_lo)
\                         * If X = 3, add (y_sign y_hi y_lo)
\                         * If X = 6, add (z_sign z_hi z_lo)
\
\   Y                   The vector to add, as follows:
\
\                         * If Y = 9,  add (nosev_x_hi nosev_x_lo)
\                         * If Y = 11, add (nosev_y_hi nosev_y_lo)
\                         * If Y = 13, add (nosev_z_hi nosev_z_lo)
\
\ Returns:
\
\   A                   The highest byte of the result with the sign cleared
\                       (e.g. |x_sign| when X = 0, etc.)
\
\ Other entry points:
\
\   MA9                 Contains an RTS
\
\ ******************************************************************************

.MAS1

 LDA INWK,Y             \ Set K(2 1) = (nosev_y_hi nosev_y_lo) * 2
 ASL A
 STA K+1
 LDA INWK+1,Y
 ROL A
 STA K+2

 LDA #0                 \ Set K+3 bit 7 to the C flag, so the sign bit of the
 ROR A                  \ above result goes into K+3
 STA K+3

 JSR MVT3               \ Add (x_sign x_hi x_lo) to K(3 2 1)

 STA INWK+2,X           \ Store the sign of the result in x_sign

 LDY K+1                \ Store K(2 1) in (x_hi x_lo)
 STY INWK,X
 LDY K+2
 STY INWK+1,X

 AND #%01111111         \ Set A to the sign byte with the sign cleared,
                        \ i.e. |x_sign| when X = 0

.MA9

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MAS2
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate a cap on the maximum distance to the planet or sun
\
\ ------------------------------------------------------------------------------
\
\ Given a value in Y that points to the start of a ship data block as an offset
\ from K%, calculate the following:
\
\   A = A OR x_sign OR y_sign OR z_sign
\
\ and clear the sign bit of the result. The K% workspace contains the ship data
\ blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
\ K% contains NI% bytes).
\
\ The result effectively contains a maximum cap of the three values (though it
\ might not be one of the three input values - it's just guaranteed to be
\ larger than all of them).
\
\ If Y = 0 and A = 0, then this calculates the maximum cap of the highest byte
\ containing the distance to the planet, as K%+2 = x_sign, K%+5 = y_sign and
\ K%+8 = z_sign (the first slot in the K% workspace represents the planet).
\
\ Arguments:
\
\   Y                   The offset from K% for the start of the ship data block
\                       to use
\
\ Returns:
\
\   A                   A OR K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
\
\ Other entry points:
\
\   m                   Do not include A in the calculation
\
\ ******************************************************************************

.m

 LDA #0                 \ Set A = 0 and fall through into MAS2 to calculate the
                        \ OR of the three bytes at K%+2+Y, K%+5+Y and K%+8+Y

.MAS2

 ORA K%+2,Y             \ Set A = A OR x_sign OR y_sign OR z_sign
 ORA K%+5,Y
 ORA K%+8,Y

 AND #%01111111         \ Clear bit 7 in A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MAS3
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate A = x_hi^2 + y_hi^2 + z_hi^2 in the K% block
\
\ ------------------------------------------------------------------------------
\
\ Given a value in Y that points to the start of a ship data block as an offset
\ from K%, calculate the following:
\
\   A = x_hi^2 + y_hi^2 + z_hi^2
\
\ returning A = &FF if the calculation overflows a one-byte result. The K%
\ workspace contains the ship data blocks, so the offset in Y must be 0 or a
\ multiple of NI% (as each block in K% contains NI% bytes).
\
\ Arguments:
\
\   Y                   The offset from K% for the start of the ship data block
\                       to use
\
\ Returns
\
\   A                   A = x_hi^2 + y_hi^2 + z_hi^2
\
\                       A = &FF if the calculation overflows a one-byte result
\
\ ******************************************************************************

.MAS3

 LDA K%+1,Y             \ Set (A P) = x_hi * x_hi
 JSR SQUA2

 STA R                  \ Store A (high byte of result) in R

 LDA K%+4,Y             \ Set (A P) = y_hi * y_hi
 JSR SQUA2

 ADC R                  \ Add A (high byte of second result) to R

 BCS MA30               \ If the addition of the two high bytes caused a carry
                        \ (i.e. they overflowed), jump to MA30 to return A = &FF

 STA R                  \ Store A (sum of the two high bytes) in R

 LDA K%+7,Y             \ Set (A P) = z_hi * z_hi
 JSR SQUA2

 ADC R                  \ Add A (high byte of third result) to R, so R now
                        \ contains the sum of x_hi^2 + y_hi^2 + z_hi^2

 BCC P%+4               \ If there is no carry, skip the following instruction
                        \ to return straight from the subroutine

.MA30

 LDA #&FF               \ The calculation has overflowed, so set A = &FF

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MVT3
\       Type: Subroutine
\   Category: Moving
\    Summary: Calculate K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
\
\ ------------------------------------------------------------------------------
\
\ Add an INWK position coordinate - i.e. x, y or z - to K(3 2 1), like this:
\
\   K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
\
\ The INWK coordinate to add to K(3 2 1) is specified by X.
\
\ Arguments:
\
\   X                   The coordinate to add to K(3 2 1), as follows:
\
\                         * If X = 0, add (x_sign x_hi x_lo)
\
\                         * If X = 3, add (y_sign y_hi y_lo)
\
\                         * If X = 6, add (z_sign z_hi z_lo)
\
\ Returns:
\
\   A                   Contains a copy of the high byte of the result, K+3
\
\   X                   X is preserved
\
\ ******************************************************************************

.MVT3

 LDA K+3                \ Set S = K+3
 STA S

 AND #%10000000         \ Set T = sign bit of K(3 2 1)
 STA T

 EOR INWK+2,X           \ If x_sign has a different sign to K(3 2 1), jump to
 BMI MV13               \ MV13 to process the addition as a subtraction

 LDA K+1                \ Set K(3 2 1) = K(3 2 1) + (x_sign x_hi x_lo)
 CLC                    \ starting with the low bytes
 ADC INWK,X
 STA K+1

 LDA K+2                \ Then the middle bytes
 ADC INWK+1,X
 STA K+2

 LDA K+3                \ And finally the high bytes
 ADC INWK+2,X

 AND #%01111111         \ Setting the sign bit of K+3 to T, the original sign
 ORA T                  \ of K(3 2 1)
 STA K+3

 RTS                    \ Return from the subroutine

.MV13

 LDA S                  \ Set S = |K+3| (i.e. K+3 with the sign bit cleared)
 AND #%01111111
 STA S

 LDA INWK,X             \ Set K(3 2 1) = (x_sign x_hi x_lo) - K(3 2 1)
 SEC                    \ starting with the low bytes
 SBC K+1
 STA K+1

 LDA INWK+1,X           \ Then the middle bytes
 SBC K+2
 STA K+2

 LDA INWK+2,X           \ And finally the high bytes, doing A = |x_sign| - |K+3|
 AND #%01111111         \ and setting the C flag for testing below
 SBC S

 ORA #%10000000         \ Set the sign bit of K+3 to the opposite sign of T,
 EOR T                  \ i.e. the opposite sign to the original K(3 2 1)
 STA K+3

 BCS MV14               \ If the C flag is set, i.e. |x_sign| >= |K+3|, then
                        \ the sign of K(3 2 1). In this case, we want the
                        \ result to have the same sign as the largest argument,
                        \ which is (x_sign x_hi x_lo), which we know has the
                        \ opposite sign to K(3 2 1), and that's what we just set
                        \ the sign of K(3 2 1) to... so we can jump to MV14 to
                        \ return from the subroutine

 LDA #1                 \ We need to swap the sign of the result in K(3 2 1),
 SBC K+1                \ which we do by calculating 0 - K(3 2 1), which we can
 STA K+1                \ do with 1 - C - K(3 2 1), as we know the C flag is
                        \ clear. We start with the low bytes

 LDA #0                 \ Then the middle bytes
 SBC K+2
 STA K+2

 LDA #0                 \ And finally the high bytes
 SBC K+3

 AND #%01111111         \ Set the sign bit of K+3 to the same sign as T,
 ORA T                  \ i.e. the same sign as the original K(3 2 1), as
 STA K+3                \ that's the largest argument

.MV14

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ESCAPE
\       Type: Subroutine
\   Category: Flight
\    Summary: Launch our escape pod
\
\ ------------------------------------------------------------------------------
\
\ This routine displays our doomed Cobra Mk III disappearing off into the ether
\ before arranging our replacement ship. Called when we press ESCAPE during
\ flight and have an escape pod fitted.
\
\ ******************************************************************************

.ESCAPE

 JSR RES2               \ Reset a number of flight variables and workspaces

 LDX #ESC               \ Set the current ship type to an escape pod, so we can
 STX TYPE               \ show it disappearing into the distance when we eject
                        \ in our pod

 JSR FRS1               \ Call FRS1 to launch the escape pod straight ahead,
                        \ like a missile launch, but with our ship instead

 LDA #16                \ Set the escape pod's byte #27 (speed) to 8
 STA INWK+27

 LDA #194               \ Set the escape pod's byte #30 (pitch counter) to 194,
 STA INWK+30            \ so it pitches as we pull away

 LSR A                  \ Set the escape pod's byte #32 (AI flag) to %01100001,
 STA INWK+32            \ so it has no AI, and we can use this value as a
                        \ counter to do the following loop 97 times

.ESL1

 JSR MVEIT_FLIGHT       \ Call MVEIT_FLIGHT to move the escape pod in space

 JSR LL9_FLIGHT         \ Call LL9 to draw the Cobra on-screen

 DEC INWK+32            \ Decrement the counter in byte #32

 BNE ESL1               \ Loop back to keep moving the Cobra until the AI flag
                        \ is 0, which gives it time to drift away from our pod

 JSR SCAN               \ Call SCAN to remove the Cobra from the scanner (by
                        \ redrawing it)

 LDA #0                 \ Set A = 0 so we can use it to zero the contents of
                        \ the cargo hold

 STA QQ20+16            \ We lose any alien items when using our escape pod, so
                        \ set QQ20+16 to 0 (which is where they are stored)

 LDX #12                \ We lose all our cargo canisters when using our escape
                        \ pod (i.e. all the cargo except gold, platinum and gem
                        \ stones), so up a counter in X so we can zero cargo
                        \ slots 0-12 in QQ20

.ESL2

 STA QQ20,X             \ Set the X-th byte of QQ20 to zero, so we no longer
                        \ have any of item type X in the cargo hold

 DEX                    \ Decrement the counter

 BPL ESL2               \ Loop back to ESL2 until we have emptied the entire
                        \ cargo hold

 STA FIST               \ Launching an escape pod also clears our criminal
                        \ record, so set our legal status in FIST to 0 ("clean")

 STA ESCP               \ The escape pod is a one-use item, so set ESCP to 0 so
                        \ we no longer have one fitted

 INC new_hold           \ We just used our escape pod, and as it's a single-use
                        \ item, we no longer have an escape pod, so increment
                        \ the free space in our ship's hold, as the pod is no
                        \ longer taking up space

 LDA new_range          \ Our replacement ship is delivered with a full tank of
 STA QQ14               \ fuel, so fetch our current ship's hyperspace range
                        \ from new_range and set the current fuel level in QQ14
                        \ to this value

 JSR update_pod         \ Update the dashboard colours as we no longer have an
                        \ escape pod

 JSR ping               \ Set the target system to the current system (which
                        \ will move the location in (QQ9, QQ10) to the current
                        \ home system

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 JSR jmp                \ Set the current system to the selected system

 JMP GOIN               \ Go to the docking bay (i.e. show the ship hangar
                        \ screen) and return from the subroutine with a tail
                        \ call

\ ******************************************************************************
\
\ Save ELTJ.bin
\
\ ******************************************************************************

 PRINT "ELITE J"
 PRINT "Assembled at ", ~CODE_J%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_J%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_J%

 PRINT "S.2.ELTJ ", ~CODE_J%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_J%
\SAVE "versions/disc/3-assembled-output/2.ELTJ.bin", CODE_J%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE K FILE
\
\ ******************************************************************************

 CODE_K% = P%
 LOAD_K% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: TACTICS (Part 1 of 7)
\       Type: Subroutine
\   Category: Tactics
\    Summary: Apply tactics: Process missiles, both enemy missiles and our own
\  Deep dive: Program flow of the tactics routine
\
\ ------------------------------------------------------------------------------
\
\ This section implements missile tactics and is entered at TA18 from the main
\ entry point below, if the current ship is a missile. Specifically:
\
\   * If E.C.M. is active, destroy the missile
\
\   * If the missile is hostile towards us, then check how close it is. If it
\     hasn't reached us, jump to part 3 so it can streak towards us, otherwise
\     we've been hit, so process a large amount of damage to our ship
\
\   * Otherwise see how close the missile is to its target. If it has not yet
\     reached its target, give the target a chance to activate its E.C.M. if it
\     has one, otherwise jump to TA19 with K3 set to the vector from the target
\     to the missile
\
\   * If it has reached its target and the target is the space station, destroy
\     the missile, potentially damaging us if we are nearby
\
\   * If it has reached its target and the target is a ship, destroy the missile
\     and the ship, potentially damaging us if we are nearby
\
\ ******************************************************************************

.TA34

                        \ If we get here, the missile is hostile

 LDA #0                 \ Set A to x_hi OR y_hi OR z_hi
 JSR MAS4

 BEQ P%+5               \ If A = 0 then the missile is very close to our ship,
                        \ so skip the following instruction

 JMP TA21               \ Jump down to part 3 to set up the vectors and skip
                        \ straight to aggressive manoeuvring

 JSR TA87+3             \ The missile has hit our ship, so call TA87+3 to set
                        \ bit 7 of the missile's byte #31, which marks the
                        \ missile as being killed

 JSR EXNO3              \ Make the sound of the missile exploding

 LDA #250               \ Call n_oops to damage the ship by 250 (taking the
 JMP n_oops             \ shields into account), which is a pretty big hit, and
                        \ return from the subroutine using a tail call

.TA18

                        \ This is the entry point for missile tactics and is
                        \ called from the main TACTICS routine below

 LDA ECMA               \ If an E.C.M. is currently active (either ours or an
 BNE TA35               \ opponent's), jump to TA35 to destroy this missile

 LDA INWK+32            \ Fetch the AI flag from byte #32 and if bit 6 is set
 ASL A                  \ (i.e. missile is hostile), jump up to TA34 to check
 BMI TA34               \ whether the missile has hit us

 LSR A                  \ Otherwise shift A right again. We know bits 6 and 7
                        \ are now clear, so this leaves bits 0-5. Bits 1-5
                        \ contain the target's slot number, and bit 0 is cleared
                        \ in FRMIS when a missile is launched, so A contains
                        \ the slot number shifted left by 1 (i.e. doubled) so we
                        \ can use it as an index for the two-byte address table
                        \ at UNIV

 TAX                    \ Copy the address of the target ship's data block from
 LDA UNIV,X             \ UNIV(X+1 X) to (A V)
 STA V
 LDA UNIV+1,X

 JSR VCSUB              \ Calculate vector K3 as follows:
                        \
                        \ K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
                        \ target ship
                        \
                        \ K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
                        \ target ship
                        \
                        \ K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
                        \ target ship

                        \ So K3 now contains the vector from the target ship to
                        \ the missile

 LDA K3+2               \ Set A = OR of all the sign and high bytes of the
 ORA K3+5               \ above, clearing bit 7 (i.e. ignore the signs)
 ORA K3+8
 AND #%01111111
 ORA K3+1
 ORA K3+4
 ORA K3+7

 BNE TA64               \ If the result is non-zero, then the missile is some
                        \ distance from the target, so jump down to TA64 see if
                        \ the target activates its E.C.M.

 LDA INWK+32            \ Fetch the AI flag from byte #32 and if only bits 7 and
 CMP #%10000010         \ 1 are set (AI is enabled and the target is slot 1, the
 BEQ TA35               \ space station), jump to TA35 to destroy this missile,
                        \ as the space station ain't kidding around

 LDY #35                \ Fetch byte #35 (the energy level) of the target ship
 SEC                    \ into A, and set the C flag for the subtraction below
 LDA (V),Y

 SBC #64                \ Set A = A - 64

 BCS n_misshit          \ If the subtraction didn't underflow, then the ship has
                        \ an energy level of at least 64 and can take the hit,
                        \ so jump to n_misshit to update the ship's energy level
                        \ with the new, reduced value

                        \ If we get here then the ship doesn't have enough
                        \ energy to withstand the missile hit, so it gets
                        \ destroyed

 LDY #31                \ Fetch byte #31 (the exploding flag) of the target ship
 LDA (V),Y              \ into A

 BIT M32+1              \ M32 contains an LDY #32 instruction, so M32+1 contains
                        \ 32, so this instruction tests A with %00100000, which
                        \ checks bit 5 of A (the "already exploding?" bit)

 BNE TA35               \ If the target ship is already exploding, jump to TA35
                        \ to destroy this missile

 ORA #%10000000         \ Otherwise set bit 7 of the target's byte #31 to mark
                        \ the ship as having been killed, so it explodes (we
                        \ update the ship data block in the next instruction)

.n_misshit

 STA (V),Y              \ Update the Y-th byte of the target ship data block,
                        \ which will either be byte #35 (if the ship has been
                        \ destroyed) or byte #31 (if it has survived)

.TA35

 LDA INWK               \ Set A = x_lo OR y_lo OR z_lo of the missile
 ORA INWK+3
 ORA INWK+6

 BNE TA87               \ If A is non-zero then the missile is not near our
                        \ ship, so jump to TA87 to skip damaging our ship

 LDA #80                \ Otherwise the missile just got destroyed near us, so
 JSR n_oops             \ call n_oops to damage the ship by 80 (taking the
                        \ shields into account), which is nowhere near as bad as
                        \ the 250 damage from a missile slamming straight into
                        \ us, but it's still pretty nasty

.TA87

 JSR EXNO2              \ Call EXNO2 to process the fact that we have killed a
                        \ missile (so increase the kill tally, make an explosion
                        \ sound and so on)

 ASL INWK+31            \ Set bit 7 of the missile's byte #31 flag to mark it as
 SEC                    \ having been killed, so it explodes
 ROR INWK+31

.TA1

 RTS                    \ Return from the subroutine

.TA64

                        \ If we get here then the missile has not reached the
                        \ target

 JSR DORND              \ Set A and X to random numbers

 CMP #16                \ If A >= 16 (94% chance), jump down to TA19S with the
 BCS TA19S              \ vector from the target to the missile in K3

.M32

 LDY #32                \ Fetch byte #32 for the target and shift bit 0 (E.C.M.)
 LDA (V),Y              \ into the C flag
 LSR A

 BCS P%+5               \ If the C flag is set then the target has E.C.M.
                        \ fitted, so skip the next instruction

.TA19S

 JMP TA19               \ The target does not have E.C.M. fitted, so jump down
                        \ to TA19 with the vector from the target to the missile
                        \ in K3

 JMP ECBLB2             \ The target has E.C.M., so jump to ECBLB2 to set it
                        \ off, returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TACTICS (Part 2 of 7)
\       Type: Subroutine
\   Category: Tactics
\    Summary: Apply tactics: Escape pod, station, lone Thargon, safe-zone pirate
\  Deep dive: Program flow of the tactics routine
\
\ ------------------------------------------------------------------------------
\
\ This section contains the main entry point at TACTICS, which is called from
\ part 2 of MVEIT for ships that have the AI flag set (i.e. bit 7 of byte #32).
\ This part does the following:
\
\   * If this is a missile, jump up to the missile code in part 1
\
\   * If this is the space station and it is hostile, consider spawning a cop
\     (6.2% chance, up to a maximum of seven) and we're done
\
\   * If this is the space station and it is not hostile, consider spawning
\     (0.8% chance if there are no Transporters around) a Transporter or Shuttle
\     (equal odds of each type) and we're done
\
\   * Recharge the ship's energy banks by 1
\
\ Arguments:
\
\   X                   The ship type
\
\ ******************************************************************************

.TACTICS

 LDY #3                 \ Set RAT = 3, which is the magnitude we set the pitch
 STY RAT                \ or roll counter to in part 7 when turning a ship
                        \ towards a vector (a higher value giving a longer
                        \ turn). This value is not changed in the TACTICS
                        \ routine, but it is set to different values by the
                        \ DOCKIT routine

 INY                    \ Set RAT2 = 4, which is the threshold below which we
 STY RAT2               \ don't apply pitch and roll to the ship (so a lower
                        \ value means we apply pitch and roll more often, and a
                        \ value of 0 means we always apply them). The value is
                        \ compared with double the high byte of sidev . XX15,
                        \ where XX15 is the vector from the ship to the enemy
                        \ or planet. This value is set to different values by
                        \ both the TACTICS and DOCKIT routines

 LDA #22                \ Set CNT2 = 22, which is the maximum angle beyond which
 STA CNT2               \ a ship will slow down to start turning towards its
                        \ prey (a lower value means a ship will start to slow
                        \ down even if its angle with the enemy ship is large,
                        \ which gives a tighter turn). This value is not changed
                        \ in the TACTICS routine, but it is set to different
                        \ values by the DOCKIT routine

 CPX #MSL               \ If this is a missile, jump up to TA18 to implement
 BEQ TA18               \ missile tactics

 CPX #SST               \ If this is not the space station, jump down to TA13
 BNE TA13

 LDA NEWB               \ This is the space station, so check whether bit 2 of
 AND #%00000100         \ the ship's NEWB flags is set, and if it is (i.e. the
 BNE TN5                \ station is hostile), jump to TN5 to spawn some cops

 LDA MANY+SHU+1         \ Set A to the number of Transporters in the vicinity

 ORA auto               \ If the docking computer is on then auto is &FF, so
                        \ this ensures that A is always non-zero when we are
                        \ auto-docking, so the following jump to TA1 will be
                        \ taken and no Transporters will be spawned from the
                        \ space station (unlike in the disc version, where you
                        \ can get smashed into space dust by a badly timed
                        \ Transporter launch when using the docking computer)

 BNE TA1                \ The station is not hostile, so check how many
                        \ Transporters there are in the vicinity, and if we
                        \ already have one, return from the subroutine (as TA1
                        \ contains an RTS)

                        \ If we get here then the station is not hostile, so we
                        \ can consider spawning a Transporter or Shuttle

 JSR DORND              \ Set A and X to random numbers

 CMP #253               \ If A < 253 (99.2% chance), return from the subroutine
 BCC TA1                \ (as TA1 contains an RTS)

 AND #1                 \ Set A = a random number that's either 0 or 1

 ADC #SHU-1             \ The C flag is set (as we didn't take the BCC above),
 TAX                    \ so this sets X to a value of either #SHU or #SHU + 1,
                        \ which is the ship type for a Shuttle or a Transporter

 BNE TN6                \ Jump to TN6 to spawn this ship type and return from
                        \ the subroutine using a tail call (this BNE is
                        \ effectively a JMP as A is never zero)

.TN5

                        \ We only call the tactics routine for the space station
                        \ when it is hostile, so if we get here then this is the
                        \ station, and we already know it's hostile, so we need
                        \ to spawn some cops

 JSR DORND              \ Set A and X to random numbers

 CMP #240               \ If A < 240 (93.8% chance), return from the subroutine
 BCC TA1                \ (as TA1 contains an RTS)

 LDA MANY+COPS          \ Check how many cops there are in the vicinity already,
 CMP #7                 \ and if there are 7 or more, return from the subroutine
 BCS TA22               \ (as TA22 contains an RTS)

 LDX #COPS              \ Set X to the ship type for a cop

.TN6

 LDA #%11110001         \ Set the AI flag to give the ship E.C.M., enable AI and
                        \ make it very aggressive (60 out of 63)

 JMP SFS1               \ Jump to SFS1 to spawn the ship, returning from the
                        \ subroutine using a tail call

.TA13

 LDY #14                \ If the ship's energy is greater or equal to the
 LDA INWK+35            \ maximum value from the ship's blueprint pointed to by
 CMP (XX0),Y            \ XX0, then skip the next instruction
 BCS TA21

 INC INWK+35            \ The ship's energy is not at maximum, so recharge the
                        \ energy banks by 1

\ ******************************************************************************
\
\       Name: TACTICS (Part 3 of 7)
\       Type: Subroutine
\   Category: Tactics
\    Summary: Apply tactics: Calculate dot product to determine ship's aim
\  Deep dive: Program flow of the tactics routine
\
\ ------------------------------------------------------------------------------
\
\ This section sets up some vectors and calculates dot products. Specifically:
\
\   * If this is a lone Thargon without a mothership, set it adrift aimlessly
\     and we're done
\
\   * If this is a trader, 80% of the time we're done, 20% of the time the
\     trader performs the same checks as the bounty hunter
\
\   * If this is a bounty hunter (or one of the 20% of traders) and we have been
\     really bad (i.e. a fugitive or serious offender), the ship becomes hostile
\     (if it isn't already)
\
\   * If the ship is not hostile, then either perform docking manoeuvres (if
\     it's docking) or fly towards the planet (if it isn't docking) and we're
\     done
\
\   * If the ship is hostile, and a pirate, and we are within the space station
\     safe zone, stop the pirate from attacking by removing all its aggression
\
\   * Calculate the dot product of the ship's nose vector (i.e. the direction it
\     is pointing) with the vector between us and the ship. This value will help
\     us work out later on whether the enemy ship is pointing towards us, and
\     therefore whether it can hit us with its lasers.
\
\ Other entry points:
\
\   GOPL                Make the ship head towards the planet
\
\ ******************************************************************************

.TA21

 CPX #TGL               \ If this is not a Thargon, jump down to TA14
 BNE TA14

 LDA MANY+THG           \ If there is at least one Thargoid in the vicinity,
 BNE TA14               \ jump down to TA14

 LSR INWK+32            \ This is a Thargon but there is no Thargoid mothership,
 ASL INWK+32            \ so clear bit 0 of the AI flag to disable its E.C.M.

 LSR INWK+27            \ And halve the Thargon's speed

.TA22

 RTS                    \ Return from the subroutine

.TA14

 JSR DORND              \ Set A and X to random numbers

 LDA NEWB               \ Extract bit 0 of the ship's NEWB flags into the C flag
 LSR A                  \ and jump to TN1 if it is clear (i.e. if this is not a
 BCC TN1                \ trader)

 CPX #100               \ This is a trader, so if X >= 100 (61% chance), return
 BCS TA22               \ from the subroutine (as TA22 contains an RTS)

.TN1

 LSR A                  \ Extract bit 1 of the ship's NEWB flags into the C flag
 BCC TN2                \ and jump to TN2 if it is clear (i.e. if this is not a
                        \ bounty hunter)

 LDX FIST               \ This is a bounty hunter, so check whether our FIST
 CPX #40                \ rating is < 40 (where 50 is a fugitive), and jump to
 BCC TN2                \ TN2 if we are not 100% evil

 LDA NEWB               \ We are a fugitive or a bad offender, and this ship is
 ORA #%00000100         \ a bounty hunter, so set bit 2 of the ship's NEWB flags
 STA NEWB               \ to make it hostile

 LSR A                  \ Shift A right twice so the next test in TN2 will check
 LSR A                  \ bit 2

.TN2

 LSR A                  \ Extract bit 2 of the ship's NEWB flags into the C flag
 BCS TN3                \ and jump to TN3 if it is set (i.e. if this ship is
                        \ hostile)

 LSR A                  \ The ship is not hostile, so extract bit 4 of the
 LSR A                  \ ship's NEWB flags into the C flag, and jump to GOPL if
 BCC GOPL               \ it is clear (i.e. if this ship is not docking)

 JMP DOCKIT             \ The ship is not hostile and is docking, so jump to
                        \ DOCKIT to apply the docking algorithm to this ship

.GOPL

 LDY #0                 \ Set Y = 0 so the call to SPS1 calculates the vector to
                        \ the planet

 JSR SPS1               \ The ship is not hostile and it is not docking, so call
                        \ SPS1 to calculate the vector to the planet and store
                        \ it in XX15

 JMP TA151              \ Jump to TA151 to make the ship head towards the planet

.TN3

 LSR A                  \ Extract bit 2 of the ship's NEWB flags into the C flag
 BCC TN4                \ and jump to TN4 if it is clear (i.e. if this ship is
                        \ not a pirate)

 LDA SSPR               \ If we are not inside the space station safe zone, jump
 BEQ TN4                \ to TN4

                        \ If we get here then this is a pirate and we are inside
                        \ the space station safe zone

 LDA INWK+32            \ Set bits 0 and 7 of the AI flag in byte #32 (has AI
 AND #%10000001         \ enabled and has an E.C.M.)
 STA INWK+32

.TN4

 LDX #8                 \ We now want to copy the ship's x, y and z coordinates
                        \ from INWK to K3, so set up a counter for 9 bytes

.TAL1

 LDA INWK,X             \ Copy the X-th byte from INWK to the X-th byte of K3
 STA K3,X

 DEX                    \ Decrement the counter

 BPL TAL1               \ Loop back until we have copied all 9 bytes

.TA19

                        \ If this is a missile that's heading for its target
                        \ (not us, one of the other ships), then the missile
                        \ routine at TA18 above jumps here after setting K3 to
                        \ the vector from the target to the missile

 JSR TAS2               \ Normalise the vector in K3 and store the normalised
                        \ version in XX15, so XX15 contains the normalised
                        \ vector from our ship to the ship we are applying AI
                        \ tactics to (or the normalised vector from the target
                        \ to the missile - in both cases it's the vector from
                        \ the potential victim to the attacker)

 JSR TAS3-2             \ Set (A X) = nosev . XX15

 STA CNT                \ Store the high byte of the dot product in CNT. The
                        \ bigger the value, the more aligned the two ships are,
                        \ with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
                        \ is positive, the ships are facing in a similar
                        \ direction, if it's negative they are facing in
                        \ opposite directions

\ ******************************************************************************
\
\       Name: TACTICS (Part 4 of 7)
\       Type: Subroutine
\   Category: Tactics
\    Summary: Apply tactics: Check energy levels, maybe launch escape pod if low
\  Deep dive: Program flow of the tactics routine
\
\ ------------------------------------------------------------------------------
\
\ This section works out what kind of condition the ship is in. Specifically:
\
\   * If this is a large ship that can spawn smaller ships, such as an Anaconda
\     or a Dragon, then consider spawning (22% chance) a Worm
\
\   * Rarely (2.5% chance) roll the ship by a noticeable amount
\
\   * If the ship has at least half its energy banks full, jump to part 6 to
\     consider firing the lasers
\
\   * If the ship is not into the last 1/8th of its energy, jump to part 5 to
\     consider firing a missile
\
\   * If the ship is into the last 1/8th of its energy, and this ship type has
\     an escape pod fitted, then rarely (10% chance) the ship launches an escape
\     pod and is left drifting in space
\
\ ******************************************************************************

 LDA TYPE               \ If this is not a missile, skip the following
 CMP #MSL               \ instruction
 BNE P%+5

 JMP TA20               \ This is a missile, so jump down to TA20 to get
                        \ straight into some aggressive manoeuvring

 CMP #14                \ If this is not a large ship that can spawn smaller
 BNE TN7                \ ships (e.g. an Anaconda or Dragon), which will be in
                        \ slot 14 in the ship files, jump down to TN7 to skip
                        \ the following

 JSR DORND              \ Set A and X to random numbers

 CMP #200               \ If A < 200 (78% chance), jump down to TN7 to skip the
 BCC TN7                \ following

 LDX #15                \ Set X to the ship in slot 15, which will be the kind
                        \ of ship that the large ship in slot 14 can spawn
                        \ (e.g. an Anaconda can spawn a Worm, while a Dragon can
                        \ spawn a Sidewinder)

 JMP TN6                \ Jump to TN6 to spawn the Worm and return from
                        \ the subroutine using a tail call

.TN7

 JSR DORND              \ Set A and X to random numbers

 CMP #250               \ If A < 250 (97.5% chance), jump down to TA7 to skip
 BCC TA7                \ the following

 JSR DORND              \ Set A and X to random numbers

 ORA #104               \ Bump A up to at least 104 and store in the roll
 STA INWK+29            \ counter, to gives the ship a noticeable roll

.TA7

 LDY #14                \ Set A = the ship's maximum energy / 2
 LDA (XX0),Y
 LSR A

 CMP INWK+35            \ If the ship's current energy in byte #35 > A, i.e. the
 BCC TA3                \ ship has at least half of its energy banks charged,
                        \ jump down to TA3

 LSR A                  \ If the ship's current energy in byte #35 > A / 4, i.e.
 LSR A                  \ the ship is not into the last 1/8th of its energy,
 CMP INWK+35            \ jump down to ta3 to consider firing a missile
 BCC ta3

 JSR DORND              \ Set A and X to random numbers

 CMP #230               \ If A < 230 (90% chance), jump down to ta3 to consider
 BCC ta3                \ firing a missile

 LDX TYPE               \ Fetch the ship blueprint's default NEWB flags from the
 LDA E%-1,X             \ table at E%, and if bit 7 is clear (i.e. this ship
 BPL ta3                \ does not have an escape pod), jump to ta3 to skip the
                        \ spawning of an escape pod

                        \ By this point, the ship has run out of both energy and
                        \ luck, so it's time to bail

 LDA #0                 \ Set the AI flag to 0 to disable AI, hostility and
 STA INWK+32            \ E.C.M., so the ship's a sitting duck

 JMP SESCP              \ Jump to SESCP to spawn an escape pod from the ship,
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TACTICS (Part 5 of 7)
\       Type: Subroutine
\   Category: Tactics
\    Summary: Apply tactics: Consider whether to launch a missile at us
\  Deep dive: Program flow of the tactics routine
\
\ ------------------------------------------------------------------------------
\
\ This section considers whether to launch a missile. Specifically:
\
\   * If the ship doesn't have any missiles, skip to the next part
\
\   * If an E.C.M. is firing, skip to the next part
\
\   * Randomly decide whether to fire a missile (or, in the case of Thargoids,
\     release a Thargon), and if we do, we're done
\
\ ******************************************************************************

.ta3

                        \ If we get here then the ship has less than half energy
                        \ so there may not be enough juice for lasers, but let's
                        \ see if we can fire a missile

 LDA INWK+31            \ Set A = bits 0-2 of byte #31, the number of missiles
 AND #%00000111         \ the ship has left

 BEQ TA3                \ If it doesn't have any missiles, jump to TA3

 STA T                  \ Store the number of missiles in T

 JSR DORND              \ Set A and X to random numbers

 AND #15                \ Restrict A to a random number in the range 0-15,
                        \ which makes it much more likely that ships will fire
                        \ missiles when compared to the disc version

 CMP T                  \ If A >= T, which is quite likely, though less likely
 BCS TA3                \ with higher numbers of missiles, jump to TA3 to skip
                        \ firing a missile

 LDA ECMA               \ If an E.C.M. is currently active (either ours or an
 BNE TA3                \ opponent's), jump to TA3 to skip firing a missile

 DEC INWK+31            \ We're done with the checks, so it's time to fire off a
                        \ missile, so reduce the missile count in byte #31 by 1

 LDA TYPE               \ Fetch the ship type into A

 CMP #THG               \ If this is not a Thargoid, jump down to TA16 to launch
 BNE TA16               \ a missile

 LDX #TGL               \ This is a Thargoid, so instead of launching a missile,
 LDA INWK+32            \ the mothership launches a Thargon, so call SFS1 to
 JMP SFS1               \ spawn a Thargon from the parent ship, and return from
                        \ the subroutine using a tail call

.TA16

 JMP SFRMIS             \ Jump to SFRMIS to spawn a missile as a child of the
                        \ current ship, make a noise and print a message warning
                        \ of incoming missiles, and return from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: TACTICS (Part 6 of 7)
\       Type: Subroutine
\   Category: Tactics
\    Summary: Apply tactics: Consider firing a laser at us, if aim is true
\  Deep dive: Program flow of the tactics routine
\
\ ------------------------------------------------------------------------------
\
\ This section looks at potentially firing the ship's laser at us. Specifically:
\
\   * If the ship is not pointing at us, skip to the next part
\
\   * If the ship is pointing at us but not accurately, fire its laser at us and
\     skip to the next part
\
\   * If we are in the ship's crosshairs, register some damage to our ship, slow
\     down the attacking ship, make the noise of us being hit by laser fire, and
\     we're done
\
\ ******************************************************************************

.TA3

                        \ If we get here then the ship either has plenty of
                        \ energy, or levels are low but it couldn't manage to
                        \ launch a missile, so maybe we can fire the laser?

 LDA #0                 \ Set A to x_hi OR y_hi OR z_hi
 JSR MAS4

 AND #%11100000         \ If any of the hi bytes have any of bits 5-7 set, then
 BNE TA4                \ jump to TA4 to skip the laser checks, as the ship is
                        \ too far away from us to hit us with a laser

 LDX CNT                \ Set X = the dot product set above in CNT. If this is
                        \ positive, this ship and our ship are facing in similar
                        \ directions, but if it's negative then we are facing
                        \ each other, so for us to be in the enemy ship's line
                        \ of fire, X needs to be negative. The value in X can
                        \ have a maximum magnitude of 36, which would mean we
                        \ were facing each other square on, so in the following
                        \ code we check X like this:
                        \
                        \   X = 0 to -31, we are not in the enemy ship's line
                        \       of fire, so they can't shoot at us
                        \
                        \   X = -32 to -34, we are in the enemy ship's line
                        \       of fire, so they can shoot at us, but they can't
                        \       hit us as we're not dead in their crosshairs
                        \
                        \   X = -35 to -36, we are bang in the middle of the
                        \       enemy ship's crosshairs, so they can not only
                        \       shoot us, they can hit us

 CPX #160               \ If X < 160, i.e. X > -32, then we are not in the enemy
 BCC TA4                \ ship's line of fire, so jump to TA4 to skip the laser
                        \ checks

 LDY #19                \ Fetch the enemy ship's byte #19 from their ship's
 LDA (XX0),Y            \ blueprint into A

 AND #%11111000         \ Extract bits 3-7, which contain the enemy's laser
                        \ power

 BEQ TA4                \ If the enemy has no laser power, jump to TA4 to skip
                        \ the laser checks

 LDA INWK+31            \ Set bit 6 in byte #31 to denote that the ship is
 ORA #%01000000         \ firing its laser at us
 STA INWK+31

 CPX #163               \ If X < 163, i.e. X > -35, then we are not in the enemy
 BCC TA4                \ ship's crosshairs, so jump to TA4 to skip the laser

 LDA (XX0),Y            \ Fetch the enemy ship's byte #19 from their ship's
                        \ blueprint into A

 LSR A                  \ Halve the enemy ship's byte #19 (which contains both
                        \ the laser power and number of missiles) to get the
                        \ amount of damage we should take

 JSR n_oops             \ Call n_oops to take some damage (taking the shields
                        \ into account), which could do anything from reducing
                        \ the shields and energy, all the way to losing cargo
                        \ or dying (if the latter, we don't come back from this
                        \ subroutine)

 DEC INWK+28            \ Halve the attacking ship's acceleration in byte #28

 LDA ECMA               \ If an E.C.M. is currently active (either ours or an
 BNE TA9-1              \ opponent's), return from the subroutine without making
                        \ the laser-strike sound (as TA9-1 contains an RTS)

 LDA #8                 \ Call the NOISE routine with A = 8 to make the sound
 JMP NOISE              \ of us being hit by lasers, returning from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: TACTICS (Part 7 of 7)
\       Type: Subroutine
\   Category: Tactics
\    Summary: Apply tactics: Set pitch, roll, and acceleration
\  Deep dive: Program flow of the tactics routine
\
\ ------------------------------------------------------------------------------
\
\ This section looks at manoeuvring the ship. Specifically:
\
\   * Work out which direction the ship should be moving, depending on the type
\     of ship, where it is, which direction it is pointing, and how aggressive
\     it is
\
\   * Set the pitch and roll counters to head in that direction
\
\   * Speed up or slow down, depending on where the ship is in relation to us
\
\ Other entry points:
\
\   TA151               Make the ship head towards the planet
\
\ ******************************************************************************

.TA4

 LDA INWK+7             \ If z_hi >= 3 then the ship is quite far away, so jump
 CMP #3                 \ down to TA5
 BCS TA5

 LDA INWK+1             \ Otherwise set A = x_hi OR y_hi and extract bits 1-7
 ORA INWK+4
 AND #%11111110

 BEQ TA15               \ If A = 0 then the ship is pretty close to us, so jump
                        \ to TA15 so it heads away from us

.TA5

                        \ If we get here then the ship is quite far away

 JSR DORND              \ Set A and X to random numbers

 ORA #%10000000         \ Set bit 7 of A

 CMP INWK+32            \ If A >= byte #32 (the ship's AI flag) then jump down
 BCS TA15               \ to TA15 so it heads away from us

                        \ We get here if A < byte #32, and the chances of this
                        \ being true are greater with high values of byte #32.
                        \ In other words, higher byte #32 values increase the
                        \ chances of a ship changing direction to head towards
                        \ us - or, to put it another way, ships with higher
                        \ byte #32 values are spoiling for a fight. Thargoids
                        \ have byte #32 set to 255, which explains an awful lot

.TA20

                        \ If this is a missile we will have jumped straight
                        \ here, but we also get here if the ship is either far
                        \ away and aggressive, or not too close

 JSR TAS6               \ Call TAS6 to negate the vector in XX15 so it points in
                        \ the opposite direction

 LDA CNT                \ Change the sign of the dot product in CNT, so now it's
 EOR #%10000000         \ positive if the ships are facing each other, and
                        \ negative if they are facing the same way

.TA152

 STA CNT                \ Update CNT with the new value in A

.TA15

                        \ If we get here, then one of the following is true:
                        \
                        \   * This is a trader and XX15 is pointing towards the
                        \     planet
                        \
                        \   * The ship is pretty close to us, or it's just not
                        \     very aggressive (though there is a random factor
                        \     at play here too). XX15 is still pointing from our
                        \     ship towards the enemy ship
                        \
                        \   * The ship is aggressive (though again, there's an
                        \     element of randomness here). XX15 is pointing from
                        \     the enemy ship towards our ship
                        \
                        \   * This is a missile heading for a target. XX15 is
                        \     pointing from the missile towards the target
                        \
                        \ We now want to move the ship in the direction of XX15,
                        \ which will make aggressive ships head towards us, and
                        \ ships that are too close turn away. Peaceful traders,
                        \ meanwhile, head off towards the planet in search of a
                        \ space station, and missiles home in on their targets

 LDY #16                \ Set (A X) = roofv . XX15
 JSR TAS3               \
                        \ This will be positive if XX15 is pointing in the same
                        \ direction as an arrow out of the top of the ship, in
                        \ other words if the ship should pull up to head in the
                        \ direction of XX15

 TAX                    \ Copy A into X so we can retrieve it below

 JSR nroll              \ Call nroll to calculate the value of the ship's pitch
                        \ counter

 STA INWK+30            \ Store the result in the ship's pitch counter

 LDA INWK+29            \ Fetch the roll counter from byte #29 into A

 ASL A                  \ Shift A left to double it and drop the sign bit

 CMP #32                \ If A >= 32 then jump to TA6, as the ship is already
 BCS TA6                \ in the process of rolling

 LDY #22                \ Set (A X) = sidev . XX15
 JSR TAS3               \
                        \ This will be positive if XX15 is pointing in the same
                        \ direction as an arrow out of the right side of the
                        \ ship, in other words if the ship should roll right to
                        \ head in the direction of XX15

 TAX                    \ Copy A into X so we can retrieve it below

 EOR INWK+30            \ Give A the correct sign of the dot product * the
                        \ current pitch direction (i.e. the sign is negative if
                        \ the pitch counter and dot product have different
                        \ signs, positive if they have the same sign)

 JSR nroll              \ Call nroll to calculate the value of the ship's pitch
                        \ counter

 STA INWK+29            \ Store the result in the ship's roll counter

.TA12

.TA6

 LDA CNT                \ Fetch the dot product, and if it's negative jump to
 BMI TA9                \ TA9, as the ships are facing away from each other and
                        \ the ship might want to slow down to take another shot

 CMP CNT2               \ The dot product is positive, so the ships are facing
 BCC TA9                \ each other. If A < CNT2 then the ships are not heading
                        \ directly towards each other, so jump to TA9 to slow
                        \ down

.PH10E

 LDA #3                 \ Otherwise set the acceleration in byte #28 to 3
 STA INWK+28

 RTS                    \ Return from the subroutine

.TA9

 AND #%01111111         \ Clear the sign bit of the dot product in A

 CMP #18                \ If A < 18 then the ship is way off the XX15 vector, so
 BCC TA10               \ return from the subroutine (TA10 contains an RTS)
                        \ without slowing down, as it still has quite a bit of
                        \ turning to do to get on course

 LDA #&FF               \ Otherwise set A = -1

 LDX TYPE               \ If this is not a missile then skip the ASL instruction
 CPX #MSL
 BNE P%+3

 ASL A                  \ This is a missile, so set A = -2, as missiles are more
                        \ nimble and can brake more quickly

 STA INWK+28            \ Set the ship's acceleration to A

.TA10

 RTS                    \ Return from the subroutine

.TA151

                        \ This is called from part 3 with the vector to the
                        \ planet in XX15, when we want the ship to turn towards
                        \ the planet. It does the same dot product calculation
                        \ as part 3, but it can also change the value of RAT2
                        \ so that roll and pitch is always applied

 JSR TAS3-2             \ Set (A X) = nosev . XX15
                        \
                        \ The bigger the value of the dot product, the more
                        \ aligned the two vectors are, with a maximum magnitude
                        \ in A of 36 (96 * 96 >> 8). If A is positive, the
                        \ vectors are facing in a similar direction, if it's
                        \ negative they are facing in opposite directions

 CMP #&98               \ If A is positive or A <= -24, jump to ttt
 BCC ttt

 LDX #0                 \ A > -24, which means the vectors are facing in
 STX RAT2               \ opposite directions but are quite aligned, so set
                        \ RAT2 = 0 instead of the default value of 4, so we
                        \ always apply roll and pitch when we turn the ship
                        \ towards the planet

.ttt

 JMP TA152              \ Jump to TA152 to store A in CNT and move the ship in
                        \ the direction of XX15

.nroll

 EOR #%10000000         \ Give the ship's pitch counter the opposite sign to the
 AND #%10000000         \ dot product result, with a value of 0, and store it in
 STA T                  \ T

 TXA                    \ Retrieve the original value of A from X

 ASL A                  \ Shift A left to double it and drop the sign bit

 CMP RAT2               \ If A < RAT2, skip to nroll2 (so if RAT2 = 0, we always
 BCC nroll2             \ set the pitch counter to RAT)

 LDA RAT                \ Set the magnitude of the ship's pitch counter to RAT
 ORA T                  \ (we already set the sign above and stored it in T)

 RTS                    \ Return from the subroutine

.nroll2

 LDA T                  \ Set A to the value we stored in T above, which has a
                        \ value of 0 and the opposite sign to the dot product
                        \ result

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DOCKIT
\       Type: Subroutine
\   Category: Flight
\    Summary: Apply docking manoeuvres to the ship in INWK
\  Deep dive: The docking computer
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   top_6a              Set bit 7 of the ship's NEWB flags to indicate that it
\                       has docked or been scooped
\
\ ******************************************************************************

.DOCKIT

 LDA #6                 \ Set RAT2 = 6, which is the threshold below which we
 STA RAT2               \ don't apply pitch and roll to the ship (so a lower
                        \ value means we apply pitch and roll more often, and a
                        \ value of 0 means we always apply them). The value is
                        \ compared with double the high byte of sidev . XX15,
                        \ where XX15 is the vector from the ship to the station

 LSR A                  \ Set RAT = 2, which is the magnitude we set the pitch
 STA RAT                \ or roll counter to in part 7 when turning a ship
                        \ towards a vector (a higher value giving a longer
                        \ turn)

 LDA #29                \ Set CNT2 = 29, which is the maximum angle beyond which
 STA CNT2               \ a ship will slow down to start turning towards its
                        \ prey (a lower value means a ship will start to slow
                        \ down even if its angle with the enemy ship is large,
                        \ which gives a tighter turn)

 LDA SSPR               \ If we are inside the space station safe zone, skip the
 BNE P%+5               \ next instruction

.GOPLS

 JMP GOPL               \ Jump to GOPL to make the ship head towards the planet

 JSR VCSU1              \ If we get here then we are in the space station safe
                        \ zone, so call VCSU1 to calculate the following, where
                        \ the station is at coordinates (station_x, station_y,
                        \ station_z):
                        \
                        \   K3(2 1 0) = (x_sign x_hi x_lo) - station_x
                        \
                        \   K3(5 4 3) = (y_sign y_hi z_lo) - station_y
                        \
                        \   K3(8 7 6) = (z_sign z_hi z_lo) - station_z
                        \
                        \ so K3 contains the vector from the station to the ship

 LDA K3+2               \ If any of the top bytes of the K3 results above are
 ORA K3+5               \ non-zero (after removing the sign bits), jump to GOPL
 ORA K3+8               \ via GOPLS to make the ship head towards the planet, as
 AND #%01111111         \ this will aim the ship in the general direction of the
 BNE GOPLS              \ station (it's too far away for anything more accurate)

 JSR TA2                \ Call TA2 to calculate the length of the vector in K3
                        \ (ignoring the low coordinates), returning it in Q

 LDA Q                  \ Store the value of Q in K, so K now contains the
 STA K                  \ distance between station and the ship

 JSR TAS2               \ Call TAS2 to normalise the vector in K3, returning the
                        \ normalised version in XX15, so XX15 contains the unit
                        \ vector pointing from the station to the ship

 LDY #10                \ Call TAS4 to calculate:
 JSR TAS4               \
                        \   (A X) = nosev . XX15
                        \
                        \ where nosev is the nose vector of the space station,
                        \ so this is the dot product of the station to ship
                        \ vector with the station's nosev (which points straight
                        \ out into space, out of the docking slot), and because
                        \ both vectors are unit vectors, the following is also
                        \ true:
                        \
                        \   (A X) = cos(t)
                        \
                        \ where t is the angle between the two vectors
                        \
                        \ If the dot product is positive, that means the vector
                        \ from the station to the ship and the nosev sticking
                        \ out of the docking slot are facing in a broadly
                        \ similar direction (so the ship is essentially heading
                        \ for the slot, which is facing towards the ship), and
                        \ if it's negative they are facing in broadly opposite
                        \ directions (so the station slot is on the opposite
                        \ side of the station as the ship approaches)

 BMI PH1                \ If the dot product is negative, i.e. the station slot
                        \ is on the opposite side, jump to PH1 to fly towards
                        \ the ideal docking position, some way in front of the
                        \ slot

 CMP #35                \ If the dot product < 35, jump to PH1 to fly towards
 BCC PH1                \ the ideal docking position, some way in front of the
                        \ slot, as there is a large angle between the vector
                        \ from the station to the ship and the station's nosev,
                        \ so the angle of approach is not very optimal
                        \
                        \ Specifically, as the unit vector length is 96 in our
                        \ vector system,
                        \
                        \   (A X) = cos(t) < 35 / 96
                        \
                        \ so:
                        \
                        \   t > arccos(35 / 96) = 68.6 degrees
                        \
                        \ so the ship is coming in from the side of the station
                        \ at an angle between 68.6 and 90 degrees off the
                        \ optimal entry angle

                        \ If we get here, the slot is on the same side as the
                        \ ship and the angle of approach is less than 68.6
                        \ degrees, so we're heading in pretty much the correct
                        \ direction for a good approach to the docking slot

 JSR TAS3-2             \ Call TAS3-2 to calculate:
                        \
                        \   (A X) = nosev . XX15
                        \
                        \ where nosev is the nose vector of the ship, so this is
                        \ the dot product of the station to ship vector with the
                        \ ship's nosev, and is a measure of how close to the
                        \ station the ship is pointing, with negative meaning it
                        \ is pointing at the station, and positive meaning it is
                        \ pointing away from the station

 CMP #&A2               \ If the dot product is in the range 0 to -34, jump to
 BCS PH3                \ PH3 to refine our approach, as we are pointing towards
                        \ the station

                        \ If we get here, then we are not pointing straight at
                        \ the station, so check how close we are

 LDA K                  \ Fetch the distance to the station into A

 CMP #157               \ If A < 157, jump to PH2 to turn away from the station,
 BCC PH2                \ as we are too close

 LDA TYPE               \ Fetch the ship type into A

 BMI PH3                \ If bit 7 is set, then that means the ship type was set
                        \ to -96 in the DOKEY routine when we switched on our
                        \ docking computer, so this is us auto-docking our
                        \ Cobra, so jump to PH3 to refine our approach
                        \
                        \ Otherwise this is an NPC trying to dock, so keep going
                        \ to turn away from the station

.PH2

                        \ If we get here then we turn away from the station and
                        \ slow right down, effectively aborting this approach
                        \ attempt

 JSR TAS6               \ Call TAS6 to negate the vector in XX15 so it points in
                        \ the opposite direction, away from the station and
                        \ towards the ship

 JSR TA151              \ Call TA151 to make the ship head in the direction of
                        \ XX15, which makes the ship turn away from the station

.PH22

                        \ If we get here then we slam on the brakes and slow
                        \ right down

 LDX #0                 \ Set the acceleration in byte #28 to 0
 STX INWK+28

 INX                    \ Set the speed in byte #28 to 1
 STX INWK+27

 RTS                    \ Return from the subroutine

.PH1

                        \ If we get here then the slot is on the opposite side
                        \ of the station to the ship, or it's on the same side
                        \ and the approach angle is not optimal, so we just fly
                        \ towards the station, aiming for the ideal docking
                        \ position some distance in front of the slot

 JSR VCSU1              \ Call VCSU1 to set K3 to the vector from the station to
                        \ the ship

 JSR DCS1               \ Call DCS1 twice to calculate the vector from the ideal
 JSR DCS1               \ docking position to the ship, where the ideal docking
                        \ position is straight out of the docking slot at a
                        \ distance of 8 unit vectors from the centre of the
                        \ station

 JSR TAS2               \ Call TAS2 to normalise the vector in K3, returning the
                        \ normalised version in XX15

 JSR TAS6               \ Call TAS6 to negate the vector in XX15 so it points in
                        \ the opposite direction

 JMP TA151              \ Call TA151 to make the ship head in the direction of
                        \ XX15, which makes the ship turn towards the ideal
                        \ docking position, and return from the subroutine using
                        \ a tail call

.TN11

                        \ If we get here, we accelerate and apply a full
                        \ clockwise roll (which matches the space station's
                        \ roll)

 INC INWK+28            \ Increment the acceleration in byte #28

 LDA #%01111111         \ Set the roll counter to a positive roll with no
 STA INWK+29            \ damping, to match the space station's roll

 BNE TN13               \ Jump down to TN13 (this BNE is effectively a JMP as
                        \ A will never be zero)

.PH3

                        \ If we get here, we refine our approach using pitch and
                        \ roll to aim for the station

 LDX #0                 \ Set RAT2 = 0
 STX RAT2

 STX INWK+30            \ Set the pitch counter to 0 to stop any pitching

 LDA TYPE               \ If this is not our ship's docking computer, but is an
 BPL PH32               \ NPC ship trying to dock, jump to PH32

                        \ In the following, ship_x and ship_y are the x and
                        \ y-coordinates of XX15, the vector from the station to
                        \ the ship

 EOR XX15               \ A is negative, so this sets the sign of A to the same
 EOR XX15+1             \ as -XX15 * XX15+1, or -ship_x * ship_y

 ASL A                  \ Shift the sign bit into the C flag, so the C flag has
                        \ the following sign:
                        \
                        \   * Positive if ship_x and ship_y have different signs
                        \   * Negative if ship_x and ship_y have the same sign

 LDA #2                 \ Set A = +2 or -2, giving it the sign in the C flag,
 ROR A                  \ and store it in byte #29, the roll counter, so that
 STA INWK+29            \ the ship rolls towards the station

 LDA XX15               \ If |ship_x * 2| >= 12, i.e. |ship_x| >= 6, then jump
 ASL A                  \ to PH22 to slow right down and return from the
 CMP #12                \ subroutine, as the station is not in our sights
 BCS PH22

 LDA XX15+1             \ Set A = +2 or -2, giving it the same sign as ship_y,
 ASL A                  \ and store it in byte #30, the pitch counter, so that
 LDA #2                 \ the ship pitches towards the station
 ROR A
 STA INWK+30

 LDA XX15+1             \ If |ship_y * 2| >= 12, i.e. |ship_y| >= 6, then jump
 ASL A                  \ to PH22 to slow right down and return from the
 CMP #12                \ subroutine, as the station is not in our sights
 BCS PH22

.PH32

                        \ If we get here, we try to match the station roll

 STX INWK+29            \ Set the roll counter to 0 to stop any pitching

 LDA INWK+22            \ Set XX15 = sidev_x_hi
 STA XX15

 LDA INWK+24            \ Set XX15+1 = sidev_y_hi
 STA XX15+1

 LDA INWK+26            \ Set XX15+2 = sidev_z_hi
 STA XX15+2             \
                        \ so XX15 contains the sidev vector of the ship

 LDY #16                \ Call TAS4 to calculate:
 JSR TAS4               \
                        \   (A X) = roofv . XX15
                        \
                        \ where roofv is the roof vector of the space station.
                        \ To dock with the slot horizontal, we want roofv to be
                        \ pointing off to the side, i.e. parallel to the ship's
                        \ sidev vector, which means we want the dot product to
                        \ be large (it can be positive or negative, as roofv can
                        \ point left or right - it just needs to be parallel to
                        \ the ship's sidev)

 ASL A                  \ If |A * 2| >= 66, i.e. |A| >= 33, then the ship is
 CMP #66                \ lined up with the slot, so jump to TN11 to accelerate
 BCS TN11               \ and roll clockwise (a positive roll) before jumping
                        \ down to TN13 to check if we're docked yet

 JSR PH22               \ Call PH22 to slow right down, as we haven't yet
                        \ matched the station's roll

.TN13

                        \ If we get here, we check to see if we have docked

 LDA K3+10              \ If K3+10 is non-zero, skip to TNRTS, to return from
 BNE TNRTS              \ the subroutine
                        \
                        \ I have to say I have no idea what K3+10 contains, as
                        \ it isn't mentioned anywhere in the whole codebase
                        \ apart from here, but it does share a location with
                        \ XX2+10, so it will sometimes be non-zero (specifically
                        \ when face #10 in the ship we're drawing is visible,
                        \ which probably happens quite a lot). This would seem
                        \ to affect whether an NPC ship can dock, as that's the
                        \ code that gets skipped if K3+10 is non-zero, but as
                        \ to what this means... that's not yet clear

.top_6a

 ASL NEWB               \ Set bit 7 of the ship's NEWB flags to indicate that
 SEC                    \ the ship has now docked, which only has meaning if
 ROR NEWB               \ this is an NPC trying to dock

.TNRTS

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: VCSU1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate vector K3(8 0) = [x y z] - coordinates of the sun or
\             space station
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of the sun or space station
\
\   K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of the sun or space station
\
\   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of the sun or space station
\
\ where the first coordinate is from the ship data block in INWK, and the second
\ coordinate is from the sun or space station's ship data block which they
\ share.
\
\ ******************************************************************************

.VCSU1

 LDA #LO(K%+NI%)        \ Set the low byte of V(1 0) to point to the coordinates
 STA V                  \ of the sun or space station

 LDA #HI(K%+NI%)        \ Set A to the high byte of the address of the
                        \ coordinates of the sun or space station

                        \ Fall through into VCSUB to calculate:
                        \
                        \   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of sun
                        \               or space station
                        \
                        \   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of sun
                        \               or space station
                        \
                        \   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of sun
                        \               or space station

\ ******************************************************************************
\
\       Name: VCSUB
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate vector K3(8 0) = [x y z] - coordinates in (A V)
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in (A V)
\
\   K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in (A V)
\
\   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in (A V)
\
\ where the first coordinate is from the ship data block in INWK, and the second
\ coordinate is from the ship data block pointed to by (A V).
\
\ ******************************************************************************

.VCSUB

 STA V+1                \ Set the low byte of V(1 0) to A, so now V(1 0) = (A V)

 LDY #2                 \ K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in data
 JSR TAS1               \ block at V(1 0)

 LDY #5                 \ K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of data
 JSR TAS1               \ block at V(1 0)

 LDY #8                 \ Fall through into TAS1 to calculate the final result:
                        \
                        \ K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of data
                        \ block at V(1 0)

\ ******************************************************************************
\
\       Name: TAS1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate K3 = (x_sign x_hi x_lo) - V(1 0)
\
\ ------------------------------------------------------------------------------
\
\ Calculate one of the following, depending on the value in Y:
\
\   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
\
\   K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
\
\   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
\
\ where the first coordinate is from the ship data block in INWK, and the second
\ coordinate is from the ship data block pointed to by V(1 0).
\
\ Arguments:
\
\   V(1 0)              The address of the ship data block to subtract
\
\   Y                   The coordinate in the V(1 0) block to subtract:
\
\                         * If Y = 2, subtract the x-coordinate and store the
\                           result in K3(2 1 0)
\
\                         * If Y = 5, subtract the y-coordinate and store the
\                           result in K3(5 4 3)
\
\                         * If Y = 8, subtract the z-coordinate and store the
\                           result in K3(8 7 6)
\
\ ******************************************************************************

.TAS1

 LDA (V),Y              \ Copy the sign byte of the V(1 0) coordinate into K+3,
 EOR #%10000000         \ flipping it in the process
 STA K+3

 DEY                    \ Copy the high byte of the V(1 0) coordinate into K+2
 LDA (V),Y
 STA K+2

 DEY                    \ Copy the high byte of the V(1 0) coordinate into K+1,
 LDA (V),Y              \ so now:
 STA K+1                \
                        \   K(3 2 1) = - coordinate in V(1 0)

 STY U                  \ Copy the index (now 0, 3 or 6) into U and X
 LDX U

 JSR MVT3               \ Call MVT3 to add the same coordinates, but this time
                        \ from INWK, so this would look like this for the
                        \ x-axis:
                        \
                        \   K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
                        \            = (x_sign x_hi x_lo) - coordinate in V(1 0)

 LDY U                  \ Restore the index into Y, though this instruction has
                        \ no effect, as Y is not used again, either here or
                        \ following calls to this routine

 STA K3+2,X             \ Store K(3 2 1) in K3+X(2 1 0), starting with the sign
                        \ byte

 LDA K+2                \ And then doing the high byte
 STA K3+1,X

 LDA K+1                \ And finally the low byte
 STA K3,X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TAS4
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the dot product of XX15 and one of the space station's
\             orientation vectors
\
\ ------------------------------------------------------------------------------
\
\ Calculate the dot product of the vector in XX15 and one of the space station's
\ orientation vectors, as determined by the value of Y. If vect is the space
\ station orientation vector, we calculate this:
\
\   (A X) = vect . XX15
\         = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
\
\ Technically speaking, this routine can also calculate the dot product between
\ XX15 and the sun's orientation vectors, as the sun and space station share the
\ same ship data slot (the second ship data block at K%). However, the sun
\ doesn't have orientation vectors, so this only gets called when that slot is
\ being used for the space station.
\
\ Arguments:
\
\   Y                   The space station's orientation vector:
\
\                         * If Y = 10, calculate nosev . XX15
\
\                         * If Y = 16, calculate roofv . XX15
\
\                         * If Y = 22, calculate sidev . XX15
\
\ Returns:
\
\   (A X)               The result of the dot product
\
\ ******************************************************************************

.TAS4

 LDX K%+NI%,Y           \ Set Q = the Y-th byte of K%+NI%, i.e. vect_x from the
 STX Q                  \ second ship data block at K%

 LDA XX15               \ Set A = XX15

 JSR MULT12             \ Set (S R) = Q * A
                        \           = vect_x * XX15

 LDX K%+NI%+2,Y         \ Set Q = the Y+2-th byte of K%+NI%, i.e. vect_y
 STX Q

 LDA XX15+1             \ Set A = XX15+1

 JSR MAD                \ Set (A X) = Q * A + (S R)
                        \           = vect_y * XX15+1 + vect_x * XX15

 STA S                  \ Set (S R) = (A X)
 STX R

 LDX K%+NI%+4,Y         \ Set Q = the Y+2-th byte of K%+NI%, i.e. vect_z
 STX Q

 LDA XX15+2             \ Set A = XX15+2

 JMP MAD                \ Set:
                        \
                        \   (A X) = Q * A + (S R)
                        \           = vect_z * XX15+2 + vect_y * XX15+1 +
                        \             vect_x * XX15
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TAS6
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Negate the vector in XX15 so it points in the opposite direction
\
\ ******************************************************************************

.TAS6

 LDA XX15               \ Reverse the sign of the x-coordinate of the vector in
 EOR #%10000000         \ XX15
 STA XX15

 LDA XX15+1             \ Then reverse the sign of the y-coordinate
 EOR #%10000000
 STA XX15+1

 LDA XX15+2             \ And then the z-coordinate, so now the XX15 vector is
 EOR #%10000000         \ pointing in the opposite direction
 STA XX15+2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DCS1
\       Type: Subroutine
\   Category: Flight
\    Summary: Calculate the vector from the ideal docking position to the ship
\
\ ------------------------------------------------------------------------------
\
\ This routine is called by the docking computer routine in DOCKIT. It works out
\ the vector between the ship and the ideal docking position, which is straight
\ in front of the docking slot, but some distance away.
\
\ Specifically, it calculates the following:
\
\   * K3(2 1 0) = K3(2 1 0) - nosev_x_hi * 4
\
\   * K3(5 4 3) = K3(5 4 3) - nosev_y_hi * 4
\
\   * K3(8 7 6) = K3(8 7 6) - nosev_x_hi * 4
\
\ where K3 is the vector from the station to the ship, and nosev is the nose
\ vector for the space station.
\
\ The nose vector points from the centre of the station through the slot, so
\ -nosev * 4 is the vector from a point in front of the docking slot, but some
\ way from the station, back to the centre of the station. Adding this to the
\ vector from the station to the ship gives the vector from the point in front
\ of the station to the ship.
\
\ In practice, this routine is called twice, so the ideal docking position is
\ actually at a distance of 8 unit vectors from the centre of the station.
\
\ Back in DOCKIT, we flip this vector round to get the vector from the ship to
\ the point in front of the station slot.
\
\ Arguments:
\
\   K3                  The vector from the station to the ship
\
\ Returns:
\
\   K3                  The vector from the ship to the ideal docking position
\                       (4 unit vectors from the centre of the station for each
\                       call to DCS1, so two calls will return the vector to a
\                       point that's 8 unit vectors from the centre of the
\                       station)
\
\ ******************************************************************************

.DCS1

 JSR P%+3               \ Run the following routine twice, so the subtractions
                        \ are all * 4

 LDA K%+NI%+10          \ Set A to the space station's byte #10, nosev_x_hi

 LDX #0                 \ Set K3(2 1 0) = K3(2 1 0) - A * 2
 JSR TAS7               \               = K3(2 1 0) - nosev_x_hi * 2

 LDA K%+NI%+12          \ Set A to the space station's byte #12, nosev_y_hi

 LDX #3                 \ Set K3(5 4 3) = K3(5 4 3) - A * 2
 JSR TAS7               \               = K3(5 4 3) - nosev_y_hi * 2

 LDA K%+NI%+14          \ Set A to the space station's byte #14, nosev_z_hi

 LDX #6                 \ Set K3(8 7 6) = K3(8 7 6) - A * 2
                        \               = K3(8 7 6) - nosev_x_hi * 2

.TAS7

                        \ This routine subtracts A * 2 from one of the K3
                        \ coordinates, as determined by the value of X:
                        \
                        \   * X = 0, set K3(2 1 0) = K3(2 1 0) - A * 2
                        \
                        \   * X = 3, set K3(5 4 3) = K3(5 4 3) - A * 2
                        \
                        \   * X = 6, set K3(8 7 6) = K3(8 7 6) - A * 2
                        \
                        \ Let's document it for X = 0, i.e. K3(2 1 0)

 ASL A                  \ Shift A left one place and move the sign bit into the
                        \ C flag, so A = |A * 2|

 STA R                  \ Set R = |A * 2|

 LDA #0                 \ Rotate the sign bit of A from the C flag into the sign
 ROR A                  \ bit of A, so A is now just the sign bit from the
                        \ original value of A. This also clears the C flag

 EOR #%10000000         \ Flip the sign bit of A, so it has the sign of -A

 EOR K3+2,X             \ Give A the correct sign of K3(2 1 0) * -A

 BMI TS71               \ If the sign of K3(2 1 0) * -A is negative, jump to
                        \ TS71, as K3(2 1 0) and A have the same sign

                        \ If we get here then K3(2 1 0) and A have different
                        \ signs, so we can add them to do the subtraction

 LDA R                  \ Set K3(2 1 0) = K3(2 1 0) + R
 ADC K3,X               \               = K3(2 1 0) + |A * 2|
 STA K3,X               \
                        \ starting with the low bytes

 BCC TS72               \ If the above addition didn't overflow, we have the
                        \ result we want, so jump to TS72 to return from the
                        \ subroutine

 INC K3+1,X             \ The above addition overflowed, so increment the high
                        \ byte of K3(2 1 0)

.TS72

 RTS                    \ Return from the subroutine

.TS71

                        \ If we get here, then K3(2 1 0) and A have the same
                        \ sign

 LDA K3,X               \ Set K3(2 1 0) = K3(2 1 0) - R
 SEC                    \               = K3(2 1 0) - |A * 2|
 SBC R                  \
 STA K3,X               \ starting with the low bytes

 LDA K3+1,X             \ And then the high bytes
 SBC #0
 STA K3+1,X

 BCS TS72               \ If the subtraction didn't underflow, we have the
                        \ result we want, so jump to TS72 to return from the
                        \ subroutine

 LDA K3,X               \ Negate the result in K3(2 1 0) by flipping all the
 EOR #%11111111         \ bits and adding 1, i.e. using two's complement to
 ADC #1                 \ give it the opposite sign, starting with the low
 STA K3,X               \ bytes

 LDA K3+1,X             \ Then doing the high bytes
 EOR #%11111111
 ADC #0
 STA K3+1,X

 LDA K3+2,X             \ And finally, flipping the sign bit
 EOR #%10000000
 STA K3+2,X

 JMP TS72               \ Jump to TS72 to return from the subroutine

\ ******************************************************************************
\
\       Name: HITCH
\       Type: Subroutine
\   Category: Tactics
\    Summary: Work out if the ship in INWK is in our crosshairs
\  Deep dive: In the crosshairs
\
\ ------------------------------------------------------------------------------
\
\ This is called by the main flight loop to see if we have laser or missile lock
\ on an enemy ship.
\
\ Returns:
\
\   C flag              Set if the ship is in our crosshairs, clear if it isn't
\
\ Other entry points:
\
\   HI1                 Contains an RTS
\
\ ******************************************************************************

.HITCH

 CLC                    \ Clear the C flag so we can return with it cleared if
                        \ our checks fail

 LDA INWK+8             \ Set A = z_sign

 BNE HI1                \ If A is non-zero then the ship is behind us and can't
                        \ be in our crosshairs, so return from the subroutine
                        \ with the C flag clear (as HI1 contains an RTS)

 LDA TYPE               \ If the ship type has bit 7 set then it is the planet
 BMI HI1                \ or sun, which we can't target or hit with lasers, so
                        \ return from the subroutine with the C flag clear (as
                        \ HI1 contains an RTS)

 LDA INWK+31            \ Fetch bit 5 of byte #31 (the exploding flag) and OR
 AND #%00100000         \ with x_hi and y_hi
 ORA INWK+1
 ORA INWK+4

 BNE HI1                \ If this value is non-zero then either the ship is
                        \ exploding (so we can't target it), or the ship is too
                        \ far away from our line of fire to be targeted, so
                        \ return from the subroutine with the C flag clear (as
                        \ HI1 contains an RTS)

 LDA INWK               \ Set A = x_lo

 JSR SQUA2              \ Set (A P) = A * A = x_lo^2

 STA S                  \ Set (S R) = (A P) = x_lo^2
 LDA P
 STA R

 LDA INWK+3             \ Set A = y_lo

 JSR SQUA2              \ Set (A P) = A * A = y_lo^2

 TAX                    \ Store the high byte in X

 LDA P                  \ Add the two low bytes, so:
 ADC R                  \
 STA R                  \   R = P + R

 TXA                    \ Restore the high byte into A and add S to give the
 ADC S                  \ following:
                        \
                        \   (A R) = (S R) + (A P) = x_lo^2 + y_lo^2

 BCS TN10               \ If the addition just overflowed then there is no way
                        \ our crosshairs are within the ship's targetable area,
                        \ so return from the subroutine with the C flag clear
                        \ (as TN10 contains a CLC then an RTS)

 STA S                  \ Set (S R) = (A P) = x_lo^2 + y_lo^2

 LDY #2                 \ Fetch the ship's blueprint and set A to the high byte
 LDA (XX0),Y            \ of the targetable area of the ship

 CMP S                  \ We now compare the high bytes of the targetable area
                        \ and the calculation in (S R):
                        \
                        \   * If A >= S then then the C flag will be set
                        \
                        \   * If A < S then the C flag will be C clear

 BNE HI1                \ If A <> S we have just set the C flag correctly, so
                        \ return from the subroutine (as HI1 contains an RTS)

 DEY                    \ The high bytes were identical, so now we fetch the
 LDA (XX0),Y            \ low byte of the targetable area into A

 CMP R                  \ We now compare the low bytes of the targetable area
                        \ and the calculation in (S R):
                        \
                        \   * If A >= R then the C flag will be set
                        \
                        \   * If A < R then the C flag will be C clear

.HI1

 RTS                    \ Return from the subroutine

.TN10

 CLC                    \ Clear the C flag to indicate the ship is not in our
                        \ crosshairs

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FRS1
\       Type: Subroutine
\   Category: Tactics
\    Summary: Launch a ship straight ahead of us, below the laser sights
\
\ ------------------------------------------------------------------------------
\
\ This is used in two places:
\
\   * When we launch a missile, in which case the missile is the ship that is
\     launched ahead of us
\
\   * When we launch our escape pod, in which case it's our abandoned Cobra Mk
\     III that is launched ahead of us
\
\   * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
\     us as part of the death screen
\
\ Arguments:
\
\   X                   The type of ship to launch ahead of us
\
\ Returns:
\
\   C flag              Set if the ship was successfully launched, clear if it
\                       wasn't (as there wasn't enough free memory)
\
\ Other entry points:
\
\   fq1                 Used to add a cargo canister to the universe
\
\ ******************************************************************************

.FRS1

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 LDA #28                \ Set y_lo = 28
 STA INWK+3

 LSR A                  \ Set z_lo = 14, so the launched ship starts out
 STA INWK+6             \ ahead of us

 LDA #%10000000         \ Set y_sign to be negative, so the launched ship is
 STA INWK+5             \ launched just below our line of sight

 LDA MSTG               \ Set A to the missile lock target, shifted left so the
 ASL A                  \ slot number is in bits 1-5

 ORA #%10000000         \ Set bit 7 and store the result in byte #32, the AI
 STA INWK+32            \ flag launched ship for the launched ship. For missiles
                        \ this enables AI (bit 7), makes it friendly towards us
                        \ (bit 6), sets the target to the value of MSTG (bits
                        \ 1-5), and sets its lock status as launched (bit 0).
                        \ It doesn't matter what it does for our abandoned
                        \ Cobra, as the AI flag gets overwritten once we return
                        \ from the subroutine back to the ESCAPE routine that
                        \ called FRS1 in the first place

.fq1

 LDA #&60               \ Set byte #14 (nosev_z_hi) to 1 (&60), so the launched
 STA INWK+14            \ ship is pointing away from us

 ORA #128               \ Set byte #22 (sidev_x_hi) to -1 (&D0), so the launched
 STA INWK+22            \ ship has the same orientation as spawned ships, just
                        \ pointing away from us (if we set sidev to +1 instead,
                        \ this ship would be a mirror image of all the other
                        \ ships, which are spawned with -1 in nosev and +1 in
                        \ sidev)

 LDA DELTA              \ Set byte #27 (speed) to 2 * DELTA, so the launched
 ROL A                  \ ship flies off at twice our speed
 STA INWK+27

 TXA                    \ Add a new ship of type X to our local bubble of
 JMP NWSHP              \ universe and return from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: FRMIS
\       Type: Subroutine
\   Category: Tactics
\    Summary: Fire a missile from our ship
\
\ ------------------------------------------------------------------------------
\
\ We fired a missile, so send it streaking away from us to unleash mayhem and
\ destruction on our sworn enemies.
\
\ ******************************************************************************

.FRMIS

 LDX #MSL               \ Call FRS1 to launch a missile straight ahead of us
 JSR FRS1

 BCC FR1                \ If FRS1 returns with the C flag clear, then there
                        \ isn't room in the universe for our missile, so jump
                        \ down to FR1 to display a "missile jammed" message

 LDX MSTG               \ Fetch the slot number of the missile's target

 JSR GINF               \ Get the address of the data block for the target ship
                        \ and store it in INF

 LDA FRIN,X             \ Fetch the ship type of the missile's target into A

 JSR ANGRY              \ Call ANGRY to make the target ship hostile

 DEC NOMSL              \ Reduce the number of missiles we have by 1

 JSR msblob             \ Reset the dashboard's missile indicators so none of
                        \ them are targeted, returning with Y = 0 and X = &FF

 STY MSAR               \ The call to msblob returns Y = 0, so this sets MSAR
                        \ to 0 to indicate that the leftmost missile is no
                        \ longer seeking a target lock

 STX MSTG               \ The call to msblob returns X = &FF, so this resets the
                        \ missile so that it is no longer locked on a target

 JMP n_sound30          \ Call n_sound30 to make the sound of a missile launch,
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: anger_8c
\       Type: Subroutine
\   Category: Tactics
\    Summary: Make the current ship angry
\
\ ******************************************************************************

.anger_8c

 LDA TYPE               \ Fetch the type of the current ship into A

                        \ Fall through into ANGRY to make this ship hostile

\ ******************************************************************************
\
\       Name: ANGRY
\       Type: Subroutine
\   Category: Tactics
\    Summary: Make a ship hostile
\
\ ------------------------------------------------------------------------------
\
\ All this routine does is set the ship's hostile flag, start it turning and
\ give it a kick of acceleration - later calls to TACTICS will make the ship
\ start to attack us.
\
\ Arguments:
\
\   A                   The type of ship we're going to irritate
\
\   INF                 The address of the data block for the ship we're going
\                       to infuriate
\
\ ******************************************************************************

.ANGRY

 CMP #SST               \ If this is the space station, jump to AN2 to make the
 BEQ AN2                \ space station hostile

 LDY #36                \ Fetch the ship's NEWB flags from byte #36
 LDA (INF),Y

 AND #%00100000         \ If bit 5 of the ship's NEWB flags is clear, skip the
 BEQ P%+5               \ following instruction, otherwise bit 5 is set, meaning
                        \ this ship is an innocent bystander, and attacking it
                        \ will annoy the space station

 JSR AN2                \ Call AN2 to make the space station hostile

 LDY #32                \ Fetch the ship's byte #32 (AI flag)
 LDA (INF),Y

 BEQ HI1                \ If the AI flag is zero then this ship has no AI and
                        \ it can't get hostile, so return from the subroutine
                        \ (as HI1 contains an RTS)

 ORA #%10000000         \ Otherwise set bit 7 (AI enabled) to ensure AI is
 STA (INF),Y            \ definitely enabled

 LDY #28                \ Set the ship's byte #28 (acceleration) to 2, so it
 LDA #2                 \ speeds up
 STA (INF),Y

 ASL A                  \ Set the ship's byte #30 (pitch counter) to 4, so it
 LDY #30                \ starts pitching
 STA (INF),Y

 LDA TYPE               \ If the ship's type is < 11 (i.e. a missile, Coriolis
 CMP #11                \ space station, escape pod, plate, cargo canister,
 BCC AN3                \ boulder, asteroid, splinter, Shuttle or Transporter),
                        \ then jump to AN3 to skip the following

 LDY #36                \ Set bit 2 of the ship's NEWB flags in byte #36 to
 LDA (INF),Y            \ make this ship hostile
 ORA #%00000100
 STA (INF),Y

.AN3

 RTS                    \ Return from the subroutine

.AN2

 LDA K%+NI%+36          \ Set bit 2 of the NEWB flags in byte #36 of the second
 ORA #%00000100         \ ship in the ship data workspace at K%, which is
 STA K%+NI%+36          \ reserved for the sun or the space station (in this
                        \ case it's the latter), to make it hostile

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FR1
\       Type: Subroutine
\   Category: Tactics
\    Summary: Display the "missile jammed" message
\
\ ------------------------------------------------------------------------------
\
\ This is shown if there isn't room in the local bubble of universe for a new
\ missile.
\
\ Other entry points:
\
\   FR1-2               Clear the C flag and return from the subroutine
\
\ ******************************************************************************

.FR1

 LDA #201               \ Print recursive token 41 ("MISSILE JAMMED") as an
 JMP MESS               \ in-flight message and return from the subroutine using
                        \ a tail call

\ ******************************************************************************
\
\       Name: SESCP
\       Type: Subroutine
\   Category: Flight
\    Summary: Spawn an escape pod from the current (parent) ship
\
\ ------------------------------------------------------------------------------
\
\ This is called when an enemy ship has run out of both energy and luck, so it's
\ time to bail.
\
\ ******************************************************************************

.SESCP

 LDX #ESC               \ Set X to the ship type for an escape pod

 LDA #%11111110         \ Set A to an AI flag that has AI enabled, is hostile,
                        \ but has no E.C.M.

                        \ Fall through into SFS1 to spawn the escape pod

\ ******************************************************************************
\
\       Name: SFS1
\       Type: Subroutine
\   Category: Universe
\    Summary: Spawn a child ship from the current (parent) ship
\
\ ------------------------------------------------------------------------------
\
\ If the parent is a space station then the child ship is spawned coming out of
\ the slot, and if the child is a cargo canister, it is sent tumbling through
\ space. Otherwise the child ship is spawned with the same ship data as the
\ parent, just with damping disabled and the ship type and AI flag that are
\ passed in A and X.
\
\ Arguments:
\
\   A                   AI flag for the new ship (see the documentation on ship
\                       data byte #32 for details)
\
\   X                   The ship type of the child to spawn
\
\   INF                 Address of the parent's ship data block
\
\   TYPE                The type of the parent ship
\
\ Returns:
\
\   C flag              Set if ship successfully added, clear if it failed
\
\   INF                 INF is preserved
\
\   XX0                 XX0 is preserved
\
\   INWK                The whole INWK workspace is preserved
\
\   X                   X is preserved
\
\ Other entry points:
\
\   SFS1-2              Add a missile to the local bubble that has AI enabled,
\                       is hostile, but has no E.C.M.
\
\ ******************************************************************************

.SFS1

 STA T1                 \ Store the child ship's AI flag in T1

                        \ Before spawning our child ship, we need to save the
                        \ INF and XX00 variables and the whole INWK workspace,
                        \ so we can restore them later when returning from the
                        \ subroutine

 TXA                    \ Store X, the ship type to spawn, on the stack so we
 PHA                    \ can preserve it through the routine

 LDA XX0                \ Store XX0(1 0) on the stack, so we can restore it
 PHA                    \ later when returning from the subroutine
 LDA XX0+1
 PHA

 LDA INF                \ Store INF(1 0) on the stack, so we can restore it
 PHA                    \ later when returning from the subroutine
 LDA INF+1
 PHA

 LDY #NI%-1             \ Now we want to store the current INWK data block in
                        \ temporary memory so we can restore it when we are
                        \ done, and we also want to copy the parent's ship data
                        \ into INWK, which we can do at the same time, so set up
                        \ a counter in Y for NI% bytes

.FRL2

 LDA INWK,Y             \ Copy the Y-th byte of INWK to the Y-th byte of
 STA XX3,Y              \ temporary memory in XX3, so we can restore it later
                        \ when returning from the subroutine

 LDA (INF),Y            \ Copy the Y-th byte of the parent ship's data block to
 STA INWK,Y             \ the Y-th byte of INWK

 DEY                    \ Decrement the loop counter

 BPL FRL2               \ Loop back to copy the next byte until we have done
                        \ them all

                        \ INWK now contains the ship data for the parent ship,
                        \ so now we need to tweak the data before creating the
                        \ new child ship (in this way, the child inherits things
                        \ like location from the parent)

 LDA NEWB               \ Clear bits 0-1 and 5-7 of the ship's NEWB flags,
 AND #%00011100         \ leaving only the hostile, pirate and docking flags
 STA NEWB               \ (so the child inherits these flags from the parent,
                        \ meaning pirates spawn pirates, angry ships spawn
                        \ angry ships, and ships that are docking spawn ships
                        \ that are also docking)

 LDA TYPE               \ Fetch the ship type of the parent into A

 CMP #SST               \ If the parent is not a space station, jump to rx to
 BNE rx                 \ skip the following

                        \ The parent is a space station, so the child needs to
                        \ launch out of the space station's slot. The space
                        \ station's nosev vector points out of the station's
                        \ slot, so we want to move the ship along this vector.
                        \ We do this by taking the unit vector in nosev and
                        \ doubling it, so we spawn our ship 2 units along the
                        \ vector from the space station's centre

 TXA                    \ Store the child's ship type in X on the stack
 PHA

 LDA #32                \ Set the child's byte #27 (speed) to 32
 STA INWK+27

 LDX #0                 \ Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
 LDA INWK+10            \ child's x-coordinate
 JSR SFS2

 LDX #3                 \ Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
 LDA INWK+12            \ child's y-coordinate
 JSR SFS2

 LDX #6                 \ Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
 LDA INWK+14            \ child's z-coordinate
 JSR SFS2

 PLA                    \ Restore the child's ship type from the stack into X
 TAX

.rx

 LDA T1                 \ Restore the child ship's AI flag from T1 and store it
 STA INWK+32            \ in the child's byte #32 (AI)

 LSR INWK+29            \ Clear bit 0 of the child's byte #29 (roll counter) so
 ASL INWK+29            \ that its roll dampens (so if we are spawning from a
                        \ space station, for example, the spawned ship won't
                        \ keep rolling forever)

 TXA                    \ Copy the child's ship type from X into A

 CMP #SPL+1             \ If the type of the child we are spawning is less than
 BCS NOIL               \ #PLT or greater than #SPL - i.e. not an alloy plate,
 CMP #PLT               \ cargo canister, boulder, asteroid or splinter - then
 BCC NOIL               \ jump to NOIL to skip us setting up some pitch and roll
                        \ for it

 PHA                    \ Store the child's ship type on the stack so we can
                        \ retrieve it below

 JSR DORND              \ Set A and X to random numbers

 ASL A                  \ Set the child's byte #30 (pitch counter) to a random
 STA INWK+30            \ value, and at the same time set the C flag randomly

 TXA                    \ Set the child's byte #27 (speed) to a random value
 AND #%00001111         \ between 0 and 15
 STA INWK+27

 LDA #&FF               \ Set the child's byte #29 (roll counter) to a full
 ROR A                  \ roll, so the canister tumbles through space, with
 STA INWK+29            \ damping randomly enabled or disabled, depending on the
                        \ C flag from above

 PLA                    \ Retrieve the child's ship type from the stack

.NOIL

 JSR NWSHP              \ Add a new ship of type A to the local bubble

                        \ We have now created our child ship, so we need to
                        \ restore all the variables we saved at the start of
                        \ the routine, so they are preserved when we return
                        \ from the subroutine

 PLA                    \ Restore INF(1 0) from the stack
 STA INF+1
 PLA
 STA INF

 LDX #NI%-1             \ Now to restore the INWK workspace that we saved into
                        \ XX3 above, so set a counter in X for NI% bytes

.FRL3

 LDA XX3,X              \ Copy the Y-th byte of XX3 to the Y-th byte of INWK
 STA INWK,X

 DEX                    \ Decrement the loop counter

 BPL FRL3               \ Loop back to copy the next byte until we have done
                        \ them all

 PLA                    \ Restore XX0(1 0) from the stack
 STA XX0+1
 PLA
 STA XX0

 PLA                    \ Retrieve the ship type to spawn from the stack into X
 TAX                    \ so it is preserved through calls to this routine

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SFS2
\       Type: Subroutine
\   Category: Moving
\    Summary: Move a ship in space along one of the coordinate axes
\
\ ------------------------------------------------------------------------------
\
\ Move a ship's coordinates by a certain amount in the direction of one of the
\ axes, where X determines the axis. Mathematically speaking, this routine
\ translates the ship along a single axis by a signed delta.
\
\ Arguments:
\
\   A                   The amount of movement, i.e. the signed delta
\
\   X                   Determines which coordinate axis of INWK to move:
\
\                         * X = 0 moves the ship along the x-axis
\
\                         * X = 3 moves the ship along the y-axis
\
\                         * X = 6 moves the ship along the z-axis
\
\ ******************************************************************************

.SFS2

 ASL A                  \ Set R = |A * 2|, with the C flag set to bit 7 of A
 STA R

 LDA #0                 \ Set bit 7 of A to the C flag, i.e. the sign bit from
 ROR A                  \ the original argument in A

 JMP MVT1               \ Add the delta R with sign A to (x_lo, x_hi, x_sign)
                        \ (or y or z, depending on the value in X) and return
                        \ from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: LL164
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Make the hyperspace sound and draw the hyperspace tunnel
\
\ ------------------------------------------------------------------------------
\
\ See the IRQ1 routine for details on the multi-coloured effect that's used.
\
\ ******************************************************************************

.LL164

 LDA #56                \ Call the NOISE routine with A = 56 to make the sound
 JSR NOISE              \ of the hyperspace drive being engaged

 LDA #1                 \ Set HFX to 1, which switches the screen mode to a full
 STA HFX                \ mode 5 screen, therefore making the hyperspace rings
                        \ multi-coloured and all zig-zaggy (see the IRQ1 routine
                        \ for details)

 JSR update_pod         \ Update the dashboard colours to reflect whether we
                        \ have an escape pod, as the hyperspace process resets
                        \ this aspect of the palette

 LDA #4                 \ Set the step size for the hyperspace rings to 4, so
                        \ there are more sections in the rings and they are
                        \ quite round (compared to the step size of 8 used in
                        \ the much more polygonal launch rings)

 JSR HFS2               \ Call HFS2 to draw the hyperspace tunnel rings

 DEC HFX                \ Set HFX back to 0, so we switch back to the normal
                        \ split-screen mode

 JMP update_pod         \ Update the dashboard colours to reflect whether we
                        \ have an escape pod, as the hyperspace process resets
                        \ this aspect of the palette

\ ******************************************************************************
\
\       Name: LAUN
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Make the launch sound and draw the launch tunnel
\
\ ------------------------------------------------------------------------------
\
\ This is shown when launching from or docking with the space station.
\
\ ******************************************************************************

.LAUN

 JSR n_sound30          \ Call n_sound30 to make the sound of the ship launching
                        \ from the station

 LDA #8                 \ Set the step size for the launch tunnel rings to 8, so
                        \ there are fewer sections in the rings and they are
                        \ quite polygonal (compared to the step size of 4 used
                        \ in the much rounder hyperspace rings)

                        \ Fall through into HFS2 to draw the launch tunnel rings

\ ******************************************************************************
\
\       Name: HFS2
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Clear the screen and draw the launch or hyperspace tunnel
\
\ ******************************************************************************

.HFS2

 STA STP                \ Store the step size in A

 JSR TTX66              \ Clear the screen and draw a white border

 JMP HFS1               \ Jump to HFS1 to draw the launch or hyperspace tunnel

\ ******************************************************************************
\
\       Name: STARS2
\       Type: Subroutine
\   Category: Stardust
\    Summary: Process the stardust for the left or right view
\  Deep dive: Stardust in the side views
\
\ ------------------------------------------------------------------------------
\
\ This moves the stardust sideways according to our speed and which side we are
\ looking out of, and applies our current pitch and roll to each particle of
\ dust, so the stardust moves correctly when we steer our ship.
\
\ These are the calculations referred to in the commentary:
\
\   1. delta_x = 8 * 256 * speed / z_hi
\   2. x = x + delta_x
\
\   3. x = x + beta * y
\   4. y = y - beta * x
\
\   5. x = x - alpha * x * y
\   6. y = y + alpha * y * y + alpha
\
\ For more information see the deep dive on "Stardust in the side views".
\
\ Arguments:
\
\   X                   The view to process:
\
\                         * X = 1 for left view
\
\                         * X = 2 for right view
\
\ ******************************************************************************

.STARS2

 LDA #0                 \ Set A to 0 so we can use it to capture a sign bit

 CPX #2                 \ If X >= 2 then the C flag is set

 ROR A                  \ Roll the C flag into the sign bit of A and store in
 STA RAT                \ RAT, so:
                        \
                        \   * Left view, C is clear so RAT = 0 (positive)
                        \
                        \   * Right view, C is set so RAT = 128 (negative)
                        \
                        \ RAT represents the end of the x-axis where we want new
                        \ stardust particles to come from: positive for the left
                        \ view where new particles come in from the right,
                        \ negative for the right view where new particles come
                        \ in from the left

 EOR #%10000000         \ Set RAT2 to the opposite sign, so:
 STA RAT2               \
                        \   * Left view, RAT2 = 128 (negative)
                        \
                        \   * Right view, RAT2 = 0 (positive)
                        \
                        \ RAT2 represents the direction in which stardust
                        \ particles should move along the x-axis: negative for
                        \ the left view where particles go from right to left,
                        \ positive for the right view where particles go from
                        \ left to right

 JSR ST2                \ Call ST2 to flip the signs of the following if this is
                        \ the right view: ALPHA, ALP2, ALP2+1, BET2 and BET2+1

 LDY NOSTM              \ Set Y to the current number of stardust particles, so
                        \ we can use it as a counter through all the stardust

.STL2

 LDA SZ,Y               \ Set A = ZZ = z_hi

 STA ZZ                 \ We also set ZZ to the original value of z_hi, which we
                        \ use below to remove the existing particle

 LSR A                  \ Set A = z_hi / 8
 LSR A
 LSR A

 JSR DV41               \ Call DV41 to set the following:
                        \
                        \   (P R) = 256 * DELTA / A
                        \         = 256 * speed / (z_hi / 8)
                        \         = 8 * 256 * speed / z_hi
                        \
                        \ This represents the distance we should move this
                        \ particle along the x-axis, let's call it delta_x

 LDA P                  \ Set S = P but with the sign from RAT2, so we now have
 EOR RAT2               \ the distance delta_x with the correct sign in (S R):
 STA S                  \
                        \   (S R) = delta_x
                        \         = 8 * 256 * speed / z_hi
                        \
                        \ So (S R) is the delta, signed to match the direction
                        \ the stardust should move in, which is result 1 above

 LDA SXL,Y              \ Set (A P) = (x_hi x_lo)
 STA P                  \           = x
 LDA SX,Y

 STA X1                 \ Set X1 = A, so X1 contains the original value of x_hi,
                        \ which we use below to remove the existing particle

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = x + delta_x

 STA S                  \ Set (S R) = (A X)
 STX R                  \           = x + delta_x

 LDA SY,Y               \ Set A = y_hi

 STA Y1                 \ Set Y1 = A, so Y1 contains the original value of y_hi,
                        \ which we use below to remove the existing particle

 EOR BET2               \ Give A the correct sign of A * beta, i.e. y_hi * beta

 LDX BET1               \ Fetch |beta| from BET1, the pitch angle

 JSR MULTS-2            \ Call MULTS-2 to calculate:
                        \
                        \   (A P) = X * A
                        \         = beta * y_hi

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = beta * y + x + delta_x

 STX XX                 \ Set XX(1 0) = (A X), which gives us results 2 and 3
 STA XX+1               \ above, done at the same time:
                        \
                        \   x = x + delta_x + beta * y

 LDX SYL,Y              \ Set (S R) = (y_hi y_lo)
 STX R                  \           = y
 LDX Y1
 STX S

 LDX BET1               \ Fetch |beta| from BET1, the pitch angle

 EOR BET2+1             \ Give A the opposite sign to x * beta

 JSR MULTS-2            \ Call MULTS-2 to calculate:
                        \
                        \   (A P) = X * A
                        \         = -beta * x

 JSR ADD                \ Call ADD to calculate:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = -beta * x + y

 STX YY                 \ Set YY(1 0) = (A X), which gives us result 4 above:
 STA YY+1               \
                        \   y = y - beta * x

 LDX ALP1               \ Set X = |alpha| from ALP2, the roll angle

 EOR ALP2               \ Give A the correct sign of A * alpha, i.e. y_hi *
                        \ alpha

 JSR MULTS-2            \ Call MULTS-2 to calculate:
                        \
                        \   (A P) = X * A
                        \         = alpha * y

 STA Q                  \ Set Q = high byte of alpha * y

 LDA XX                 \ Set (S R) = XX(1 0)
 STA R                  \           = x
 LDA XX+1               \
 STA S                  \ and set A = y_hi at the same time

 EOR #%10000000         \ Flip the sign of A = -x_hi

 JSR MAD                \ Call MAD to calculate:
                        \
                        \   (A X) = Q * A + (S R)
                        \         = alpha * y * -x + x

 STA XX+1               \ Store the high byte A in XX+1

 TXA
 STA SXL,Y              \ Store the low byte X in x_lo

                        \ So (XX+1 x_lo) now contains result 5 above:
                        \
                        \   x = x - alpha * x * y

 LDA YY                 \ Set (S R) = YY(1 0)
 STA R                  \           = y
 LDA YY+1               \
 STA S                  \ and set A = y_hi at the same time

 JSR MAD                \ Call MAD to calculate:
                        \
                        \   (A X) = Q * A + (S R)
                        \         = alpha * y * y_hi + y

 STA S                  \ Set (S R) = (A X)
 STX R                  \           = y + alpha * y * y

 LDA #0                 \ Set P = 0
 STA P

 LDA ALPHA              \ Set A = alpha, so:
                        \
                        \   (A P) = (alpha 0)
                        \         = alpha / 256

 JSR PIX1               \ Call PIX1 to calculate the following:
                        \
                        \   (YY+1 y_lo) = (A P) + (S R)
                        \               = alpha * 256 + y + alpha * y * y
                        \
                        \ i.e. y = y + alpha / 256 + alpha * y^2, which is
                        \ result 6 above
                        \
                        \ PIX1 also draws a particle at (X1, Y1) with distance
                        \ ZZ, which will remove the old stardust particle, as we
                        \ set X1, Y1 and ZZ to the original values for this
                        \ particle during the calculations above

                        \ We now have our newly moved stardust particle at
                        \ x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
                        \ and distance z_hi, so we draw it if it's still on
                        \ screen, otherwise we recycle it as a new bit of
                        \ stardust and draw that

 LDA XX+1               \ Set X1 and x_hi to the high byte of XX in XX+1, so
 STA SX,Y               \ the new x-coordinate is in (x_hi x_lo) and the high
 STA X1                 \ byte is in X1

 AND #%01111111         \ If |x_hi| >= 116 then jump to KILL2 to recycle this
 CMP #116               \ particle, as it's gone off the side of the screen,
 BCS KILL2              \ and re-join at STC2 with the new particle

 LDA YY+1               \ Set Y1 and y_hi to the high byte of YY in YY+1, so
 STA SY,Y               \ the new x-coordinate is in (y_hi y_lo) and the high
 STA Y1                 \ byte is in Y1

 AND #%01111111         \ If |y_hi| >= 116 then jump to ST5 to recycle this
 CMP #116               \ particle, as it's gone off the top or bottom of the
 BCS ST5                \ screen, and re-join at STC2 with the new particle

.STC2

 JSR PIXEL2             \ Draw a stardust particle at (X1,Y1) with distance ZZ,
                        \ i.e. draw the newly moved particle at (x_hi, y_hi)
                        \ with distance z_hi

 DEY                    \ Decrement the loop counter to point to the next
                        \ stardust particle

 BEQ ST2                \ If we have just done the last particle, skip the next
                        \ instruction to return from the subroutine

 JMP STL2               \ We have more stardust to process, so jump back up to
                        \ STL2 for the next particle

                        \ Fall through into ST2 to restore the signs of the
                        \ following if this is the right view: ALPHA, ALP2,
                        \ ALP2+1, BET2 and BET2+1

.ST2

 LDA ALPHA              \ If this is the right view, flip the sign of ALPHA
 EOR RAT
 STA ALPHA

 LDA ALP2               \ If this is the right view, flip the sign of ALP2
 EOR RAT
 STA ALP2

 EOR #%10000000         \ If this is the right view, flip the sign of ALP2+1
 STA ALP2+1

 LDA BET2               \ If this is the right view, flip the sign of BET2
 EOR RAT
 STA BET2

 EOR #%10000000         \ If this is the right view, flip the sign of BET2+1
 STA BET2+1

 RTS                    \ Return from the subroutine

.KILL2

 JSR DORND              \ Set A and X to random numbers

 STA Y1                 \ Set y_hi and Y1 to random numbers, so the particle
 STA SY,Y               \ starts anywhere along the y-axis

 LDA #115               \ Make sure A is at least 115 and has the sign in RAT
 ORA RAT

 STA X1                 \ Set x_hi and X1 to A, so this particle starts on the
 STA SX,Y               \ correct edge of the screen for new particles

 BNE STF1               \ Jump down to STF1 to set the z-coordinate (this BNE is
                        \ effectively a JMP as A will never be zero)

.ST5

 JSR DORND              \ Set A and X to random numbers

 STA X1                 \ Set x_hi and X1 to random numbers, so the particle
 STA SX,Y               \ starts anywhere along the x-axis

 LDA #110               \ Make sure A is at least 110 and has the sign in AL2+1,
 ORA ALP2+1             \ the flipped sign of the roll angle alpha

 STA Y1                 \ Set y_hi and Y1 to A, so the particle starts at the
 STA SY,Y               \ top or bottom edge, depending on the current roll
                        \ angle alpha

.STF1

 JSR DORND              \ Set A and X to random numbers

 ORA #8                 \ Make sure A is at least 8 and store it in z_hi and
 STA ZZ                 \ ZZ, so the new particle starts at any distance from
 STA SZ,Y               \ us, but not too close

 BNE STC2               \ Jump up to STC2 to draw this new particle (this BNE is
                        \ effectively a JMP as A will never be zero)

\ ******************************************************************************
\
\       Name: MU5
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
\
\ ------------------------------------------------------------------------------
\
\ In practice this is only called via a BEQ following an AND instruction, in
\ which case A = 0, so this routine effectively does this:
\
\   K(3 2 1 0) = 0
\
\ Other entry points:
\
\   n_store             Set K(3 2 1) = (A A A) and clear the C flag
\
\ ******************************************************************************

.MU5

 STA K                  \ Set K(3 2 1 0) to (A A A A), starting with the lowest
                        \ byte

.n_store

 STA K+1                \ And then the high bytes
 STA K+2
 STA K+3

 CLC                    \ Clear the C flag

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MULT3
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
\  Deep dive: Shift-and-add multiplication
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following multiplication between a signed 24-bit number and a
\ signed 8-bit number, returning the result as a signed 32-bit number:
\
\   K(3 2 1 0) = (A P+1 P) * Q
\
\ The algorithm is the same shift-and-add algorithm as in routine MULT1, but
\ extended to cope with more bits.
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.MULT3

 STA R                  \ Store the high byte of (A P+1 P) in R

 AND #%01111111         \ Set K+2 to |A|, the high byte of K(2 1 0)
 STA K+2

 LDA Q                  \ Set A to bits 0-6 of Q, so A = |Q|
 AND #%01111111

 BEQ MU5                \ If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
                        \ returning from the subroutine using a tail call

 SEC                    \ Set T = |Q| - 1
 SBC #1
 STA T

                        \ We now use the same shift-and-add algorithm as MULT1
                        \ to calculate the following:
                        \
                        \ K(2 1 0) = K(2 1 0) * |Q|
                        \
                        \ so we start with the first shift right, in which we
                        \ take (K+2 P+1 P) and shift it right, storing the
                        \ result in K(2 1 0), ready for the multiplication loop
                        \ (so the multiplication loop actually calculates
                        \ (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
                        \ (|A| P+1 P) shifted right)

 LDA P+1                \ Set A = P+1

 LSR K+2                \ Shift the high byte in K+2 to the right

 ROR A                  \ Shift the middle byte in A to the right and store in
 STA K+1                \ K+1 (so K+1 contains P+1 shifted right)

 LDA P                  \ Shift the middle byte in P to the right and store in
 ROR A                  \ K, so K(2 1 0) now contains (|A| P+1 P) shifted right
 STA K

                        \ We now use the same shift-and-add algorithm as MULT1
                        \ to calculate the following:
                        \
                        \ K(2 1 0) = K(2 1 0) * |Q|

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LDX #24                \ Set up a counter in X to count the 24 bits in K(2 1 0)

.MUL2

 BCC P%+4               \ If C (i.e. the next bit from K) is set, do the
 ADC T                  \ addition for this bit of K:
                        \
                        \   A = A + T + C
                        \     = A + |Q| - 1 + 1
                        \     = A + |Q|

 ROR A                  \ Shift A right by one place to catch the next digit
 ROR K+2                \ next digit of our result in the left end of K(2 1 0),
 ROR K+1                \ while also shifting K(2 1 0) right to fetch the next
 ROR K                  \ bit for the calculation into the C flag
                        \
                        \ On the last iteration of this loop, the bit falling
                        \ off the end of K will be bit 0 of the original A, as
                        \ we did one shift before the loop and we are doing 24
                        \ iterations. We set A to 0 before looping, so this
                        \ means the loop exits with the C flag clear

 DEX                    \ Decrement the loop counter

 BNE MUL2               \ Loop back for the next bit until K(2 1 0) has been
                        \ rotated all the way

                        \ The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
                        \ but it is positive and doesn't have the correct sign
                        \ of the final result yet

 STA T                  \ Save the high byte of the result into T

 LDA R                  \ Fetch the sign byte from the original (A P+1 P)
                        \ argument that we stored in R

 EOR Q                  \ EOR with Q so the sign bit is the same as that of
                        \ (A P+1 P) * Q

 AND #%10000000         \ Extract the sign bit

 ORA T                  \ Apply this to the high byte of the result in T, so
                        \ that A now has the correct sign for the result, and
                        \ (A K+2 K+1 K) therefore contains the correctly signed
                        \ result

 STA K+3                \ Store A in K+3, so K(3 2 1 0) now contains the result

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MLS2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   (S R) = XX(1 0)
\
\   (A P) = A * ALP1
\
\ where ALP1 is the magnitude of the current roll angle alpha, in the range
\ 0-31.
\
\ ******************************************************************************

.MLS2

 LDX XX                 \ Set (S R) = XX(1 0), starting with the low bytes
 STX R

 LDX XX+1               \ And then doing the high bytes
 STX S

                        \ Fall through into MLS1 to calculate (A P) = A * ALP1

\ ******************************************************************************
\
\       Name: MLS1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A P) = ALP1 * A
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   (A P) = ALP1 * A
\
\ where ALP1 is the magnitude of the current roll angle alpha, in the range
\ 0-31.
\
\ This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
\ use the same algorithm but with P set to ALP1 and X set to A. The unrolled
\ version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
\ only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
\ shifts can be done without a test (for bits 5-7).
\
\ Other entry points:
\
\   MULTS-2             Calculate (A P) = X * A
\
\ ******************************************************************************

.MLS1

 LDX ALP1               \ Set P to the roll angle alpha magnitude in ALP1
 STX P                  \ (0-31), so now we calculate P * A

.MULTS

 TAX                    \ Set X = A, so now we can calculate P * X instead of
                        \ P * A to get our result, and we can use the algorithm
                        \ from MU11 to do that, just unrolled (as MU11 returns
                        \ P * X)

 AND #%10000000         \ Set T to the sign bit of A
 STA T

 TXA                    \ Set A = |A|
 AND #127

 BEQ MU6                \ If A = 0, jump to MU6 to set P(1 0) = 0 and return
                        \ from the subroutine using a tail call

 TAX                    \ Set T1 = X - 1
 DEX                    \
 STX T1                 \ We subtract 1 as the C flag will be set when we want
                        \ to do an addition in the loop below

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LSR P                  \ Set P = P >> 1
                        \ and C flag = bit 0 of P

                        \ We are now going to work our way through the bits of
                        \ P, and do a shift-add for any bits that are set,
                        \ keeping the running total in A, but instead of using a
                        \ loop like MU11, we just unroll it, starting with bit 0

 BCC P%+4               \ If C (i.e. the next bit from P) is set, do the
 ADC T1                 \ addition for this bit of P:
                        \
                        \   A = A + T1 + C
                        \     = A + X - 1 + 1
                        \     = A + X

 ROR A                  \ Shift A right to catch the next digit of our result,
                        \ which the next ROR sticks into the left end of P while
                        \ also extracting the next bit of P

 ROR P                  \ Add the overspill from shifting A to the right onto
                        \ the start of P, and shift P right to fetch the next
                        \ bit for the calculation into the C flag

 BCC P%+4               \ Repeat the shift-and-add loop for bit 1
 ADC T1
 ROR A
 ROR P

 BCC P%+4               \ Repeat the shift-and-add loop for bit 2
 ADC T1
 ROR A
 ROR P

 BCC P%+4               \ Repeat the shift-and-add loop for bit 3
 ADC T1
 ROR A
 ROR P

 BCC P%+4               \ Repeat the shift-and-add loop for bit 4
 ADC T1
 ROR A
 ROR P

 LSR A                  \ Just do the "shift" part for bit 5
 ROR P

 LSR A                  \ Just do the "shift" part for bit 6
 ROR P

 LSR A                  \ Just do the "shift" part for bit 7
 ROR P

 ORA T                  \ Give A the sign bit of the original argument A that
                        \ we put into T above

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MLU1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
\
\ ------------------------------------------------------------------------------
\
\ Do the following assignment, and multiply the Y-th stardust particle's
\ y-coordinate with an unsigned number Q:
\
\   Y1 = y_hi
\
\   (A P) = |y_hi| * Q
\
\ ******************************************************************************

.MLU1

 LDA SY,Y               \ Set Y1 the Y-th byte of SY
 STA Y1

                        \ Fall through into MLU2 to calculate:
                        \
                        \   (A P) = |A| * Q

\ ******************************************************************************
\
\       Name: MLU2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A P) = |A| * Q
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of a sign-magnitude 8-bit number P with an
\ unsigned number Q:
\
\   (A P) = |A| * Q
\
\ ******************************************************************************

.MLU2

 AND #%01111111         \ Clear the sign bit in P, so P = |A|
 STA P

 JMP MULTU              \ Call MULTU to calculate:
                        \
                        \   (A P) = P * Q
                        \         = |A| * Q
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: MU6
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Set P(1 0) = (A A)
\
\ ------------------------------------------------------------------------------
\
\ In practice this is only called via a BEQ following an AND instruction, in
\ which case A = 0, so this routine effectively does this:
\
\   P(1 0) = 0
\
\ ******************************************************************************

.MU6

 STA P+1                \ Set P(1 0) = (A A)
 STA P

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Unused duplicate of MULTU
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Unused duplicate of the MULTU routine
\
\ ------------------------------------------------------------------------------
\
\ This is a duplicate of the MULTU routine, but with no entry label, so it can't
\ be called by name. It is unused, and could have been culled to save a few
\ bytes (24 to be precise), but it's still here, unnamed, unloved and unvisited,
\ through no fault of its own.
\
\ ******************************************************************************

{

.MUL6

 BCC P%+4
 ADC T
 ROR A
 ROR P
 DEX
 BNE MUL6
 RTS
}

\ ******************************************************************************
\
\       Name: MLTU2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A P+1 P) = (A ~P) * Q
\  Deep dive: Shift-and-add multiplication
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of an unsigned 16-bit number and an unsigned
\ 8-bit number:
\
\   (A P+1 P) = (A ~P) * Q
\
\ where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
\ words, if you wanted to calculate &1234 * &56, you would:
\
\   * Set A to &12
\   * Set P to &34 EOR %11111111 = &CB
\   * Set Q to &56
\
\ before calling MLTU2.
\
\ This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
\ inverted argument trick to work out whether or not to do an addition, and like
\ MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
\ extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
\ the algorithm is still the shift-and-add approach explained in MULT1, just
\ with more bits.
\
\ Returns:
\
\   Q                   Q is preserved
\
\ Other entry points:
\
\   MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
\
\ ******************************************************************************

 STX Q                  \ Store X in Q

.MLTU2

 EOR #%11111111         \ Flip the bits in A and rotate right, storing the
 LSR A                  \ result in P+1, so we now calculate (P+1 P) * Q
 STA P+1

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LDX #16                \ Set up a counter in X to count the 16 bits in (P+1 P)

 ROR P                  \ Set P = P >> 1 with bit 7 = bit 0 of A
                        \ and C flag = bit 0 of P

.MUL7

 BCS MU21               \ If C (i.e. the next bit from P) is set, do not do the
                        \ addition for this bit of P, and instead skip to MU21
                        \ to just do the shifts

 ADC Q                  \ Do the addition for this bit of P:
                        \
                        \   A = A + Q + C
                        \     = A + Q

 ROR A                  \ Rotate (A P+1 P) to the right, so we capture the next
 ROR P+1                \ digit of the result in P+1, and extract the next digit
 ROR P                  \ of (P+1 P) in the C flag

 DEX                    \ Decrement the loop counter

 BNE MUL7               \ Loop back for the next bit until P has been rotated
                        \ all the way

 RTS                    \ Return from the subroutine

.MU21

 LSR A                  \ Shift (A P+1 P) to the right, so we capture the next
 ROR P+1                \ digit of the result in P+1, and extract the next digit
 ROR P                  \ of (P+1 P) in the C flag

 DEX                    \ Decrement the loop counter

 BNE MUL7               \ Loop back for the next bit until P has been rotated
                        \ all the way

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MUT2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
\
\ ------------------------------------------------------------------------------
\
\ Do the following assignment, and multiplication of two signed 8-bit numbers:
\
\   (S R) = XX(1 0)
\   (A P) = Q * A
\
\ ******************************************************************************

.MUT2

 LDX XX+1               \ Set S = XX+1
 STX S

                        \ Fall through into MUT1 to do the following:
                        \
                        \   R = XX
                        \   (A P) = Q * A

\ ******************************************************************************
\
\       Name: MUT1
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate R = XX and (A P) = Q * A
\
\ ------------------------------------------------------------------------------
\
\ Do the following assignment, and multiplication of two signed 8-bit numbers:
\
\   R = XX
\   (A P) = Q * A
\
\ ******************************************************************************

.MUT1

 LDX XX                 \ Set R = XX
 STX R

 JMP MULT1              \ Jump to MULT1 to do the following:
                        \
                        \   (A P) = Q * A
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TAS3
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the dot product of XX15 and an orientation vector
\
\ ------------------------------------------------------------------------------
\
\ Calculate the dot product of the vector in XX15 and one of the orientation
\ vectors, as determined by the value of Y. If vect is the orientation vector,
\ we calculate this:
\
\   (A X) = vect . XX15
\         = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
\
\ Arguments:
\
\   Y                   The orientation vector:
\
\                         * If Y = 10, calculate nosev . XX15
\
\                         * If Y = 16, calculate roofv . XX15
\
\                         * If Y = 22, calculate sidev . XX15
\
\ Returns:
\
\   (A X)               The result of the dot product
\
\ Other entry points:
\
\   TAS3-2              Calculate nosev . XX15
\
\ ******************************************************************************

 LDY #10                \ Set Y = 10 so we calculate nosev . XX15

.TAS3

 LDX INWK,Y             \ Set Q = the Y-th byte of INWK, i.e. vect_x
 STX Q

 LDA XX15               \ Set A = XX15

 JSR MULT12             \ Set (S R) = Q * A
                        \           = vect_x * XX15

 LDX INWK+2,Y           \ Set Q = the Y+2-th byte of INWK, i.e. vect_y
 STX Q

 LDA XX15+1             \ Set A = XX15+1

 JSR MAD                \ Set (A X) = Q * A + (S R)
                        \           = vect_y * XX15+1 + vect_x * XX15

 STA S                  \ Set (S R) = (A X)
 STX R

 LDX INWK+4,Y           \ Set Q = the Y+2-th byte of INWK, i.e. vect_z
 STX Q

 LDA XX15+2             \ Set A = XX15+2

 JMP MAD                \ Call MAD to calculate:
                        \
                        \   (A X) = Q * A + (S R)
                        \           = vect_z * XX15+2 + vect_y * XX15+1 +
                        \             vect_x * XX15
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: DV42
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (P R) = 256 * DELTA / z_hi
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following division and remainder:
\
\   P = DELTA / (the Y-th stardust particle's z_hi coordinate)
\
\   R = remainder as a fraction of A, where 1.0 = 255
\
\ Another way of saying the above is this:
\
\   (P R) = 256 * DELTA / z_hi
\
\ DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
\ are removed at lower values than this), so this means P is between 0 and 2
\ (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
\
\ This uses the same shift-and-subtract algorithm as TIS2, but this time we
\ keep the remainder.
\
\ Arguments:
\
\   Y                   The number of the stardust particle to process
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.DV42

 LDA SZ,Y               \ Fetch the Y-th dust particle's z_hi coordinate into A

                        \ Fall through into DV41 to do:
                        \
                        \   (P R) = 256 * DELTA / A
                        \         = 256 * DELTA / Y-th stardust particle's z_hi

\ ******************************************************************************
\
\       Name: DV41
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (P R) = 256 * DELTA / A
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following division and remainder:
\
\   P = DELTA / A
\
\   R = remainder as a fraction of A, where 1.0 = 255
\
\ Another way of saying the above is this:
\
\   (P R) = 256 * DELTA / A
\
\ This uses the same shift-and-subtract algorithm as TIS2, but this time we
\ keep the remainder.
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.DV41

 STA Q                  \ Store A in Q

 LDA DELTA              \ Fetch the speed from DELTA into A

 JMP DVID4              \ Jump to DVID4 to do:
                        \
                        \   (P R) = 256 * A / Q
                        \         = 256 * DELTA / A
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: DVID3B2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
\  Deep dive: Shift-and-subtract division
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
\
\ The actual division here is done as an 8-bit calculation using LL31, but this
\ routine shifts both the numerator (the top part of the division) and the
\ denominator (the bottom part of the division) around to get the multi-byte
\ result we want.
\
\ Specifically, it shifts both of them to the left as far as possible, keeping a
\ tally of how many shifts get done in each one - and specifically, the
\ difference in the number of shifts between the top and bottom (as shifting
\ both of them once in the same direction won't change the result). It then
\ divides the two highest bytes with the simple 8-bit routine in LL31, and
\ shifts the result by the difference in the number of shifts, which acts as a
\ scale factor to get the correct result.
\
\ Returns:
\
\   K(3 2 1 0)          The result of the division
\
\   X                   X is preserved
\
\ ******************************************************************************

.DVID3B2

 STA P+2                \ Set P+2 = A

 LDA INWK+6             \ Set Q = z_lo
 STA Q

 LDA INWK+7             \ Set R = z_hi
 STA R

 LDA INWK+8             \ Set S = z_sign
 STA S

.DVID3B

                        \ Given the above assignments, we now want to calculate
                        \ the following to get the result we want:
                        \
                        \   K(3 2 1 0) = P(2 1 0) / (S R Q)

 LDA P                  \ Make sure P(2 1 0) is at least 1
 ORA #1
 STA P

 LDA P+2                \ Set T to the sign of P+2 * S (i.e. the sign of the
 EOR S                  \ result) and store it in T
 AND #%10000000
 STA T

 LDY #0                 \ Set Y = 0 to store the scale factor

 LDA P+2                \ Clear the sign bit of P+2, so the division can be done
 AND #%01111111         \ with positive numbers and we'll set the correct sign
                        \ below, once all the maths is done
                        \
                        \ This also leaves A = P+2, which we use below

.DVL9

                        \ We now shift (A P+1 P) left until A >= 64, counting
                        \ the number of shifts in Y. This makes the top part of
                        \ the division as large as possible, thus retaining as
                        \ much accuracy as we can.  When we come to return the
                        \ final result, we shift the result by the number of
                        \ places in Y, and in the correct direction

 CMP #64                \ If A >= 64, jump down to DV14
 BCS DV14

 ASL P                  \ Shift (A P+1 P) to the left
 ROL P+1
 ROL A

 INY                    \ Increment the scale factor in Y

 BNE DVL9               \ Loop up to DVL9 (this BNE is effectively a JMP, as Y
                        \ will never be zero)

.DV14

                        \ If we get here, A >= 64 and contains the highest byte
                        \ of the numerator, scaled up by the number of left
                        \ shifts in Y

 STA P+2                \ Store A in P+2, so we now have the scaled value of
                        \ the numerator in P(2 1 0)

 LDA S                  \ Set A = |S|
 AND #%01111111

 BMI DV9                \ If bit 7 of A is set, jump down to DV9 to skip the
                        \ left-shifting of the denominator (though this branch
                        \ instruction has no effect as bit 7 of the above AND
                        \ can never be set, which is why this instruction was
                        \ removed from later versions)

.DVL6

                        \ We now shift (S R Q) left until bit 7 of S is set,
                        \ reducing Y by the number of shifts. This makes the
                        \ bottom part of the division as large as possible, thus
                        \ retaining as much accuracy as we can. When we come to
                        \ return the final result, we shift the result by the
                        \ total number of places in Y, and in the correct
                        \ direction, to give us the correct result
                        \
                        \ We set A to |S| above, so the following actually
                        \ shifts (A R Q)

 DEY                    \ Decrement the scale factor in Y

 ASL Q                  \ Shift (A R Q) to the left
 ROL R
 ROL A

 BPL DVL6               \ Loop up to DVL6 to do another shift, until bit 7 of A
                        \ is set and we can't shift left any further

.DV9

                        \ We have now shifted both the numerator and denominator
                        \ left as far as they will go, keeping a tally of the
                        \ overall scale factor of the various shifts in Y. We
                        \ can now divide just the two highest bytes to get our
                        \ result

 STA Q                  \ Set Q = A, the highest byte of the denominator

 LDA #254               \ Set R to have bits 1-7 set, so we can pass this to
 STA R                  \ LL31 to act as the bit counter in the division

 LDA P+2                \ Set A to the highest byte of the numerator

 JSR LL31               \ Call LL31 to calculate:
                        \
                        \   R = 256 * A / Q
                        \     = 256 * numerator / denominator

                        \ The result of our division is now in R, so we just
                        \ need to shift it back by the scale factor in Y

 LDA #0                 \ Call n_store to set K(3 2 1) = 0 to hold the result
 JSR n_store            \ (we populate K next)

 TYA                    \ If Y is positive, jump to DV12
 BPL DV12

                        \ If we get here then Y is negative, so we need to shift
                        \ the result R to the left by Y places, and then set the
                        \ correct sign for the result

 LDA R                  \ Set A = R

.DVL8

 ASL A                  \ Shift (K+3 K+2 K+1 A) left
 ROL K+1
 ROL K+2
 ROL K+3

 INY                    \ Increment the scale factor in Y

 BNE DVL8               \ Loop back to DVL8 until we have shifted left by Y
                        \ places

 STA K                  \ Store A in K so the result is now in K(3 2 1 0)

 LDA K+3                \ Set K+3 to the sign in T, which we set above to the
 ORA T                  \ correct sign for the result
 STA K+3

 RTS                    \ Return from the subroutine

.DV13

                        \ If we get here then Y is zero, so we don't need to
                        \ shift the result R, we just need to set the correct
                        \ sign for the result

 LDA R                  \ Store R in K so the result is now in K(3 2 1 0)
 STA K

 LDA T                  \ Set K+3 to the sign in T, which we set above to the
 STA K+3                \ correct sign for the result

 RTS                    \ Return from the subroutine

.DV12

 BEQ DV13               \ We jumped here having set A to the scale factor in Y,
                        \ so this jumps up to DV13 if Y = 0

                        \ If we get here then Y is positive and non-zero, so we
                        \ need to shift the result R to the right by Y places
                        \ and then set the correct sign for the result. We also
                        \ know that K(3 2 1) will stay 0, as we are shifting the
                        \ lowest byte to the right, so no set bits will make
                        \ their way into the top three bytes

 LDA R                  \ Set A = R

.DVL10

 LSR A                  \ Shift A right

 DEY                    \ Decrement the scale factor in Y

 BNE DVL10              \ Loop back to DVL10 until we have shifted right by Y
                        \ places

 STA K                  \ Store the shifted A in K so the result is now in
                        \ K(3 2 1 0)

 LDA T                  \ Set K+3 to the sign in T, which we set above to the
 STA K+3                \ correct sign for the result

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: cntr
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Apply damping to the pitch or roll dashboard indicator
\
\ ------------------------------------------------------------------------------
\
\ Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
\ centre point (so X represents a position on a centre-based dashboard slider,
\ such as pitch or roll). If the value is in the left-hand side of the slider
\ (1-127) then it bumps the value up by 1 so it moves towards the centre, and
\ if it's in the right-hand side, it reduces it by 1, also moving it towards the
\ centre.
\
\ ******************************************************************************

.cntr

 LDA auto               \ If the docking computer is currently activated, jump
 BNE cnt2               \ to cnt2 to skip the following as we always want to
                        \ enable damping for the docking computer

 LDA DAMP               \ If DAMP is non-zero, then keyboard damping is not
 BNE RE1                \ enabled, so jump to RE1 to return from the subroutine

.cnt2

 TXA                    \ If X < 128, then it's in the left-hand side of the
 BPL BUMP               \ dashboard slider, so jump to BUMP to bump it up by 1,
                        \ to move it closer to the centre

 DEX                    \ Otherwise X >= 128, so it's in the right-hand side
 BMI RE1                \ of the dashboard slider, so decrement X by 1, and if
                        \ it's still >= 128, jump to RE1 to return from the
                        \ subroutine, otherwise fall through to BUMP to undo
                        \ the bump and then return

.BUMP

 INX                    \ Bump X up by 1, and if it hasn't overshot the end of
 BNE RE1                \ the dashboard slider, jump to RE1 to return from the
                        \ subroutine, otherwise fall through to REDU to drop
                        \ it down by 1 again

.REDU

 DEX                    \ Reduce X by 1, and if we have reached 0 jump up to
 BEQ BUMP               \ BUMP to add 1, because we need the value to be in the
                        \ range 1 to 255

.RE1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: BUMP2
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Bump up the value of the pitch or roll dashboard indicator
\
\ ------------------------------------------------------------------------------
\
\ Increase ("bump up") X by A, where X is either the current rate of pitch or
\ the current rate of roll.
\
\ The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
\ This is the amount by which the pitch or roll is currently changing, so 1
\ means it is decreasing at the maximum rate, 128 means it is not changing,
\ and 255 means it is increasing at the maximum rate. These values correspond
\ to the line on the DC or RL indicators on the dashboard, with 1 meaning full
\ left, 128 meaning the middle, and 255 meaning full right.
\
\ If bumping up X would push it past 255, then X is set to 255.
\
\ If keyboard auto-recentre is configured and the result is less than 128, we
\ bump X up to the mid-point, 128. This is the equivalent of having a roll or
\ pitch in the left half of the indicator, when increasing the roll or pitch
\ should jump us straight to the mid-point.
\
\ Other entry points:
\
\   RE2+2               Restore A from T and return from the subroutine
\
\ ******************************************************************************

.BUMP2

 STA T                  \ Store argument A in T so we can restore it later

 TXA                    \ Copy argument X into A

 CLC                    \ Clear the C flag so we can do addition without the
                        \ C flag affecting the result

 ADC T                  \ Set X = A = argument X + argument A
 TAX

 BCC RE2                \ If the C flag is clear, then we didn't overflow, so
                        \ jump to RE2 to auto-recentre and return the result

 LDX #255               \ We have an overflow, so set X to the maximum possible
                        \ value of 255

.RE2

 BPL RE3+2              \ If X has bit 7 clear (i.e. the result < 128), then
                        \ jump to RE3+2 in routine REDU2 to do an auto-recentre,
                        \ if configured, because the result is on the left side
                        \ of the centre point of 128

                        \ Jumps to RE2+2 end up here

 LDA T                  \ Restore the original argument A from T into A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: REDU2
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Reduce the value of the pitch or roll dashboard indicator
\
\ ------------------------------------------------------------------------------
\
\ Reduce X by A, where X is either the current rate of pitch or the current
\ rate of roll.
\
\ The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
\ This is the amount by which the pitch or roll is currently changing, so 1
\ means it is decreasing at the maximum rate, 128 means it is not changing,
\ and 255 means it is increasing at the maximum rate. These values correspond
\ to the line on the DC or RL indicators on the dashboard, with 1 meaning full
\ left, 128 meaning the middle, and 255 meaning full right.
\
\ If reducing X would bring it below 1, then X is set to 1.
\
\ If keyboard auto-recentre is configured and the result is greater than 128, we
\ reduce X down to the mid-point, 128. This is the equivalent of having a roll
\ or pitch in the right half of the indicator, when decreasing the roll or pitch
\ should jump us straight to the mid-point.
\
\ Other entry points:
\
\   RE3+2               Auto-recentre the value in X, if keyboard auto-recentre
\                       is configured
\
\ ******************************************************************************

.REDU2

 STA T                  \ Store argument A in T so we can restore it later

 TXA                    \ Copy argument X into A

 SEC                    \ Set the C flag so we can do subtraction without the
                        \ C flag affecting the result

 SBC T                  \ Set X = A = argument X - argument A
 TAX

 BCS RE3                \ If the C flag is set, then we didn't underflow, so
                        \ jump to RE3 to auto-recentre and return the result

 LDX #1                 \ We have an underflow, so set X to the minimum possible
                        \ value, 1

.RE3

 BPL RE2+2              \ If X has bit 7 clear (i.e. the result < 128), then
                        \ jump to RE2+2 above to return the result as is,
                        \ because the result is on the left side of the centre
                        \ point of 128, so we don't need to auto-centre

                        \ Jumps to RE3+2 end up here

                        \ If we get here, then we need to apply auto-recentre,
                        \ if it is configured

 LDA DJD                \ If keyboard auto-recentre is disabled, then
 BNE RE2+2              \ jump to RE2+2 to restore A and return

 LDX #128               \ If we get here then keyboard auto-recentre is enabled,
 BMI RE2+2              \ so set X to 128 (the middle of our range) and jump to
                        \ RE2+2 to restore A and return from the subroutine
                        \ (this BMI is effectively a JMP as bit 7 of X is always
                        \ set)

\ ******************************************************************************
\
\       Name: ARCTAN
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate A = arctan(P / Q)
\  Deep dive: The sine, cosine and arctan tables
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   A = arctan(P / Q)
\
\ In other words, this finds the angle in the right-angled triangle where the
\ opposite side to angle A is length P and the adjacent side to angle A has
\ length Q, so:
\
\   tan(A) = P / Q
\
\ The result in A is an integer representing the angle in radians. The routine
\ returns values in the range 0 to 128, which covers 0 to 180 degrees (or 0 to
\ PI radians).
\
\ ******************************************************************************

.ARCTAN

 LDA P                  \ Set T1 = P EOR Q, which will have the sign of P * Q
 EOR Q
 STA T1

 LDA Q                  \ If Q = 0, jump to AR2 to return a right angle
 BEQ AR2

 ASL A                  \ Set Q = |Q| * 2 (this is a quick way of clearing the
 STA Q                  \ sign bit, and we don't need to shift right again as we
                        \ only ever use this value in the division with |P| * 2,
                        \ which we set next)

 LDA P                  \ Set A = |P| * 2
 ASL A

 CMP Q                  \ If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
 BCS AR1                \ and Q around, so we can still use the lookup table

 JSR ARS1               \ Call ARS1 to set the following from the lookup table:
                        \
                        \   A = arctan(A / Q)
                        \     = arctan(|P / Q|)

 SEC                    \ Set the C flag so the SBC instruction in AR3 will be
                        \ correct, should we jump there

.AR4

 LDX T1                 \ If T1 is negative, i.e. P and Q have different signs,
 BMI AR3                \ jump down to AR3 to return arctan(-|P / Q|)

 RTS                    \ Otherwise P and Q have the same sign, so our result is
                        \ correct and we can return from the subroutine

.AR1

                        \ We want to calculate arctan(t) where |t| > 1, so we
                        \ can use the calculation described in the documentation
                        \ for the ACT table, i.e. 64 - arctan(1 / t)

 LDX Q                  \ Swap the values in Q and P, using the fact that we
 STA Q                  \ called AR1 with A = P
 STX P                  \
 TXA                    \ This also sets A = P (which now contains the original
                        \ argument |Q|)

 JSR ARS1               \ Call ARS1 to set the following from the lookup table:
                        \
                        \   A = arctan(A / Q)
                        \     = arctan(|Q / P|)
                        \     = arctan(1 / |P / Q|)

 STA T                  \ Set T = 64 - T
 LDA #64
 SBC T

 BCS AR4                \ Jump to AR4 to continue the calculation (this BCS is
                        \ effectively a JMP as the subtraction will never
                        \ underflow, as ARS1 returns values in the range 0-31)

.AR2

                        \ If we get here then Q = 0, so tan(A) = infinity and
                        \ A is a right angle, or 0.25 of a circle. We allocate
                        \ 255 to a full circle, so we should return 63 for a
                        \ right angle

 LDA #63                \ Set A to 63, to represent a right angle

 RTS                    \ Return from the subroutine

.AR3

                        \ A contains arctan(|P / Q|) but P and Q have different
                        \ signs, so we need to return arctan(-|P / Q|), using
                        \ the calculation described in the documentation for the
                        \ ACT table, i.e. 128 - A

 STA T                  \ Set A = 128 - A
 LDA #128               \
 SBC T                  \ The subtraction will work because we did a SEC before
                        \ calling AR3

 RTS                    \ Return from the subroutine

.ARS1

                        \ This routine fetches arctan(A / Q) from the ACT table,
                        \ so A will be set to an integer in the range 0 to 31
                        \ that represents an angle from 0 to 45 degrees (or 0 to
                        \ PI / 4 radians)

 JSR LL28               \ Call LL28 to calculate:
                        \
                        \   R = 256 * A / Q

 LDA R                  \ Set X = R / 8
 LSR A                  \       = 32 * A / Q
 LSR A                  \
 LSR A                  \ so X has the value t * 32 where t = A / Q, which is
 TAX                    \ what we need to look up values in the ACT table

 LDA ACT,X              \ Fetch ACT+X from the ACT table into A, so now:
                        \
                        \   A = value in ACT + X
                        \     = value in ACT + (32 * A / Q)
                        \     = arctan(A / Q)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: LASLI
\       Type: Subroutine
\   Category: Drawing lines
\    Summary: Draw the laser lines for when we fire our lasers
\
\ ------------------------------------------------------------------------------
\
\ Draw the laser lines, aiming them to slightly different place each time so
\ they appear to flicker and dance. Also heat up the laser temperature and drain
\ some energy.
\
\ Other entry points:
\
\   LASLI2              Just draw the current laser lines without moving the
\                       centre point, draining energy or heating up. This has
\                       the effect of removing the lines from the screen
\
\   LASLI-1             Contains an RTS
\
\ ******************************************************************************

.LASLI

 JSR DORND              \ Set A and X to random numbers

 AND #7                 \ Restrict A to a random value in the range 0 to 7

 ADC #Y-4               \ Set LASY to four pixels above the centre of the
 STA LASY               \ screen (#Y), plus our random number, so the laser
                        \ dances above and below the centre point

 JSR DORND              \ Set A and X to random numbers

 AND #7                 \ Restrict A to a random value in the range 0 to 7

 ADC #X-4               \ Set LASX to four pixels left of the centre of the
 STA LASX               \ screen (#X), plus our random number, so the laser
                        \ dances to the left and right of the centre point

 LDA GNTMP              \ Add 8 to the laser temperature in GNTMP
 ADC #8
 STA GNTMP

 JSR DENGY              \ Call DENGY to deplete our energy banks by 1

.LASLI2

 LDA QQ11               \ If this is not a space view (i.e. QQ11 is non-zero)
 BNE LASLI-1            \ then jump to MA9 to return from the main flight loop
                        \ (as LASLI-1 is an RTS)

 LDA #32                \ Set A = 32 and Y = 224 for the first set of laser
 LDY #224               \ lines (the wider pair of lines)

 JSR las                \ Call las below to draw the first set of laser lines

 LDA #48                \ Fall through into las with A = 48 and Y = 208 to draw
 LDY #208               \ a second set of lines (the narrower pair)

                        \ The following routine draws two laser lines, one from
                        \ the centre point down to point A on the bottom row,
                        \ and the other from the centre point down to point Y
                        \ on the bottom row. We therefore get lines from the
                        \ centre point to points 32, 48, 208 and 224 along the
                        \ bottom row, giving us the triangular laser effect
                        \ we're after

.las

 STA X2                 \ Set X2 = A

 LDA LASX               \ Set (X1, Y1) to the random centre point we set above
 STA X1
 LDA LASY
 STA Y1

 LDA #2*Y-1             \ Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
 STA Y2                 \ y-coordinate of the mid-point of the space view, so
                        \ this sets Y2 to 191, the y-coordinate of the bottom
                        \ pixel row of the space view

 JSR LOIN               \ Draw a line from (X1, Y1) to (X2, Y2), so that's from
                        \ the centre point to (A, 191)

 LDA LASX               \ Set (X1, Y1) to the random centre point we set above
 STA X1
 LDA LASY
 STA Y1

 STY X2                 \ Set X2 = Y

 LDA #2*Y-1             \ Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
 STA Y2                 \ pixel row of the space view (as before)

 JMP LOIN               \ Draw a line from (X1, Y1) to (X2, Y2), so that's from
                        \ the centre point to (Y, 191), and return from
                        \ the subroutine using a tail call

\ ******************************************************************************
\
\ Save ELTK.bin
\
\ ******************************************************************************

 PRINT "ELITE K"
 PRINT "Assembled at ", ~CODE_K%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_K%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_K%

 PRINT "S.2.ELTK ", ~CODE_K%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_K%
\SAVE "versions/disc/3-assembled-output/2.ELTK.bin", CODE_K%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE L FILE
\
\ ******************************************************************************

 CODE_L% = P%
 LOAD_L% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: tnpr1
\       Type: Subroutine
\   Category: Market
\    Summary: Work out if we have space for one tonne of cargo
\
\ ------------------------------------------------------------------------------
\
\ Given a market item, work out whether there is room in the cargo hold for one
\ tonne of this item.
\
\ For standard tonne canisters, the limit is given by size of the cargo hold of
\ our current ship.
\
\ For items measured in kg (gold, platinum), g (gem-stones) and alien items,
\ there is no limit.
\
\ Arguments:
\
\   X                   The type of market item (see QQ23 for a list of market
\                       item numbers)
\
\ Returns:
\
\   A                   The new number of items of type X in the hold
\
\   C flag              Returns the result:
\
\                         * Set if there is no room for this item
\
\                         * Clear if there is room for this item
\
\ ******************************************************************************

.tnpr1

 CPX #16                \ If we are checking whether to add alien items (item
 BEQ n_aliens           \ type 16), jump to n_aliens to skip the following two
                        \ instructions

 CPX #13                \ If X >= 13, then X = 13, 14 or 15 (gold, platinum or
 BCS l_2b04             \ gem-stones), for which there is no storage limit, so
                        \ jump to l_2b04 to signal that there is room for this
                        \ item

.n_aliens

 LDY #12                \ Here we count the tonne canisters we have in the hold
                        \ and add 1 to see if we have enough room for one more
                        \ tonne of cargo, using Y as the loop counter, starting
                        \ with Y = 12

 SEC                    \ Set the C flag, so the addition below has one extra,
                        \ representing the extra tonne we want to try to add

 LDA QQ20+16            \ Set A to the number of alien items we already have in
                        \ the hold

.l_2af9

 ADC QQ20,Y             \ Set A = A + the number of tonnes we have in the hold
                        \ of market item number Y

 BCS n_cargo            \ If the addition overflowed, jump to n_cargo to return
                        \ from the subroutine with the C flag set, as the hold
                        \ is already full

 DEY                    \ Decrement the loop counter

 BPL l_2af9             \ Loop back to add in the next market item in the hold,
                        \ until we have added up all market items from 12
                        \ (minerals) down to 0 (food)

 CMP new_hold           \ If A < new_hold then the C flag will be clear (we have
                        \ room in the hold)
                        \
                        \ If A >= new_hold then the C flag will be set (we do
                        \ not have room in the hold)

.n_cargo

 RTS                    \ Return from the subroutine

.l_2b04

                        \ If we get here then the item is gold, platinum or
                        \ gem-stones, for which there is no storage limit, and
                        \ the C flag is set

 LDA QQ20,X             \ Set A to the number of units of this item that we
                        \ already have in the hold

 ADC #0                 \ The C flag is set, so this adds one for the item we
                        \ just scooped

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: hyp
\       Type: Subroutine
\   Category: Flight
\    Summary: Start the hyperspace process
\
\ ------------------------------------------------------------------------------
\
\ Called when "H" or CTRL-H is pressed during flight. Checks the following:
\
\   * We are in space
\
\   * We are not already in a hyperspace countdown
\
\ If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
\ otherwise we check that:
\
\   * The selected system is not the current system
\
\   * We have enough fuel to make the jump
\
\ and if all the pre-jump checks are passed, we print the destination on-screen
\ and start the countdown.
\
\ Other entry points:
\
\   TTX111              Used to rejoin this routine from the call to TTX110
\
\ ******************************************************************************

.hyp

 LDA QQ22+1             \ Fetch QQ22+1, which contains the number that's shown
                        \ on-screen during hyperspace countdown

 ORA QQ12               \ If we are docked (QQ12 = &FF) or there is already a
 BNE zZ+1               \ countdown in progress, then return from the subroutine
                        \ using a tail call (as zZ+1 contains an RTS), as we
                        \ can't hyperspace when docked, or there is already a
                        \ countdown in progress

 JSR CTRL               \ Scan the keyboard to see if CTRL is currently pressed

 BMI Ghy                \ If it is, then the galactic hyperdrive has been
                        \ activated, so jump to Ghy to process it

 LDA QQ11               \ If the current view is not 0 (i.e. not the space view)
 BNE P%+8               \ then skip the following two instructions

 JSR TT111              \ This is the space view, so select the system closest
                        \ to galactic coordinates (QQ9, QQ10)

 JMP TTX111             \ Skip the following instruction, as we don't want to
                        \ draw the crosshairs in the space view

 JSR hm                 \ This is a chart view, so call hm to redraw the chart
                        \ crosshairs

.TTX111

                        \ If we get here then the current view is either the
                        \ space view or a chart

 LDA QQ8                \ If both bytes of the distance to the selected system
 ORA QQ8+1              \ in QQ8 are zero, return from the subroutine (as zZ+1
 BEQ zZ+1               \ contains an RTS), as the selected system is the
                        \ current system

 LDA #7                 \ Move the text cursor to column 7, row 23 (in the
 STA XC                 \ middle of the bottom text row)
 LDA #23
 STA YC

 LDA #0                 \ Set QQ17 = 0 to switch to ALL CAPS
 STA QQ17

 LDA #189               \ Print recursive token 29 ("HYPERSPACE ")
 JSR TT27

 LDA QQ8+1              \ If the high byte of the distance to the selected
 BNE TT147              \ system in QQ8 is > 0, then it is definitely too far to
                        \ jump (as our maximum range is 7.0 light years, or a
                        \ value of 70 in QQ8(1 0)), so jump to TT147 to print
                        \ "RANGE?" and return from the subroutine using a tail
                        \ call

 LDA QQ14               \ Fetch our current fuel level from Q114 into A

 CMP QQ8                \ If our fuel reserves are less than the distance to the
 BCC TT147              \ selected system, then we don't have enough fuel for
                        \ this jump, so jump to TT147 to print "RANGE?" and
                        \ return from the subroutine using a tail call

 LDA #'-'               \ Print a hyphen
 JSR TT27

 JSR cpl                \ Call cpl to print the name of the selected system

                        \ Fall through into wW to start the hyperspace countdown

\ ******************************************************************************
\
\       Name: wW
\       Type: Subroutine
\   Category: Flight
\    Summary: Start a hyperspace countdown
\
\ ------------------------------------------------------------------------------
\
\ Start the hyperspace countdown (for both inter-system hyperspace and the
\ galactic hyperdrive).
\
\ ******************************************************************************

.wW

 LDA #15                \ The hyperspace countdown starts from 15, so set A to
                        \ 15 so we can set the two hyperspace counters

 STA QQ22+1             \ Set the number in QQ22+1 to 15, which is the number
                        \ that's shown on-screen during the hyperspace countdown

 STA QQ22               \ Set the number in QQ22 to 15, which is the internal
                        \ counter that counts down by 1 each iteration of the
                        \ main game loop, and each time it reaches zero, the
                        \ on-screen counter gets decremented, and QQ22 gets set
                        \ to 5, so setting QQ22 to 15 here makes the first tick
                        \ of the hyperspace counter longer than subsequent ticks

 TAX                    \ Print the 8-bit number in X (i.e. 15) at text location
 BNE ee3                \ (0, 1), padded to 5 digits, so it appears in the top
                        \ left corner of the screen, and return from the
                        \ subroutine using a tail call (the BNE is effectively a
                        \ JMP as A is never zero)

\ ******************************************************************************
\
\       Name: Ghy
\       Type: Subroutine
\   Category: Flight
\    Summary: Perform a galactic hyperspace jump
\  Deep dive: Twisting the system seeds
\             Galaxy and system seeds
\
\ ------------------------------------------------------------------------------
\
\ Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
\ being pressed.
\
\ This routine also updates the galaxy seeds to point to the next galaxy. Using
\ a galactic hyperdrive rotates each seed byte to the left, rolling each byte
\ left within itself like this:
\
\   01234567 -> 12345670
\
\ to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
\ roll round to those of the first galaxy again.
\
\ We always arrive in a new galaxy at galactic coordinates (96, 96), and then
\ find the nearest system and set that as our location.
\
\ Other entry points:
\
\   zZ+1                Contains an RTS
\
\ ******************************************************************************

.Ghy

 LDX GHYP               \ Fetch GHYP, which tells us whether we own a galactic
 BEQ zZ+1               \ hyperdrive, and if it is zero, which means we don't,
                        \ return from the subroutine (as zZ+1 contains an RTS)

 INC new_hold           \ Free up one tonne of space in the hold, as we have
                        \ just used up the galactic hyperdrive

 INX                    \ We own a galactic hyperdrive, so X is &FF, so this
                        \ instruction sets X = 0

 STX GHYP               \ The galactic hyperdrive is a one-use item, so set GHYP
                        \ to 0 so we no longer have one fitted

 STX FIST               \ Changing galaxy also clears our criminal record, so
                        \ set our legal status in FIST to 0 ("clean")

 STX cmdr_cour          \ Reset the special cargo delivery mission timer in
 STX cmdr_cour+1        \ cmdr_cour(1 0)

 JSR wW                 \ Call wW to start the hyperspace countdown

 LDX #5                 \ To move galaxy, we rotate the galaxy's seeds left, so
                        \ set a counter in X for the 6 seed bytes

 INC GCNT               \ Increment the current galaxy number in GCNT

 LDA GCNT               \ Set GCNT = GCNT mod 8, so we jump from galaxy 7 back
 AND #7                 \ to galaxy 0 (shown in-game as going from galaxy 8 back
 STA GCNT               \ to the starting point in galaxy 1)

.G1

 LDA QQ21,X             \ Load the X-th seed byte into A

 ASL A                  \ Set the C flag to bit 7 of the seed

 ROL QQ21,X             \ Rotate the seed in memory, which will add bit 7 back
                        \ in as bit 0, so this rolls the seed around on itself

 DEX                    \ Decrement the counter

 BPL G1                 \ Loop back for the next seed byte, until we have
                        \ rotated them all

.zZ

 LDA #96                \ Set (QQ9, QQ10) to (96, 96), which is where we always
 STA QQ9                \ arrive in a new galaxy (the selected system will be
 STA QQ10               \ set to the nearest actual system later on)

 JSR TT110              \ Call TT110 to show the front space view

 JSR TT111              \ Call TT111 to set the current system to the nearest
                        \ system to (QQ9, QQ10), and put the seeds of the
                        \ nearest system into QQ15 to QQ15+5
                        \
                        \ This call fixes a bug in the cassette version, where
                        \ the galactic hyperdrive will take us to coordinates
                        \ (96, 96) in the new galaxy, even if there isn't
                        \ actually a system there, so if we jump when we are
                        \ low on fuel, it is possible to get stuck in the
                        \ middle of nowhere when changing galaxy
                        \
                        \ This call sets the current system correctly, so we
                        \ always arrive at the nearest system to (96, 96)

 LDX #0                 \ Set the distance to the selected system in QQ8(1 0)
 STX QQ8                \ to 0
 STX QQ8+1

 LDA #116               \ Print recursive token 116 (GALACTIC HYPERSPACE ")
 JSR MESS               \ as an in-flight message

                        \ Fall through into jmp to set the system to the
                        \ current system and return from the subroutine there

 JMP jmp                \ Set the current system to the selected system and
                        \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: ee3
\       Type: Subroutine
\   Category: Text
\    Summary: Print the hyperspace countdown in the top-left of the screen
\
\ ------------------------------------------------------------------------------
\
\ Print the 8-bit number in X at text location (1, 1). Print the number to
\ 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
\ numbers < 10000 are right-aligned), with no decimal point.
\
\ Arguments:
\
\   X                   The number to print
\
\ ******************************************************************************

.ee3

 LDY #1                 \ Move the text cursor to column 1
 STY XC

 STY YC                 \ Move the text cursor to row 1

 DEY                    \ Decrement Y to 0 for the high byte in pr6

 JMP pr6                \ Jump to pr6 to print X to 5 digits, as the high byte
                        \ in Y is 0, and return from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: TT147
\       Type: Subroutine
\   Category: Text
\    Summary: Print an error when a system is out of hyperspace range
\
\ ------------------------------------------------------------------------------
\
\ Print "RANGE?" for when the hyperspace distance is too far
\
\ ******************************************************************************

.TT147

 LDA #202               \ Print token 42 ("RANGE") followed by a question mark
 JMP prq                \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: hyp1_FLIGHT
\       Type: Subroutine
\   Category: Universe
\    Summary: Process a jump to the system closest to (QQ9, QQ10) (flight
\             version)
\
\ ******************************************************************************

.hyp1_FLIGHT

 JSR jmp                \ Set the current system to the selected system

 LDX #5                 \ We now want to copy the seeds for the selected system
                        \ in QQ15 into QQ2, where we store the seeds for the
                        \ current system, so set up a counter in X for copying
                        \ 6 bytes (for three 16-bit seeds)

.TT112_FLIGHT

 LDA QQ15,X             \ Copy the X-th byte in QQ15 to the X-th byte in QQ2, to
 STA QQ2,X              \ update the selected system to the new one. Note that
                        \ this approach has a minor bug associated with it: if
                        \ your hyperspace counter hits 0 just as you're docking,
                        \ then you will magically appear in the station in your
                        \ hyperspace destination, without having to go to the
                        \ effort of actually flying there. This bug was fixed in
                        \ later versions by saving the destination seeds in a
                        \ separate location called safehouse, and using those
                        \ instead... but that isn't the case in this version

 DEX                    \ Decrement the counter

 BPL TT112_FLIGHT       \ Loop back to TT112_FLIGHT if we still have more bytes
                        \ to copy

 INX                    \ Set X = 0 (as we ended the above loop with X = &FF)

 STX EV                 \ Set EV, the extra vessels spawning counter, to 0, as
                        \ we are entering a new system with no extra vessels
                        \ spawned

 LDA QQ3                \ Set the current system's economy in QQ28 to the
 STA QQ28               \ selected system's economy from QQ3

 LDA QQ5                \ Set the current system's tech level in tek to the
 STA tek                \ selected system's economy from QQ5

 LDA QQ4                \ Set the current system's government in gov to the
 STA gov                \ selected system's government from QQ4

 JSR DORND              \ Set A and X to random numbers

 STA QQ26               \ Set QQ26 to the random byte that's used in the market
                        \ calculations

 JMP GVL                \ Jump to GVL to calculate the availability of market
                        \ items, returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: GTHG
\       Type: Subroutine
\   Category: Universe
\    Summary: Spawn a Thargoid ship and a Thargon companion
\  Deep dive: Fixing ship positions
\
\ ******************************************************************************

.GTHG

 JSR Ze                 \ Call Ze to initialise INWK
                        \
                        \ Note that because Ze uses the value of X returned by
                        \ DORND, and X contains the value of A returned by the
                        \ previous call to DORND, this does not set the new ship
                        \ to a totally random location. See the deep dive on
                        \ "Fixing ship positions" for details

 LDA #%11111111         \ Set the AI flag in byte #32 so that the ship has AI,
 STA INWK+32            \ is extremely and aggressively hostile, and has E.C.M.

 LDA #THG               \ Call NWSHP to add a new Thargoid ship to our local
 JSR NWSHP              \ bubble of universe

 LDA #TGL               \ Call NWSHP to add a new Thargon ship to our local
 JMP NWSHP              \ bubble of universe, and return from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\       Name: MJP
\       Type: Subroutine
\   Category: Flight
\    Summary: Process a mis-jump into witchspace
\
\ ------------------------------------------------------------------------------
\
\ Process a mis-jump into witchspace (which happens very rarely). Witchspace has
\ a strange, almost dust-free aspect to it, and it is populated by hostile
\ Thargoids. Using our escape pod will be fatal, and our position on the
\ galactic chart is in-between systems. It is a scary place...
\
\ There is a 0.78% chance that this routine is called from TT18 instead of doing
\ a normal hyperspace, or we can manually trigger a mis-jump by holding down
\ CTRL after first enabling the "author display" configuration option ("X") when
\ paused.
\
\ Other entry points:
\
\   RTS111              Contains an RTS
\
\ ******************************************************************************

.MJP

 LDA #3                 \ Call SHIPinA populate the ship blueprints table but
 JSR SHIPinA            \ without setting the compass to show the planet (the
                        \ LDA here has no effect and is left over from the disc
                        \ version)

 LDA #3                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 3

 JSR LL164              \ Call LL164 to show the hyperspace tunnel and make the
                        \ hyperspace sound for a second time (as we already
                        \ called LL164 in TT18)

 JSR RES2               \ Reset a number of flight variables and workspaces, as
                        \ well as setting Y to &FF

 STY MJ                 \ Set the mis-jump flag in MJ to &FF, to indicate that
                        \ we are now in witchspace

.MJP1

 JSR GTHG               \ Call GTHG to spawn a Thargoid ship and a Thargon
                        \ companion

 LDA #3                 \ Fetch the number of Thargoid ships from MANY+THG, and
 CMP MANY+THG           \ if it is less than or equal to 3, loop back to MJP1 to
 BCS MJP1               \ spawn another one, until we have four Thargoids

 STA NOSTM              \ Set NOSTM (the maximum number of stardust particles)
                        \ to 3, so there are fewer bits of stardust in
                        \ witchspace (normal space has a maximum of 18)

 LDX #0                 \ Initialise the front space view
 JSR LOOK1

 LDA QQ1                \ Fetch the current system's galactic y-coordinate in
 EOR #%00011111         \ QQ1 and flip bits 0-5, so we end up somewhere in the
 STA QQ1                \ vicinity of our original destination, but above or
                        \ below it in the galactic chart

.RTS111

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TT18
\       Type: Subroutine
\   Category: Flight
\    Summary: Try to initiate a jump into hyperspace
\
\ ------------------------------------------------------------------------------
\
\ Try to go through hyperspace. Called from TT102 in the main loop when the
\ hyperspace countdown has finished.
\
\ Other entry points:
\
\   hyper_snap          Perform a hyperspace, but without using up any fuel
\
\ ******************************************************************************

.TT18

 LDA QQ14               \ Subtract the distance to the selected system (in QQ8)
 SEC                    \ from the amount of fuel in our tank (in QQ14) into A
 SBC QQ8

 STA QQ14               \ Store the updated fuel amount in QQ14

.hyper_snap

 LDA QQ11               \ If the current view is not a space view, jump to ee5
 BNE ee5                \ to skip the following

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 0 (space
                        \ view)

 JSR LL164              \ Call LL164 to show the hyperspace tunnel and make the
                        \ hyperspace sound

.ee5

 JSR DORND              \ Set A and X to random numbers

 CMP #253               \ If A >= 253 (0.78% chance) then jump to MJP to trigger
 BCS MJP                \ a mis-jump into witchspace

 JSR hyp1_FLIGHT        \ Jump straight to the system at (QQ9, QQ10)

 JSR RES2               \ Reset a number of flight variables and workspaces

 JSR SOLAR              \ Halve our legal status, update the missile indicators,
                        \ and set up data blocks and slots for the planet and
                        \ sun

 JSR LOMOD              \ Call LOMOD to populate the ship blueprints table
                        \ with a random selection of ships

 LDA QQ11               \ If the current view in QQ11 is not a space view (0) or
 AND #%00111111         \ one of the charts (64 or 128), return from the
 BNE RTS111             \ subroutine (as RTS111 contains an RTS)

 JSR TTX66              \ Otherwise clear the screen and draw a white border

 LDA QQ11               \ If the current view is one of the charts, jump to
 BNE TT114              \ TT114 (from which we jump to the correct routine to
                        \ display the chart)

 INC QQ11               \ This is a space view, so increment QQ11 to 1

                        \ Fall through into TT110 to show the front space view

\ ******************************************************************************
\
\       Name: TT110
\       Type: Subroutine
\   Category: Flight
\    Summary: Launch from a station or show the front space view
\
\ ------------------------------------------------------------------------------
\
\ Launch the ship (if we are docked), or show the front space view (if we are
\ already in space).
\
\ Called when red key f0 is pressed while docked (launch), after we arrive in a
\ new galaxy, or after a hyperspace if the current view is a space view.
\
\ ******************************************************************************

.TT110

 LDX QQ12               \ If we are not docked (QQ12 = 0) then jump to NLUNCH
 BEQ NLUNCH             \ to skip the launch tunnel and setup process

 JSR LAUN               \ Show the space station launch tunnel

 JSR RES2               \ Reset a number of flight variables and workspaces

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 INC INWK+8             \ Increment z_sign ready for the call to SOS, so the
                        \ planet appears at a z_sign of 1 in front of us when
                        \ we launch

 JSR SOS1               \ Call SOS1 to set up the planet's data block and add it
                        \ to FRIN, where it will get put in the first slot as
                        \ it's the first one to be added to our local bubble of
                        \ universe following the call to RES2 above

 LDA #128               \ For the space station, set z_sign to &80, so it's
 STA INWK+8             \ behind us (&80 is negative)

 INC INWK+7             \ And increment z_hi, so it's only just behind us

 JSR NWSPS              \ Add a new space station to our local bubble of
                        \ universe

 LDA #12                \ Set our launch speed in DELTA to 12
 STA DELTA

 JSR BAD                \ Call BAD to work out how much illegal contraband we
                        \ are carrying in our hold (A is up to 40 for a
                        \ standard hold crammed with contraband, up to 70 for
                        \ an extended cargo hold full of narcotics and slaves)

 ORA FIST               \ OR the value in A with our legal status in FIST to
                        \ get a new value that is at least as high as both
                        \ values, to reflect the fact that launching with a
                        \ hold full of contraband can only make matters worse

 STA FIST               \ Update our legal status with the new value

 LDA #255               \ Set the view number in QQ11 to 255
 STA QQ11

 JSR HFS1               \ Call HFS1 to draw 8 concentric rings to remove the
                        \ launch tunnel that we drew above

.NLUNCH

 LDX #0                 \ Set QQ12 to 0 to indicate we are not docked
 STX QQ12

 JMP LOOK1              \ Jump to LOOK1 to switch to the front view (X = 0),
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: TT114
\       Type: Subroutine
\   Category: Charts
\    Summary: Display either the Long-range or Short-range Chart
\
\ ------------------------------------------------------------------------------
\
\ Display either the Long-range or Short-range Chart, depending on the current
\ view setting. Called from TT18 once we know the current view is one of the
\ charts.
\
\ Arguments:
\
\   A                   The current view, loaded from QQ11
\
\ ******************************************************************************

.TT114

 BMI TT115              \ If bit 7 of the current view is set (i.e. the view is
                        \ the Short-range Chart, 128), skip to TT115 below to
                        \ jump to TT23 to display the chart

 JMP TT22               \ Otherwise the current view is the Long-range Chart, so
                        \ jump to TT22 to display it

.TT115

 JMP TT23               \ Jump to TT23 to display the Short-range Chart

\ ******************************************************************************
\
\       Name: write_0346
\       Type: Subroutine
\   Category: Tube
\    Summary: Update the value of LASCT by sending a write_0346 command to the
\             I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The new value of LASCT
\
\ ******************************************************************************

.write_0346

 PHA                    \ Store the new value of LASCT on the stack

 LDA #&97               \ Send command &97 to the I/O processor:
 JSR tube_write         \
                        \   write_0346(value)
                        \
                        \ which will set the I/O processor's copy of LASCT to
                        \ the given value

 PLA                    \ Send the parameter to the I/O processor:
 JMP tube_write         \
                        \   * value = the new value of LASCT that we stored on
                        \             the stack
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: read_0346
\       Type: Subroutine
\   Category: Tube
\    Summary: Get the value of LASCT by sending a read_0346 command to the I/O
\             processor
\
\ ******************************************************************************

.read_0346

 LDA #&98               \ Send command &98 to the I/O processor:
 JSR tube_write         \
                        \   =read_0346()
                        \
                        \ which will ask the I/O processor to send the value of
                        \ its copy of LASCT

 JSR tube_read          \ Set A to the response from the I/O processor, which
                        \ will be the value of LASCT that's stored in the I/O
                        \ processor

 STA LASCT              \ Update LASCT to the value received from the I/O
                        \ processor

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DOEXP
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw an exploding ship
\  Deep dive: Drawing explosion clouds
\             Generating random numbers
\
\ ******************************************************************************

.EX2

 LDA INWK+31            \ Set bits 5 and 7 of the ship's byte #31 to denote that
 ORA #%10100000         \ the ship is exploding and has been killed
 STA INWK+31

 RTS                    \ Return from the subroutine

.DOEXP

 LDA INWK+31            \ If bit 6 of the ship's byte #31 is clear, then the
 AND #%01000000         \ ship is not already exploding so there is no existing
 BEQ P%+5               \ explosion cloud to remove, so skip the following
                        \ instruction

 JSR PTCLS              \ Call PTCLS to remove the existing cloud by drawing it
                        \ again

 LDA INWK+6             \ Set T = z_lo
 STA T

 LDA INWK+7             \ Set A = z_hi, so (A T) = z

 CMP #32                \ If z_hi < 32, skip the next two instructions
 BCC P%+6

 LDA #&FE               \ Set A = 254 and jump to yy (this BNE is effectively a
 BNE yy                 \ JMP, as A is never zero)

 ASL T                  \ Shift (A T) left twice
 ROL A
 ASL T
 ROL A

 SEC                    \ And then shift A left once more, inserting a 1 into
 ROL A                  \ bit 0

                        \ Overall, the above multiplies A by 8 and makes sure it
                        \ is at least 1, to leave a one-byte distance in A. We
                        \ can use this as the distance for our cloud, to ensure
                        \ that the explosion cloud is visible even for ships
                        \ that blow up a long way away

.yy

 STA Q                  \ Store the distance to the explosion in Q

 LDY #1                 \ Fetch byte #1 of the ship line heap, which contains
 LDA (XX19),Y           \ the cloud counter

 ADC #4                 \ Add 4 to the cloud counter, so it ticks onwards every
                        \ we redraw it

 BCS EX2                \ If the addition overflowed, jump up to EX2 to update
                        \ the explosion flags and return from the subroutine

 STA (XX19),Y           \ Store the updated cloud counter in byte #1 of the ship
                        \ line heap

 JSR DVID4              \ Calculate the following:
                        \
                        \   (P R) = 256 * A / Q
                        \         = 256 * cloud counter / distance
                        \
                        \ We are going to use this as our cloud size, so the
                        \ further away the cloud, the smaller it is, and as the
                        \ cloud counter ticks onward, the cloud expands

 LDA P                  \ Set A = P, so we now have:
                        \
                        \   (A R) = 256 * cloud counter / distance

 CMP #&1C               \ If A < 28, skip the next two instructions
 BCC P%+6

 LDA #&FE               \ Set A = 254 and skip the following (this BNE is
 BNE LABEL_1            \ effectively a JMP as A is never zero)

 ASL R                  \ Shift (A R) left three times to multiply by 8
 ROL A
 ASL R
 ROL A
 ASL R
 ROL A

                        \ Overall, the above multiplies (A R) by 8 to leave a
                        \ one-byte cloud size in A, given by the following:
                        \
                        \   A = 8 * cloud counter / distance

.LABEL_1

 DEY                    \ Decrement Y to 0

 STA (XX19),Y           \ Store the cloud size in byte #0 of the ship line heap

 LDA INWK+31            \ Clear bit 6 of the ship's byte #31 to denote that the
 AND #%10111111         \ explosion has not yet been drawn
 STA INWK+31

 AND #%00001000         \ If bit 3 of the ship's byte #31 is clear, then nothing
 BEQ DOEXP-1            \ is being drawn on-screen for this ship anyway, so
                        \ return from the subroutine (as DOEXP-1 contains an
                        \ RTS)

 LDY #2                 \ Otherwise it's time to draw an explosion cloud, so
 LDA (XX19),Y           \ fetch byte #2 of the ship line heap into Y, which we
 TAY                    \ set to the explosion count for this ship (i.e. the
                        \ number of vertices used as origins for explosion
                        \ clouds)
                        \
                        \ The explosion count is stored as 4 * n + 6, where n is
                        \ the number of vertices, so the following loop copies
                        \ the coordinates of the first n vertices from the heap
                        \ at XX3, which is where we stored all the visible
                        \ vertex coordinates in part 8 of the LL9 routine, and
                        \ sticks them in the ship line heap pointed to by XX19,
                        \ starting at byte #7 (so it leaves the first 6 bytes of
                        \ the ship line heap alone)

.EXL1

 LDA XX3-7,Y            \ Copy byte Y-7 from the XX3 heap, into the Y-th byte of
 STA (XX19),Y           \ the ship line heap

 DEY                    \ Decrement the loop counter

 CPY #6                 \ Keep copying vertex coordinates into the ship line
 BNE EXL1               \ heap until Y = 6 (which will copy n vertices, where n
                        \ is the number of vertices we should be exploding)

 LDA INWK+31            \ Set bit 6 of the ship's byte #31 to denote that the
 ORA #%01000000         \ explosion has been drawn (as it's about to be)
 STA INWK+31

.PTCLS

                        \ This part of the routine actually draws the explosion
                        \ cloud

 LDY #0                 \ Fetch byte #0 of the ship line heap, which contains
 LDA (XX19),Y           \ the cloud size we stored above, and store it in Q
 STA Q

 INY                    \ Increment the index in Y to point to byte #1

 LDA (XX19),Y           \ Fetch byte #1 of the ship line heap, which contains
                        \ the cloud counter. We are now going to process this
                        \ into the number of particles in each vertex's cloud

 BPL P%+4               \ If the cloud counter < 128, then we are in the first
                        \ half of the cloud's existence, so skip the next
                        \ instruction

 EOR #&FF               \ Flip the value of A so that in the second half of the
                        \ cloud's existence, A counts down instead of up

 LSR A                  \ Divide A by 8 so that is has a maximum value of 15
 LSR A
 LSR A

 ORA #1                 \ Make sure A is at least 1 and store it in U, to
 STA U                  \ give us the number of particles in the explosion for
                        \ each vertex

 INY                    \ Increment the index in Y to point to byte #2

 LDA (XX19),Y           \ Fetch byte #2 of the ship line heap, which contains
 STA TGT                \ the explosion count for this ship (i.e. the number of
                        \ vertices used as origins for explosion clouds) and
                        \ store it in TGT

 LDA RAND+1             \ Fetch the current random number seed in RAND+1 and
 PHA                    \ store it on the stack, so we can re-randomise the
                        \ seeds when we are done

 LDY #6                 \ Set Y = 6 to point to the byte before the first vertex
                        \ coordinate we stored on the ship line heap above (we
                        \ increment it below so it points to the first vertex)

.EXL5

 LDX #3                 \ We are about to fetch a pair of coordinates from the
                        \ ship line heap, so set a counter in X for 4 bytes

.EXL3

 INY                    \ Increment the index in Y so it points to the next byte
                        \ from the coordinate we are copying

 LDA (XX19),Y           \ Copy the Y-th byte from the ship line heap to the X-th
 STA K3,X               \ byte of K3

 DEX                    \ Decrement the X index

 BPL EXL3               \ Loop back to EXL3 until we have copied all four bytes

                        \ The above loop copies the vertex coordinates from the
                        \ ship line heap to K3, reversing them as we go, so it
                        \ sets the following:
                        \
                        \   K3+3 = x_lo
                        \   K3+2 = x_hi
                        \   K3+1 = y_lo
                        \   K3+0 = y_hi

 STY CNT                \ Set CNT to the index that points to the next vertex on
                        \ the ship line heap

 LDY #2                 \ Set Y = 2, which we will use to point to bytes #3 to
                        \ #6, after incrementing it

                        \ This next loop copies bytes #3 to #6 from the ship
                        \ line heap into the four random number seeds in RAND to
                        \ RAND+3, EOR'ing them with the vertex index so they are
                        \ different for every vertex. This enables us to
                        \ generate random numbers for drawing each vertex that
                        \ are random but repeatable, which we need when we
                        \ redraw the cloud to remove it
                        \
                        \ Note that we haven't actually set the values of bytes
                        \ #3 to #6 in the ship line heap, so we have no idea
                        \ what they are, we just use what's already there. But
                        \ the fact that those bytes are stored for this ship
                        \ means we can repeat the random generation of the
                        \ cloud, which is the important bit

.EXL2

 INY                    \ Increment the index in Y so it points to the next
                        \ random number seed to copy

 LDA (XX19),Y           \ Fetch the Y-th byte from the ship line heap

 EOR CNT                \ EOR with the vertex index, so the seeds are different
                        \ for each vertex

 STA &FFFD,Y            \ Y is going from 3 to 6, so this stores the four bytes
                        \ in memory locations &00, &01, &02 and &03, which are
                        \ the memory locations of RAND through RAND+3

 CPY #6                 \ Loop back to EXL2 until Y = 6, which means we have
 BNE EXL2               \ copied four bytes

 LDY U                  \ Set Y to the number of particles in the explosion for
                        \ each vertex, which we stored in U above. We will now
                        \ use this as a loop counter to iterate through all the
                        \ particles in the explosion

.EXL4

 JSR DORND2             \ Set ZZ to a random number, making sure the C flag
 STA ZZ                 \ doesn't affect the outcome

 LDA K3+1               \ Set (A R) = (y_hi y_lo)
 STA R                  \           = y
 LDA K3

 JSR EXS1               \ Set (A X) = (A R) +/- random * cloud size
                        \           = y +/- random * cloud size

 BNE EX11               \ If A is non-zero, the particle is off-screen as the
                        \ coordinate is bigger than 255), so jump to EX11 to do
                        \ the next particle

 CPX #2*Y-1             \ If X > the y-coordinate of the bottom of the screen,
 BCS EX11               \ the particle is off the bottom of the screen, so jump
                        \ to EX11 to do the next particle

                        \ Otherwise X contains a random y-coordinate within the
                        \ cloud

 STX Y1                 \ Set Y1 = our random y-coordinate within the cloud

 LDA K3+3               \ Set (A R) = (x_hi x_lo)
 STA R
 LDA K3+2

 JSR EXS1               \ Set (A X) = (A R) +/- random * cloud size
                        \           = x +/- random * cloud size

 BNE EX4                \ If A is non-zero, the particle is off-screen as the
                        \ coordinate is bigger than 255), so jump to EX11 to do
                        \ the next particle

                        \ Otherwise X contains a random x-coordinate within the
                        \ cloud

 LDA Y1                 \ Set A = our random y-coordinate within the cloud

 JSR PIXEL              \ Draw a point at screen coordinate (X, A) with the
                        \ point size determined by the distance in ZZ

.EX4

 DEY                    \ Decrement the loop counter for the next particle

 BPL EXL4               \ Loop back to EXL4 until we have done all the particles
                        \ in the cloud

 LDY CNT                \ Set Y to the index that points to the next vertex on
                        \ the ship line heap

 CPY TGT                \ If Y < TGT, which we set to the explosion count for
 BCC EXL5               \ this ship (i.e. the number of vertices used as origins
                        \ for explosion clouds), loop back to EXL5 to do a cloud
                        \ for the next vertex

 PLA                    \ Restore the current random number seed to RAND+1 that
 STA RAND+1             \ we stored at the start of the routine

 LDA K%+6               \ Store the z_lo coordinate for the planet (which will
 STA RAND+3             \ be pretty random) in the RAND+3 seed

 RTS                    \ Return from the subroutine

.EX11

 JSR DORND2             \ Set A and X to random numbers, making sure the C flag
                        \ doesn't affect the outcome

 JMP EX4                \ We just skipped a particle, so jump up to EX4 to do
                        \ the next one

.EXS1

                        \ This routine calculates the following:
                        \
                        \   (A X) = (A R) +/- random * cloud size
                        \
                        \ returning with the flags set for the high byte in A

 STA S                  \ Store A in S so we can use it later

 JSR DORND2             \ Set A and X to random numbers, making sure the C flag
                        \ doesn't affect the outcome

 ROL A                  \ Set A = A * 2

 BCS EX5                \ If bit 7 of A was set (50% chance), jump to EX5

 JSR FMLTU              \ Set A = A * Q / 256
                        \       = random << 1 * projected cloud size / 256

 ADC R                  \ Set (A X) = (S R) + A
 TAX                    \           = (S R) + random * projected cloud size
                        \
                        \ where S contains the argument A, starting with the low
                        \ bytes

 LDA S                  \ And then the high bytes
 ADC #0

 RTS                    \ Return from the subroutine

.EX5

 JSR FMLTU              \ Set T = A * Q / 256
 STA T                  \       = random << 1 * projected cloud size / 256

 LDA R                  \ Set (A X) = (S R) - T
 SBC T                  \
 TAX                    \ where S contains the argument A, starting with the low
                        \ bytes

 LDA S                  \ And then the high bytes
 SBC #0

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SOS1
\       Type: Subroutine
\   Category: Universe
\    Summary: Update the missile indicators, set up the planet data block
\
\ ------------------------------------------------------------------------------
\
\ Update the missile indicators, and set up a data block for the planet, but
\ only setting the pitch and roll counters to 127 (no damping).
\
\ ******************************************************************************

.SOS1

 JSR msblob             \ Reset the dashboard's missile indicators so none of
                        \ them are targeted

 LDA #127               \ Set the pitch and roll counters to 127 (no damping
 STA INWK+29            \ so the planet's rotation doesn't slow down)
 STA INWK+30

 LDA tek                \ Set A = 128 or 130 depending on bit 1 of the system's
 AND #%00000010         \ tech level in tek
 ORA #%10000000

 JMP NWSHP              \ Add a new planet to our local bubble of universe,
                        \ with the planet type defined by A (128 is a planet
                        \ with an equator and meridian, 130 is a planet with
                        \ a crater)

\ ******************************************************************************
\
\       Name: SOLAR
\       Type: Subroutine
\   Category: Universe
\    Summary: Set up various aspects of arriving in a new system
\
\ ------------------------------------------------------------------------------
\
\ Halve our legal status, update the missile indicators, and set up data blocks
\ and slots for the planet and sun.
\
\ ******************************************************************************

.SOLAR

                        \ We now want to extract bits 3-10 of QQ8(1 0) into A,
                        \ so we can subtract this value from our legal status in
                        \ FIST (so the further we travel, the quicker our legal
                        \ status drops back down to clean, as we put more
                        \ distance between us and our crimes - specifically, we
                        \ drop 1.2 FIST points for each light year, as we
                        \ subtract (QQ8 / 8) from FIST, and QQ8 contains the
                        \ distance in light years * 10)

 LDA QQ8                \ Set A to the low byte of the distance to the selected
                        \ system in QQ8(1 0), so (QQ8+1 A) contains the distance

 LDY #3                 \ We're going to extract bits 3-10 by shifting QQ8(1 0)
                        \ right by 3 places, so we start by setting a loop
                        \ counter in Y

.legal_div

 LSR QQ8+1              \ Shift (QQ8+1 A) to the right by one place
 ROR A

 DEY                    \ Decrement the loop counter

 BNE legal_div          \ Loop back until we have shifted right by 3 places, by
                        \ which point A will contain bits 3-10 of QQ8(1 0)

                        \ We now subtract A from FIST, and subtract 1 more,
                        \ making sure we don't reduce FIST beyond 0, which we do
                        \ by doing the subtraction in reverse and then negating
                        \ the result with one's complement

 SEC                    \ Set A = A - FIST (which we will negate later)
 SBC FIST

 BCC legal_over         \ If the subtraction underflowed, i.e. A < FIST, skip
                        \ the following instruction

 LDA #&FF               \ A > FIST, so we set A = &FF so the EOR flips this to
                        \ 0, so FIST gets set to 0 when we travel far enough to
                        \ clear our name

.legal_over

 EOR #&FF               \ Flip all the bits in A to negate the result, so if the
                        \ subtraction underflowed, i.e. A < FIST, we now have
                        \ A = FIST - A - 1

 STA FIST               \ Update the value of FIST to the new value in A

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace, which
                        \ doesn't affect the C flag

 LDA QQ15+1             \ Fetch s0_hi

 AND #%00000011         \ Extract bits 0-1 (which also help to determine the
                        \ economy), which will be between 0 and 3

 ADC #3                 \ Add 3 + C, to get a result between 3 and 7, clearing
                        \ the C flag in the process

 STA INWK+8             \ Store the result in z_sign in byte #6

 ROR A                  \ Halve A, rotating in the C flag (which is clear) and
 STA INWK+2             \ store in both x_sign and y_sign, moving the planet to
 STA INWK+5             \ the upper right

 JSR SOS1               \ Call SOS1 to set up the planet's data block and add it
                        \ to FRIN, where it will get put in the first slot as
                        \ it's the first one to be added to our local bubble of
                        \ this new system's universe

 LDA QQ15+3             \ Fetch s1_hi, extract bits 0-2, set bits 0 and 7 and
 AND #%00000111         \ store in z_sign, so the sun is behind us at a distance
 ORA #%10000001         \ of 1 to 7
 STA INWK+8

 LDA QQ15+5             \ Fetch s2_hi, extract bits 0-1 and store in x_sign and
 AND #%00000011         \ y_sign, so the sun is either dead centre in our rear
 STA INWK+2             \ laser crosshairs, or off to the top left by a distance
 STA INWK+1             \ of 1 or 2 when we look out the back

 LDA #0                 \ Set the pitch and roll counters to 0 (no rotation)
 STA INWK+29
 STA INWK+30

 LDA #129               \ Set A = 129, the ship type for the sun

 JSR NWSHP              \ Call NWSHP to set up the sun's data block and add it
                        \ to FRIN, where it will get put in the second slot as
                        \ it's the second one to be added to our local bubble
                        \ of this new system's universe

\ ******************************************************************************
\
\       Name: NWSTARS
\       Type: Subroutine
\   Category: Stardust
\    Summary: Initialise the stardust field
\
\ ------------------------------------------------------------------------------
\
\ This routine is called when the space view is initialised in routine LOOK1.
\
\ ******************************************************************************

.NWSTARS

 LDA QQ11               \ If this is not a space view, jump to WPSHPS via
 BNE WPSHPSS            \ WPSHPSS to skip the initialisation of the SX, SY and
                        \ SZ tables

\ ******************************************************************************
\
\       Name: nWq
\       Type: Subroutine
\   Category: Stardust
\    Summary: Create a random cloud of stardust
\
\ ------------------------------------------------------------------------------
\
\ Create a random cloud of stardust containing the correct number of dust
\ particles, i.e. NOSTM of them, which is 3 in witchspace and 18 (#NOST) in
\ normal space. Also clears the scanner and initialises the LSO block.
\
\ This is called by the DEATH routine when it displays our untimely demise.
\
\ ******************************************************************************

.nWq

 LDY NOSTM              \ Set Y to the current number of stardust particles, so
                        \ we can use it as a counter through all the stardust

.SAL4

 JSR DORND              \ Set A and X to random numbers

 ORA #8                 \ Set A so that it's at least 8

 STA SZ,Y               \ Store A in the Y-th particle's z_hi coordinate at
                        \ SZ+Y, so the particle appears in front of us

 STA ZZ                 \ Set ZZ to the particle's z_hi coordinate

 JSR DORND              \ Set A and X to random numbers

 STA SX,Y               \ Store A in the Y-th particle's x_hi coordinate at
                        \ SX+Y, so the particle appears in front of us

 STA X1                 \ Set X1 to the particle's x_hi coordinate

 JSR DORND              \ Set A and X to random numbers

 STA SY,Y               \ Store A in the Y-th particle's y_hi coordinate at
                        \ SY+Y, so the particle appears in front of us

 STA Y1                 \ Set Y1 to the particle's y_hi coordinate

 JSR PIXEL2             \ Draw a stardust particle at (X1,Y1) with distance ZZ

 DEY                    \ Decrement the counter to point to the next particle of
                        \ stardust

 BNE SAL4               \ Loop back to SAL4 until we have randomised all the
                        \ stardust particles

                        \ Fall through into WPSHPS to clear the scanner and
                        \ reset the LSO block

\ ******************************************************************************
\
\       Name: WPSHPSS
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Clear the scanner, reset the ball line and sun line heaps
\
\ ------------------------------------------------------------------------------
\
\ This routine is a duplicate of WPSHPS that is close enough to the NWSTARS
\ routine for it to be called by a branch instruction.
\
\ ******************************************************************************

.WPSHPSS

 JMP WPSHPS             \ Jump to WPSHPS to clear the scanner and reset the ball
                        \ line and sun line heaps

\ ******************************************************************************
\
\       Name: DET1
\       Type: Subroutine
\   Category: Screen mode
\    Summary: Show or hide the dashboard (for when we die) by sending a
\             write_crtc command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of text rows to display on the screen (24
\                       will hide the dashboard, 31 will make it reappear)
\
\ ******************************************************************************

.DET1

 LDA #&95               \ Send command &95 to the I/O processor:
 JSR tube_write         \
                        \   write_crtc(rows)
                        \
                        \ which will update the screen to show the specified
                        \ number of text rows

 TXA                    \ Send the parameter to the I/O processor:
 JMP tube_write         \
                        \   * rows = X
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: SHD
\       Type: Subroutine
\   Category: Flight
\    Summary: Charge a shield and drain some energy from the energy banks
\
\ ------------------------------------------------------------------------------
\
\ Charge up a shield, and if it needs charging, drain some energy from the
\ energy banks.
\
\ Arguments:
\
\   X                   The value of the shield to recharge
\
\ ******************************************************************************

 DEX                    \ Increment the shield value so that it doesn't go past
                        \ a maximum of 255

 RTS                    \ Return from the subroutine

.SHD

 INX                    \ Increment the shield value

 BEQ SHD-2              \ If the shield value is 0 then this means it was 255
                        \ before, which is the maximum value, so jump to SHD-2
                        \ to bring it back down to 258 and return

                        \ Otherwise fall through into DENGY to drain our energy
                        \ to pay for all this shield charging

\ ******************************************************************************
\
\       Name: DENGY
\       Type: Subroutine
\   Category: Flight
\    Summary: Drain some energy from the energy banks
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   Z flag              Set if we have no energy left, clear otherwise
\
\ ******************************************************************************

.DENGY

 DEC ENERGY             \ Decrement the energy banks in ENERGY

 PHP                    \ Save the flags on the stack

 BNE P%+5               \ If the energy levels are not yet zero, skip the
                        \ following instruction

 INC ENERGY             \ The minimum allowed energy level is 1, and we just
                        \ reached 0, so increment ENERGY back to 1

 PLP                    \ Restore the flags from the stack, so we return with
                        \ the Z flag from the DEC instruction above

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SPS2
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (Y X) = A / 10
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following, where A is a sign-magnitude 8-bit integer and the
\ result is a signed 16-bit integer:
\
\   (Y X) = A / 10
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.SPS2

 ASL A                  \ Set X = |A| * 2, and set the C flag to the sign bit of
 TAX                    \ A

 LDA #0                 \ Set Y to have the sign bit from A in bit 7, with the
 ROR A                  \ rest of its bits zeroed, so Y now contains the sign of
 TAY                    \ the original argument

 LDA #20                \ Set Q = 20
 STA Q

 TXA                    \ Copy X into A, so A now contains the argument A * 2

 JSR DVID4              \ Calculate the following:
                        \
                        \   P = A / Q
                        \     = |argument A| * 2 / 20
                        \     = |argument A| / 10

 LDX P                  \ Set X to the result

 TYA                    \ If the sign of the original argument A is negative,
 BMI LL163              \ jump to LL163 to flip the sign of the result

 LDY #0                 \ Set the high byte of the result to 0, as the result is
                        \ positive

 RTS                    \ Return from the subroutine

.LL163

 LDY #&FF               \ The result is negative, so set the high byte to &FF

 TXA                    \ Flip the low byte and add 1 to get the negated low
 EOR #&FF               \ byte, using two's complement
 TAX
 INX

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: COMPAS
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update the compass
\
\ ******************************************************************************

.COMPAS

 JSR DOT                \ Call DOT to redraw (i.e. remove) the current compass
                        \ dot

 LDY #NI%               \ Set Y = NI%, so SPS1 will calculate the vector to the
                        \ second slot in the local bubble, i.e. the space
                        \ station or the sun

 LDA SSPR               \ If we are inside the space station safe zone, jump to
 BNE l_station          \ l_station to skip the following instruction and ensure
                        \ we draw the space station on the compass

 LDY finder             \ We are not inside the space station safe zone, so
                        \ set the value of Y to finder, which determines whether
                        \ the compass is configured to show the sun or the
                        \ planet

.l_station

 JSR SPS1               \ We now draw the planet or sun/station on the compass,
                        \ so first call SPS1 to calculate the vector to the
                        \ planet/sun/station and store it in XX15

                        \ Fall through into SP2 to draw XX15 on the compass

\ ******************************************************************************
\
\       Name: SP2
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Draw a dot on the compass, given the planet/station vector
\
\ ------------------------------------------------------------------------------
\
\ Draw a dot on the compass to represent the planet or station, whose normalised
\ vector is in XX15.
\
\   XX15 to XX15+2      The normalised vector to the planet or space station,
\                       stored as x in XX15, y in XX15+1 and z in XX15+2
\
\ ******************************************************************************

.SP2

 LDA XX15               \ Set A to the x-coordinate of the planet or station to
                        \ show on the compass, which will be in the range -96 to
                        \ +96 as the vector has been normalised

 JSR SPS2               \ Set (Y X) = A / 10, so X will be from -9 to +9, which
                        \ is the x-offset from the centre of the compass of the
                        \ dot we want to draw. Returns with the C flag clear

 TXA                    \ Set COMX = 195 + X, as 186 is the pixel x-coordinate
 ADC #195               \ of the leftmost dot possible on the compass, and X can
 STA COMX               \ be -9, which would be 195 - 9 = 186. This also means
                        \ that the highest value for COMX is 195 + 9 = 204,
                        \ which is the pixel x-coordinate of the rightmost dot
                        \ in the compass... but the compass dot is actually two
                        \ pixels wide, so the compass dot can overlap the right
                        \ edge of the compass, but not the left edge

 LDA XX15+1             \ Set A to the y-coordinate of the planet or station to
                        \ show on the compass, which will be in the range -96 to
                        \ +96 as the vector has been normalised

 JSR SPS2               \ Set (Y X) = A / 10, so X will be from -9 to +9, which
                        \ is the x-offset from the centre of the compass of the
                        \ dot we want to draw. Returns with the C flag clear

 STX T                  \ Set COMY = 204 - X, as 203 is the pixel y-coordinate
 LDA #204               \ of the centre of the compass, the C flag is clear,
 SBC T                  \ and the y-axis needs to be flipped around (because
 STA COMY               \ when the planet or station is above us, and the
                        \ vector is therefore positive, we want to show the dot
                        \ higher up on the compass, which has a smaller pixel
                        \ y-coordinate). So this calculation does this:
                        \
                        \   COMY = 204 - X - (1 - 0) = 203 - X

 LDA #&F0               \ Set A to a 4-pixel mode 5 byte row in colour 2
                        \ (yellow/white), the colour for when the planet or
                        \ station in the compass is in front of us

 LDX XX15+2             \ If the z-coordinate of the XX15 vector is positive,
 BPL P%+4               \ skip the following instruction

 LDA #&FF               \ The z-coordinate of XX15 is negative, so the planet or
                        \ station is behind us and the compass dot should be in
                        \ green/cyan, so set A to a 4-pixel mode 5 byte row in
                        \ colour 3

 STA COMC               \ Store the compass colour in COMC

                        \ Fall through into DOT to draw the dot on the compass

\ ******************************************************************************
\
\       Name: DOT
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Draw a dash on the compass
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   COMX                The screen pixel x-coordinate of the dash
\
\   COMY                The screen pixel y-coordinate of the dash
\
\   COMC                The colour and thickness of the dash:
\
\                         * &F0 = a double-height dash in yellow/white, for when
\                           the object in the compass is in front of us
\
\                         * &FF = a single-height dash in green/cyan, for when
\                           the object in the compass is behind us
\
\ ******************************************************************************

.DOT

 LDA COMY               \ Set Y1 = COMY, the y-coordinate of the dash
 STA Y1

 LDA COMX               \ Set X1 = COMX, the x-coordinate of the dash
 STA X1

 LDA COMC               \ Set COL = COMC, the mode 5 colour byte for the dash
 STA COL

 CMP #&F0               \ If COL is &F0 then the planet/station is in front of
 BNE CPIX2              \ us and we want to draw a double-height dash, so if it
                        \ isn't &F0 jump to CPIX2 to draw a single-height dash

                        \ Otherwise fall through into CPIX4 to draw a double-
                        \ height dash

\ ******************************************************************************
\
\       Name: CPIX4
\       Type: Subroutine
\   Category: Drawing pixels
\    Summary: Draw a double-height dot on the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Draw a double-height mode 5 dot (2 pixels high, 2 pixels wide).
\
\ Arguments:
\
\   X1                  The screen pixel x-coordinate of the bottom-left corner
\                       of the dot
\
\   Y1                  The screen pixel y-coordinate of the bottom-left corner
\                       of the dot
\
\   COL                 The colour of the dot as a mode 5 character row byte
\
\ ******************************************************************************

.CPIX4

 JSR CPIX2              \ Call CPIX2 to draw a single-height dash at (X1, Y1)

 DEC Y1                 \ Decrement Y1

                        \ Fall through into CPIX2 to draw a second single-height
                        \ dash on the pixel row above the first one, to create a
                        \ double-height dot

\ ******************************************************************************
\
\       Name: CPIX2
\       Type: Subroutine
\   Category: Drawing pixels
\    Summary: Draw a single-height dash on the dashboard by sending a draw_blob
\             command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X1                  The screen pixel x-coordinate of the dash
\
\   Y1                  The screen pixel y-coordinate of the dash
\
\   COL                 The colour of the dash as a mode 5 character row byte
\
\ ******************************************************************************

.CPIX2

 LDA #&90               \ Send command &90 to the I/O processor:
 JSR tube_write         \
                        \   draw_blob(x, y, colour)
                        \
                        \ which will draw a dash of the specified colour and
                        \ position on the dashboard

 LDA X1                 \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * x = X1

 LDA Y1                 \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * y = Y1

 LDA COL                \ Send the third parameter to the I/O processor:
 JMP tube_write         \
                        \   * colour = COL
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: n_oops
\       Type: Subroutine
\   Category: Flight
\    Summary: Take some damage, taking our ship's shields into consideration
\
\ ------------------------------------------------------------------------------
\
\ We just took some damage, so calculate whether the amount of damage will be
\ sucked up by the shields, and if not, apply that damage to our ship.
\
\ Arguments:
\
\   A                   The amount of damage to take
\
\ ******************************************************************************

.n_oops

 SEC                    \ Reduce the amount of damage in A by the level of our
 SBC new_shields        \ shields in new_shields

 BCC n_shok             \ If the amount of damage is less than the level of our
                        \ shields, then return from the subroutine without
                        \ taking any damage (as b_shok contains an RTS)

                        \ The amount of damage is greater than our shield level,
                        \ so we need to take some damage. The amount of damage
                        \ has already been reduced by our shield level (as they
                        \ absorb the amount of damage in new_shields), so fall
                        \ into OOPS to take the remaining amount of damage

\ ******************************************************************************
\
\       Name: OOPS
\       Type: Subroutine
\   Category: Flight
\    Summary: Take some damage
\
\ ------------------------------------------------------------------------------
\
\ We just took some damage, so reduce the shields if we have any, or reduce the
\ energy levels and potentially take some damage to the cargo if we don't.
\
\ Arguments:
\
\   A                   The amount of damage to take
\
\   INF                 The address of the ship block for the ship that attacked
\                       us, or the ship that we just ran into
\
\ Other entry points:
\
\   n_shok              Contains an RTS
\
\ ******************************************************************************

.OOPS

 STA T                  \ Store the amount of damage in T

 LDX #0                 \ Fetch byte #8 (z_sign) for the ship attacking us, and
 LDY #8                 \ set X = 0
 LDA (INF),Y

 BMI OO1                \ If A is negative, then we got hit in the rear, so jump
                        \ to OO1 to process damage to the aft shield

 LDA FSH                \ Otherwise the forward shield was damaged, so fetch the
 SBC T                  \ shield strength from FSH and subtract the damage in T

 BCC OO2                \ If the C flag is clear then this amount of damage was
                        \ too much for the shields, so jump to OO2 to set the
                        \ shield level to 0 and start taking damage directly
                        \ from the energy banks

 STA FSH                \ Store the new value of the forward shield in FSH

.n_shok

 RTS                    \ Return from the subroutine

.OO2

 STX FSH                \ Set the forward shield to 0

 BCC OO3                \ Jump to OO3 to start taking damage directly from the
                        \ energy banks (this BCC is effectively a JMP as the C
                        \ flag is clear, as we jumped to OO2 with a BCC)

.OO1

 LDA ASH                \ The aft shield was damaged, so fetch the shield
 SBC T                  \ strength from ASH and subtract the damage in T

 BCC OO5                \ If the C flag is clear then this amount of damage was
                        \ too much for the shields, so jump to OO5 to set the
                        \ shield level to 0 and start taking damage directly
                        \ from the energy banks

 STA ASH                \ Store the new value of the aft shield in ASH

 RTS                    \ Return from the subroutine

.OO5

 STX ASH                \ Set the aft shield to 0

.OO3

 ADC ENERGY             \ A is negative and contains the amount by which the
 STA ENERGY             \ damage overwhelmed the shields, so this drains the
                        \ energy banks by that amount (and because the energy
                        \ banks are shown over four indicators rather than one,
                        \ but with the same value range of 0-255, energy will
                        \ appear to drain away four times faster than the
                        \ shields did)

 BEQ P%+4               \ If we have just run out of energy, skip the next
                        \ instruction to jump straight to our death

 BCS P%+5               \ If the C flag is set, then subtracting the damage from
                        \ the energy banks didn't underflow, so we had enough
                        \ energy to survive, and we can skip the next
                        \ instruction to make a sound and take some damage

 JMP DEATH              \ Otherwise our energy levels are either 0 or negative,
                        \ and in either case that means we jump to our DEATH,
                        \ returning from the subroutine using a tail call

 JSR EXNO3              \ We didn't die, so call EXNO3 to make the sound of a
                        \ collision

 JMP OUCH               \ And jump to OUCH to take damage and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: SPS3
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Copy a space coordinate from the K% block into K3
\
\ ------------------------------------------------------------------------------
\
\ Copy one of the space coordinates of the planet, sun or space station into the
\ corresponding location in the temporary variable K3. The high byte and
\ absolute value of the sign byte are copied into the first two K3 bytes, and
\ the sign of the sign byte is copied into the highest K3 byte.
\
\ The comments below are written for copying the planet's x-coordinate into
\ K3(2 1 0).
\
\ Arguments:
\
\   X                   Determines where to copy the coordinate to:
\
\                         * X = 0 copies the coordinate into K3(2 1 0)
\
\                         * X = 3 copies the coordinate into K3(5 4 3)
\
\                         * X = 6 copies the coordinate into K3(8 7 6)
\
\   Y                   Determines which coordinate to copy:
\
\                         * Y = 0 copies (x_sign, x_hi) of planet
\
\                         * Y = 3 copies (y_sign, y_hi) of planet
\
\                         * Y = 6 copies (z_sign, z_hi) of planet
\
\                         * Y = NI% + 0 copies (x_sign, x_hi) of sun/station
\
\                         * Y = NI% + 3 copies (y_sign, y_hi) of sun/station
\
\                         * Y = NI% + 6 copies (z_sign, z_hi) of sun/station
\
\ Returns:
\
\   X                   X is incremented by 3 to point to the next coordinate
\
\   Y                   Y is incremented by 3 to point to the next coordinate
\
\ ******************************************************************************

.SPS3

 LDA K%+1,Y             \ Copy x_hi into K3+X
 STA K3,X

 LDA K%+2,Y             \ Set A = x_sign and store it on the stack
 PHA

 AND #%01111111         \ Set K3+1 = |x_sign|
 STA K3+1,X

 PLA                    \ Set K3+2 = the sign of x_sign
 AND #%10000000
 STA K3+2,X

 INY                    \ Increment the value of Y by 3 so the next call to SPS3
 INY                    \ will copy the next coordinate (i.e. x then y then z)
 INY

 INX                    \ Increment the value of X by 3 so the next call to SPS3
 INX                    \ will store the coordinate in the next 24-bit K3 number
 INX

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UNIV
\       Type: Variable
\   Category: Universe
\    Summary: Table of pointers to the local universe's ship data blocks
\  Deep dive: The local bubble of universe
\
\ ------------------------------------------------------------------------------
\
\ See the deep dive on "Ship data blocks" for details on ship data blocks, and
\ the deep dive on "The local bubble of universe" for details of how Elite
\ stores the local universe in K%, FRIN and UNIV.
\
\ ******************************************************************************

.UNIV

 FOR I%, 0, NOSH

  EQUW K% + I% * NI%    \ Address of block no. I%, of size NI%, in workspace K%

 NEXT

\ ******************************************************************************
\
\       Name: GINF
\       Type: Subroutine
\   Category: Universe
\    Summary: Fetch the address of a ship's data block into INF
\
\ ------------------------------------------------------------------------------
\
\ Get the address of the data block for ship slot X and store it in INF. This
\ address is fetched from the UNIV table, which stores the addresses of the 13
\ ship data blocks in workspace K%.
\
\ Arguments:
\
\   X                   The ship slot number for which we want the data block
\                       address
\
\ ******************************************************************************

.GINF

 TXA                    \ Set Y = X * 2
 ASL A
 TAY

 LDA UNIV,Y             \ Get the high byte of the address of the X-th ship
 STA INF                \ from UNIV and store it in INF

 LDA UNIV+1,Y           \ Get the low byte of the address of the X-th ship
 STA INF+1              \ from UNIV and store it in INF

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: NWSPS
\       Type: Subroutine
\   Category: Universe
\    Summary: Add a new space station to our local bubble of universe
\
\ ******************************************************************************

.NWSPS

 JSR SPBLB              \ Light up the space station bulb on the dashboard

 LDX #%10000001         \ Set the AI flag in byte #32 to %10000001 (hostile,
 STX INWK+32            \ no AI, has an E.C.M.)

 LDX #255               \ Set roll counter to 255 (maximum roll with no
 STX INWK+29            \ damping)

 INX                    \ Set pitch counter to 0 (no pitch, roll only)
 STX INWK+30

 STX FRIN+1             \ Set the second slot in the FRIN table to 0, so when we
                        \ fall through into NWSHP below, the new station that
                        \ gets created will go into slot FRIN+1, as this will be
                        \ the first empty slot that the routine finds

 STX INWK+33            \ As part of the setup, we want to point INWK(34 33) to
                        \ LSO, the line heap for the space station. LSO is at
                        \ &0E00, so this sets the low byte at byte #33 to 0 (we
                        \ set the high byte below)

 LDA FIST               \ If bit 7 of FIST is clear, i.e. FIST < 128, then jump
 BPL n_enemy            \ to n_enemy with X = 0 to skip the following
                        \ instruction and set the NEWB flags to 0 (so the
                        \ station is not hostile)

 LDX #%00000100         \ Bit 7 of FIST is set, i.e. FIST >= 128 (so our
                        \ "fugitive/innocent status" is very bad!), so set bit
                        \ #3 of X so we the following sets the NEWB flags to
                        \ make the station hostile

.n_enemy

 STX NEWB               \ Set the station's NEWB flag with the value in X, so it
                        \ be hostile if FIST > 127, or friendly otherwise

 LDX #10                \ Call NwS1 to flip the sign of nosev_x_hi (byte #10)
 JSR NwS1

 JSR NwS1               \ And again to flip the sign of nosev_y_hi (byte #12)

                        \ NwS1 increments X by 2 for each call, so at this point
                        \ the value of X is 10 + 2 + 2 = 14 = &E, which we can
                        \ use to set the correct INWK+34 value in the following

 STX INWK+34            \ As part of the setup, we want to point INWK(34 33) to
                        \ LSO, the line heap for the space station. LSO is at
                        \ &0E00, so this sets the high byte at byte #34 to &0E
                        \ (we already set the low byte above)

 JSR NwS1               \ And again to flip the sign of nosev_z_hi (byte #14)

 LDA #SST               \ Set A to the space station type, and fall through
                        \ into NWSHP to finish adding the space station to the
                        \ universe

\ ******************************************************************************
\
\       Name: NWSHP
\       Type: Subroutine
\   Category: Universe
\    Summary: Add a new ship to our local bubble of universe
\
\ ------------------------------------------------------------------------------
\
\ This creates a new block of ship data in the K% workspace, allocates a new
\ block in the ship line heap at WP, adds the new ship's type into the first
\ empty slot in FRIN, and adds a pointer to the ship data into UNIV. If there
\ isn't enough free memory for the new ship, it isn't added.
\
\ Arguments:
\
\   A                   The type of the ship to add (see variable XX21 for a
\                       list of ship types)
\
\ Returns:
\
\   C flag              Set if the ship was successfully added, clear if it
\                       wasn't (as there wasn't enough free memory)
\
\   INF                 Points to the new ship's data block in K%
\
\ ******************************************************************************

.NWSHP

 STA T                  \ Store the ship type in location T

 LDX #0                 \ Before we can add a new ship, we need to check
                        \ whether we have an empty slot we can put it in. To do
                        \ this, we need to loop through all the slots to look
                        \ for an empty one, so set a counter in X that starts
                        \ from the first slot at 0. When ships are killed, then
                        \ the slots are shuffled down by the KILLSHP routine, so
                        \ the first empty slot will always come after the last
                        \ filled slot. This allows us to tack the new ship's
                        \ data block and ship line heap onto the end of the
                        \ existing ship data and heap, as shown in the memory
                        \ map below

.NWL1

 LDA FRIN,X             \ Load the ship type for the X-th slot

 BEQ NW1                \ If it is zero, then this slot is empty and we can use
                        \ it for our new ship, so jump down to NW1

 INX                    \ Otherwise increment X to point to the next slot

 CPX #NOSH              \ If we haven't reached the last slot yet, loop back up
 BCC NWL1               \ to NWL1 to check the next slot (note that this means
                        \ only slots from 0 to #NOSH - 1 are populated by this
                        \ routine, but there is one more slot reserved in FRIN,
                        \ which is used to identify the end of the slot list
                        \ when shuffling the slots down in the KILLSHP routine)

.NW3

 CLC                    \ Otherwise we don't have an empty slot, so we can't
 RTS                    \ add a new ship, so clear the C flag to indicate that
                        \ we have not managed to create the new ship, and return
                        \ from the subroutine

.NW1

                        \ If we get here, then we have found an empty slot at
                        \ index X, so we can go ahead and create our new ship.
                        \ We do that by creating a ship data block at INWK and,
                        \ when we are done, copying the block from INWK into
                        \ the K% workspace (specifically, to INF)

 JSR GINF               \ Get the address of the data block for ship slot X
                        \ (which is in workspace K%) and store it in INF

 LDA T                  \ If the type of ship that we want to create is
 BMI NW2                \ negative, then this indicates a planet or sun, so
                        \ jump down to NW2, as the next section sets up a ship
                        \ data block, which doesn't apply to planets and suns,
                        \ as they don't have things like shields, missiles,
                        \ vertices and edges

                        \ This is a ship, so first we need to set up various
                        \ pointers to the ship blueprint we will need. The
                        \ blueprints for each ship type in Elite are stored
                        \ in a table at location XX21, so refer to the comments
                        \ on that variable for more details on the data we're
                        \ about to access

 ASL A                  \ Set Y = ship type * 2
 TAY

 LDA XX21-1,Y           \ The ship blueprints at XX21 start with a lookup
                        \ table that points to the individual ship blueprints,
                        \ so this fetches the high byte of this particular ship
                        \ type's blueprint

 BEQ NW3                \ If the high byte is 0 then this is not a valid ship
                        \ type, so jump to NW3 to clear the C flag and return
                        \ from the subroutine

 STA XX0+1              \ This is a valid ship type, so store the high byte in
                        \ XX0+1

 LDA XX21-2,Y           \ Fetch the low byte of this particular ship type's
 STA XX0                \ blueprint and store it in XX0, so XX0(1 0) now
                        \ contains the address of this ship's blueprint

 CPY #2*SST             \ If the ship type is a space station (SST), then jump
 BEQ NW6                \ to NW6, skipping the heap space steps below, as the
                        \ space station has its own line heap at LSO (which it
                        \ shares with the sun)

                        \ We now want to allocate space for a heap that we can
                        \ use to store the lines we draw for our new ship (so it
                        \ can easily be erased from the screen again). SLSP
                        \ points to the start of the current heap space, and we
                        \ can extend it downwards with the heap for our new ship
                        \ (as the heap space always ends just before the WP
                        \ workspace)

 LDY #5                 \ Fetch ship blueprint byte #5, which contains the
 LDA (XX0),Y            \ maximum heap size required for plotting the new ship,
 STA T1                 \ and store it in T1

 LDA SLSP               \ Take the 16-bit address in SLSP and subtract T1,
 SEC                    \ storing the 16-bit result in INWK(34 33), so this now
 SBC T1                 \ points to the start of the line heap for our new ship
 STA INWK+33
 LDA SLSP+1
 SBC #0
 STA INWK+34

                        \ We now need to check that there is enough free space
                        \ for both this new line heap and the new data block
                        \ for our ship. In memory, this is the layout of the
                        \ ship data blocks and ship line heaps:
                        \
                        \   +-----------------------------------+   &0F34
                        \   |                                   |
                        \   | WP workspace                      |
                        \   |                                   |
                        \   +-----------------------------------+   &0D40 = WP
                        \   |                                   |
                        \   | Current ship line heap            |
                        \   |                                   |
                        \   +-----------------------------------+   SLSP
                        \   |                                   |
                        \   | Proposed heap for new ship        |
                        \   |                                   |
                        \   +-----------------------------------+   INWK(34 33)
                        \   |                                   |
                        \   .                                   .
                        \   .                                   .
                        \   .                                   .
                        \   .                                   .
                        \   .                                   .
                        \   |                                   |
                        \   +-----------------------------------+   INF + NI%
                        \   |                                   |
                        \   | Proposed data block for new ship  |
                        \   |                                   |
                        \   +-----------------------------------+   INF
                        \   |                                   |
                        \   | Existing ship data blocks         |
                        \   |                                   |
                        \   +-----------------------------------+   &0900 = K%
                        \
                        \ So, to work out if we have enough space, we have to
                        \ make sure there is room between the end of our new
                        \ ship data block at INF + NI%, and the start of the
                        \ proposed heap for our new ship at the address we
                        \ stored in INWK(34 33). Or, to put it another way, we
                        \ and to make sure that:
                        \
                        \   INWK(34 33) > INF + NI%
                        \
                        \ which is the same as saying:
                        \
                        \   INWK+33 - INF > NI%
                        \
                        \ because INWK is in zero page, so INWK+34 = 0

 LDA INWK+33            \ Calculate INWK+33 - INF, again using 16-bit
 SBC INF                \ arithmetic, and put the result in (A Y), so the high
 TAY                    \ byte is in A and the low byte in Y. The subtraction
 LDA INWK+34            \ works because the previous subtraction will never
 SBC INF+1              \ underflow, so we know the C flag is set

 BCC NW3+1              \ If we have an underflow from the subtraction, then
                        \ INF > INWK+33 and we definitely don't have enough
                        \ room for this ship, so jump to NW3+1, which returns
                        \ from the subroutine (with the C flag already cleared)

 BNE NW4                \ If the subtraction of the high bytes in A is not
                        \ zero, and we don't have underflow, then we definitely
                        \ have enough space, so jump to NW4 to continue setting
                        \ up the new ship

 CPY #NI%               \ Otherwise the high bytes are the same in our
 BCC NW3+1              \ subtraction, so now we compare the low byte of the
                        \ result (which is in Y) with NI%. This is the same as
                        \ doing INWK+33 - INF > NI% (see above). If this isn't
                        \ true, the C flag will be clear and we don't have
                        \ enough space, so we jump to NW3+1, which returns
                        \ from the subroutine (with the C flag already cleared)

.NW4

 LDA INWK+33            \ If we get here then we do have enough space for our
 STA SLSP               \ new ship, so store the new bottom of the ship line
 LDA INWK+34            \ heap (i.e. INWK+33) in SLSP, doing both the high and
 STA SLSP+1             \ low bytes

.NW6

 LDY #14                \ Fetch ship blueprint byte #14, which contains the
 LDA (XX0),Y            \ ship's energy, and store it in byte #35
 STA INWK+35

 LDY #19                \ Fetch ship blueprint byte #19, which contains the
 LDA (XX0),Y            \ number of missiles and laser power, and AND with %111
 AND #%00000111         \ to extract the number of missiles before storing in
 STA INWK+31            \ byte #31

 LDA T                  \ Restore the ship type we stored above

.NW2

 STA FRIN,X             \ Store the ship type in the X-th byte of FRIN, so the
                        \ this slot is now shown as occupied in the index table

 TAX                    \ Copy the ship type into X

 BMI NW8                \ If the ship type is negative (planet or sun), then
                        \ jump to NW8 to skip the following instructions

 CPX #JL                \ If JL <= X < JH, i.e. the type of ship we killed in X
 BCC NW7                \ is junk (escape pod, alloy plate, cargo canister,
 CPX #JH                \ asteroid, splinter, Shuttle or Transporter), then keep
 BCS NW7                \ going, otherwise jump to NW7

.gangbang

 INC JUNK               \ We're adding junk, so increase the junk counter

.NW7

 INC MANY,X             \ Increment the total number of ships of type X

.NW8

 LDY T                  \ Restore the ship type we stored above

 LDA E%-1,Y             \ Fetch the E% byte for this ship to get the default
                        \ settings for the ship's NEWB flags

 AND #%01101111         \ Zero bits 4 and 7 (so the new ship is not docking, has
                        \ not been scooped, and has not just docked)

 ORA NEWB               \ Apply the result to the ship's NEWB flags, which sets
 STA NEWB               \ bits 0-3 and 5-6 in NEWB if they are set in the E%
                        \ byte

 LDY #NI%-1             \ The final step is to copy the new ship's data block
                        \ from INWK to INF, so set up a counter for NI% bytes
                        \ in Y

.NWL3

 LDA INWK,Y             \ Load the Y-th byte of INWK and store in the Y-th byte
 STA (INF),Y            \ of the workspace pointed to by INF

 DEY                    \ Decrement the loop counter

 BPL NWL3               \ Loop back for the next byte until we have copied them
                        \ all over

 SEC                    \ We have successfully created our new ship, so set the
                        \ C flag to indicate success

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: NwS1
\       Type: Subroutine
\   Category: Universe
\    Summary: Flip the sign and double an INWK byte
\
\ ------------------------------------------------------------------------------
\
\ Flip the sign of the INWK byte at offset X, and increment X by 2. This is
\ used by the space station creation routine at NWSPS.
\
\ Arguments:
\
\   X                   The offset of the INWK byte to be flipped
\
\ Returns:
\
\   X                   X is incremented by 2
\
\ ******************************************************************************

.NwS1

 LDA INWK,X             \ Load the X-th byte of INWK into A and flip bit 7,
 EOR #%10000000         \ storing the result back in the X-th byte of INWK
 STA INWK,X

 INX                    \ Add 2 to X
 INX

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ABORT
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Disarm missiles and update the dashboard indicators
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The new status of the leftmost missile indicator
\
\ ******************************************************************************

.ABORT

 LDX #&FF               \ Set X to &FF, which is the value of MSTG when we have
                        \ no target lock for our missile

                        \ Fall through into ABORT2 to set the missile lock to
                        \ the value in X, which effectively disarms the missile

\ ******************************************************************************
\
\       Name: ABORT2
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Set/unset the lock target for a missile and update the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Set the lock target for the leftmost missile and update the dashboard.
\
\ Arguments:
\
\   X                   The slot number of the ship to lock our missile onto, or
\                       &FF to remove missile lock
\
\   Y                   The new colour of the missile indicator:
\
\                         * &00 = black (no missile)
\
\                         * &0E = red (armed and locked)
\
\                         * &E0 = yellow/white (armed)
\
\                         * &EE = green/cyan (disarmed)
\
\ ******************************************************************************

.ABORT2

 STX MSTG               \ Store the target of our missile lock in MSTG

 LDX NOMSL              \ Call MSBAR (via MSBARS) to update the leftmost
 DEX                    \ indicator in the dashboard's missile bar, by calling
 JSR MSBARS             \ with X = NOMSL - 1 (as the missile indicators are
                        \ numbered 0-3 in Elite-A rather than the 1-4 in the
                        \ disc version)
                        \
                        \ MSBARS returns with Y = 0

 STY MSAR               \ Set MSAR = 0 to indicate that the leftmost missile
                        \ is no longer seeking a target lock

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ECBLB2
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Start up the E.C.M. (indicator, start countdown and make sound)
\
\ ------------------------------------------------------------------------------
\
\ Light up the E.C.M. indicator bulb on the dashboard, set the E.C.M. countdown
\ timer to 32, and start making the E.C.M. sound.
\
\ ******************************************************************************

.ECBLB2

 LDA #32                \ Set the E.C.M. countdown timer in ECMA to 32
 STA ECMA

 ASL A                  \ Call the NOISE routine with A = 64 to make the sound
 JSR NOISE              \ of the E.C.M. being switched on

                        \ Fall through into ECBLB to light up the E.C.M. bulb

\ ******************************************************************************
\
\       Name: ECBLB
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Light up the E.C.M. indicator bulb ("E") on the dashboard by
\             sending a draw_E command to the I/O processor
\
\ ******************************************************************************

.ECBLB

 LDA #&93               \ Send command &93 to the I/O processor:
 JMP tube_write         \
                        \   draw_E()
                        \
                        \ which will toggle the E.C.M. indicator bulb ("E") on
                        \ the dashboard and return from the subroutine using a
                        \ tail call

\ ******************************************************************************
\
\       Name: SPBLB
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Light up the space station indicator ("S") on the dashboard by
\             sending a draw_S command to the I/O processor
\
\ ******************************************************************************

.SPBLB

 LDA #&92               \ Send command &92 to the I/O processor:
 JMP tube_write         \
                        \   draw_S()
                        \
                        \ which will toggle the space station indicator ("S") on
                        \ the dashboard and return from the subroutine using a
                        \ tail call

\ ******************************************************************************
\
\       Name: MSBARS
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Draw a specific indicator in the dashboard's missile bar
\
\ ------------------------------------------------------------------------------
\
\ This routine wraps the standard MSBAR routine and ensures that X is never
\ greater than 3. This enables ships to support large numbers of missiles, while
\ still only having four indicators on the dashboard.
\
\ Arguments:
\
\   X                   The number of the missile indicator to update (counting
\                       from right to left and starting at 0 rather than 1, so
\                       indicator NOMSL - 1 is the leftmost indicator)
\
\   Y                   The colour of the missile indicator:
\
\                         * &00 = black (no missile)
\
\                         * &0E = red (armed and locked)
\
\                         * &E0 = yellow/white (armed)
\
\                         * &EE = green/cyan (disarmed)
\
\ Returns:
\
\   X                   X is preserved
\
\   Y                   Y is set to 0
\
\ ******************************************************************************

.MSBARS

 CPX #4                 \ If X < 4 then jump to n_mok to skip the following
 BCC n_mok              \ instruction

 LDX #3                 \ Set X = 3 so X is never bigger than 3

.n_mok

 JMP MSBAR              \ Jump to MSBAR to draw the missile indicator

\ ******************************************************************************
\
\       Name: PROJ
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Project the current ship onto the screen
\  Deep dive: Extended screen coordinates
\
\ ------------------------------------------------------------------------------
\
\ Project the current ship's location onto the screen, either returning the
\ screen coordinates of the projection (if it's on-screen), or returning an
\ error via the C flag.
\
\ In this context, "on-screen" means that the point is projected into the
\ following range:
\
\   centre of screen - 1024 < x < centre of screen + 1024
\   centre of screen - 1024 < y < centre of screen + 1024
\
\
\ The projection calculation is:
\
\   K3(1 0) = #X + x / z
\   K4(1 0) = #Y + y / z
\
\ where #X and #Y are the pixel x-coordinate and y-coordinate of the centre of
\ the screen.
\
\ Arguments:
\
\   INWK                The ship data block for the ship to project on-screen
\
\ Returns:
\
\   K3(1 0)             The x-coordinate of the ship's projection on-screen
\
\   K4(1 0)             The y-coordinate of the ship's projection on-screen
\
\   C flag              Set if the ship's projection doesn't fit on the screen,
\                       clear if it does project onto the screen
\
\   A                   Contains K4+1, the high byte of the y-coordinate
\
\ ******************************************************************************

.PROJ

 LDA INWK               \ Set P(1 0) = (x_hi x_lo)
 STA P                  \            = x
 LDA INWK+1
 STA P+1

 LDA INWK+2             \ Set A = x_sign

 JSR PLS6               \ Call PLS6 to calculate:
                        \
                        \   (X K) = (A P) / (z_sign z_hi z_lo)
                        \         = (x_sign x_hi x_lo) / (z_sign z_hi z_lo)
                        \         = x / z

 BCS PL2-1              \ If the C flag is set then the result overflowed and
                        \ the coordinate doesn't fit on the screen, so return
                        \ from the subroutine with the C flag set (as PL2-1
                        \ contains an RTS)

 LDA K                  \ Set K3(1 0) = (X K) + #X
 ADC #X                 \             = #X + x / z
 STA K3                 \
                        \ first doing the low bytes

 TXA                    \ And then the high bytes. #X is the x-coordinate of
 ADC #0                 \ the centre of the space view, so this converts the
 STA K3+1               \ space x-coordinate into a screen x-coordinate

 LDA INWK+3             \ Set P(1 0) = (y_hi y_lo)
 STA P
 LDA INWK+4
 STA P+1

 LDA INWK+5             \ Set A = -y_sign
 EOR #%10000000

 JSR PLS6               \ Call PLS6 to calculate:
                        \
                        \   (X K) = (A P) / (z_sign z_hi z_lo)
                        \         = -(y_sign y_hi y_lo) / (z_sign z_hi z_lo)
                        \         = -y / z

 BCS PL2-1              \ If the C flag is set then the result overflowed and
                        \ the coordinate doesn't fit on the screen, so return
                        \ from the subroutine with the C flag set (as PL2-1
                        \ contains an RTS)

 LDA K                  \ Set K4(1 0) = (X K) + #Y
 ADC #Y                 \             = #Y - y / z
 STA K4                 \
                        \ first doing the low bytes

 TXA                    \ And then the high bytes. #Y is the y-coordinate of
 ADC #0                 \ the centre of the space view, so this converts the
 STA K4+1               \ space x-coordinate into a screen y-coordinate

 CLC                    \ Clear the C flag to indicate success

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PL2
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Remove the planet or sun from the screen
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   PL2-1               Contains an RTS
\
\ ******************************************************************************

.PL2

 LDA TYPE               \ Shift bit 0 of the planet/sun's type into the C flag
 LSR A

 BCS P%+5               \ If the planet/sun's type has bit 0 clear, then it's
                        \ either 128 or 130, which is a planet; meanwhile, the
                        \ sun has type 129, which has bit 0 set. So if this is
                        \ the sun, skip the following instruction

 JMP WPLS2              \ This is the planet, so jump to WPLS2 to remove it from
                        \ screen, returning from the subroutine using a tail
                        \ call

 JMP WPLS               \ This is the sun, so jump to WPLS to remove it from
                        \ screen, returning from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: PLANET
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Draw the planet or sun
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   INWK                The planet or sun's ship data block
\
\ ******************************************************************************

.PLANET

 LDA INWK+8             \ Set A = z_sign (the highest byte in the planet/sun's
                        \ coordinates)

 BMI PL2                \ If A is negative then the planet/sun is behind us, so
                        \ jump to PL2 to remove it from the screen, returning
                        \ from the subroutine using a tail call

 CMP #48                \ If A >= 48 then the planet/sun is too far away to be
 BCS PL2                \ seen, so jump to PL2 to remove it from the screen,
                        \ returning from the subroutine using a tail call

 ORA INWK+7             \ Set A to 0 if both z_sign and z_hi are 0

 BEQ PL2                \ If both z_sign and z_hi are 0, then the planet/sun is
                        \ too close to be shown, so jump to PL2 to remove it
                        \ from the screen, returning from the subroutine using a
                        \ tail call

 JSR PROJ               \ Project the planet/sun onto the screen, returning the
                        \ centre's coordinates in K3(1 0) and K4(1 0)

 BCS PL2                \ If the C flag is set by PROJ then the planet/sun is
                        \ not visible on-screen, so jump to PL2 to remove it
                        \ from the screen, returning from the subroutine using
                        \ a tail call

 LDA #96                \ Set (A P+1 P) = (0 96 0) = 24576
 STA P+1                \
 LDA #0                 \ This represents the planet/sun's radius at a distance
 STA P                  \ of z = 1

 JSR DVID3B2            \ Call DVID3B2 to calculate:
                        \
                        \   K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
                        \              = (0 96 0) / z
                        \              = 24576 / z
                        \
                        \ so K now contains the planet/sun's radius, reduced by
                        \ the actual distance to the planet/sun. We know that
                        \ K+3 and K+2 will be 0, as the number we are dividing,
                        \ (0 96 0), fits into the two bottom bytes, so the
                        \ result is actually in K(1 0)

 LDA K+1                \ If the high byte of the reduced radius is zero, jump
 BEQ PL82               \ to PL82, as K contains the radius on its own

 LDA #248               \ Otherwise set K = 248, to round up the radius in
 STA K                  \ K(1 0) to the nearest integer (if we consider the low
                        \ byte to be the fractional part)

.PL82

 LDA TYPE               \ If the planet/sun's type has bit 0 clear, then it's
 LSR A                  \ either 128 or 130, which is a planet (the sun has type
 BCC PL9                \ 129, which has bit 0 set). So jump to PL9 to draw the
                        \ planet with radius K, returning from the subroutine
                        \ using a tail call

 JMP SUN                \ Otherwise jump to SUN to draw the sun with radius K,
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PL9 (Part 1 of 3)
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Draw the planet, with either an equator and meridian, or a crater
\
\ ------------------------------------------------------------------------------
\
\ Draw the planet with radius K at pixel coordinate (K3, K4), and with either an
\ equator and meridian, or a crater.
\
\ Arguments:
\
\   K(1 0)              The planet's radius
\
\   K3(1 0)             Pixel x-coordinate of the centre of the planet
\
\   K4(1 0)             Pixel y-coordinate of the centre of the planet
\
\   INWK                The planet's ship data block
\
\ ******************************************************************************

.PL9

 JSR WPLS2              \ Call WPLS2 to remove the planet from the screen

 JSR CIRCLE             \ Call CIRCLE to draw the planet's new circle

 BCS PL20               \ If the call to CIRCLE returned with the C flag set,
                        \ then the circle does not fit on-screen, so jump to
                        \ PL20 to return from the subroutine

 LDA K+1                \ If K+1 is zero, jump to PL25 as K(1 0) < 256, so the
 BEQ PL25               \ planet fits on the screen and we can draw meridians or
                        \ craters

.PL20

 RTS                    \ The planet doesn't fit on-screen, so return from the
                        \ subroutine

.PL25

 LDA TYPE               \ If the planet type is 128 then it has an equator and
 CMP #128               \ a meridian, so this jumps to PL26 if this is not a
 BNE PL26               \ planet with an equator - in other words, if it is a
                        \ planet with a crater

                        \ Otherwise this is a planet with an equator and
                        \ meridian, so fall through into the following to draw
                        \ them

\ ******************************************************************************
\
\       Name: PL9 (Part 2 of 3)
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Draw the planet's equator and meridian
\  Deep dive: Drawing meridians and equators
\
\ ------------------------------------------------------------------------------
\
\ Draw the planet's equator and meridian.
\
\ Arguments:
\
\   K(1 0)              The planet's radius
\
\   K3(1 0)             Pixel x-coordinate of the centre of the planet
\
\   K4(1 0)             Pixel y-coordinate of the centre of the planet
\
\   INWK                The planet's ship data block
\
\ ******************************************************************************

 LDA K                  \ If the planet's radius is less than 6, the planet is
 CMP #6                 \ too small to show a meridian, so jump to PL20 to
 BCC PL20               \ return from the subroutine

 LDA INWK+14            \ Set P = -nosev_z_hi
 EOR #%10000000
 STA P

 LDA INWK+20            \ Set A = roofv_z_hi

 JSR PLS4               \ Call PLS4 to calculate the following:
                        \
                        \   CNT2 = arctan(P / A) / 4
                        \        = arctan(-nosev_z_hi / roofv_z_hi) / 4
                        \
                        \ and do the following if nosev_z_hi >= 0:
                        \
                        \   CNT2 = CNT2 + PI

 LDX #9                 \ Set X to 9 so the call to PLS1 divides nosev_x

 JSR PLS1               \ Call PLS1 to calculate the following:
 STA K2                 \
 STY XX16               \   (XX16 K2) = nosev_x / z
                        \
                        \ and increment X to point to nosev_y for the next call

 JSR PLS1               \ Call PLS1 to calculate the following:
 STA K2+1               \
 STY XX16+1             \   (XX16+1 K2+1) = nosev_y / z

 LDX #15                \ Set X to 15 so the call to PLS5 divides roofv_x

 JSR PLS5               \ Call PLS5 to calculate the following:
                        \
                        \   (XX16+2 K2+2) = roofv_x / z
                        \
                        \   (XX16+3 K2+3) = roofv_y / z

 JSR PLS2               \ Call PLS2 to draw the first meridian

 LDA INWK+14            \ Set P = -nosev_z_hi
 EOR #%10000000
 STA P

 LDA INWK+26            \ Set A = sidev_z_hi, so the second meridian will be at
                        \ 90 degrees to the first

 JSR PLS4               \ Call PLS4 to calculate the following:
                        \
                        \   CNT2 = arctan(P / A) / 4
                        \        = arctan(-nosev_z_hi / sidev_z_hi) / 4
                        \
                        \ and do the following if nosev_z_hi >= 0:
                        \
                        \   CNT2 = CNT2 + PI

 LDX #21                \ Set X to 21 so the call to PLS5 divides sidev_x

 JSR PLS5               \ Call PLS5 to calculate the following:
                        \
                        \   (XX16+2 K2+2) = sidev_x / z
                        \
                        \   (XX16+3 K2+3) = sidev_y / z

 JMP PLS2               \ Jump to PLS2 to draw the second meridian, returning
                        \ from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PL9 (Part 3 of 3)
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Draw the planet's crater
\  Deep dive: Drawing craters
\
\ ------------------------------------------------------------------------------
\
\ Draw the planet's crater.
\
\ Arguments:
\
\   K(1 0)              The planet's radius
\
\   K3(1 0)             Pixel x-coordinate of the centre of the planet
\
\   K4(1 0)             Pixel y-coordinate of the centre of the planet
\
\   INWK                The planet's ship data block
\
\ ******************************************************************************

.PL26

 LDA INWK+20            \ Set A = roofv_z_hi

 BMI PL20               \ If A is negative, the crater is on the far side of the
                        \ planet, so return from the subroutine (as PL2
                        \ contains an RTS)

 LDX #15                \ Set X = 15, so the following call to PLS3 operates on
                        \ roofv

 JSR PLS3               \ Call PLS3 to calculate:
                        \
                        \   (Y A P) = 222 * roofv_x / z
                        \
                        \ to give the x-coordinate of the crater offset and
                        \ increment X to point to roofv_y for the next call

 CLC                    \ Calculate:
 ADC K3                 \
 STA K3                 \   K3(1 0) = (Y A) + K3(1 0)
                        \           = 222 * roofv_x / z + x-coordinate of planet
                        \             centre
                        \
                        \ starting with the high bytes

 TYA                    \ And then doing the low bytes, so now K3(1 0) contains
 ADC K3+1               \ the x-coordinate of the crater offset plus the planet
 STA K3+1               \ centre to give the x-coordinate of the crater's centre

 JSR PLS3               \ Call PLS3 to calculate:
                        \
                        \   (Y A P) = 222 * roofv_y / z
                        \
                        \ to give the y-coordinate of the crater offset

 STA P                  \ Calculate:
 LDA K4                 \
 SEC                    \   K4(1 0) = K4(1 0) - (Y A)
 SBC P                  \           = 222 * roofv_y / z - y-coordinate of planet
 STA K4                 \             centre
                        \
                        \ starting with the low bytes

 STY P                  \ And then doing the low bytes, so now K4(1 0) contains
 LDA K4+1               \ the y-coordinate of the crater offset plus the planet
 SBC P                  \ centre to give the y-coordinate of the crater's centre
 STA K4+1

 LDX #9                 \ Set X = 9, so the following call to PLS1 operates on
                        \ nosev

 JSR PLS1               \ Call PLS1 to calculate the following:
                        \
                        \   (Y A) = nosev_x / z
                        \
                        \ and increment X to point to nosev_y for the next call

 LSR A                  \ Set (XX16 K2) = (Y A) / 2
 STA K2
 STY XX16

 JSR PLS1               \ Call PLS1 to calculate the following:
                        \
                        \   (Y A) = nosev_y / z
                        \
                        \ and increment X to point to nosev_z for the next call

 LSR A                  \ Set (XX16+1 K2+1) = (Y A) / 2
 STA K2+1
 STY XX16+1

 LDX #21                \ Set X = 21, so the following call to PLS1 operates on
                        \ sidev

 JSR PLS1               \ Call PLS1 to calculate the following:
                        \
                        \   (Y A) = sidev_x / z
                        \
                        \ and increment X to point to sidev_y for the next call

 LSR A                  \ Set (XX16+2 K2+2) = (Y A) / 2
 STA K2+2
 STY XX16+2

 JSR PLS1               \ Call PLS1 to calculate the following:
                        \
                        \   (Y A) = sidev_y / z
                        \
                        \ and increment X to point to sidev_z for the next call

 LSR A                  \ Set (XX16+3 K2+3) = (Y A) / 2
 STA K2+3
 STY XX16+3

 LDA #64                \ Set TGT = 64, so we draw a full ellipse in the call to
 STA TGT                \ PLS22 below

 LDA #0                 \ Set CNT2 = 0 as we are drawing a full ellipse, so we
 STA CNT2               \ don't need to apply an offset

 BEQ PLS22              \ Jump to PLS22 to draw the crater, returning from the
                        \ subroutine using a tail call (this BEQ is effectively
                        \ a JMP as A is always zero)

\ ******************************************************************************
\
\       Name: PLS1
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Calculate (Y A) = nosev_x / z
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following division of a specified value from one of the
\ orientation vectors (in this example, nosev_x):
\
\   (Y A) = nosev_x / z
\
\ where z is the z-coordinate of the planet from INWK. The result is an 8-bit
\ magnitude in A, with maximum value 254, and just a sign bit (bit 7) in Y.
\
\ Arguments:
\
\   X                   Determines which of the INWK orientation vectors to
\                       divide:
\
\                         * X = 9, 11, 13: divides nosev_x, nosev_y, nosev_z
\
\                         * X = 15, 17, 19: divides roofv_x, roofv_y, roofv_z
\
\                         * X = 21, 23, 25: divides sidev_x, sidev_y, sidev_z
\
\   INWK                The planet's ship data block
\
\ Returns:
\
\   A                   The result as an 8-bit magnitude with maximum value 254
\
\   Y                   The sign of the result in bit 7
\
\   K+3                 Also the sign of the result in bit 7
\
\   X                   X gets incremented by 2 so it points to the next
\                       coordinate in this orientation vector (so consecutive
\                       calls to the routine will start with x, then move onto y
\                       and then z)
\
\ ******************************************************************************

.PLS1

 LDA INWK,X             \ Set P = nosev_x_lo
 STA P

 LDA INWK+1,X           \ Set P+1 = |nosev_x_hi|
 AND #%01111111
 STA P+1

 LDA INWK+1,X           \ Set A = sign bit of nosev_x_lo
 AND #%10000000

 JSR DVID3B2            \ Call DVID3B2 to calculate:
                        \
                        \   K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)

 LDA K                  \ Fetch the lowest byte of the result into A

 LDY K+1                \ Fetch the second byte of the result into Y

 BEQ P%+4               \ If the second byte is 0, skip the next instruction

 LDA #254               \ The second byte is non-zero, so the result won't fit
                        \ into one byte, so set A = 254 as our maximum one-byte
                        \ value to return

 LDY K+3                \ Fetch the sign of the result from K+3 into Y

 INX                    \ Add 2 to X so the index points to the next coordinate
 INX                    \ in this orientation vector (so consecutive calls to
                        \ the routine will start with x, then move onto y and z)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PLS2
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Draw a half-ellipse
\  Deep dive: Drawing ellipses
\             Drawing meridians and equators
\
\ ------------------------------------------------------------------------------
\
\ Draw a half-ellipse, used for the planet's equator and meridian.
\
\ ******************************************************************************

.PLS2

 LDA #31                \ Set TGT = 31, so we only draw half an ellipse
 STA TGT

                        \ Fall through into PLS22 to draw the half-ellipse

\ ******************************************************************************
\
\       Name: PLS22
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Draw an ellipse or half-ellipse
\  Deep dive: Drawing ellipses
\             Drawing meridians and equators
\             Drawing craters
\
\ ------------------------------------------------------------------------------
\
\ Draw an ellipse or half-ellipse, to be used for the planet's equator and
\ meridian (in which case we draw half an ellipse), or crater (in which case we
\ draw a full ellipse).
\
\ The ellipse is defined by a centre point, plus two conjugate radius vectors,
\ u and v, where:
\
\   u = [ u_x ]       v = [ v_x ]
\       [ u_y ]           [ v_y ]
\
\ The individual components of these 2D vectors (i.e. u_x, u_y etc.) are 16-bit
\ sign-magnitude numbers, where the high bytes contain only the sign bit (in
\ bit 7), with bits 0 to 6 being clear. This means that as we store u_x as
\ (XX16 K2), for example, we know that |u_x| = K2.
\
\ This routine calls BLINE to draw each line segment in the ellipse, passing the
\ coordinates as follows:
\
\   K6(1 0) = K3(1 0) + u_x * cos(CNT2) + v_x * sin(CNT2)
\
\   K6(3 2) = K4(1 0) - u_y * cos(CNT2) - v_y * sin(CNT2)
\
\ The y-coordinates are negated because BLINE expects pixel coordinates but the
\ u and v vectors are extracted from the orientation vector. The y-axis runs
\ in the opposite direction in 3D space to that on the screen, so we need to
\ negate the 3D space coordinates before we can combine them with the ellipse's
\ centre coordinates.
\
\ Arguments:
\
\   K(1 0)              The planet's radius
\
\   K3(1 0)             The pixel x-coordinate of the centre of the ellipse
\
\   K4(1 0)             The pixel y-coordinate of the centre of the ellipse
\
\   (XX16 K2)           The x-component of u (i.e. u_x), where XX16 contains
\                       just the sign of the sign-magnitude number
\
\   (XX16+1 K2+1)       The y-component of u (i.e. u_y), where XX16+1 contains
\                       just the sign of the sign-magnitude number
\
\   (XX16+2 K2+2)       The x-component of v (i.e. v_x), where XX16+2 contains
\                       just the sign of the sign-magnitude number
\
\   (XX16+3 K2+3)       The y-component of v (i.e. v_y), where XX16+3 contains
\                       just the sign of the sign-magnitude number
\
\   TGT                 The number of segments to draw:
\
\                         * 32 for a half ellipse (a meridian)
\
\                         * 64 for a full ellipse (a crater)
\
\   CNT2                The starting segment for drawing the half-ellipse
\
\ ******************************************************************************

.PLS22

 LDX #0                 \ Set CNT = 0
 STX CNT

 DEX                    \ Set FLAG = &FF to reset the ball line heap in the call
 STX FLAG               \ to the BLINE routine below

.PLL4

 LDA CNT2               \ Set X = CNT2 mod 32
 AND #31                \
 TAX                    \ So X is the starting segment, reduced to the range 0
                        \ to 32, so as there are 64 segments in the circle, this
                        \ reduces the starting angle to 0 to 180 degrees, so we
                        \ can use X as an index into the sine table (which only
                        \ contains values for segments 0 to 31)
                        \
                        \ Also, because CNT2 mod 32 is in the range 0 to 180
                        \ degrees, we know that sin(CNT2 mod 32) is always
                        \ positive, or to put it another way:
                        \
                        \   sin(CNT2 mod 32) = |sin(CNT2)|

 LDA SNE,X              \ Set Q = sin(X)
 STA Q                  \       = sin(CNT2 mod 32)
                        \       = |sin(CNT2)|

 LDA K2+2               \ Set A = K2+2
                        \       = |v_x|

 JSR FMLTU              \ Set R = A * Q / 256
 STA R                  \       = |v_x| * |sin(CNT2)|

 LDA K2+3               \ Set A = K2+3
                        \       = |v_y|

 JSR FMLTU              \ Set K = A * Q / 256
 STA K                  \       = |v_y| * |sin(CNT2)|

 LDX CNT2               \ If CNT2 >= 33 then this sets the C flag, otherwise
 CPX #33                \ it's clear, so this means that:
                        \
                        \   * C is clear if the segment starts in the first half
                        \     of the circle, 0 to 180 degrees
                        \
                        \   * C is set if the segment starts in the second half
                        \     of the circle, 180 to 360 degrees
                        \
                        \ In other words, the C flag contains the sign bit for
                        \ sin(CNT2), which is positive for 0 to 180 degrees
                        \ and negative for 180 to 360 degrees

 LDA #0                 \ Shift the C flag into the sign bit of XX16+5, so
 ROR A                  \ XX16+5 has the correct sign for sin(CNT2)
 STA XX16+5             \
                        \ Because we set the following above:
                        \
                        \   K = |v_y| * |sin(CNT2)|
                        \   R = |v_x| * |sin(CNT2)|
                        \
                        \ we can add XX16+5 as the high byte to give us the
                        \ following:
                        \
                        \   (XX16+5 K) = |v_y| * sin(CNT2)
                        \   (XX16+5 R) = |v_x| * sin(CNT2)

 LDA CNT2               \ Set X = (CNT2 + 16) mod 32
 CLC                    \
 ADC #16                \ So we can use X as a lookup index into the SNE table
 AND #31                \ to get the cosine (as there are 16 segments in a
 TAX                    \ quarter-circle)
                        \
                        \ Also, because the sine table only contains positive
                        \ values, we know that sin((CNT2 + 16) mod 32) will
                        \ always be positive, or to put it another way:
                        \
                        \   sin((CNT2 + 16) mod 32) = |cos(CNT2)|

 LDA SNE,X              \ Set Q = sin(X)
 STA Q                  \       = sin((CNT2 + 16) mod 32)
                        \       = |cos(CNT2)|

 LDA K2+1               \ Set A = K2+1
                        \       = |u_y|

 JSR FMLTU              \ Set K+2 = A * Q / 256
 STA K+2                \         = |u_y| * |cos(CNT2)|

 LDA K2                 \ Set A = K2
                        \       = |u_x|

 JSR FMLTU              \ Set P = A * Q / 256
 STA P                  \       = |u_x| * |cos(CNT2)|
                        \
                        \ The call to FMLTU also sets the C flag, so in the
                        \ following, ADC #15 adds 16 rather than 15

 LDA CNT2               \ If (CNT2 + 16) mod 64 >= 33 then this sets the C flag,
 ADC #15                \ otherwise it's clear, so this means that:
 AND #63                \
 CMP #33                \   * C is clear if the segment starts in the first or
                        \     last quarter of the circle, 0 to 90 degrees or 270
                        \     to 360 degrees
                        \
                        \   * C is set if the segment starts in the second or
                        \     third quarter of the circle, 90 to 270 degrees
                        \
                        \ In other words, the C flag contains the sign bit for
                        \ cos(CNT2), which is positive for 0 to 90 degrees or
                        \ 270 to 360 degrees, and negative for 90 to 270 degrees

 LDA #0                 \ Shift the C flag into the sign bit of XX16+4, so:
 ROR A                  \ XX16+4 has the correct sign for cos(CNT2)
 STA XX16+4             \
                        \ Because we set the following above:
                        \
                        \   K+2 = |u_y| * |cos(CNT2)|
                        \   P   = |u_x| * |cos(CNT2)|
                        \
                        \ we can add XX16+4 as the high byte to give us the
                        \ following:
                        \
                        \   (XX16+4 K+2) = |u_y| * cos(CNT2)
                        \   (XX16+4 P)   = |u_x| * cos(CNT2)

 LDA XX16+5             \ Set S = the sign of XX16+2 * XX16+5
 EOR XX16+2             \       = the sign of v_x * XX16+5
 STA S                  \
                        \ So because we set this above:
                        \
                        \   (XX16+5 R) = |v_x| * sin(CNT2)
                        \
                        \ we now have this:
                        \
                        \   (S R) = v_x * sin(CNT2)

 LDA XX16+4             \ Set A = the sign of XX16 * XX16+4
 EOR XX16               \       = the sign of u_x * XX16+4
                        \
                        \ So because we set this above:
                        \
                        \   (XX16+4 P)   = |u_x| * cos(CNT2)
                        \
                        \ we now have this:
                        \
                        \   (A P) = u_x * cos(CNT2)

 JSR ADD                \ Set (A X) = (A P) + (S R)
                        \           = u_x * cos(CNT2) + v_x * sin(CNT2)

 STA T                  \ Store the high byte in T, so the result is now:
                        \
                        \   (T X) = u_x * cos(CNT2) + v_x * sin(CNT2)

 BPL PL42               \ If the result is positive, jump down to PL42

 TXA                    \ The result is negative, so we need to negate the
 EOR #%11111111         \ magnitude using two's complement, first doing the low
 CLC                    \ byte in X
 ADC #1
 TAX

 LDA T                  \ And then the high byte in T, making sure to leave the
 EOR #%01111111         \ sign bit alone
 ADC #0
 STA T

.PL42

 TXA                    \ Set K6(1 0) = K3(1 0) + (T X)
 ADC K3                 \
 STA K6                 \ starting with the low bytes

 LDA T                  \ And then doing the high bytes, so we now get:
 ADC K3+1               \
 STA K6+1               \   K6(1 0) = K3(1 0) + (T X)
                        \           = K3(1 0) + u_x * cos(CNT2)
                        \                     + v_x * sin(CNT2)
                        \
                        \ K3(1 0) is the x-coordinate of the centre of the
                        \ ellipse, so we now have the correct x-coordinate for
                        \ our ellipse segment that we can pass to BLINE below

 LDA K                  \ Set R = K = |v_y| * sin(CNT2)
 STA R

 LDA XX16+5             \ Set S = the sign of XX16+3 * XX16+5
 EOR XX16+3             \       = the sign of v_y * XX16+5
 STA S                  \
                        \ So because we set this above:
                        \
                        \   (XX16+5 K) = |v_y| * sin(CNT2)
                        \
                        \ and we just set R = K, we now have this:
                        \
                        \   (S R) = v_y * sin(CNT2)

 LDA K+2                \ Set P = K+2 = |u_y| * cos(CNT2)
 STA P

 LDA XX16+4             \ Set A = the sign of XX16+1 * XX16+4
 EOR XX16+1             \       = the sign of u_y * XX16+4
                        \
                        \ So because we set this above:
                        \
                        \   (XX16+4 K+2) = |u_y| * cos(CNT2)
                        \
                        \ and we just set P = K+2, we now have this:
                        \
                        \   (A P) = u_y * cos(CNT2)

 JSR ADD                \ Set (A X) = (A P) + (S R)
                        \           =  u_y * cos(CNT2) + v_y * sin(CNT2)

 EOR #%10000000         \ Store the negated high byte in T, so the result is
 STA T                  \ now:
                        \
                        \   (T X) = - u_y * cos(CNT2) - v_y * sin(CNT2)
                        \
                        \ This negation is necessary because BLINE expects us
                        \ to pass pixel coordinates, where y-coordinates get
                        \ larger as we go down the screen; u_y and v_y, on the
                        \ other hand, are extracted from the orientation
                        \ vectors, where y-coordinates get larger as we go up
                        \ in space, so to rectify this we need to negate the
                        \ result in (T X) before we can add it to the
                        \ y-coordinate of the ellipse's centre in BLINE

 BPL PL43               \ If the result is positive, jump down to PL43

 TXA                    \ The result is negative, so we need to negate the
 EOR #%11111111         \ magnitude using two's complement, first doing the low
 CLC                    \ byte in X
 ADC #1
 TAX

 LDA T                  \ And then the high byte in T, making sure to leave the
 EOR #%01111111         \ sign bit alone
 ADC #0
 STA T

.PL43

                        \ We now call BLINE to draw the ellipse line segment
                        \
                        \ The first few instructions of BLINE do the following:
                        \
                        \   K6(3 2) = K4(1 0) + (T X)
                        \
                        \ which gives:
                        \
                        \   K6(3 2) = K4(1 0) - u_y * cos(CNT2)
                        \                     - v_y * sin(CNT2)
                        \
                        \ K4(1 0) is the pixel y-coordinate of the centre of the
                        \ ellipse, so this gives us the correct y-coordinate for
                        \ our ellipse segment (we already calculated the
                        \ x-coordinate in K3(1 0) above)

 JSR BLINE              \ Call BLINE to draw this segment, which also returns
                        \ the updated value of CNT in A

 CMP TGT                \ If CNT > TGT then jump to PL40 to stop drawing the
 BEQ P%+4               \ ellipse (which is how we draw half-ellipses)
 BCS PL40

 LDA CNT2               \ Set CNT2 = (CNT2 + STP) mod 64
 CLC
 ADC STP
 AND #63
 STA CNT2

 JMP PLL4               \ Jump back to PLL4 to draw the next segment

.PL40

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CIRCLE
\       Type: Subroutine
\   Category: Drawing circles
\    Summary: Draw a circle for the planet
\  Deep dive: Drawing circles
\
\ ------------------------------------------------------------------------------
\
\ Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
\ planet's main outline.
\
\ Arguments:
\
\   K                   The planet's radius
\
\   K3(1 0)             Pixel x-coordinate of the centre of the planet
\
\   K4(1 0)             Pixel y-coordinate of the centre of the planet
\
\ ******************************************************************************

.CIRCLE

 JSR CHKON              \ Call CHKON to check whether the circle fits on-screen

 BCS PL40               \ If CHKON set the C flag then the circle does not fit
                        \ on-screen, so return from the subroutine (as PL40
                        \ contains an RTS)

 LDA #0                 \ Set LSX2 = 0 to indicate that the ball line heap is
 STA LSX2               \ not empty, as we are about to fill it

 LDX K                  \ Set X = K = radius

 LDA #8                 \ Set A = 8

 CPX #8                 \ If the radius < 8, skip to PL89
 BCC PL89

 LSR A                  \ Halve A so A = 4

 CPX #60                \ If the radius < 60, skip to PL89
 BCC PL89

 LSR A                  \ Halve A so A = 2

.PL89

 STA STP                \ Set STP = A. STP is the step size for the circle, so
                        \ the above sets a smaller step size for bigger circles

 JMP CIRCLE2            \ Jump to CIRCLE2 to draw the circle with the correct
                        \ step size and return from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: WPLS2
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Remove the planet from the screen
\  Deep dive: The ball line heap
\
\ ------------------------------------------------------------------------------
\
\ We do this by redrawing it using the lines stored in the ball line heap when
\ the planet was originally drawn by the BLINE routine.
\
\ ******************************************************************************

.WPLS2

 LDY LSX2               \ If LSX2 is non-zero (which indicates the ball line
 BNE WP1                \ heap is empty), jump to WP1 to reset the line heap
                        \ without redrawing the planet

                        \ Otherwise Y is now 0, so we can use it as a counter to
                        \ loop through the lines in the line heap, redrawing
                        \ each one to remove the planet from the screen, before
                        \ resetting the line heap once we are done

.WPL1

 CPY LSP                \ If Y >= LSP then we have reached the end of the line
 BCS WP1                \ heap and have finished redrawing the planet (as LSP
                        \ points to the end of the heap), so jump to WP1 to
                        \ reset the line heap, returning from the subroutine
                        \ using a tail call

 LDA LSY2,Y             \ Set A to the y-coordinate of the current heap entry

 CMP #&FF               \ If the y-coordinate is &FF, this indicates that the
 BEQ WP2                \ next point in the heap denotes the start of a line
                        \ segment, so jump to WP2 to put it into (X1, Y1)

 STA Y2                 \ Set (X2, Y2) to the x- and y-coordinates from the
 LDA LSX2,Y             \ heap
 STA X2

 JSR LOIN               \ Draw a line from (X1, Y1) to (X2, Y2)

 INY                    \ Increment the loop counter to point to the next point

 LDA X2                 \ Swap (X1, Y1) and (X2, Y2), so the next segment will
 STA X1                 \ be drawn from the current (X2, Y2) to the next point
 LDA Y2                 \ in the heap
 STA Y1

 JMP WPL1               \ Loop back to WPL1 for the next point in the heap

.WP2

 INY                    \ Increment the loop counter to point to the next point

 LDA LSX2,Y             \ Set (X1, Y1) to the x- and y-coordinates from the
 STA X1                 \ heap
 LDA LSY2,Y
 STA Y1

 INY                    \ Increment the loop counter to point to the next point

 JMP WPL1               \ Loop back to WPL1 for the next point in the heap

\ ******************************************************************************
\
\       Name: WP1
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Reset the ball line heap
\
\ ******************************************************************************

.WP1

 LDA #1                 \ Set LSP = 1 to reset the ball line heap pointer
 STA LSP

 LDA #&FF               \ Set LSX2 = &FF to indicate the ball line heap is empty
 STA LSX2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: WPLS
\       Type: Subroutine
\   Category: Drawing suns
\    Summary: Remove the sun from the screen
\  Deep dive: Drawing the sun
\
\ ------------------------------------------------------------------------------
\
\ We do this by redrawing it using the lines stored in the sun line heap when
\ the sun was originally drawn by the SUN routine.
\
\ Arguments:
\
\   SUNX(1 0)           The x-coordinate of the vertical centre axis of the sun
\
\ Other entry points:
\
\   WPLS-1              Contains an RTS
\
\ ******************************************************************************

.WPLS

 LDA LSX                \ If LSX < 0, the sun line heap is empty, so return from
 BMI WPLS-1             \ the subroutine (as WPLS-1 contains an RTS)

 LDA SUNX               \ Set YY(1 0) = SUNX(1 0), the x-coordinate of the
 STA YY                 \ vertical centre axis of the sun that's currently on
 LDA SUNX+1             \ screen
 STA YY+1

 LDY #2*Y-1             \ #Y is the y-coordinate of the centre of the space
                        \ view, so this sets Y as a counter for the number of
                        \ lines in the space view (i.e. 191), which is also the
                        \ number of lines in the LSO block

.WPL2

 LDA LSO,Y              \ Fetch the Y-th point from the sun line heap, which
                        \ gives us the half-width of the sun's line on this line
                        \ of the screen

 BEQ P%+5               \ If A = 0, skip the following call to HLOIN2 as there
                        \ is no sun line on this line of the screen

 JSR HLOIN2             \ Call HLOIN2 to draw a horizontal line on pixel line Y,
                        \ with centre point YY(1 0) and half-width A, and remove
                        \ the line from the sun line heap once done

 DEY                    \ Decrement the loop counter

 BNE WPL2               \ Loop back for the next line in the line heap until
                        \ we have gone through the entire heap

 DEY                    \ This sets Y to &FF, as we end the loop with Y = 0

 STY LSX                \ Set LSX to &FF to indicate the sun line heap is empty

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PLS3
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Calculate (Y A P) = 222 * roofv_x / z
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following, with X determining the vector to use:
\
\   (Y A P) = 222 * roofv_x / z
\
\ though in reality only (Y A) is used.
\
\ Although the code below supports a range of values of X, in practice the
\ routine is only called with X = 15, and then again after X has been
\ incremented to 17. So the values calculated by PLS1 use roofv_x first, then
\ roofv_y. The comments below refer to roofv_x, for the first call.
\
\ Arguments:
\
\   X                   Determines which of the INWK orientation vectors to
\                       divide:
\
\                         * X = 15: divides roofv_x
\
\                         * X = 17: divides roofv_y
\
\ Returns:
\
\   X                   X gets incremented by 2 so it points to the next
\                       coordinate in this orientation vector (so consecutive
\                       calls to the routine will start with x, then move onto y
\                       and then z)
\
\ ******************************************************************************

.PLS3

 JSR PLS1               \ Call PLS1 to calculate the following:
 STA P                  \
                        \   P = |roofv_x / z|
                        \   K+3 = sign of roofv_x / z
                        \
                        \ and increment X to point to roofv_y for the next call

 LDA #222               \ Set Q = 222, the offset to the crater
 STA Q

 STX U                  \ Store the vector index X in U for retrieval after the
                        \ call to MULTU

 JSR MULTU              \ Call MULTU to calculate
                        \
                        \   (A P) = P * Q
                        \         = 222 * |roofv_x / z|

 LDX U                  \ Restore the vector index from U into X

 LDY K+3                \ If the sign of the result in K+3 is positive, skip to
 BPL PL12               \ PL12 to return with Y = 0

 EOR #&FF               \ Otherwise the result should be negative, so negate the
 CLC                    \ high byte of the result using two's complement with
 ADC #1                 \ A = ~A + 1

 BEQ PL12               \ If A = 0, jump to PL12 to return with (Y A) = 0

 LDY #&FF               \ Set Y = &FF to be a negative high byte

 RTS                    \ Return from the subroutine

.PL12

 LDY #0                 \ Set Y = 0 to be a positive high byte

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PLS4
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Calculate CNT2 = arctan(P / A) / 4
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   CNT2 = arctan(P / A) / 4
\
\ and do the following if nosev_z_hi >= 0:
\
\   CNT2 = CNT2 + 32
\
\ which is the equivalent of adding 180 degrees to the result (or PI radians),
\ as there are 64 segments in a full circle.
\
\ This routine is called with the following arguments when calculating the
\ equator and meridian for planets:
\
\   * A = roofv_z_hi, P = -nosev_z_hi
\
\   * A = sidev_z_hi, P = -nosev_z_hi
\
\ So it calculates the angle between the planet's orientation vectors, in the
\ z-axis.
\
\ ******************************************************************************

.PLS4

 STA Q                  \ Set Q = A

 JSR ARCTAN             \ Call ARCTAN to calculate:
                        \
                        \   A = arctan(P / Q)
                        \       arctan(P / A)
                        \
                        \ The result in A will be in the range 0 to 128, which
                        \ represents an angle of 0 to 180 degrees (or 0 to PI
                        \ radians)

 LDX INWK+14            \ If nosev_z_hi is negative, skip the following
 BMI P%+4               \ instruction to leave the angle in A as a positive
                        \ integer in the range 0 to 128 (so when we calculate
                        \ CNT2 below, it will be in the right half of the
                        \ anti-clockwise arc that we describe when drawing
                        \ circles, i.e. from 6 o'clock, through 3 o'clock and
                        \ on to 12 o'clock)

 EOR #%10000000         \ If we get here then nosev_z_hi is positive, so flip
                        \ bit 7 of the angle in A, which is the same as adding
                        \ 128 to give a result in the range 129 to 256 (i.e. 129
                        \ to 0), or 180 to 360 degrees (so when we calculate
                        \ CNT2 below, it will be in the left half of the
                        \ anti-clockwise arc that we describe when drawing
                        \ circles, i.e. from 12 o'clock, through 9 o'clock and
                        \ on to 6 o'clock)

 LSR A                  \ Set CNT2 = A / 4
 LSR A
 STA CNT2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PLS5
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Calculate roofv_x / z and roofv_y / z
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following divisions of a specified value from one of the
\ orientation vectors (in this example, roofv):
\
\   (XX16+2 K2+2) = roofv_x / z
\
\   (XX16+3 K2+3) = roofv_y / z
\
\ Arguments:
\
\   X                   Determines which of the INWK orientation vectors to
\                       divide:
\
\                         * X = 15: divides roofv_x and roofv_y
\
\                         * X = 21: divides sidev_x and sidev_y
\
\   INWK                The planet's ship data block
\
\ ******************************************************************************

.PLS5

 JSR PLS1               \ Call PLS1 to calculate the following:
 STA K2+2               \
 STY XX16+2             \   K+2    = |roofv_x / z|
                        \   XX16+2 = sign of roofv_x / z
                        \
                        \ i.e. (XX16+2 K2+2) = roofv_x / z
                        \
                        \ and increment X to point to roofv_y for the next call

 JSR PLS1               \ Call PLS1 to calculate the following:
 STA K2+3               \
 STY XX16+3             \   K+3    = |roofv_y / z|
                        \   XX16+3 = sign of roofv_y / z
                        \
                        \ i.e. (XX16+3 K2+3) = roofv_y / z
                        \
                        \ and increment X to point to roofv_z for the next call

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PLS6
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Calculate (X K) = (A P) / (z_sign z_hi z_lo)
\
\ ------------------------------------------------------------------------------
\
\ Calculate the following:
\
\   (X K) = (A P) / (z_sign z_hi z_lo)
\
\ returning an overflow in the C flag if the result is >= 1024.
\
\ Arguments:
\
\   INWK                The planet or sun's ship data block
\
\ Returns:
\
\   C flag              Set if the result >= 1024, clear otherwise
\
\ ******************************************************************************

.PLS6

 JSR DVID3B2            \ Call DVID3B2 to calculate:
                        \
                        \   K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)

 LDA K+3                \ Set A = |K+3| OR K+2
 AND #%01111111
 ORA K+2

 BNE PL21S              \ If A is non-zero then the two high bytes of K(3 2 1 0)
                        \ are non-zero, so jump to PL21S to set the C flag and
                        \ return from the subroutine

                        \ We can now just consider K(1 0), as we know the top
                        \ two bytes of K(3 2 1 0) are both 0

 LDX K+1                \ Set X = K+1, so now (X K) contains the result in
                        \ K(1 0), which is the format we want to return the
                        \ result in

 CPX #4                 \ If the high byte of K(1 0) >= 4 then the result is
 BCS PL6                \ >= 1024, so return from the subroutine with the C flag
                        \ set to indicate an overflow (as PL6 contains an RTS)

 LDA K+3                \ Fetch the sign of the result from K+3 (which we know
                        \ has zeroes in bits 0-6, so this just fetches the sign)

 BPL PL6                \ If the sign bit is clear and the result is positive,
                        \ then the result is already correct, so return from
                        \ the subroutine with the C flag clear to indicate
                        \ success (as PL6 contains an RTS)

 LDA K                  \ Otherwise we need to negate the result, which we do
 EOR #%11111111         \ using two's complement, starting with the low byte:
 ADC #1                 \
 STA K                  \   K = ~K + 1

 TXA                    \ And then the high byte:
 EOR #%11111111         \
 ADC #0                 \   X = ~X
 TAX

 CLC                    \ Clear the C flag to indicate success

.PL6

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PL21S
\       Type: Subroutine
\   Category: Drawing planets
\    Summary: Return from a planet/sun-drawing routine with a failure flag
\
\ ------------------------------------------------------------------------------
\
\ This routine is a duplicate of PL21 that is close enough to the PLS6 routine
\ for it to be called by a branch instruction.
\
\ Set the C flag and return from the subroutine. This is used to return from a
\ planet- or sun-drawing routine with the C flag indicating an overflow in the
\ calculation.
\
\ ******************************************************************************

.PL21S

 SEC                    \ Set the C flag to indicate an overflow

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: KS3
\       Type: Subroutine
\   Category: Universe
\    Summary: Set the SLSP ship heap pointer after shuffling ship slots
\
\ ------------------------------------------------------------------------------
\
\ The final part of the KILLSHP routine, called after we have shuffled the ship
\ slots and sorted out our missiles. This simply sets SLSP to the new bottom of
\ the ship heap space.
\
\ Arguments:
\
\   P(1 0)              Points to the ship line heap of the ship in the last
\                       occupied slot (i.e. it points to the bottom of the
\                       descending heap)
\
\ ******************************************************************************

.KS3

 LDA P                  \ After shuffling the ship slots, P(1 0) will point to
 STA SLSP               \ the new bottom of the ship heap, so store this in
 LDA P+1                \ SLSP(1 0), which stores the bottom of the heap
 STA SLSP+1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: KS1
\       Type: Subroutine
\   Category: Universe
\    Summary: Remove the current ship from our local bubble of universe
\
\ ------------------------------------------------------------------------------
\
\ Part 12 of the main flight loop calls this routine to remove the ship that is
\ currently being analysed by the flight loop. Once the ship is removed, it
\ jumps back to MAL1 to re-join the main flight loop, with X pointing to the
\ same slot that we just cleared (and which now contains the next ship in the
\ local bubble of universe).
\
\ Arguments:
\
\   XX0                 The address of the blueprint for this ship
\
\   INF                 The address of the data block for this ship
\
\ ******************************************************************************

.KS1

 LDX XSAV               \ Store the current ship's slot number in XSAV

 JSR KILLSHP            \ Call KILLSHP to remove the ship in slot X from our
                        \ local bubble of universe

 LDX XSAV               \ Restore the current ship's slot number from XSAV,
                        \ which now points to the next ship in the bubble

 JMP MAL1               \ Jump to MAL1 to re-join the main flight loop at the
                        \ start of the ship analysis loop

\ ******************************************************************************
\
\       Name: KS4
\       Type: Subroutine
\   Category: Universe
\    Summary: Remove the space station and replace it with the sun
\
\ ******************************************************************************

.KS4

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 JSR FLFLLS             \ Reset the LSO block, returns with A = 0

 STA FRIN+1             \ Set the second slot in the FRIN table to 0, which
                        \ sets this slot to empty, so when we call NWSHP below
                        \ the new sun that gets created will go into FRIN+1

 STA SSPR               \ Set the "space station present" flag to 0, as we are
                        \ no longer in the space station's safe zone

 JSR SPBLB              \ Call SPBLB to redraw the space station bulb, which
                        \ will erase it from the dashboard

 LDA #6                 \ Set the sun's y_sign to 6
 STA INWK+5

 LDA #129               \ Set A = 129, the ship type for the sun

 JMP NWSHP              \ Call NWSHP to set up the sun's data block and add it
                        \ to FRIN, where it will get put in the second slot as
                        \ we just cleared out the second slot, and the first
                        \ slot is already taken by the planet

\ ******************************************************************************
\
\       Name: KS2
\       Type: Subroutine
\   Category: Universe
\    Summary: Check the local bubble for missiles with target lock
\
\ ------------------------------------------------------------------------------
\
\ Check the local bubble of universe to see if there are any missiles with
\ target lock in the vicinity. If there are, then check their targets; if we
\ just removed their target in the KILLSHP routine, then switch off their AI so
\ they just drift in space, otherwise update their targets to reflect the newly
\ shuffled slot numbers.
\
\ This is called from KILLSHP once the slots have been shuffled down, following
\ the removal of a ship.
\
\ Arguments:
\
\   XX4                 The slot number of the ship we removed just before
\                       calling this routine
\
\ ******************************************************************************

.KS2

 LDX #&FF               \ We want to go through the ships in our local bubble
                        \ and pick out all the missiles, so set X to &FF to
                        \ use as a counter

.KSL4

 INX                    \ Increment the counter (so it starts at 0 on the first
                        \ iteration)

 LDA FRIN,X             \ If slot X is empty, loop round again until it isn't,
 BEQ KS3                \ at which point A contains the ship type in that slot

 CMP #MSL               \ If the slot does not contain a missile, loop back to
 BNE KSL4               \ KSL4 to check the next slot

                        \ We have found a slot containing a missile, so now we
                        \ want to check whether it has target lock

 TXA                    \ Set Y = X * 2 and fetch the Y-th address from UNIV
 ASL A                  \ and store it in SC and SC+1 - in other words, set
 TAY                    \ SC(1 0) to point to the missile's ship data block
 LDA UNIV,Y
 STA SC
 LDA UNIV+1,Y
 STA SC+1

 LDY #32                \ Fetch byte #32 from the missile's ship data (AI)
 LDA (SC),Y

 BPL KSL4               \ If bit 7 of byte #32 is clear, then the missile is
                        \ dumb and has no AI, so loop back to KSL4 to move on
                        \ to the next slot

 AND #%01111111         \ Otherwise this missile has AI, so clear bit 7 and
 LSR A                  \ shift right to set the C flag to the missile's "is
                        \ locked" flag, and A to the target's slot number

 CMP XX4                \ If this missile's target is less than XX4, then the
 BCC KSL4               \ target's slot isn't being shuffled down, so jump to
                        \ KSL4 to move on to the next slot

 BEQ KS6                \ If this missile was locked onto the ship that we just
                        \ removed in KILLSHP, jump to KS6 to stop the missile
                        \ from continuing to hunt it down

 SBC #1                 \ Otherwise this missile is locked and has AI enabled,
                        \ and its target will have moved down a slot, so
                        \ subtract 1 from the target number (we know C is set
                        \ from the BCC above)

 ASL A                  \ Shift the target number left by 1, so it's in bits
                        \ 1-6 once again, and also set bit 0 to 1, as the C
                        \ flag is still set, so this makes sure the missile is
                        \ still set to being locked

 ORA #%10000000         \ Set bit 7, so the missile's AI is enabled

 STA (SC),Y             \ Update the missile's AI flag to the value in A

 BNE KSL4               \ Loop back to KSL4 to move on to the next slot (this
                        \ BNE is effectively a JMP as A will never be zero)

.KS6

 LDA #0                 \ The missile's target lock just got removed, so set the
 STA (SC),Y             \ AI flag to 0 to make it dumb and not locked

 BEQ KSL4               \ Loop back to KSL4 to move on to the next slot (this
                        \ BEQ is effectively a JMP as A is always zero)

\ ******************************************************************************
\
\       Name: KILLSHP
\       Type: Subroutine
\   Category: Universe
\    Summary: Remove a ship from our local bubble of universe
\
\ ------------------------------------------------------------------------------
\
\ Remove the ship in slot X from our local bubble of universe. This happens
\ when we kill a ship, collide with a ship and destroy it, or when a ship moves
\ outside our local bubble.
\
\ We also use this routine when we move out of range of the space station, in
\ which case we replace it with the sun.
\
\ When removing a ship, this creates a gap in the ship slots at FRIN, so we
\ shuffle all the later slots down to close the gap. We also shuffle the ship
\ data blocks at K% and ship line heap at WP, to reclaim all the memory that
\ the removed ship used to occupy.
\
\ Arguments:
\
\   X                   The slot number of the ship to remove
\
\   XX0                 The address of the blueprint for the ship to remove
\
\   INF                 The address of the data block for the ship to remove
\
\ ******************************************************************************

.KILLSHP

 STX XX4                \ Store the slot number of the ship to remove in XX4

 CPX MSTG               \ Check whether this slot matches the slot number in
                        \ MSTG, which is the target of our missile lock

 BNE KS5                \ If our missile is not locked on this ship, jump to KS5

 LDY #&EE               \ Otherwise we need to remove our missile lock, so call
 JSR ABORT              \ ABORT to disarm the missile and update the missile
                        \ indicators on the dashboard to green/cyan (Y = &EE)

 LDA #200               \ Print recursive token 40 ("TARGET LOST") as an
 JSR MESS               \ in-flight message

.KS5

 LDY XX4                \ Restore the slot number of the ship to remove into Y

 LDX FRIN,Y             \ Fetch the contents of the slot, which contains the
                        \ ship type

 CPX #SST               \ If this is the space station, then jump to KS4 to
 BEQ KS4                \ replace the space station with the sun

 CPX #CON               \ Did we just kill the Constrictor from mission 1? If
 BNE lll                \ not, jump to lll

 LDA TP                 \ We just killed the Constrictor from mission 1, so set
 ORA #%00000010         \ bit 1 of TP to indicate that we have successfully
 STA TP                 \ completed mission 1

.lll

 CPX #JL                \ If JL <= X < JH, i.e. the type of ship we killed in X
 BCC KS7                \ is junk (escape pod, alloy plate, cargo canister,
 CPX #JH                \ asteroid, splinter, Shuttle or Transporter), then keep
 BCS KS7                \ going, otherwise jump to KS7

 DEC JUNK               \ We just killed junk, so decrease the junk counter

.KS7

 DEC MANY,X             \ Decrease the number of this type of ship in our little
                        \ bubble, which is stored in MANY+X (where X is the ship
                        \ type)

 LDX XX4                \ Restore the slot number of the ship to remove into X

                        \ We now want to remove this ship and reclaim all the
                        \ memory that it uses. Removing the ship will leave a
                        \ gap in three places, which we need to close up:
                        \
                        \   * The ship slots in FRIN
                        \
                        \   * The ship data blocks in K%
                        \
                        \   * The descending ship line heap at WP down
                        \
                        \ The rest of this routine closes up these gaps by
                        \ looping through all the occupied ship slots after the
                        \ slot we are removing, one by one, and shuffling each
                        \ ship's slot, data block and line heap down to close
                        \ up the gaps left by the removed ship. As part of this,
                        \ we have to make sure we update any address pointers
                        \ so they point to the newly shuffled data blocks and
                        \ line heaps
                        \
                        \ In the following, when shuffling a ship's data down
                        \ into the preceding empty slot, we call the ship that
                        \ we are shuffling down the "source", and we call the
                        \ empty slot we are shuffling it into the "destination"
                        \
                        \ Before we start looping through the ships we need to
                        \ shuffle down, we need to set up some variables to
                        \ point to the source and destination line heaps

 LDY #5                 \ Fetch byte #5 of the removed ship's blueprint into A,
 LDA (XX0),Y            \ which gives the ship's maximum heap size for the ship
                        \ we are removing (i.e. the size of the gap in the heap
                        \ created by the ship removal)

                        \ INF currently contains the ship data for the ship we
                        \ are removing, and INF(34 33) contains the address of
                        \ the bottom of the ship's heap, so we can calculate
                        \ the address of the top of the heap by adding the heap
                        \ size to this address

 LDY #33                \ First we add A and the address in INF+33, to get the
 CLC                    \ low byte of the top of the heap, which we store in P
 ADC (INF),Y
 STA P

 INY                    \ And next we add A and address in INF+34, with any
 LDA (INF),Y            \ from the previous addition, to get the high byte of
 ADC #0                 \ the top of the heap, which we store in P+1, so P(1 0)
 STA P+1                \ points to the top of this ship's heap

                        \ Now, we're ready to start looping through the ships
                        \ we want to move, moving the slots, data blocks and
                        \ line heap from the source to the destination. In the
                        \ following, we set up SC to point to the source data,
                        \ and INF (which currently points to the removed ship's
                        \ data that we can now overwrite) points to the
                        \ destination
                        \
                        \ So P(1 0) now points to the top of the line heap for
                        \ the destination

.KSL1

 INX                    \ On entry, X points to the empty slot we want to
                        \ shuffle the next ship into (the destination), so
                        \ this increment points X to the next slot - i.e. the
                        \ source slot we want to shuffle down

 LDA FRIN,X             \ Copy the contents of the source slot into the
 STA FRIN-1,X           \ destination slot

 BNE P%+5               \ If the slot we just shuffled down is not empty, then
                        \ skip the following instruction

 JMP KS2                \ The source slot is empty and we are done shuffling,
                        \ so jump to KS2 to move on to processing missiles

 ASL A                  \ Otherwise we have a source ship to shuffle down into
 TAY                    \ the destination, so set Y = A * 2 so it can act as an
                        \ index into the two-byte ship blueprint lookup table
                        \ at XX21 for the source ship

 LDA XX21-2,Y           \ Set SC(0 1) to point to the blueprint data for the
 STA SC                 \ source ship
 LDA XX21-1,Y
 STA SC+1

 LDY #5                 \ Fetch blueprint byte #5 for the source ship, which
 LDA (SC),Y             \ gives us its maximum heap size, and store it in T
 STA T

                        \ We now subtract T from P(1 0), so P(1 0) will point to
                        \ the bottom of the line heap for the destination
                        \ (which we will use later when closing up the gap in
                        \ the heap space)

 LDA P                  \ First, we subtract the low bytes
 SEC
 SBC T
 STA P

 LDA P+1                \ And then we do the high bytes, for which we subtract
 SBC #0                 \ 0 to include any carry, so this is effectively doing
 STA P+1                \ P(1 0) = P(1 0) - (0 T)

                        \ Next, we want to set SC(1 0) to point to the source
                        \ ship's data block

 TXA                    \ Set Y = X * 2 so it can act as an index into the
 ASL A                  \ two-byte lookup table at UNIV, which contains the
 TAY                    \ addresses of the ship data blocks. In this case we are
                        \ multiplying X by 2, and X contains the source ship's
                        \ slot number so Y is now an index for the source ship's
                        \ entry in UNIV

 LDA UNIV,Y             \ Set SC(1 0) to the address of the data block for the
 STA SC                 \ source ship
 LDA UNIV+1,Y
 STA SC+1

                        \ We have now set up our variables as follows:
                        \
                        \   SC(1 0) points to the source's ship data block
                        \
                        \   INF(1 0) points to the destination's ship data block
                        \
                        \   P(1 0) points to the destination's line heap
                        \
                        \ so let's start copying data from the source to the
                        \ destination

 LDY #36                \ We are going to be using Y as a counter for the 37
                        \ bytes of ship data we want to copy from the source
                        \ to the destination, so we set it to 36 to start things
                        \ off, and will decrement Y for each byte we copy

 LDA (SC),Y             \ Fetch byte #36 of the source's ship data block at SC,
 STA (INF),Y            \ and store it in byte #36 of the destination's block
 DEY                    \ at INF, so that's the ship's NEWB flags copied from
                        \ the source to the destination. One down, quite a few
                        \ to go...

 LDA (SC),Y             \ Fetch byte #35 of the source's ship data block at SC,
 STA (INF),Y            \ and store it in byte #35 of the destination's block
                        \ at INF, so that's the ship's energy copied from the
                        \ source to the destination

 DEY                    \ Fetch byte #34 of the source ship, which is the
 LDA (SC),Y             \ high byte of the source ship's line heap, and store
 STA K+1                \ in K+1

 LDA P+1                \ Set the low byte of the destination's heap pointer
 STA (INF),Y            \ to P+1

 DEY                    \ Fetch byte #33 of the source ship, which is the
 LDA (SC),Y             \ low byte of the source ship's heap, and store in K
 STA K                  \ so now we have the following:
                        \
                        \   K(1 0) points to the source's line heap

 LDA P                  \ Set the low byte of the destination's heap pointer
 STA (INF),Y            \ to P, so now the destination's heap pointer is to
                        \ P(1 0), so that's the heap pointer in bytes #33 and
                        \ #34 done

 DEY                    \ Luckily, we can just copy the rest of the source's
                        \ ship data block into the destination, as there are no
                        \ more address pointers, so first we decrement our
                        \ counter in Y to point to the next byte (the AI flag)
                        \ in byte #32) and then start looping

.KSL2

 LDA (SC),Y             \ Copy the Y-th byte of the source to the Y-th byte of
 STA (INF),Y            \ the destination

 DEY                    \ Decrement the counter

 BPL KSL2               \ Loop back to KSL2 to copy the next byte until we have
                        \ copied the whole block

                        \ We have now shuffled the ship's slot and the ship's
                        \ data block, so we only have the heap data itself to do

 LDA SC                 \ First, we copy SC into INF, so when we loop round
 STA INF                \ again, INF will correctly point to the destination for
 LDA SC+1               \ the next iteration
 STA INF+1

 LDY T                  \ Now we want to move the contents of the heap, as all
                        \ we did above was to update the pointers, so first
                        \ we set a counter in Y that is initially set to T
                        \ (which we set above to the maximum heap size for the
                        \ source ship)
                        \
                        \ As a reminder, we have already set the following:
                        \
                        \   K(1 0) points to the source's line heap
                        \
                        \   P(1 0) points to the destination's line heap
                        \
                        \ so we can move the heap data by simply copying the
                        \ correct number of bytes from K(1 0) to P(1 0)
.KSL3

 DEY                    \ Decrement the counter

 LDA (K),Y              \ Copy the Y-th byte of the source heap at K(1 0) to
 STA (P),Y              \ the destination heap at P(1 0)

 TYA                    \ Loop back to KSL3 to copy the next byte, until we
 BNE KSL3               \ have done them all

 BEQ KSL1               \ We have now shuffled everything down one slot, so
                        \ jump back up to KSL1 to see if there is another slot
                        \ that needs shuffling down (this BEQ is effectively a
                        \ JMP as A will always be zero)

\ ******************************************************************************
\
\ Save ELTL.bin
\
\ ******************************************************************************

 PRINT "ELITE L"
 PRINT "Assembled at ", ~CODE_L%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_L%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_L%

 PRINT "S.2.ELTL ", ~CODE_L%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_L%
\SAVE "versions/disc/3-assembled-output/2.ELTL.bin", CODE_L%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE M FILE
\
\ ******************************************************************************

 CODE_M% = P%
 LOAD_M% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: rand_posn
\       Type: Subroutine
\   Category: Universe
\    Summary: Set up the INWK workspace for a ship in a random ship position
\
\ ------------------------------------------------------------------------------
\
\ This routine sets up a new ship, with the following coordinates:
\
\   * (x_sign x_hi x_lo) is a random number in the range -8191 to +8191:
\
\     * x_sign is randomly positive or negative
\     * x_hi is a random number in the range 0 to 31
\     * x_lo is a random number in the range 0 to 255
\
\   * (y_sign y_hi y_lo) is a random number in the range -8191 to +8191:
\
\     * y_sign is randomly positive or negative
\     * y_hi is a random number in the range 0 to 31
\     * y_lo is a random number in the range 0 to 255
\
\   * z_sign is a random number in the range 4352 to 20224:
\
\     * z_sign is 0 (positive)
\     * z_hi is a random number in the range 17 to 79
\     * z_lo is 0
\
\ In other words, the ship is randomly up, down, left or right, but is always in
\ front of us.
\
\ Returns:
\
\   A                   A is set to a random number
\
\   X                   X is set to a random number
\
\   T1                  T1 is set to a random number
\
\ ******************************************************************************

.rand_posn

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 JSR DORND              \ Set A and X to random numbers

 STA INWK               \ Set x_lo to the random number in A

 STX INWK+3             \ Set y_lo to the random number in X

 STA T1                 \ Store x_lo in T1

 LSR A                  \ Set bit 7 of x_sign randomly (to bit 0 of the random
 ROR INWK+2             \ number in A), so the x-coordinate it is randomly
                        \ positive or negative

 LSR A                  \ Set bit 7 of y_sign randomly (to bit 1 of the random
 ROR INWK+5             \ number in A), so the y-coordinate it is randomly
                        \ positive or negative

 LSR A                  \ Set bits 0-4 of y_hi randomly (to bits 3-7 of the
 STA INWK+4             \ random number in A), so the high byte of the
                        \ y-coordinate is in the range 0 to 31

 TXA                    \ Set x_hi to the random number X, reduced to the range
 AND #31                \ 0 to 31
 STA INWK+1

 LDA #80                \ Set z_hi = 80 - x_hi - y_hi - 1
 SBC INWK+1             \
 SBC INWK+4             \ The C flag is clear as INWK+4 was 0 before the ROR
 STA INWK+7             \ above, so this sets z_hi in the range 17 to 79
                        \ (as x_hi and y_hi are both in the range 0 to 31)

 JMP DORND              \ Set A and X to random numbers and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: THERE
\       Type: Subroutine
\   Category: Missions
\    Summary: Check whether we are in the Constrictor's system in mission 1
\
\ ------------------------------------------------------------------------------
\
\ The stolen Constrictor is the target of mission 1. We finally track it down to
\ the Orarra system in the second galaxy, which is at galactic coordinates
\ (144, 33). This routine checks whether we are in this system and sets the C
\ flag accordingly.
\
\ Returns:
\
\   C flag              Set if we are in the Constrictor system, otherwise clear
\
\ ******************************************************************************

.THERE

 LDX GCNT               \ Set X = GCNT - 1
 DEX

 BNE THEX               \ If X is non-zero (i.e. GCNT is not 1, so we are not in
                        \ the second galaxy), then jump to THEX

 LDA QQ0                \ Set A = the current system's galactic x-coordinate

 CMP #144               \ If A <> 144 then jump to THEX
 BNE THEX

 LDA QQ1                \ Set A = the current system's galactic y-coordinate

 CMP #33                \ If A = 33 then set the C flag

 BEQ THEX+1             \ If A = 33 then jump to THEX+1, so we return from the
                        \ subroutine with the C flag set (otherwise we clear the
                        \ C flag with the next instruction)

.THEX

 CLC                    \ Clear the C flag

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Ze
\       Type: Subroutine
\   Category: Universe
\    Summary: Initialise the INWK workspace to a hostile ship
\  Deep dive: Fixing ship positions
\
\ ------------------------------------------------------------------------------
\
\ Specifically, this routine does the following:
\
\   * Reset the INWK ship workspace
\
\   * Set the ship to a fair distance away in all axes, in front of us but
\     randomly up or down, left or right
\
\   * Give the ship a 4% chance of having E.C.M.
\
\   * Set the ship to hostile, with AI enabled
\
\ This routine also sets A, X, T1 and the C flag to random values.
\
\ Note that because this routine uses the value of X returned by DORND, and X
\ contains the value of A returned by the previous call to DORND, this routine
\ does not necessarily set the new ship to a totally random location. See the
\ deep dive on "Fixing ship positions" for details.
\
\ ******************************************************************************

.Ze

 JSR rand_posn          \ Call rand_posn to set up the INWK workspace for a ship
                        \ in a random ship position, and set T1 to a random
                        \ number

 CMP #245               \ Set the C flag if A >= 245 (4% chance)

 ROL A                  \ Set bit 0 of A to the C flag (i.e. there's a 4%
                        \ chance of this ship having E.C.M.)

 ORA #%11000000         \ Set bits 6 and 7 of A, so the ship is hostile (bit 6
                        \ and has AI (bit 7)

 STA INWK+32            \ Store A in the AI flag of this ship

                        \ Fall through into DORND2 to set A, X and the C flag
                        \ randomly

\ ******************************************************************************
\
\       Name: DORND2
\       Type: Subroutine
\   Category: Utility routines
\    Summary: Generate random numbers, making sure the C flag doesn't affect the
\             outcome
\  Deep dive: Generating random numbers
\
\ ******************************************************************************

.DORND2

 CLC                    \ Clear the C flag so the value of the C flag on entry
                        \ doesn't affect the outcome

 JMP DORND              \ Jump to DORND to generate random numbers in A and X,
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: Main game loop for flight (Part 1 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Spawn a trader (a Cobra Mk III, Python, Boa or Anaconda)
\  Deep dive: Program flow of the main game loop
\             Ship data blocks
\
\ ------------------------------------------------------------------------------
\
\ This is part of the main game loop. This is the loop for when we are in
\ flight, while the main game loop for when we are docked is at TT100.
\
\ This section covers the following:
\
\   * Spawn a trader, i.e. a Cobra Mk III, Python, Boa or Anaconda, with a 50%
\     chance of it having a missile, a 50% chance of it having an E.C.M., a 50%
\     chance of it docking and being aggressive if attacked, a speed between 16
\     and 31, and a gentle clockwise roll
\
\ We call this from within the main loop.
\
\ ******************************************************************************

.MTT4

 JSR DORND              \ Set A and X to random numbers

 LSR A                  \ Clear bit 7 of our random number in A and set the C
                        \ flag to bit 0 of A, which is random

 STA INWK+32            \ Store this in the ship's AI flag, so this ship does
                        \ not have AI

 STA INWK+29            \ Store A in the ship's roll counter, giving it a
                        \ clockwise roll (as bit 7 is clear), and a 1 in 127
                        \ chance of it having no damping

 ROL INWK+31            \ Set bit 0 of the ship's missile count randomly (as the
                        \ C flag was set), giving the ship either no missiles or
                        \ one missile

 AND #15                \ Set the ship speed to our random number, set to a
 STA INWK+27            \ minimum of 0 and a maximum of 15

 JSR DORND              \ Set A and X to random numbers, plus the C flag

 BMI nodo               \ If A is negative (50% chance), jump to nodo to skip
                        \ the following

                        \ If we get here then we are going to spawn a ship that
                        \ is minding its own business and trying to dock

 LDA INWK+32            \ Set bits 6 and 7 of the ship's AI flag, to make it
 ORA #%11000000         \ aggressive if attacked, and enable its AI
 STA INWK+32

 LDX #%00010000         \ Set bit 4 of the ship's NEWB flags, to indicate that
 STX NEWB               \ this ship is docking

.nodo

 LDA #11                \ Call hordes to spawn a pack of ships from ship slots
 LDX #3                 \ 11 to 14, which is where the trader ships live in the
 JMP hordes             \ ship files

\ ******************************************************************************
\
\       Name: Main game loop for flight (Part 2 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Update the main loop counters
\
\ ******************************************************************************

.TT100_FLIGHT

 JSR M%                 \ Call M% to iterate through the main flight loop

 DEC DLY                \ Decrement the delay counter in DLY, so any in-flight
                        \ messages get removed once the counter reaches zero

 BEQ me2_flight         \ If DLY is now 0, jump to me2_flight to remove any
                        \ in-flight message from the space view, and once done,
                        \ return to me3_flight below, skipping the following
                        \ two instructions

 BPL me3_flight         \ If DLY is positive, jump to me3_flight to skip the
                        \ next instruction

 INC DLY                \ If we get here, DLY is negative, so we have gone too
                        \ and need to increment DLY back to 0

.me3_flight

 DEC MCNT               \ Decrement the main loop counter in MCNT

 BEQ d_3fd4             \ If the counter has reached zero, which it will do
                        \ every 256 main loops, skip the next JMP instruction
                        \ (or to put it another way, if the counter hasn't
                        \ reached zero, jump down to MLOOP, skipping all the
                        \ following checks)

.ytq_flight

 JMP MLOOP_FLIGHT       \ Jump down to MLOOP_FLIGHT to do some end-of-loop
                        \ tidying and restart the main loop

                        \ We only get here once every 256 iterations of the
                        \ main loop. If we aren't in witchspace and don't
                        \ already have 3 or more asteroids in our local bubble,
                        \ then this section has a 13% chance of spawning
                        \ something benign (the other 87% of the time we jump
                        \ down to consider spawning cops, pirates and bounty
                        \ hunters)
                        \
                        \ If we are in that 13%, then 50% of the time this will
                        \ be a Cobra Mk III trader, and the other 50% of the
                        \ time it will either be an asteroid (98.5% chance) or,
                        \ very rarely, a cargo canister (1.5% chance)

.me2_flight

 LDA MCH                \ Fetch the token number of the current message into A

 JSR MESS               \ Call MESS to print the token, which will remove it
                        \ from the screen as printing uses EOR logic

 LDA #0                 \ Set the delay in DLY to 0, so any new in-flight
 STA DLY                \ messages will be shown instantly

 JMP me3_flight         \ Jump back into the main spawning loop at me3_flight

.d_3fd4

 LDA MJ                 \ If we are in witchspace following a mis-jump, skip the
 BNE ytq_flight         \ following by jumping down to MLOOP_FLIGHT (via
                        \ ytq_flight above)

 JSR DORND              \ Set A and X to random numbers

 CMP #51                \ If A >= 51 (80% chance), jump down to MTT1 to skip
 BCS MTT1               \ the spawning of an asteroid or cargo canister and
                        \ potentially spawn something else

 LDA JUNK               \ If we already have 3 or more bits of junk in the local
 CMP #3                 \ bubble, jump down to MTT1 to skip the following and
 BCS MTT1               \ potentially spawn something else

 JSR rand_posn          \ Call rand_posn to set up the INWK workspace for a ship
                        \ in a random ship position

 BVS MTT4               \ If V flag is set (50% chance), jump up to MTT4 to
                        \ spawn a trader

 ORA #%01101111         \ Take the random number in A and set bits 0-3 and 5-6,
 STA INWK+29            \ so the result has a 50% chance of being positive or
                        \ negative, and a 50% chance of bits 0-6 being 127.
                        \ Storing this number in the roll counter therefore
                        \ gives our new ship a fast roll speed with a 50%
                        \ chance of having no damping, plus a 50% chance of
                        \ rolling clockwise or anti-clockwise

 LDA SSPR               \ If we are inside the space station safe zone, jump
 BNE MLOOPS             \ down to MLOOPS to skip the following and potentially
                        \ spawn something else

 TXA                    \ Set A to the random X we set above, which we haven't
 BCS MTT2               \ used yet, and if the C flag is set (50% chance) jump
                        \ down to MTT2 to skip the following

 AND #15                \ Set the ship speed to our random number, reduced to
 STA INWK+27            \ the range 0 to 15

 BCC MTT3               \ Jump down to MTT3, skipping the following (this BCC
                        \ is effectively a JMP as we know the C flag is clear,
                        \ having passed through the BCS above)

.MTT2

 ORA #%01111111         \ Set bits 0-6 of A to 127, leaving bit 7 as random, so
 STA INWK+30            \ storing this number in the pitch counter means we have
                        \ full pitch with no damping, with a 50% chance of
                        \ pitching up or down

.MTT3

 JSR DORND              \ Set A and X to random numbers

 CMP #10                \ If random A >= 10 (96% of the time), set the C flag

 AND #1                 \ Reduce A to a random number that's 0 or 1

 ADC #OIL               \ Set A = #OIL + A + C, so there's a tiny chance of us
                        \ spawning a cargo canister (#OIL) and an even chance of
                        \ us spawning either a boulder (#OIL + 1) or an asteroid
                        \ (#OIL + 2)

 BNE horde_plain        \ Jump to horde_plain to spawn a whole pack of cargo
                        \ canisters, boulders or asteroids, according to the
                        \ value of A (the BNE is effectively a JMP, as A will
                        \ never be zero)

\ ******************************************************************************
\
\       Name: Main game loop for flight (Part 3 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Potentially spawn a cop, particularly if we've been bad
\  Deep dive: Program flow of the main game loop
\             Ship data blocks
\             Fixing ship positions
\
\ ------------------------------------------------------------------------------
\
\ This section covers the following:
\
\   * Potentially spawn a cop (in a Viper), very rarely if we have been good,
\     more often if have been naughty, and very often if we have been properly
\     bad
\
\ ******************************************************************************

.MTT1

 LDA SSPR               \ If we are outside the space station's safe zone, skip
 BEQ P%+5               \ the following instruction

.MLOOPS

 JMP MLOOP_FLIGHT       \ Jump to MLOOP_FLIGHT to skip the following

 JSR BAD                \ Call BAD to work out how much illegal contraband we
                        \ are carrying in our hold (A is up to 40 for a
                        \ standard hold crammed with contraband, up to 70 for
                        \ an extended cargo hold full of narcotics and slaves)

 ASL A                  \ Double A to a maximum of 80 or 140

 LDX MANY+COPS          \ If there are no cops in the local bubble, skip the
 BEQ P%+5               \ next instruction

 ORA FIST               \ There are cops in the vicinity and we've got a hold
                        \ full of jail time, so OR the value in A with FIST to
                        \ get a new value that is at least as high as both
                        \ values, to reflect the fact that they have almost
                        \ certainly scanned our ship

 STA T                  \ Store our badness level in T

 JSR Ze                 \ Call Ze to initialise INWK to a potentially hostile
                        \ ship, and set A and X to random values
                        \
                        \ Note that because Ze uses the value of X returned by
                        \ DORND, and X contains the value of A returned by the
                        \ previous call to DORND, this does not set the new ship
                        \ to a totally random location. See the deep dive on
                        \ "Fixing ship positions" for details

 CMP T                  \ If the random value in A >= our badness level, which
 BCS P%+8               \ will be the case unless we have been really, really
                        \ bad, then skip the following three instructions (so
                        \ if we are really bad, there's a higher chance of
                        \ spawning a cop, otherwise we got away with it, for
                        \ now)

 LDA #COPS              \ Set A to the ship type for a cop, so the following
                        \ call to hordes will spawn a pack of cops

.horde_plain

 LDX #0                 \ Jump to hordes to spawn a pack of ships of type A,
 BEQ hordes             \ returning from the subroutine using a tail call (the
                        \ BEQ is effectively a JMP as X is always zero)

 LDA MANY+COPS          \ If we now have at least one cop in the local bubble,
 BNE MLOOPS             \ jump down to MLOOPS to stop spawning, otherwise fall
                        \ through into the next part to look at spawning
                        \ something else

\ ******************************************************************************
\
\       Name: Main game loop for flight (Part 4 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Potentially spawn a lone bounty hunter, a Thargoid, or up to four
\             pirates
\  Deep dive: Program flow of the main game loop
\             Ship data blocks
\             Fixing ship positions
\
\ ------------------------------------------------------------------------------
\
\ This section covers the following:
\
\   * Potentially spawn (47% chance) either a pack of up to 8 bounty hunters,
\     a Thargoid, or a pack of up to 8 pirates
\
\   * Also potentially spawn a Constrictor if this is the mission 1 endgame, or
\     Thargoids if mission 2 is in progress
\
\ Other entry points:
\
\   hordes              Spawn a pack of ships, made up of ships from type A to
\                       type A + X, with the pack size normally being one to
\                       four ships, but rarely being up to eight ships
\
\ ******************************************************************************

 DEC EV                 \ Decrement EV, the extra vessels spawning delay, and if
 BPL MLOOPS             \ it is still positive, jump to MLOOPS to stop spawning,
                        \ so we only do the following when the EV counter runs
                        \ down

 INC EV                 \ EV is negative, so bump it up again, setting it back
                        \ to 0

 LDA TP                 \ Fetch bits 2 and 3 of TP, which contain the status of
 AND #%00001100         \ mission 2

 CMP #%00001000         \ If bit 3 is set and bit 2 is clear, keep going to
 BNE nopl               \ spawn a Thargoid as we are transporting the plans in
                        \ mission 2 and the Thargoids are trying to stop us,
                        \ otherwise jump to nopl to skip spawning a Thargoid

 JSR DORND              \ Set A and X to random numbers

 CMP #200               \ If the random number in A < 200 (78% chance), jump to
 BCC nopl               \ nopl to skip spawning a Thargoid

.fothg2

 JSR GTHG               \ Call GTHG to spawn a Thargoid ship and a Thargon
                        \ companion

.nopl

 JSR DORND              \ Set A and X to random numbers

 LDY gov                \ If the government of this system is 0 (anarchy), jump
 BEQ LABEL_2            \ straight to LABEL_2 to start spawning pirates or
                        \ bounty hunters

 CMP #120               \ If the random number in A >= 120 (53% chance), jump to
 BCS MLOOPS             \ MLOOPS to stop spawning (so there's a 47% chance of
                        \ spawning pirates or bounty hunters)

 AND #7                 \ Reduce the random number in A to the range 0-7, and
 CMP gov                \ if A is less than government of this system, jump
 BCC MLOOPS             \ to MLOOPS to stop spawning (so safer governments with
                        \ larger gov numbers have a greater chance of jumping
                        \ out, which is another way of saying that more
                        \ dangerous systems spawn pirates and bounty hunters
                        \ more often)

.LABEL_2

                        \ Now to spawn a group of bounty hunters, a Thargoid or
                        \ a pack of pirates

 CPX #100               \ If the random number in X >= 100 (61% chance), jump
 BCS mt1                \ to mt1 to spawn pirates, otherwise keep going to
                        \ spawn bounty hunters or a Thargoid

 INC EV                 \ Increase the extra vessels spawning counter, to
                        \ prevent the next attempt to spawn extra vessels

 AND #3                 \ Set A = random number in the range 0-3, which we
                        \ will now use to determine the type of ship

 ADC #25                \ Add A to 25 (we know the C flag is clear as we passed
                        \ through the BCS above), so A is now a ship blueprint
                        \ position in the range 25-28, which is where the bounty
                        \ hunter ships live in the ship files

 TAY                    \ Copy the new ship type to Y

 JSR THERE              \ Call THERE to see if we are in the Constrictor's
                        \ system in mission 1

 BCC NOCON              \ If the C flag is clear then we are not in the
                        \ Constrictor's system, so skip to NOCON

 LDA #%11111001         \ Set the AI flag of this ship so that it has E.C.M.,
 STA INWK+32            \ has a very high aggression level of 28 out of 31, is
                        \ hostile, and has AI enabled - nasty stuff!

 LDA TP                 \ Fetch bits 0 and 1 of TP, which contain the status of
 AND #%00000011         \ mission 1

 LSR A                  \ Shift bit 0 into the C flag

 BCC NOCON              \ If bit 0 is clear, skip to NOCON as mission 1 is not
                        \ in progress

 ORA MANY+CON           \ Bit 0 of A now contains bit 1 of TP, so this will be
                        \ set if we have already completed mission 1, so this OR
                        \ will be non-zero if we have either completed mission
                        \ 1, or there is already a Constrictor in our local
                        \ bubble of universe (in which case MANY+CON will be
                        \ non-zero)

 BEQ YESCON             \ If A = 0 then mission 1 is in progress, we haven't
                        \ completed it yet, and there is no Constrictor in the
                        \ vicinity, so jump to YESCON to spawn the Constrictor

.NOCON

 TYA                    \ Set A to the new ship type in Y

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &1F, or BIT &1FA9, which does nothing apart
                        \ from affect the flags

.YESCON

 LDA #CON               \ If we jump straight here, we are in the mission 1
                        \ endgame and it's time to spawn the Constrictor, so
                        \ set A to the Constrictor's type

.focoug

 JSR NWSHP              \ Spawn the new ship, whether it's a pirate, Thargoid or
                        \ Constrictor

.mj1

 JMP MLOOP_FLIGHT       \ Jump down to MLOOP_FLIGHT, as we are done spawning
                        \ ships

.mt1

 LDA #17                \ Fall through into hordes to spawn a pack of ships from
 LDX #7                 \ ship blueprint positions 17 to 24, which is where the
                        \ pirate ships live in the ship blueprint files

.hordes

                        \ This routine spawns a pack of ships, made up of ships
                        \ from type A to type A + X, with the pack size normally
                        \ being one to four ships, but rarely being up to eight
                        \ ships
                        \
                        \ Let's call A the "base ship type", and X the "ship
                        \ type range"

 STA horde_base+1       \ Modify the ADC instruction at horde_base so that it
                        \ adds the base ship type given in A

 STX horde_mask+1       \ Modify the ADC instruction at horde_mask so that it
                        \ ANDs the ship type range given in X

 JSR DORND              \ Set A and X to random numbers

 CMP #248               \ If A >= 248 (3.1% chance), jump to horde_large so we
 BCS horde_large        \ potentially spawn a larger pack (i.e. up to 8 ships)

 STA XX13               \ We are going to spawn a smaller pack (i.e. up to 4
 TXA                    \ ships), so set:
 AND XX13               \
 AND #3                 \   A = A AND X AND 3
                        \
                        \ to give a random pack size of 0-3, with a greater
                        \ chance of the smaller numbers than the larger ones
                        \ (due to the AND). This will be our pack size, which
                        \ won't be affected further by the following AND
                        \ instruction

.horde_large

 AND #7                 \ If we are going to spawn a larger pack, reduce the
                        \ random number in A to the range 0-7, with an equal
                        \ chance of each of the numbers. This will be our pack
                        \ size

                        \ By this point our pack size is in A, and is either
                        \ 0-3 or 0-7

 STA EV                 \ Delay further spawnings by this number

 STA XX13               \ Store the number in XX13, the pack size counter

.mt3

 JSR DORND              \ Set A and X to random numbers

 STA T                  \ Set A = A AND X
 TXA                    \
 AND T                  \ which is in the range 0-255, but with a greater chance
                        \ of being a smaller number (due to the AND)

.horde_mask

 AND #&FF               \ This instruction gets modified so that it ANDs the
                        \ ship type range given in the argument X to the
                        \ hordes routine, i.e. it turns into AND #type_range,
                        \ which reduces our random number to be between 0 and
                        \ the ship type range (so if we add this number to the
                        \ base ship type, it will pick a random ship type from
                        \ within the range A to A + X, where A and X are the
                        \ arguments to the original call to hordes

 STA CPIR               \ Set CPIR to our random number in the range 0 to
                        \ the ship type

.more

 LDA CPIR               \ Set A to the ship type in CPIR

 CLC                    \ Clear the C flag for the addition below

.horde_base

 ADC #0                 \ This instruction gets modified so that it adds the
                        \ ship type given in the argument A to the hordes
                        \ routine, i.e. it turns into ADC #ship_type, so this
                        \ sets A to a ship type in the range we want

 INC INWK+27            \ Increment the speed of the ship we are about to spawn,
                        \ so later ships in the pack go faster

 INC INWK+1             \ Increment the x_hi coordinate of the ship we are about
                        \ to spawn, so later ships in the pack are spread out to
                        \ the sides

 INC INWK+4             \ Increment the y_hi coordinate of the ship we are about
                        \ to spawn, so later ships in the pack are spread out
                        \ to the top and bottom

 JSR NWSHP              \ Try adding a new ship of type A to the local bubble

 CMP #24                \ This compares the value of A (which is set to the
                        \ x_sign value of the spawned ship by NWSHP), but the
                        \ result isn't used anywhere, as CMP affects the Z and N
                        \ flags (not the C flag), and these same flags will be
                        \ overwritten by the two DEC instructions below... so
                        \ instruction has no effect

 BCS P%+7               \ If the ship was successfully added, skip the following
                        \ two instructions

 DEC CPIR               \ The ship wasn't added, which might be because the ship
                        \ blueprint for this ship type isn't in the currently
                        \ loaded ship blueprints file, so decrement CPIR to
                        \ point to the previous ship type, so we can try
                        \ spawning that type of ship instead

 BPL more               \ Loop back to more to have another go at spawning this
                        \ ship, until CPIR is 0, in which case we have tried
                        \ spawning all the ship types in the range, so give up
                        \ and move on to the next pirate to spawn

 DEC XX13               \ Decrement the pack size counter

 BPL mt3                \ If we need more ships, loop back up to mt3,
                        \ otherwise we are done spawning, so fall through into
                        \ the end of the main loop at MLOOP

\ ******************************************************************************
\
\       Name: Main game loop for flight (Part 5 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Cool down lasers, make calls to update the dashboard
\
\ ******************************************************************************

.MLOOP_FLIGHT

 LDX #&FF               \ Set the stack pointer to &01FF, which is the standard
 TXS                    \ location for the 6502 stack, so this instruction
                        \ effectively resets the stack

 LDX GNTMP              \ If the laser temperature in GNTMP is non-zero,
 BEQ EE20               \ decrement it (i.e. cool it down a bit)
 DEC GNTMP

.EE20

 JSR DIALS              \ Call DIALS to update the dashboard

 JSR COMPAS             \ Call COMPAS to update the compass

 LDA QQ11               \ If this is a space view, skip the following two
 BEQ P%+7               \ instructions (i.e. jump to JSR TT17 below)

\AND PATG               \ These instructions are commented out in the original
\LSR A                  \ source
\BCS d_40f8

 LDY #2                 \ Wait for 2/50 of a second (0.04 seconds), to slow the
 JSR DELAY              \ main loop down a bit

\JSR WSCAN              \ This instruction is commented out in the original
                        \ source

 JSR DOKEY_FLIGHT       \ Scan the keyboard for flight controls and pause keys,
                        \ (or the equivalent on joystick) and update the key
                        \ logger, setting KL to the key pressed

 JSR chk_dirn           \ Call chk_dirn to set the movement variables based on
                        \ the current state of the key logger

\ ******************************************************************************
\
\       Name: Main game loop for flight (Part 6 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Process non-flight key presses (red function keys, docked keys)
\
\ ******************************************************************************

.FRCE_FLIGHT

 PHA                    \ Store the key to "press" in A on the stack

 LDA QQ22+1             \ Fetch QQ22+1, which contains the number that's shown
                        \ on-screen during hyperspace countdown

 BNE d_locked           \ If the hyperspace countdown is non-zero, jump to
                        \ d_locked so the key does not get "pressed"

 PLA                    \ Retrieve the key to "press" from the stack into A so
                        \ we can now process it

 JSR TT102              \ Call TT102 to process the key pressed in A

 JMP TT100_FLIGHT       \ Otherwise jump to TT100_FLIGHT to restart the main
                        \ loop from the start

.d_locked

 PLA                    \ Retrieve the key to "press" from the stack into A

 JSR TT107              \ Call TT107 to progress the countdown of the hyperspace
                        \ counter

 JMP TT100_FLIGHT       \ Jump to TT100_FLIGHT to restart the main loop from
                        \ the start

\ ******************************************************************************
\
\       Name: TT102
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process function key, save key, hyperspace and chart key presses
\
\ ------------------------------------------------------------------------------
\
\ Process function key presses, plus "@" (save commander), "H" (hyperspace),
\ "D" (show distance to system) and "O" (move chart cursor back to current
\ system). We can also pass cursor position deltas in X and Y to indicate that
\ the cursor keys or joystick have been used (i.e. the values that are returned
\ by routine TT17).
\
\ Arguments:
\
\   A                   The internal key number of the key pressed (see p.142 of
\                       the Advanced User Guide for a list of internal key
\                       numbers)
\
\   X                   The amount to move the crosshairs in the x-axis
\
\   Y                   The amount to move the crosshairs in the y-axis
\
\ Other entry points:
\
\   BAD                 Work out how bad we are from the amount of contraband in
\                       our hold
\
\   T95                 Print the distance to the selected system
\
\   TT107               Progress the countdown of the hyperspace counter
\
\ ******************************************************************************

.TT102

 CMP #f8                \ If red key f8 was pressed, jump to STATUS to show the
 BNE P%+5               \ Status Mode screen, returning from the subroutine
 JMP STATUS             \ using a tail call

 CMP #f4                \ If red key f4 was pressed, jump to TT22 to show the
 BNE P%+5               \ Long-range Chart, returning from the subroutine using
 JMP TT22               \ a tail call

 CMP #f5                \ If red key f5 was pressed, jump to TT23 to show the
 BNE P%+5               \ Short-range Chart, returning from the subroutine using
 JMP TT23               \ a tail call

 CMP #f6                \ If red key f6 was pressed, call TT111 to select the
 BNE TT92               \ system nearest to galactic coordinates (QQ9, QQ10)
 JSR TT111              \ (the location of the chart crosshairs) and set ZZ to
 JMP TT25               \ the system number, and then jump to TT25 to show the
                        \ Data on System screen (along with an extended system
                        \ description for the system in ZZ if we're docked),
                        \ returning from the subroutine using a tail call

.TT92

 CMP #f9                \ If red key f9 was pressed, jump to TT213 to show the
 BNE P%+5               \ Inventory screen, returning from the subroutine
 JMP TT213              \ using a tail call

 CMP #f7                \ If red key f7 was pressed, jump to TT167 to show the
 BNE P%+5               \ Market Price screen, returning from the subroutine
 JMP TT167              \ using a tail call

.LABEL_3

 CMP #&32               \ If "D" was pressed, jump to T95 to print the distance
 BEQ T95                \ to a system (if we are in one of the chart screens)

 CMP #&43               \ If "F" was not pressed, jump down to HME1, otherwise
 BNE HME1               \ keep going to process searching for systems (when
                        \ docked) or toggle the compass display (when flying)

 LDA QQ11               \ If the current view is a chart (QQ11 = 64 or 128),
 AND #%11000000         \ keep going, otherwise jump to n_finder
 BEQ n_finder

 LDA dockedp            \ If dockedp is non-zero, then we are not docked and
 BNE t95                \ can't search for a system, so return from the
                        \ subroutine (as t95 contains an RTS)

 JMP HME2               \ Jump to HME2 to let us search for a system, returning
                        \ from the subroutine using a tail call

.n_finder

 LDA dockedp            \ If dockedp is zero, then we are docked and we can't
 BEQ t95                \ change the compass configuration, so return from the
                        \ subroutine (as t95 contains an RTS)

 LDA finder             \ Set the value of A to finder, which determines whether
                        \ the compass is configured to show the sun or the
                        \ planet

 EOR #NI%               \ The value of finder is 0 (show the planet) or NI%
                        \ (show the sun), so this toggles the value between the
                        \ two

 STA finder             \ Store the toggled value in finder

 JMP WSCAN              \ Jump to WSCAN to wait for the vertical sync and return
                        \ from the subroutine using a tail call

.t95

 RTS                    \ Return from the subroutine

.HME1

 CMP #&36               \ If "O" was pressed, do the following, otherwise skip
 BNE not_home           \ to not_home to continue checking key presses

 LDA QQ11               \ If bits 6 and 7 of the view number are both clear - so
 AND #%11000000         \ this is not the Short-range or Long-range Chart - then
 BEQ t95                \ jump to t95 to return from the subroutine, otherwise
                        \ do the following three jumps

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will erase the crosshairs currently there

 JSR ping               \ Set the target system to the current system (which
                        \ will move the location in (QQ9, QQ10) to the current
                        \ home system

 JMP TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will draw the crosshairs at our current home
                        \ system, and return from the subroutine using a tail
                        \ call

.not_home

 CMP #&21               \ If "W" was pressed, continue on to move the crosshairs
 BNE ee2                \ to the special cargo destination, otherwise skip to
                        \ ee2 to continue

 LDA QQ11               \ If bits 6 and 7 of the view number are both clear - so
 AND #%11000000         \ this is not the Short-range or Long-range Chart - then
 BEQ t95                \ jump to t95 to return from the subroutine, otherwise
                        \ do the following three jumps

 LDA cmdr_cour          \ If there is no special cargo delivery mission in
 ORA cmdr_cour+1        \ progress, then the mission timer in cmdr_cour(1 0)
 BEQ t95                \ will be zero, so return from the subroutine (as t95
                        \ contains an RTS)

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will erase the crosshairs currently there

 LDA cmdr_courx         \ Set the galactic coordinates in (QQ9, QQ10) to the
 STA QQ9                \ current special cargo delivery destination in
 LDA cmdr_coury         \ (cmdr_courx, cmdr_coury)
 STA QQ10

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will draw the crosshairs at our current home
                        \ system

.T95

                        \ If we get here, "D" was pressed, so we need to show
                        \ the distance to the selected system (if we are in a
                        \ chart view)

 LDA QQ11               \ If the current view is a chart (QQ11 = 64 or 128),
 AND #%11000000         \ keep going, otherwise return from the subroutine (as
 BEQ t95                \ t95 contains an RTS)

 JSR hm                 \ Call hm to move the crosshairs to the target system
                        \ in (QQ9, QQ10), returning with A = 0

 STA QQ17               \ Set QQ17 = 0 to switch to ALL CAPS

 JSR cpl                \ Print control code 3 (the selected system name)

 LDA #%10000000         \ Set bit 7 of QQ17 to switch to Sentence Case, with the
 STA QQ17               \ next letter in capitals

 LDA #1                 \ Move the text cursor to column 1 and down one line
 STA XC                 \ (in other words, to the start of the next line)
 INC YC

 JMP TT146              \ Print the distance to the selected system and return
                        \ from the subroutine using a tail call

.ee2

 BIT dockedp            \ If bit 7 of dockedp is set, then we are not docked, so
 BMI flying             \ jump to flying

 CMP #f0                \ If red key f0 was not pressed, jump to fvw to check
 BNE fvw                \ for the next key

 JSR CTRL               \ Red key f0 was pressed, so check whether CTRL was
 BMI jump_stay          \ also pressed, and if so, jump to jump_stay to skip the
                        \ following instruction

 JMP RSHIPS             \ Red key f0 was pressed on its own, so jump to RSHIPS
                        \ to launch our ship, returning from the subroutine
                        \ using a tail call

.jump_stay

 JMP stay_here          \ CTRL-f0 was pressed, so jump to stay_here to pay the
                        \ docking fee and refresh prices

.fvw

 CMP #f3                \ If red key f3 was pressed, jump to EQSHP to show the
 BNE P%+5               \ Equip Ship screen, returning from the subroutine using
 JMP EQSHP              \ a tail call

 CMP #f1                \ If red key f1 was pressed, jump to TT219 to show the
 BNE P%+5               \ Buy Cargo screen, returning from the subroutine using
 JMP TT219              \ a tail call

 CMP #&47               \ If "@" was not pressed, skip to nosave
 BNE nosave

 JSR SVE                \ "@" was pressed, so call SVE to show the disc access
                        \ menu

 BCC P%+5               \ If the C flag was set by SVE, then we loaded a new
 JMP QU5                \ commander file, so jump to QU5 to restart the game
                        \ with the newly loaded commander

 JMP BAY                \ Otherwise the C flag was clear, so jump to BAY to go
                        \ to the docking bay (i.e. show the Status Mode screen)

.nosave

 CMP #f2                \ If red key f2 was pressed, jump to TT208 to show the
 BNE not_sell           \ Sell Cargo screen, returning from the subroutine using
 JMP TT208              \ a tail call

.not_sell

 CMP #&54               \ If "H" was not pressed, jump to NWDAV5 to skip the
 BNE NWDAV5             \ following

 JSR CLYNS              \ "H" was pressed, so clear the bottom three text rows
                        \ of the upper screen, and move the text cursor to
                        \ column 1 on row 21, i.e. the start of the top row of
                        \ the three bottom rows

 LDA #15                \ Move the text cursor to column 15 (the middle of the
 STA XC                 \ screen)

 LDA #205               \ Print extended token 205 ("DOCKED") and return from
 JMP DETOK              \ the subroutine using a tail call

.flying

 CMP #&20               \ If "D" was pressed, jump to TT110 to print the
 BNE P%+5               \ distance to a system (if we are in one of the chart
 JMP TT110              \ screens)

 CMP #f1                \ If the key pressed is < red key f1 or > red key f3,
 BCC d_4143             \ jump to d_4143 (so only do the following if the key
 CMP #f3+1              \ pressed is f1, f2 or f3)
 BCS d_4143

 AND #3                 \ If we get here then we are either in space, or we are
 TAX                    \ docked and none of f1-f3 were pressed, so we can now
 JMP LOOK1              \ process f1-f3 with their in-flight functions, i.e.
                        \ switching space views
                        \
                        \ A will contain &71, &72 or &73 (for f1, f2 or f3), so
                        \ set X to the last digit (1, 2 or 3) and jump to LOOK1
                        \ to switch to view X (rear, left or right), returning
                        \ from the subroutine using a tail call

.d_4143

 CMP #&54               \ If "H" was not pressed, jump to NWDAV5 to skip the
 BNE NWDAV5             \ following

 JMP hyp                \ Jump to hyp to do a hyperspace jump (if we are in
                        \ space), returning from the subroutine using a tail
                        \ call

.TT107

 LDA QQ22+1             \ If the on-screen hyperspace counter is zero, return
 BEQ d_418a             \ from the subroutine (as d_418a contains an RTS), as we
                        \ are not currently counting down to a hyperspace jump

 DEC QQ22               \ Decrement the internal hyperspace counter

 BNE d_418a             \ If the internal hyperspace counter is still non-zero,
                        \ then we are still counting down, so return from the
                        \ subroutine (as d_418a contains an RTS)

                        \ If we get here then the internal hyperspace counter
                        \ has just reached zero and it wasn't zero before, so
                        \ we need to reduce the on-screen counter and update
                        \ the screen. We do this by first printing the next
                        \ number in the countdown sequence, and then printing
                        \ the old number, which will erase the old number
                        \ and display the new one because printing uses EOR
                        \ logic

 LDX QQ22+1             \ Set X = the on-screen hyperspace counter - 1
 DEX                    \ (i.e. the next number in the sequence)

 JSR ee3                \ Print the 8-bit number in X at text location (0, 1)

 LDA #5                 \ Reset the internal hyperspace counter to 5
 STA QQ22

 LDX QQ22+1             \ Set X = the on-screen hyperspace counter (i.e. the
                        \ current number in the sequence, which is already
                        \ shown on-screen)

 JSR ee3                \ Print the 8-bit number in X at text location (0, 1),
                        \ i.e. print the hyperspace countdown in the top-left
                        \ corner

 DEC QQ22+1             \ Decrement the on-screen hyperspace countdown

 BNE d_418a             \ If the countdown is not yet at zero, return from the
                        \ subroutine (as d_418a contains an RTS)

 JMP TT18               \ Otherwise the countdown has finished, so jump to TT18
                        \ to do a hyperspace jump, returning from the subroutine
                        \ using a tail call

.BAD

 LDA QQ20+3             \ Set A to the number of tonnes of slaves in the hold

 CLC                    \ Clear the C flag so we can do addition without the
                        \ C flag affecting the result

 ADC QQ20+6             \ Add the number of tonnes of narcotics in the hold

 ASL A                  \ Double the result and add the number of tonnes of
 ADC QQ20+10            \ firearms in the hold

.d_418a

 RTS                    \ Return from the subroutine

.NWDAV5

 LDA QQ11               \ If the current view is a chart (QQ11 = 64 or 128),
 AND #%11000000         \ keep going, otherwise return from the subroutine (as
 BEQ d_418a             \ d_418a contains an RTS)

 JMP TT16               \ Jump to TT16 to move the crosshairs by the amount in X
                        \ and Y, which were passed to this subroutine as
                        \ arguments, and return from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: FAROF
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Compare x_hi, y_hi and z_hi with 224
\
\ ------------------------------------------------------------------------------
\
\ Compare x_hi, y_hi and z_hi with 224, and set the C flag if all three <= 224,
\ otherwise clear the C flag.
\
\ Returns:
\
\   C flag              Set if x_hi <= 224 and y_hi <= 224 and z_hi <= 224
\
\                       Clear otherwise (i.e. if any one of them are bigger than
\                       224)
\
\ ******************************************************************************

.FAROF

 LDA #224               \ Set A = 224 and fall through into FAROF2 to do the
                        \ comparison

\ ******************************************************************************
\
\       Name: FAROF2
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Compare x_hi, y_hi and z_hi with A
\
\ ------------------------------------------------------------------------------
\
\ Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
\ otherwise clear the C flag.
\
\ Returns:
\
\   C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
\
\                       Clear otherwise (i.e. if any one of them are bigger than
\                       A)
\
\ ******************************************************************************

.FAROF2

 CMP INWK+1             \ If A < x_hi, C will be clear so jump to FA1 to
 BCC FA1                \ return from the subroutine with C clear, otherwise
                        \ C will be set so move on to the next one

 CMP INWK+4             \ If A < y_hi, C will be clear so jump to FA1 to
 BCC FA1                \ return from the subroutine with C clear, otherwise
                        \ C will be set so move on to the next one

 CMP INWK+7             \ If A < z_hi, C will be clear, otherwise C will be set

.FA1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MAS4
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate a cap on the maximum distance to a ship
\
\ ------------------------------------------------------------------------------
\
\ Logical OR the value in A with the high bytes of the ship's position (x_hi,
\ y_hi and z_hi).
\
\ Returns:
\
\   A                   A OR x_hi OR y_hi OR z_hi
\
\ ******************************************************************************

.MAS4

 ORA INWK+1             \ OR A with x_hi, y_hi and z_hi
 ORA INWK+4
 ORA INWK+7

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DEATH
\       Type: Subroutine
\   Category: Start and end
\    Summary: Display the death screen
\
\ ------------------------------------------------------------------------------
\
\ We have been killed, so display the chaos of our destruction above a "GAME
\ OVER" sign, and clean up the mess ready for the next attempt.
\
\ ******************************************************************************

.DEATH

 JSR EXNO3              \ Make the sound of us dying

 JSR RES2               \ Reset a number of flight variables and workspaces

 ASL DELTA              \ Divide our speed in DELTA by 4
 ASL DELTA

 LDX #24                \ Set the screen to only show 24 text rows, which hides
 JSR DET1               \ the dashboard, setting A to 6 in the process

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 6 (death
                        \ screen)

 JSR BOX                \ Call BOX to redraw the same white border (BOX is part
                        \ of TT66), which removes the border as it is drawn
                        \ using EOR logic

 JSR nWq                \ Create a cloud of stardust containing the correct
                        \ number of dust particles (i.e. NOSTM of them)

 LDA #12                \ Move the text cursor to column 12 on row 12
 STA YC
 STA XC

 LDA #146               \ Print recursive token 146 ("{all caps}GAME OVER")
 JSR ex

.D1

 JSR Ze                 \ Call Ze to initialise INWK to a potentially hostile
                        \ ship, and set A and X to random values

 LSR A                  \ Set A = A / 4, so A is now between 0 and 63, and
 LSR A                  \ store in byte #0 (x_lo)
 STA INWK

 LDY #0                 \ Set the following to 0: the current view in QQ11
 STY QQ11               \ (space view), x_hi, y_hi, z_hi and the AI flag (no AI
 STY INWK+1             \ or E.C.M. and not hostile)
 STY INWK+4
 STY INWK+7
 STY INWK+32

 DEY                    \ Set Y = 255

 STY MCNT               \ Reset the main loop counter to 255, so all timer-based
                        \ calls will be stopped

 EOR #%00101010         \ Flip bits 1, 3 and 5 in A (x_lo) to get another number
 STA INWK+3             \ between 48 and 63, and store in byte #3 (y_lo)

 ORA #%01010000         \ Set bits 4 and 6 of A to bump it up to between 112 and
 STA INWK+6             \ 127, and store in byte #6 (z_lo)

 TYA                    \ Tell the I/O processor to set its copy of LASCT to
 JSR write_0346         \ 255, to act as a counter in the D2 loop below, so this
                        \ setting determines how long the death animation lasts
                        \ (it's 5.1 seconds, as LASCT is decremented every
                        \ vertical sync, or 50 times a second, and
                        \ 255 / 50 = 5.1)

 TXA                    \ Set A to the random number in X and keep bits 0-3 and
 AND #%10001111         \ the sign in bit 7 to get a number between -15 and +15,
 STA INWK+29            \ and store in byte #29 (roll counter) to give our ship
                        \ a gentle roll with damping

 ROR A                  \ The C flag is randomly set from the above call to Ze,
 AND #%10000111         \ so this sets A to a number between -7 and +7, which
 STA INWK+30            \ we store in byte #30 (the pitch counter) to give our
                        \ ship a very gentle pitch with damping

 LDX #OIL               \ Set X to #OIL, the ship type for a cargo canister

 BCC D3                 \ If the C flag is clear, which will be random following
                        \ the above call to Ze, jump to D3 to skip the following
                        \ instruction

 DEX                    \ Decrement X, which sets it to #PLT, the ship type for
                        \ an alloy plate

.D3

 JSR fq1                \ Call fq1 with X set to #OIL or #PLT, which adds a new
                        \ cargo canister or alloy plate to our local bubble of
                        \ universe and points it away from us with double DELTA
                        \ speed (i.e. 6, as DELTA was set to 3 by the call to
                        \ RES2 above). INF is set to point to the new arrival's
                        \ ship data block in K%

 JSR DORND              \ Set A and X to random numbers and extract bit 7 from A
 AND #%10000000

 LDY #31                \ Store this in byte #31 of the ship's data block, so it
 STA (INF),Y            \ has a 50% chance of marking our new arrival as being
                        \ killed (so it will explode)

 LDA FRIN+4             \ The call we made to RES2 before we entered the loop at
 BEQ D1                 \ D1 will have reset all the ship slots at FRIN, so this
                        \ checks to see if the fifth slot is empty, and if it
                        \ is we loop back to D1 to add another canister, until
                        \ we have added five of them

 JSR U%                 \ Clear the key logger, which also sets A = 0

 STA DELTA              \ Set our speed in DELTA to 0, as we aren't going
                        \ anywhere any more

.D2

 JSR M%                 \ Call the M% routine to do the main flight loop once,
                        \ which will display our exploding canister scene and
                        \ move everything about

 JSR read_0346          \ Get the value of the I/O processor's copy of LASCT

 BNE D2                 \ Loop back to D2 to run the main flight loop until
                        \ LASCT reaches zero (which will take 5.1 seconds, as
                        \ explained above)

 LDX #31                \ Set the screen to show all 31 text rows, which shows
 JSR DET1               \ the dashboard

 JMP DEATH2             \ Jump to DEATH2 to reset and restart the game

\ ******************************************************************************
\
\       Name: RSHIPS
\       Type: Subroutine
\   Category: Loader
\    Summary: Launch from the station, load a new set of ship blueprints and
\             jump into the main game loop
\
\ ******************************************************************************

.RSHIPS

 JSR LOMOD              \ Call LOMOD to populate the ship blueprints table
                        \ with a random selection of ships

 JSR RESET              \ Call RESET to reset most variables

 LDA #&FF               \ Set QQ1 to &FF to indicate we are docked, so when
 STA QQ12               \ we reach TT110 after calling FRCE below, it shows the
                        \ launch tunnel

 STA QQ11               \ Set the view number to a non-zero value, so when we
                        \ reach LOOK1 after calling FRCE below, it sets up a
                        \ new space view

 STA dockedp            \ Set dockedp to &FF to indicate that we are no longer
                        \ docked

 LDA #f0                \ Jump into the main game loop at FRCE_FLIGHT, setting
 JMP FRCE_FLIGHT        \ the key "pressed" to red key f0 (so we launch from the
                        \ station)

\ ******************************************************************************
\
\       Name: LOMOD
\       Type: Subroutine
\   Category: Universe
\    Summary: Populate the ship blueprints table at XX21 with a random selection
\             of ships and set the compass to point to the planet
\  Deep dive: Ship blueprints in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   SHIPinA             Populate the ship blueprints table but without setting
\                       the compass to show the planet
\
\ ******************************************************************************

.LOMOD

 LDA #0                 \ Set finder to 0, so the compass shows the planet
 STA finder

.SHIPinA

 LDX #0                 \ The first task is to fill blueprint position 2, which
                        \ contains the space station blueprint, so set X = 0,
                        \ which is the ship_list ship type for a Dodo space
                        \ station

 LDA tek                \ If the current system's tech level is 10 or more, then
 CMP #10                \ skip the following instruction, as we already have the
 BCS mix_station        \ correct space station type in X

 INX                    \ Increment X to 1, the ship_list ship type for a
                        \ Coriolis space station

.mix_station

 LDY #2                 \ Install a ship of type X (Dodo or Coriolis station)
 JSR install_ship       \ into blueprint position 2

 LDY #9                 \ The next blueprint position we need to fill is number
                        \ 9, for the shuttle, so set Y to point to this position
                        \ so we can use it as a counter, starting at position 9
                        \ and working our way up to position 28 (as positions 29
                        \ to 31 are already filled)

.mix_retry

 LDA #0                 \ Set X1 = 0 to act as a failure counter, so we can
 STA X1                 \ have 256 failed attempts to fill each blueprint
                        \ position before giving up and leaving it blank

.mix_match

 JSR DORND              \ Set A and X to random numbers

 CMP #ship_total        \ If A >= #ship_total then it is too big to be a
 BCS mix_match          \ ship_list ship type, so loop back to choose another
                        \ random number until it is a valid ship type

 ASL A                  \ Set Y1 = A * 4, so we can use it a random index into
 ASL A                  \ the ship_bits table, which has four bytes in each
 STA Y1                 \ entry

                        \ Y1 now contains the ship_list ship type of the ship we
                        \ are going to try installing into position Y, just
                        \ multiplied by 4 so it can be used as a four-byte index
                        \
                        \ We now want to check the ship_bits table to see if the
                        \ ship type in Y1 is allowed in ship blueprint position
                        \ Y. The table contains a 32-bit number for each ship
                        \ type, with the corresponding bits set for allowed
                        \ positions, so if a ship type were allowed in positions
                        \ 11 and 17, for example, only bits 11 and 17 would be
                        \ set in the ship_bits table entry for that type
                        \
                        \ To do this, we work out which of the four bytes in the
                        \ 32-bit number contains the bit we want to match, and
                        \ then create a byte that has the correct bit set for
                        \ that particular byte, so we can AND them together to
                        \ see if there is a match
                        \
                        \ For example, say we are trying to populate position 17
                        \ (so Y = 17), and we want to know whether our ship of
                        \ type Y1 is allowed in this position. We know what we
                        \ need to look at the 32-bit number in row Y1 of the
                        \ ship_bits table, and we also know that bit 17 appears
                        \ in the third byte of a 32-bit number (i.e. byte #2),
                        \ so we can set an index in X:
                        \
                        \   X = Y1 + 2
                        \
                        \ and we can use this as an index into the ship_bits
                        \ table to fetch the relevant byte from the 32-bit
                        \ number we want to match, which is at this location:
                        \
                        \   ship_bits + X
                        \
                        \ Given this byte, we need to check the relevant bit. We
                        \ know that bit 17 of a 32-bit number corresponds to the
                        \ second bit of the third byte, so if we create a byte
                        \ with that bit set:
                        \
                        \   A = %00000010
                        \
                        \ then we can AND the two together, and if we get a
                        \ non-zero result, we know that bit 17 in the 32-bit
                        \ number is set:
                        \
                        \   result = ?(ship_bits + X) AND A
                        \
                        \ where ?(addr) is the contents of address addr
                        \
                        \ This is what we now do, starting with the byte in A,
                        \ which we can grab from the lookup table at mix_bits,
                        \ then calculating X, before extracting the relevant
                        \ byte from the ship_bits table and performing the AND

 TYA                    \ Set X = Y mod 8, so as Y works through the positions
 AND #7                 \ from 0 to 31, making its way from bit 0 to bit 31 of
 TAX                    \ the 32-bit number, X represents the position of the
                        \ current bit within each of the four bytes that make up
                        \ the 32-bit number

 LDA mix_bits,X         \ Set A to the X-th byte from mix_bits, which contains a
                        \ table of bytes with the relevant bit sit for each
                        \ value of X (so the value at mix_bits + X has bit X
                        \ set). This gives us our value of A in the above
                        \ explanation, so if we were looking to populate
                        \ blueprint position 17, A would now be %00000010

 LDX Y1                 \ Set X to the ship type we are going to try to install

                        \ We now want to add to X to point to the correct byte
                        \ within the 32-bit number, depending on the blueprint
                        \ position in Y that we are trying to fill:
                        \
                        \   * If Y is in the range  0 to  7, X = X + 0
                        \   * If Y is in the range  8 to 15, X = X + 1
                        \   * If Y is in the range 16 to 23, X = X + 2
                        \   * If Y is in the range 24 to 28, X = X + 3
                        \
                        \ note that because we are starting at position 9, we
                        \ can ignore the first case. In our above example, we
                        \ are filling position 17, so we would add 2 to X

 CPY #16                \ If the blueprint position we are trying to fill is
 BCC mix_byte2          \ less than 16, jump to mix_byte2 so we increment X once

 CPY #24                \ If the blueprint position we are trying to fill is
 BCC mix_byte3          \ less than 24, jump to mix_byte3 so we increment X
                        \ twice

 INX                    \ Increment X as Y is in the range 24 to 28

.mix_byte3

 INX                    \ Increment X as Y is in the range 16 to 28

.mix_byte2

 INX                    \ Increment X as Y is in the range 9 to 28

                        \ We now have the correct values of A and X, as per the
                        \ above calculation, so it's time to do the AND logic:
                        \
                        \   result = ?(ship_bits + X) AND A
                        \
                        \ which we can do easily in assembly language:
                        \
                        \   AND ship_bits,X
                        \
                        \ followed by a BEQ to check whether the result is zero

 AND ship_bits,X        \ If the X-th byte of ship_bits does not have the same
 BEQ mix_fail           \ bit set as our moving bit counter in A, jump to
                        \ mix_fail to have another go at filling this blueprint
                        \ position, as the ship in Y1 is not allowed in
                        \ blueprint position Y

.mix_try

                        \ If we get here then the ship in Y1 is allowed in
                        \ blueprint position Y, so now we decide whether or not
                        \ to go ahead, depending on the probability figure for
                        \ this ship type, which we fetch from the first entry in
                        \ the ship_bytes table for this ship type

 JSR DORND              \ Set A and X to random numbers

 LDX Y1                 \ Set X to the ship type we are going to try to install

 CMP ship_bytes,X       \ If A < the X-th entry in ship_bytes, i.e. it is less
 BCC mix_ok             \ than the first byte in the ship_bytes entry for this
                        \ ship type, jump to mix_ok to install this ship into
                        \ the blueprint position. So, for example, if this ship
                        \ type has a value of 100 as the first byte in its entry
                        \ in the ship_bytes table, which is the case for the
                        \ Mamba and Sidewinder, then we only add it to this
                        \ blueprint position if A < 100, or a 39% chance. The
                        \ much rarer Dragon, meanwhile, has a ship_bytes entry
                        \ of 3, so the calculation is A < 3, or a 1.2% chance

.mix_fail

                        \ If we get here then either this ship isn't allowed in
                        \ this position, or it failed the probability test
                        \ above, so we decrement the failure counter and loop
                        \ back for another go (up to a maximum number of 256
                        \ attempts for each position)

 DEC X1                 \ Decrement the failure counter in X1

 BNE mix_match          \ If we haven't run out of failure attempts, jump back
                        \ to mix_match to have another go at filling this
                        \ blueprint position

 LDX #ship_total*4      \ Otherwise we have run out of attempts, so set X to
                        \ point to the last entry in the table, which contains
                        \ data for an empty position, so this blueprint position
                        \ will be empty

.mix_ok

 STY X2                 \ Store Y, the blueprint position we are trying to fill,
                        \ in X2 so we can retrieve it later

 CPX #13*4              \ If X is the four-byte index for ship number 13, then
 BEQ mix_anaconda       \ we just decided to add an Anaconda, so jump to
                        \ mix_anaconda to install it as the "large ship", along
                        \ with a Worm as the "small ship"

 CPX #29*4              \ If X is the four-byte index for ship number 29, then
 BEQ mix_dragon         \ we just decided to add a Dragon, so jump to mix_dragon
                        \ to install it as the "large ship", along with a
                        \ Sidewinder as the "small ship"

 TXA                    \ Set X = X / 4, so X is now the type of the ship we
 LSR A                  \ want to add, rather than an index into a four-byte
 LSR A                  \ table
 TAX

.mix_install

 JSR install_ship       \ Install a ship of type X into blueprint position Y

 LDY X2                 \ Set Y to the blueprint position we are trying to fill,
                        \ which we stored in X2 above

.mix_next

 INY                    \ Increment Y to point to the next blueprint position to
                        \ fill

 CPY #15                \ If the next position is not number 15 (the "small
 BNE mix_skip           \ ship") then jump to mix_skip to skip the following two
                        \ instructions

 INY                    \ The next position is 15, so increment Y twice so we
 INY                    \ skip over positions 15 (the "small ship") and 16 (the
                        \ cop), as the first one is only filled if we have an
                        \ Anaconda or Dragon as the "large ship" (see above),
                        \ and the second one is already filled with a Viper

.mix_skip

 CPY #29                \ If the next blueprint position we are trying to fill
 BNE mix_retry          \ is not 29, then loop back to mix_retry to fill the
                        \ next position

 RTS                    \ Otherwise we just filled the last position, number 28,
                        \ so return from the subroutine as we are done

.mix_anaconda

 LDX #13                \ Install ship number 13 (Anaconda) into blueprint
 LDY #14                \ position 14 (the "large ship")
 JSR install_ship

 LDX #14                \ Install ship number 14 (Worm) into blueprint position
 LDY #15                \ 15 (the "small ship"), so the Anaconda can spawn
 JMP mix_install        \ Worms, and rejoin the mix loop via mix_install

.mix_dragon

 LDX #29                \ Install ship number 29 (Dragon) into blueprint
 LDY #14                \ position 14 (the "large ship")
 JSR install_ship

 LDX #17                \ Install ship number 14 (Sidewinder) into blueprint
 LDY #15                \ position 15 (the "small ship"), so the Dragon can
 JMP mix_install        \ spawn Sidewinders, and rejoin the mix loop via
                        \ mix_install

\ ******************************************************************************
\
\       Name: mix_bits
\       Type: Variable
\   Category: Loader
\    Summary: Lookup table for locating a specific bit in the 32-bit word for a
\             given ship blueprint position
\  Deep dive: Ship blueprints in Elite-A
\
\ ******************************************************************************

.mix_bits

 EQUB %00000001         \ Positions 0,  8, 16, 24
 EQUB %00000010         \ Positions 1,  9, 17, 25
 EQUB %00000100         \ Positions 2, 10, 18, 26
 EQUB %00001000         \ Positions 3, 11, 19, 27
 EQUB %00010000         \ Positions 4, 12, 20, 28
 EQUB %00100000         \ Positions 5, 13, 21, 29
 EQUB %01000000         \ Positions 6, 14, 22, 30
 EQUB %10000000         \ Positions 7, 15, 23, 31

\ ******************************************************************************
\
\       Name: SPS1
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the vector to the planet, sun or station and store it in
\             XX15
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   Determines the object whose vector we are calculating:
\
\                         * 0 = calculate the vector to the planet
\
\                         * NI% = calculate the vector to the sun/space station
\
\ Other entry points:
\
\   SPS1+1              A BRK instruction
\
\ ******************************************************************************

.SPS1

 LDX #0                 \ Copy the two high bytes of the planet/sun/station's
 JSR SPS3               \ x-coordinate into K3(2 1 0), separating out the sign
                        \ bit into K3+2

 JSR SPS3               \ Copy the two high bytes of the planet/sun/station's
                        \ y-coordinate into K3(5 4 3), separating out the sign
                        \ bit into K3+5

 JSR SPS3               \ Copy the two high bytes of the planet/sun/station's
                        \ z-coordinate into K3(8 7 6), separating out the sign
                        \ bit into K3+8

                        \ Fall through into TAS2 to build XX15 from K3

\ ******************************************************************************
\
\       Name: TAS2
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Normalise the three-coordinate vector in K3
\
\ ------------------------------------------------------------------------------
\
\ Normalise the vector in K3, which has 16-bit values and separate sign bits,
\ and store the normalised version in XX15 as a signed 8-bit vector.
\
\ A normalised vector (also known as a unit vector) has length 1, so this
\ routine takes an existing vector in K3 and scales it so the length of the
\ new vector is 1. This is used in two places: when drawing the compass, and
\ when applying AI tactics to ships.
\
\ We do this in two stages. This stage shifts the 16-bit vector coordinates in
\ K3 to the left as far as they will go without losing any bits off the end, so
\ we can then take the high bytes and use them as the most accurate 8-bit vector
\ to normalise. Then the next stage (in routine NORM) does the normalisation.
\
\ Arguments:
\
\   K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
\                       x_sign is just bit 7
\
\   K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
\                       y_sign is just bit 7
\
\   K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
\                       z_sign is just bit 7
\
\ Returns:
\
\   XX15                The normalised vector, with:
\
\                         * The x-coordinate in XX15
\
\                         * The y-coordinate in XX15+1
\
\                         * The z-coordinate in XX15+2
\
\ Other entry points:
\
\   TA2                 Calculate the length of the vector in XX15 (ignoring the
\                       low coordinates), returning it in Q
\
\ ******************************************************************************

.TAS2

 LDA K3                 \ OR the three low bytes and 1 to get a byte that has
 ORA K3+3               \ a 1 wherever any of the three low bytes has a 1
 ORA K3+6               \ (as well as always having bit 0 set), and store in
 ORA #1                 \ K3+9
 STA K3+9

 LDA K3+1               \ OR the three high bytes to get a byte in A that has a
 ORA K3+4               \ 1 wherever any of the three high bytes has a 1
 ORA K3+7

                        \ (A K3+9) now has a 1 wherever any of the 16-bit
                        \ values in K3 has a 1
.TAL2

 ASL K3+9               \ Shift (A K3+9) to the left, so bit 7 of the high byte
 ROL A                  \ goes into the C flag

 BCS TA2                \ If the left shift pushed a 1 out of the end, then we
                        \ know that at least one of the coordinates has a 1 in
                        \ this position, so jump to TA2 as we can't shift the
                        \ values in K3 any further to the left

 ASL K3                 \ Shift K3(1 0), the x-coordinate, to the left
 ROL K3+1

 ASL K3+3               \ Shift K3(4 3), the y-coordinate, to the left
 ROL K3+4

 ASL K3+6               \ Shift K3(6 7), the z-coordinate, to the left
 ROL K3+7

 BCC TAL2               \ Jump back to TAL2 to do another shift left (this BCC
                        \ is effectively a JMP as we know bit 7 of K3+7 is not a
                        \ 1, as otherwise bit 7 of A would have been a 1 and we
                        \ would have taken the BCS above)

.TA2

 LDA K3+1               \ Fetch the high byte of the x-coordinate from our left-
 LSR A                  \ shifted K3, shift it right to clear bit 7, stick the
 ORA K3+2               \ sign bit in there from the x_sign part of K3, and
 STA XX15               \ store the resulting signed 8-bit x-coordinate in XX15

 LDA K3+4               \ Fetch the high byte of the y-coordinate from our left-
 LSR A                  \ shifted K3, shift it right to clear bit 7, stick the
 ORA K3+5               \ sign bit in there from the y_sign part of K3, and
 STA XX15+1             \ store the resulting signed 8-bit y-coordinate in
                        \ XX15+1

 LDA K3+7               \ Fetch the high byte of the z-coordinate from our left-
 LSR A                  \ shifted K3, shift it right to clear bit 7, stick the
 ORA K3+8               \ sign bit in there from the z_sign part of K3, and
 STA XX15+2             \ store the resulting signed 8-bit  z-coordinate in
                        \ XX15+2

 JMP NORM               \ Now we have a signed 8-bit version of the vector K3 in
                        \ XX15, so jump to NORM to normalise it, returning from
                        \ the subroutine using a tail call

\ ******************************************************************************
\
\       Name: WARP
\       Type: Subroutine
\   Category: Flight
\    Summary: Perform an in-system jump
\
\ ------------------------------------------------------------------------------
\
\ This is called when we press "J" during flight. The following checks are
\ performed:
\
\   * Make sure we don't have any ships or space stations in the vicinity
\
\   * Make sure we are not in witchspace
\
\   * If we are facing the planet, make sure we aren't too close
\
\   * If we are facing the sun, make sure we aren't too close
\
\ If the above checks are passed, then we perform an in-system jump by moving
\ the sun and planet in the opposite direction to travel, so we appear to jump
\ in space. This means that any asteroids, cargo canisters or escape pods get
\ dragged along for the ride.
\
\ Other entry points:
\
\   WA1                 Make a long, low beep
\
\ ******************************************************************************

.WARP

 LDX JUNK               \ Set X to the total number of junk items in the
                        \ vicinity (e.g. asteroids, escape pods, cargo
                        \ canisters, Shuttles, Transporters and so on)

 LDA FRIN+2,X           \ If the slot at FRIN+2+X is non-zero, then we have
                        \ something else in the vicinity besides asteroids,
                        \ escape pods and cargo canisters, so to check whether
                        \ we can jump, we first grab the slot contents into A

 ORA JUNK               \ If there is any junk in the vicinity, then JUNK will
                        \ be non-zero, so OR'ing with JUNK will produce a
                        \ non-zero result if either A or JUNK are non-zero
                        \ (so this prevents in-system jumps if there is any
                        \ junk nearby, which is different to the other versions
                        \ which allow you to jump, dragging any junk along with
                        \ the ship)

 ORA SSPR               \ If there is a space station nearby, then SSPR will
                        \ be non-zero, so OR'ing with SSPR will produce a
                        \ non-zero result if either A or SSPR are non-zero

 ORA MJ                 \ If we are in witchspace, then MJ will be non-zero, so
                        \ OR'ing with MJ will produce a non-zero result if
                        \ either A or SSPR or MJ are non-zero

 BNE WA1                \ A is non-zero if we have either a ship, or a space
                        \ station, or junk in the vicinity, or we are in
                        \ witchspace, in which case jump to WA1 to make a low
                        \ beep to show that we can't do an in-system jump

 LDY K%+8               \ Otherwise we can do an in-system jump, so now we fetch
                        \ the byte at K%+8, which contains the z_sign for the
                        \ first ship slot, i.e. the distance of the planet

 BMI WA3                \ If the planet's z_sign is negative, then the planet
                        \ is behind us, so jump to WA3 to skip the following

 TAY                    \ Set A = Y = 0 (as we didn't BNE above) so the call
                        \ to MAS2 measures the distance to the planet

 JSR MAS2               \ Call MAS2 to set A to the largest distance to the
                        \ planet in any of the three axes (we could also call
                        \ routine m to do the same thing, as A = 0)

 LSR A                  \ If A < 2 then jump to WA1 to abort the in-system jump
 BEQ WA1                \ with a low beep, as we are facing the planet and are
                        \ too close to jump in that direction

.WA3

 LDY K%+NI%+8           \ Fetch the z_sign (byte #8) of the second ship in the
                        \ ship data workspace at K%, which is reserved for the
                        \ sun or the space station (in this case it's the
                        \ former, as we already confirmed there isn't a space
                        \ station in the vicinity)

 BMI WA2                \ If the sun's z_sign is negative, then the sun is
                        \ behind us, so jump to WA2 to skip the following

 LDY #NI%               \ Set Y to point to the offset of the ship data block
                        \ for the sun, which is NI% (as each block is NI% bytes
                        \ long, and the sun is the second block)

 JSR m                  \ Call m to set A to the largest distance to the sun
                        \ in any of the three axes

 LSR A                  \ If A < 2 then jump to WA1 to abort the in-system jump
 BEQ WA1                \ with a low beep, as we are facing the sun and are too
                        \ close to jump in that direction

.WA2

                        \ If we get here, then we can do an in-system jump, as
                        \ we don't have any ships or space stations in the
                        \ vicinity, we are not in witchspace, and if we are
                        \ facing the planet or the sun, we aren't too close to
                        \ jump towards it
                        \
                        \ We do an in-system jump by moving the sun and planet,
                        \ rather than moving our own local bubble (this is why
                        \ in-system jumps drag asteroids, cargo canisters and
                        \ escape pods along for the ride). Specifically, we move
                        \ them in the z-axis by a fixed amount in the opposite
                        \ direction to travel, thus performing a jump towards
                        \ our destination

 LDA #&81               \ Set R = R = P = &81
 STA S
 STA R
 STA P

 LDA K%+8               \ Set A = z_sign for the planet

 JSR ADD                \ Set (A X) = (A P) + (S R)
                        \           = (z_sign &81) + &8181
                        \           = (z_sign &81) - &0181
                        \
                        \ This moves the planet against the direction of travel
                        \ by reducing z_sign by 1, as the above maths is:
                        \
                        \         z_sign 00000000
                        \   +   00000000 10000001
                        \   -   00000001 10000001
                        \
                        \ or:
                        \
                        \         z_sign 00000000
                        \   +   00000000 00000000
                        \   -   00000001 00000000
                        \
                        \ i.e. the high byte is z_sign - 1, making sure the sign
                        \ is preserved

 STA K%+8               \ Set the planet's z_sign to the high byte of the result

 LDA K%+NI%+8           \ Set A = z_sign for the sun

 JSR ADD                \ Set (A X) = (A P) + (S R)
                        \           = (z_sign &81) + &8181
                        \           = (z_sign &81) - &0181
                        \
                        \ which moves the sun against the direction of travel
                        \ by reducing z_sign by 1

 STA K%+NI%+8           \ Set the planet's z_sign to the high byte of the result

 LDA #1                 \ These instructions have no effect, as the call to
 STA QQ11               \ LOOK1 below starts by setting QQ11 to 0; instead they
                        \ just set the current view type in QQ11 to 1 for the
                        \ duration of the next three instructions

 STA MCNT               \ Set the main loop counter to 1, so the next iteration
                        \ through the main loop will potentially spawn ships
                        \ (see part 2 of the main game loop at me3)

 LSR A                  \ Set EV, the extra vessels spawning counter, to 0
 STA EV                 \ (the LSR produces a 0 as A was previously 1)

 LDX VIEW               \ Set X to the current view (front, rear, left or right)
 JMP LOOK1              \ and jump to LOOK1 to initialise that view, returning
                        \ from the subroutine using a tail call

.WA1

 LDA #40                \ If we get here then we can't do an in-system jump, so
 JMP NOISE              \ call the NOISE routine with A = 40 to make a long, low
                        \ beep and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: EXNO3
\       Type: Subroutine
\   Category: Sound
\    Summary: Make an explosion sound
\
\ ------------------------------------------------------------------------------
\
\ Make the sound of death in the cold, hard vacuum of space. Apparently, in
\ Elite space, everyone can hear you scream.
\
\ This routine also makes the sound of a destroyed cargo canister if we don't
\ get scooping right, the sound of us colliding with another ship, and the sound
\ of us being hit with depleted shields. It is not a good sound to hear.
\
\ ******************************************************************************

.EXNO3

 JSR sound_10           \ Call sound_10 make the first death sound

 LDA #24                \ Call the NOISE routine with A = 24 to make the
 JMP NOISE              \ death sound and return from the subroutine using a
                        \ tail call

\ ******************************************************************************
\
\       Name: SFRMIS
\       Type: Subroutine
\   Category: Tactics
\    Summary: Add an enemy missile to our local bubble of universe
\
\ ------------------------------------------------------------------------------
\
\ An enemy has fired a missile, so add the missile to our universe if there is
\ room, and if there is, make the appropriate warnings and noises.
\
\ Other entry points:
\
\   n_sound30           Make the sound of a missile being launched
\
\ ******************************************************************************

.SFRMIS

 LDX #MSL               \ Set X to the ship type of a missile, and call SFS1-2
 JSR SFS1-2             \ to add the missile to our universe with an AI flag
                        \ of %11111110 (AI enabled, hostile, no E.C.M.)

 BCC d_4418             \ The C flag will be set if the call to SFS1-2 was a
                        \ success, so if it's clear, jump down to d_4418 to
                        \ return from the subroutine

 LDA #120               \ Print recursive token 120 ("INCOMING MISSILE") as an
 JSR MESS               \ in-flight message

.n_sound30

 LDA #48                \ Call the NOISE routine with A = 48 to make the sound
 JMP NOISE              \ of the missile being launched and return from the
                        \ subroutine using a tail call

.d_4418

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: EXNO2
\       Type: Subroutine
\   Category: Status
\    Summary: Process us making a kill
\  Deep dive: Combat rank
\
\ ------------------------------------------------------------------------------
\
\ We have killed a ship, so increase the kill tally, displaying an iconic
\ message of encouragement if the kill total is a multiple of 256, and then
\ make a nearby explosion sound.
\
\
\ ******************************************************************************

.EXNO2

 INC TALLY              \ Increment the low byte of the kill count in TALLY

 BNE EXNO-2             \ If there is no carry, jump to the LDX #7 below (at
                        \ EXNO-2)

 INC TALLY+1            \ Increment the high byte of the kill count in TALLY

 LDA #101               \ The kill total is a multiple of 256, so it's time
 JSR MESS               \ for a pat on the back, so print recursive token 101
                        \ ("RIGHT ON COMMANDER!") as an in-flight message

 LDX #7                 \ Set X = 7 and fall through into EXNO to make the
                        \ sound of a ship exploding

\ ******************************************************************************
\
\       Name: EXNO
\       Type: Subroutine
\   Category: Sound
\    Summary: Make the sound of a laser strike or ship explosion
\
\ ------------------------------------------------------------------------------
\
\ Make the two-part explosion sound of us making a laser strike, or of another
\ ship exploding.
\
\ The volume of the first explosion is affected by the distance of the ship
\ being hit, with more distant ships being quieter. The value in X also affects
\ the volume of the first explosion, with a higher X giving a quieter sound
\ (so X can be used to differentiate a laser strike from an explosion).
\
\ Arguments:
\
\   X                   The larger the value of X, the fainter the explosion.
\                       Allowed values are:
\
\                         * 7  = explosion is louder (i.e. the ship has just
\                                exploded)
\
\                         * 15 = explosion is quieter (i.e. this is just a laser
\                                strike)
\
\ Other entry points:
\
\   EXNO-2              Set X = 7 and fall through into EXNO to make the sound
\                       of a ship exploding
\
\   sound_10            Make the first part of the death sound, or the second
\                       part of the explosion sound
\
\ ******************************************************************************

.EXNO

 STX T                  \ Store the distance in T

 LDA #24                \ Set A = 24 to denote the sound of us making a hit or
 JSR NOS1               \ kill (part 1 of the explosion), and call NOS1 to set
                        \ up the sound block in XX16

 LDA INWK+7             \ Fetch z_hi, the distance of the ship being hit in
 LSR A                  \ terms of the z-axis (in and out of the screen), and
 LSR A                  \ divide by 4. If z_hi has either bit 6 or 7 set then
                        \ that ship is too far away to be shown on the scanner
                        \ (as per the SCAN routine), so we know the maximum
                        \ z_hi at this point is %00111111, and shifting z_hi
                        \ to the right twice gives us a maximum value of
                        \ %00001111

 AND T                  \ This reduces A to a maximum of X; X can be either
                        \ 7 = %0111 or 15 = %1111, so AND'ing with 15 will
                        \ not affect A, while AND'ing with 7 will clear bit
                        \ 3, reducing the maximum value in A to 7

 ORA #%11110001         \ The SOUND statement's amplitude ranges from 0 (for no
                        \ sound) to -15 (full volume), so we can set bits 0 and
                        \ 4-7 in A, and keep bits 1-3 from the above to get
                        \ a value between -15 (%11110001) and -1 (%11111111),
                        \ with lower values of z_hi and argument X leading
                        \ to a more negative, or quieter number (so the closer
                        \ the ship, i.e. the smaller the value of X, the louder
                        \ the sound)

 STA XX16+2             \ The amplitude byte of the sound block in XX16 is in
                        \ byte #3 (where it's the low byte of the amplitude), so
                        \ this sets the amplitude to the value in A

 JSR NO3                \ Make the sound from our updated sound block in XX16

.sound_10

 LDA #16                \ Set A = 16 to denote we have made a hit or kill
                        \ (part 2 of the explosion)

 JMP NOISE              \ Jump to NOISE to make the sound and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: DKS1
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan the keyboard or joystick for a flight key by sending a scan_y
\             command to the I/O processor
\
\ ------------------------------------------------------------------------------
\
\ Scan the keyboard for the flight key given in register Y, where Y is the
\ offset into the KYTB table above (so we can scan for Space by setting Y to
\ 2, for example). If the key is pressed, set the corresponding byte in the
\ key logger at KL to a negative value (i.e. with bit 7 set).
\
\ Arguments:
\
\   Y                   The offset into the KYTB table above of the key that we
\                       want to scan on the keyboard
\
\ ******************************************************************************

.DKS1

 LDA #&96               \ Send command &96 to the I/O processor:
 JSR tube_write         \
                        \   =scan_y(key_offset, delta_14b)
                        \
                        \ which will update the roll or pitch dashboard
                        \ indicator to the specified value

 TYA                    \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * key_offset = Y

 LDA BSTK               \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * delta14b = BTSK

 JSR tube_read          \ Set A to the response from the I/O processor, which
                        \ will be the key number, but with bit 7 clear if the
                        \ key is not being pressed, or bit 7 set if it is being
                        \ pressed

 BPL b_quit             \ If the response is positive (i.e. bit 7 is clear) then
                        \ the key is not being pressed, so skip the following
                        \ instruction

 STA KL,Y               \ The response is negative, so store this in the Y-th
                        \ byte of the key logger at KL to indicate that the key
                        \ is being pressed

.b_quit

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DKJ1
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Read joystick and flight controls
\
\ ------------------------------------------------------------------------------
\
\ Specifically, scan the keyboard for the speed up and slow down keys, and read
\ the joystick's fire button and X and Y axes, storing the results in the key
\ logger and the joystick position variables.
\
\ This routine is only called if joysticks are enabled (JSTK = non-zero).
\
\ ******************************************************************************

.DKJ1

 LDA auto               \ If auto is non-zero, then the docking computer is
 BNE auton              \ currently activated, so jump to auton in DOKEY so the
                        \ docking computer can "press" the flight keys for us

 LDY #1                 \ Update the key logger for key 1 in the KYTB table, so
 JSR DKS1               \ KY1 will be &FF if "?" (slow down) is being pressed

 INY                    \ Update the key logger for key 2 in the KYTB table, so
 JSR DKS1               \ KY2 will be &FF if Space (speed up) is being pressed

 JSR scan_fire          \ Call scan_fire to check whether the joystick's fire
                        \ button is being pressed, which clears bit 4 in A if
                        \ the fire button is being pressed, and sets it if it
                        \ is not being pressed

 EOR #%00010000         \ Flip bit 4 so that it's set if the fire button has
 STA KY7                \ been pressed, and store the result in the keyboard
                        \ logger at location KY7, which is also where the A key
                        \ (fire lasers) key is logged

 LDX #1                 \ Call DKS2 to fetch the value of ADC channel 1 (the
 JSR DKS2               \ joystick X value) into (A X), and OR A with 1. This
 ORA #1                 \ ensures that the high byte is at least 1, and then we
 STA JSTX               \ store the result in JSTX

 LDX #2                 \ Call DKS2 to fetch the value of ADC channel 2 (the
 JSR DKS2               \ joystick Y value) into (A X), and EOR A with JSTGY.
 EOR JSTGY              \ JSTGY will be &FF if the game is configured to
 STA JSTY               \ reverse the joystick Y channel, so this EOR does
                        \ exactly that, and then we store the result in JSTY

 JMP DK4_FLIGHT         \ We are done scanning the joystick flight controls,
                        \ so jump to DK4_FLIGHT to scan for other keys, using a
                        \ tail call so we can return from the subroutine there

\ ******************************************************************************
\
\       Name: U%
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Clear the key logger
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   A is set to 0
\
\   Y                   Y is set to 0
\
\ ******************************************************************************

.U%

 LDA #0                 \ Set A to 0, as this means "key not pressed" in the
                        \ key logger at KL

 LDY #16                \ We want to clear the 16 key logger locations from
                        \ KY1 to KY20, so set a counter in Y

.DKL3

 STA KL,Y               \ Store 0 in the Y-th byte of the key logger

 DEY                    \ Decrement the counter

 BNE DKL3               \ And loop back for the next key, until we have just
                        \ KL+1. We don't want to clear the first key logger
                        \ location at KL, as the keyboard table at KYTB starts
                        \ with offset 1, not 0, so KL is not technically part of
                        \ the key logger (it's actually used for logging keys
                        \ that don't appear in the keyboard table, and which
                        \ therefore don't use the key logger)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DOKEY_FLIGHT
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan for the seven primary flight controls (flight version)
\
\ ******************************************************************************

.DOKEY_FLIGHT

 JSR U%                 \ Call U% to clear the key logger

 LDA QQ22+1             \ Fetch QQ22+1, which contains the number that's shown
                        \ on-screen during hyperspace countdown

 BEQ l_open             \ If the hyperspace countdown is non-zero, jump to
 JMP DK4_FLIGHT         \ DK4_FLIGHT to skip scanning for primary flight keys,
                        \ and move on to scanning for pause, configuration and
                        \ secondary flight keys

.l_open

 LDA JSTK               \ If JSTK is non-zero, then we are configured to use
 BNE DKJ1               \ the joystick rather than keyboard, so jump to DKJ1
                        \ to read the joystick flight controls, before jumping
                        \ to DK4 to scan for pause, configuration and secondary
                        \ flight keys

 LDY #7                 \ We're going to work our way through the primary flight
                        \ control keys (pitch, roll, speed and laser), so set a
                        \ counter in Y so we can loop through all 7

.DKL2

 JSR DKS1               \ Call DKS1 to see if the KYTB key at offset Y is being
                        \ pressed, and set the key logger accordingly

 DEY                    \ Decrement the loop counter

 BNE DKL2               \ Loop back for the next key, working our way from A at
                        \ KYTB+7 down to ? at KYTB+1

 LDA auto               \ If auto is 0, then the docking computer is not
 BEQ DK15               \ currently activated, so jump to DK15 to skip the
                        \ docking computer manoeuvring code below

.auton

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 LDA #96                \ Set nosev_z_hi = 96
 STA INWK+14

 ORA #%10000000         \ Set sidev_x_hi = -96
 STA INWK+22

 STA TYPE               \ Set the ship type to -96, so the negative value will
                        \ let us check in the DOCKIT routine whether this is our
                        \ ship that is activating its docking computer, rather
                        \ than an NPC ship docking

 LDA DELTA              \ Set the ship speed to DELTA (our speed)
 STA INWK+27

 JSR DOCKIT             \ Call DOCKIT to calculate the docking computer's moves
                        \ and update INWK with the results

                        \ We now "press" the relevant flight keys, depending on
                        \ the results from DOCKIT, starting with the pitch keys

 LDA INWK+27            \ Fetch the updated ship speed from byte #27 into A

 CMP #22                \ If A < 22, skip the next instruction
 BCC P%+4

 LDA #22                \ Set A = 22, so the maximum speed during docking is 22

 STA DELTA              \ Update DELTA to the new value in A

 LDA #&FF               \ Set A = &FF, which we can insert into the key logger
                        \ to "fake" the docking computer working the keyboard

 LDX #0                 \ Set X = 0, so we "press" KY1 below ("?", slow down)

 LDY INWK+28            \ If the updated acceleration in byte #28 is zero, skip
 BEQ DK11               \ to DK11

 BMI P%+3               \ If the updated acceleration is negative, skip the
                        \ following instruction

 INX                    \ The updated acceleration is positive, so increment X
                        \ to 1, so we "press" KY2 below (Space, speed up)

 STA KY1,X              \ Store &FF in either KY1 or KY2 to "press" the relevant
                        \ key, depending on whether the updated acceleration is
                        \ negative (in which case we "press" KY1, "?", to slow
                        \ down) or positive (in which case we "press" KY2,
                        \ Space, to speed up)

.DK11

                        \ We now "press" the relevant roll keys, depending on
                        \ the results from DOCKIT

 LDA #128               \ Set A = 128, which indicates no change in roll when
                        \ stored in JSTX (i.e. the centre of the roll indicator)

 LDX #0                 \ Set X = 0, so we "press" KY3 below ("<", increase
                        \ roll)

 ASL INWK+29            \ Shift ship byte #29 left, which shifts bit 7 of the
                        \ updated roll counter (i.e. the roll direction) into
                        \ the C flag

 BEQ DK12               \ If the remains of byte #29 is zero, then the updated
                        \ roll counter is zero, so jump to DK12 set JSTX to 128,
                        \ to indicate there's no change in the roll

 BCC P%+3               \ If the C flag is clear, skip the following instruction

 INX                    \ The C flag is set, i.e. the direction of the updated
                        \ roll counter is negative, so increment X to 1 so we
                        \ "press" KY4 below (">", decrease roll)

 BIT INWK+29            \ We shifted the updated roll counter to the left above,
 BPL DK14               \ so this tests bit 6 of the original value, and if it
                        \ is clear (i.e. the magnitude is less than 64), jump to
                        \ DK14 to "press" the key and leave JSTX unchanged

 LDA #64                \ The magnitude of the updated roll is 64 or more, so
 STA JSTX               \ set JSTX to 64 (so the roll decreases at half the
                        \ maximum rate)

 LDA #0                 \ And set A = 0 so we do not "press" any keys (so if the
                        \ docking computer needs to make a serious roll, it does
                        \ so by setting JSTX directly rather than by "pressing"
                        \ a key)

.DK14

 STA KY3,X              \ Store A in either KY3 or KY4, depending on whether
                        \ the updated roll rate is increasing (KY3) or
                        \ decreasing (KY4)

 LDA JSTX               \ Fetch A from JSTX so the next instruction has no
                        \ effect

.DK12

 STA JSTX               \ Store A in JSTX to update the current roll rate

                        \ We now "press" the relevant pitch keys, depending on
                        \ the results from DOCKIT

 LDA #128               \ Set A = 128, which indicates no change in pitch when
                        \ stored in JSTX (i.e. the centre of the pitch
                        \ indicator)

 LDX #0                 \ Set X = 0, so we "press" KY5 below ("X", decrease
                        \ pitch)

 ASL INWK+30            \ Shift ship byte #30 left, which shifts bit 7 of the
                        \ updated pitch counter (i.e. the pitch direction) into
                        \ the C flag

 BEQ DK13               \ If the remains of byte #30 is zero, then the updated
                        \ pitch counter is zero, so jump to DK13 set JSTY to
                        \ 128, to indicate there's no change in the pitch

 BCS P%+3               \ If the C flag is set, skip the following instruction

 INX                    \ The C flag is clear, i.e. the direction of the updated
                        \ pitch counter is positive, so increment X to 1 so we
                        \ "press" KY6 below ("S", increase pitch)

 STA KY5,X              \ Store 128 in either KY5 or KY6 to "press" the relevant
                        \ key, depending on whether the pitch direction is
                        \ negative (in which case we "press" KY5, "X", to
                        \ decrease the pitch) or positive (in which case we
                        \ "press" KY6, "S", to increase the pitch)

 LDA JSTY               \ Fetch A from JSTY so the next instruction has no
                        \ effect

.DK13

 STA JSTY               \ Store A in JSTY to update the current pitch rate

.DK15

 LDX JSTX               \ Set X = JSTX, the current roll rate (as shown in the
                        \ RL indicator on the dashboard)

 LDA #7                 \ Set A to 7, which is the amount we want to alter the
                        \ roll rate by if the roll keys are being pressed

 LDY KL+3               \ If the "<" key is being pressed, then call the BUMP2
 BEQ P%+5               \ routine to increase the roll rate in X by A
 JSR BUMP2

 LDY KL+4               \ If the ">" key is being pressed, then call the REDU2
 BEQ P%+5               \ routine to decrease the roll rate in X by A, taking
 JSR REDU2              \ the keyboard auto re-centre setting into account

 STX JSTX               \ Store the updated roll rate in JSTX

 ASL A                  \ Double the value of A, to 14

 LDX JSTY               \ Set X = JSTY, the current pitch rate (as shown in the
                        \ DC indicator on the dashboard)

 LDY KL+5               \ If the "X" key is being pressed, then call the REDU2
 BEQ P%+5               \ routine to decrease the pitch rate in X by A, taking
 JSR REDU2              \ the keyboard auto re-centre setting into account

 LDY KL+6               \ If the "S" key is being pressed, then call the BUMP2
 BEQ P%+5               \ routine to increase the pitch rate in X by A
 JSR BUMP2

 STX JSTY               \ Store the updated roll rate in JSTY

                        \ Fall through into DK4_FLIGHT to scan for other keys

\ ******************************************************************************
\
\       Name: DK4_FLIGHT
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan for pause, configuration and secondary flight keys (flight
\             version)
\
\ ******************************************************************************

.DK4_FLIGHT

 JSR RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press)

 STX KL                 \ Store X in KL, byte #0 of the key logger

 CPX #&69               \ If COPY is not being pressed, jump to DK2_FLIGHT
 BNE DK2_FLIGHT         \ below, otherwise let's process the configuration
                        \ keys

.FREEZE_FLIGHT

                        \ COPY is being pressed, so we enter a loop that
                        \ listens for configuration keys, and we keep looping
                        \ until we detect a DELETE key press. This effectively
                        \ pauses the game when COPY is pressed, and unpauses
                        \ it when DELETE is pressed

 JSR WSCAN              \ Call WSCAN to wait for the vertical sync, so the whole
                        \ screen gets drawn

 JSR RDKEY              \ Scan the keyboard for a key press and return the
                        \ internal key number in X (or 0 for no key press)

 CPX #&51               \ If "S" is not being pressed, skip to DK6_FLIGHT
 BNE DK6_FLIGHT

 LDA #0                 \ "S" is being pressed, so set DNOIZ to 0 to turn the
 STA DNOIZ              \ sound on

.DK6_FLIGHT

 LDY #&40               \ We now want to loop through the keys that toggle
                        \ various settings. These have internal key numbers
                        \ between &40 (CAPS LOCK) and &46 ("K"), so we set up
                        \ the first key number in Y to act as a loop counter.
                        \ See subroutine DKS3 for more details on this

.DKL4_FLIGHT

 JSR DKS3               \ Call DKS3 to scan for the key given in Y, and toggle
                        \ the relevant setting if it is pressed

 INY                    \ Increment Y to point to the next toggle key

 CPY #&48               \ The last toggle key is &47 (@), so check whether we
                        \ have just done that one

 BNE DKL4_FLIGHT        \ If not, loop back to check for the next toggle key

 CPX #&10               \ If "Q" is not being pressed, skip to DK7_FLIGHT
 BNE DK7_FLIGHT

 STX DNOIZ              \ "Q" is being pressed, so set DNOIZ to X, which is
                        \ non-zero (&10), so this will turn the sound off

.DK7_FLIGHT

 CPX #&70               \ If ESCAPE is not being pressed, skip over the next
 BNE P%+5               \ instruction

 JMP DEATH2             \ ESCAPE is being pressed, so jump to DEATH2 to end
                        \ the game

\CPX #&37               \ These instructions are commented out in the original
\BNE dont_dump          \ source
\JSR printer
\.dont_dump

 CPX #&59               \ If DELETE is not being pressed, we are still paused,
 BNE FREEZE_FLIGHT      \ so loop back up to keep listening for configuration
                        \ keys, otherwise fall through into the rest of the
                        \ key detection code, which unpauses the game

.DK2_FLIGHT

 LDA QQ11               \ If the current view is non-zero (i.e. not a space
 BNE DK5                \ view), return from the subroutine (as DK5 contains
                        \ an RTS)

 LDY #16                \ This is a space view, so now we want to check for all
                        \ the secondary flight keys. The internal key numbers
                        \ are in the keyboard table KYTB from KYTB+8 to
                        \ KYTB+16, and their key logger locations are from KL+8
                        \ to KL+16. So set a decreasing counter in Y for the
                        \ index, starting at 16, so we can loop through them

.DKL1_FLIGHT

 JSR DKS1               \ Call DKS1 to see if the KYTB key at offset Y is being
                        \ pressed, and set the key logger accordingly

 DEY                    \ Decrement the loop counter

 CPY #7                 \ Have we just done the last key?

 BNE DKL1_FLIGHT        \ If not, loop back to process the next key

.DK5

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: me1
\       Type: Subroutine
\   Category: Text
\    Summary: Erase an old in-flight message and display a new one
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The text token to be printed
\
\   X                   Must be set to 0
\
\ ******************************************************************************

.me1

 STX DLY                \ Set the message delay in DLY to 0, so any new
                        \ in-flight messages will be shown instantly

 PHA                    \ Store the new message token we want to print

 LDA MCH                \ Set A to the token number of the message that is
 JSR mes9               \ currently on-screen, and call mes9 to print it (which
                        \ will remove it from the screen, as printing is done
                        \ using EOR logic)

 PLA                    \ Restore the new message token

 EQUB &2C               \ Fall through into ou2 to print the new message, but
                        \ skip the first instruction by turning it into
                        \ &2C &A9 &6C, or BIT &6CA9, which does nothing apart
                        \ from affect the flags

\ ******************************************************************************
\
\       Name: cargo_mtok
\       Type: Subroutine
\   Category: Text
\    Summary: Print the name of a specific cargo item
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of the cargo item whose name we want to print
\                       (where 0 = food, 1 = textiles, and so on up to 16 for
\                       alien items)
\
\                       See QQ23 for a list of market item numbers and their
\                       storage units
\
\ ******************************************************************************

.cargo_mtok

 ADC #208               \ Add 208 to the value in A, so when we fall through
                        \ into MESS, we print recursive token 48 + A as an
                        \ in-flight token, which will be in the range 48
                        \ ("FOOD") to 64 ("ALIEN ITEMS")

\ ******************************************************************************
\
\       Name: MESS
\       Type: Subroutine
\   Category: Text
\    Summary: Display an in-flight message
\
\ ------------------------------------------------------------------------------
\
\ Display an in-flight message in capitals at the bottom of the space view,
\ erasing any existing in-flight message first.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.MESS

 LDX #0                 \ Set QQ17 = 0 to switch to ALL CAPS
 STX QQ17

 LDY #9                 \ Move the text cursor to column 9, row 22, at the
 STY XC                 \ bottom middle of the screen, and set Y = 22
 LDY #22
 STY YC

 CPX DLY                \ If the message delay in DLY is not zero, jump up to
 BNE me1                \ me1 to erase the current message first (whose token
                        \ number will be in MCH)

 STY DLY                \ Set the message delay in DLY to 22

 STA MCH                \ Set MCH to the token we are about to display

                        \ Fall through into mes9 to print the token in A

\ ******************************************************************************
\
\       Name: mes9
\       Type: Subroutine
\   Category: Text
\    Summary: Print a text token, possibly followed by " DESTROYED"
\
\ ------------------------------------------------------------------------------
\
\ Print a text token, followed by " DESTROYED" if the destruction flag is set
\ (for when a piece of equipment is destroyed).
\
\ ******************************************************************************

.mes9

 JSR TT27               \ Call TT27 to print the text token in A

 LSR de                 \ If bit 0 of variable de is clear, return from the
 BCC DK5                \ subroutine (as DK5 contains an RTS)

 LDA #253               \ Print recursive token 93 (" DESTROYED") and return
 JMP TT27               \ from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: OUCH
\       Type: Subroutine
\   Category: Flight
\    Summary: Potentially lose cargo or equipment following damage
\
\ ------------------------------------------------------------------------------
\
\ Our shields are dead and we are taking damage, so there is a small chance of
\ losing cargo or equipment.
\
\ ******************************************************************************

.OUCH

 JSR DORND              \ Set A and X to random numbers

 BMI DK5                \ If A < 0 (50% chance), return from the subroutine
                        \ (as DK5 contains an RTS)

 CPX #24                \ If X >= 24 (90% chance), return from the subroutine
 BCS DK5                \ (as DK5 contains an RTS)

 LDA CRGO,X             \ If we do not have any of item CRGO+X, return from the
 BEQ DK5                \ subroutine (as DK5 contains an RTS). X is in the range
                        \ 0-23, so this not only checks for cargo, but also for
                        \ the I.F.F. system, E.C.M. system, fuel scoops,
                        \ hyperspace unit, energy unit, docking computer and
                        \ galactic hyperdrive, all of which can be destroyed

 LDA DLY                \ If there is already an in-flight message on-screen,
 BNE DK5                \ return from the subroutine (as DK5 contains an RTS)

 LDY #3                 \ Set bit 1 of de, the equipment destruction flag, so
 STY de                 \ that when we call MESS below, " DESTROYED" is appended
                        \ to the in-flight message

 STA CRGO,X             \ A is 0 (as we didn't branch with the BNE above), so
                        \ this sets CRGO+X to 0, which destroys any cargo or
                        \ equipment we have of that type

 DEX                    \ Decrement X, so X is now in the range -1 to 22, and a
                        \ value of 0 means we just lost some food, 1 means we
                        \ lost some textiles, and so on

 BMI ou1                \ If X is now negative, then we just lost the I.F.F.
                        \ system (as X was 0 before being decremented), so jump
                        \ to ou1 to print the relevant message, which will be
                        \ "I.F.F.SYSTEM DESTROYED" as A = 0 and the C flag is
                        \ clear (as we passed through the BCS above)

 CPX #17                \ If X = 17 then we just lost the E.C.M., so jump to ou1
 BEQ ou1                \ to print the relevant message, which will be
                        \ "E.C.M.SYSTEM DESTROYED" as A = 0 and the C flag is
                        \ set from the CPX

                        \ If we get here then X is in the range 0-16 or 18-22

 TXA                    \ Copy the value of X into A

 BCC cargo_mtok         \ If X < 17 then we just lost some cargo (as opposed to
                        \ equipment), so jump to cargo_mtok to print the name of
                        \ the cargo whose number is in A, plus " DESTROYED", and
                        \ return from the subroutine using a tail call

                        \ If we get here then X (and A) are in the range 18-22

 CMP #18                \ If A is not 18, jump down to equip_mtok with A in the
 BNE equip_mtok         \ range 19-22 and the C flag set from the CMP, to print
                        \ token 113 ("HYPERSPACE UNIT") through 116 ("GALACTIC
                        \ HYPERSPACE")

 LDA #111-107-1         \ Otherwise A is 18, so we have lost the fuel scoops, so
                        \ set A to 111-107-1 = 3 and the C flag set from the CMP
                        \ to print token 111 ("FUEL SCOOPS")

.ou1

 ADC #107-93            \ We can reach here with three values of A and the C
                        \ flag, and then add 93 below to print the following
                        \ tokens:
                        \
                        \   A = 0, C flag clear = token 107 ("I.F.F.SYSTEM")
                        \   A = 0, C flag set   = token 108 ("E.C.M.SYSTEM")
                        \   A = 3, C flag set   = token 111 ("FUEL SCOOPS")

.equip_mtok

 ADC #93                \ We can either reach here from above, or jump straight
                        \ here with A = 19-22 and the C flag set, in which case
                        \ adding 93 will give us token 113 ("HYPERSPACE UNIT")
                        \ through 116 ("GALACTIC HYPERSPACE ")

 INC new_hold           \ We just lost a piece of equipment, so increment the
                        \ amount of free space in the hold

 BNE MESS               \ Print recursive token A as an in-flight message,
                        \ followed by " DESTROYED", and return from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: LL9_FLIGHT
\       Type: Subroutine
\   Category: Drawing ships
\    Summary: Draw a ship (flight version)
\
\ ******************************************************************************

.LL25

 JMP PLANET             \ Jump to the PLANET routine, returning from the
                        \ subroutine using a tail call

.LL9_FLIGHT

 LDA TYPE               \ If the ship type is negative then this indicates a
 BMI LL25               \ planet or sun, so jump to PLANET via LL25 above

 JMP LL9                \ Jump to LL9 to draw the ship

\ ******************************************************************************
\
\       Name: MVEIT_FLIGHT (Part 1 of 6)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship (flight version)
\
\ ******************************************************************************

.MVEIT_FLIGHT

 LDA INWK+31            \ If bit 5 or 7 of ship byte #31 is set, jump to MV30
 AND #%10100000         \ as the ship is either exploding or has been killed, so
 BNE MV30               \ we don't need to tidy its orientation vectors or apply
                        \ tactics

 LDA MCNT               \ Fetch the main loop counter

 EOR XSAV               \ Fetch the slot number of the ship we are moving, EOR
 AND #15                \ with the loop counter and apply mod 15 to the result.
 BNE P%+5               \ The result will be zero when "counter mod 15" matches
                        \ the slot number, so this makes sure we call TIDY 12
                        \ times every 16 main loop iterations, like this:
                        \
                        \   Iteration 0, tidy the ship in slot 0
                        \   Iteration 1, tidy the ship in slot 1
                        \   Iteration 2, tidy the ship in slot 2
                        \     ...
                        \   Iteration 11, tidy the ship in slot 11
                        \   Iteration 12, do nothing
                        \   Iteration 13, do nothing
                        \   Iteration 14, do nothing
                        \   Iteration 15, do nothing
                        \   Iteration 16, tidy the ship in slot 0
                        \     ...
                        \
                        \ and so on

 JSR TIDY               \ Call TIDY to tidy up the orientation vectors, to
                        \ prevent the ship from getting elongated and out of
                        \ shape due to the imprecise nature of trigonometry
                        \ in assembly language

\ ******************************************************************************
\
\       Name: MVEIT_FLIGHT (Part 2 of 6)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Call tactics routine, remove ship from scanner
\  Deep dive: Scheduling tasks with the main loop counter
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * Apply tactics to ships with AI enabled (by calling the TACTICS routine)
\
\   * Remove the ship from the scanner, so we can move it
\
\ ******************************************************************************

 LDX TYPE               \ If the type of the ship we are moving is positive,
 BPL P%+5               \ i.e. it is not a planet (types 128 and 130) or sun
                        \ (type 129), then skip the following instruction

 JMP MV40               \ This item is the planet or sun, so jump to MV40 to
                        \ move it, which ends by jumping back into this routine
                        \ at MV45 (after all the rotation, tactics and scanner
                        \ code, which we don't need to apply to planets or suns)

 LDA INWK+32            \ Fetch the ship's byte #32 (AI flag) into A

 BPL MV30               \ If bit 7 of the AI flag is clear, then if this is a
                        \ ship or missile it is dumb and has no AI, and if this
                        \ is the space station it is not hostile, so in both
                        \ cases skip the following as it has no tactics

 CPX #MSL               \ If the ship is a missile, skip straight to MV26 to
 BEQ MV26               \ call the TACTICS routine, as we do this every
                        \ iteration of the main loop for missiles only

 LDA MCNT               \ Fetch the main loop counter

 EOR XSAV               \ Fetch the slot number of the ship we are moving, EOR
 AND #7                 \ with the loop counter and apply mod 8 to the result.
 BNE MV30               \ The result will be zero when "counter mod 8" matches
                        \ the slot number mod 8, so this makes sure we call
                        \ TACTICS 12 times every 8 main loop iterations, like
                        \ this:
                        \
                        \   Iteration 0, apply tactics to slots 0 and 8
                        \   Iteration 1, apply tactics to slots 1 and 9
                        \   Iteration 2, apply tactics to slots 2 and 10
                        \   Iteration 3, apply tactics to slots 3 and 11
                        \   Iteration 4, apply tactics to slot 4
                        \   Iteration 5, apply tactics to slot 5
                        \   Iteration 6, apply tactics to slot 6
                        \   Iteration 7, apply tactics to slot 7
                        \   Iteration 8, apply tactics to slots 0 and 8
                        \     ...
                        \
                        \ and so on

.MV26

 JSR TACTICS            \ Call TACTICS to apply AI tactics to this ship

.MV30

 JSR SCAN               \ Draw the ship on the scanner, which has the effect of
                        \ removing it, as it's already at this point and hasn't
                        \ yet moved

\ ******************************************************************************
\
\       Name: MVEIT_FLIGHT (Part 3 of 6)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Move ship forward according to its speed
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * Move the ship forward (along the vector pointing in the direction of
\     travel) according to its speed:
\
\     (x, y, z) += nosev_hi * speed / 64
\
\ ******************************************************************************

 LDA INWK+27            \ Set Q = the ship's speed byte #27 * 4
 ASL A
 ASL A
 STA Q

 LDA INWK+10            \ Set A = |nosev_x_hi|
 AND #%01111111

 JSR FMLTU              \ Set R = A * Q / 256
 STA R                  \       = |nosev_x_hi| * speed / 64

 LDA INWK+10            \ If nosev_x_hi is positive, then:
 LDX #0                 \
 JSR MVT1-2             \   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + R
                        \
                        \ If nosev_x_hi is negative, then:
                        \
                        \   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - R
                        \
                        \ So in effect, this does:
                        \
                        \   (x_sign x_hi x_lo) += nosev_x_hi * speed / 64

 LDA INWK+12            \ Set A = |nosev_y_hi|
 AND #%01111111

 JSR FMLTU              \ Set R = A * Q / 256
 STA R                  \       = |nosev_y_hi| * speed / 64

 LDA INWK+12            \ If nosev_y_hi is positive, then:
 LDX #3                 \
 JSR MVT1-2             \   (y_sign y_hi y_lo) = (y_sign y_hi y_lo) + R
                        \
                        \ If nosev_y_hi is negative, then:
                        \
                        \   (y_sign y_hi y_lo) = (y_sign y_hi y_lo) - R
                        \
                        \ So in effect, this does:
                        \
                        \   (y_sign y_hi y_lo) += nosev_y_hi * speed / 64

 LDA INWK+14            \ Set A = |nosev_z_hi|
 AND #%01111111

 JSR FMLTU              \ Set R = A * Q / 256
 STA R                  \       = |nosev_z_hi| * speed / 64

 LDA INWK+14            \ If nosev_y_hi is positive, then:
 LDX #6                 \
 JSR MVT1-2             \   (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + R
                        \
                        \ If nosev_z_hi is negative, then:
                        \
                        \   (z_sign z_hi z_lo) = (z_sign z_hi z_lo) - R
                        \
                        \ So in effect, this does:
                        \
                        \   (z_sign z_hi z_lo) += nosev_z_hi * speed / 64

\ ******************************************************************************
\
\       Name: MVEIT_FLIGHT (Part 4 of 6)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Apply acceleration to ship's speed as a one-off
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * Apply acceleration to the ship's speed (if acceleration is non-zero),
\     and then zero the acceleration as it's a one-off change
\
\ ******************************************************************************

 LDA INWK+27            \ Set A = the ship's speed in byte #24 + the ship's
 CLC                    \ acceleration in byte #28
 ADC INWK+28

 BPL P%+4               \ If the result is positive, skip the following
                        \ instruction

 LDA #0                 \ Set A to 0 to stop the speed from going negative

 LDY #15                \ We now fetch byte #15 from the ship's blueprint, which
                        \ contains the ship's maximum speed, so set Y = 15 to
                        \ use as an index

 CMP (XX0),Y            \ If A < the ship's maximum speed, skip the following
 BCC P%+4               \ instruction

 LDA (XX0),Y            \ Set A to the ship's maximum speed

 STA INWK+27            \ We have now calculated the new ship's speed after
                        \ accelerating and keeping the speed within the ship's
                        \ limits, so store the updated speed in byte #27

 LDA #0                 \ We have added the ship's acceleration, so we now set
 STA INWK+28            \ it back to 0 in byte #28, as it's a one-off change

\ ******************************************************************************
\
\       Name: MVEIT_FLIGHT (Part 5 of 6)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Rotate ship's location by our pitch and roll
\  Deep dive: Rotating the universe
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * Rotate the ship's location in space by the amount of pitch and roll of
\     our ship. See below for a deeper explanation of this routine
\
\ ******************************************************************************

 LDX ALP1               \ Fetch the magnitude of the current roll into X, so
                        \ if the roll angle is alpha, X contains |alpha|

 LDA INWK               \ Set P = ~x_lo (i.e. with all its bits flipped) so that
 EOR #%11111111         \ we can pass x_lo to MLTU2 below)
 STA P

 LDA INWK+1             \ Set A = x_hi

 JSR MLTU2-2            \ Set (A P+1 P) = (A ~P) * X
                        \               = (x_hi x_lo) * alpha

 STA P+2                \ Store the high byte of the result in P+2, so we now
                        \ have:
                        \
                        \ P(2 1 0) = (x_hi x_lo) * alpha

 LDA ALP2+1             \ Fetch the flipped sign of the current roll angle alpha
 EOR INWK+2             \ from ALP2+1 and EOR with byte #2 (x_sign), so if the
                        \ flipped roll angle and x_sign have the same sign, A
                        \ will be positive, else it will be negative. So A will
                        \ contain the sign bit of x_sign * flipped alpha sign,
                        \ which is the opposite to the sign of the above result,
                        \ so we now have:
                        \
                        \ (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256

 LDX #3                 \ Set (A P+2 P+1) = (y_sign y_hi y_lo) + (A P+2 P+1)
 JSR MVT6               \                 = y - x * alpha / 256

 STA K2+3               \ Set K2(3) = A = the sign of the result

 LDA P+1                \ Set K2(1) = P+1, the low byte of the result
 STA K2+1

 EOR #%11111111         \ Set P = ~K2+1 (i.e. with all its bits flipped) so
 STA P                  \ that we can pass K2+1 to MLTU2 below)

 LDA P+2                \ Set K2(2) = A = P+2
 STA K2+2

                        \ So we now have result 1 above:
                        \
                        \ K2(3 2 1) = (A P+2 P+1)
                        \           = y - x * alpha / 256

 LDX BET1               \ Fetch the magnitude of the current pitch into X, so
                        \ if the pitch angle is beta, X contains |beta|

 JSR MLTU2-2            \ Set (A P+1 P) = (A ~P) * X
                        \               = K2(2 1) * beta

 STA P+2                \ Store the high byte of the result in P+2, so we now
                        \ have:
                        \
                        \ P(2 1 0) = K2(2 1) * beta

 LDA K2+3               \ Fetch the sign of the above result in K(3 2 1) from
 EOR BET2               \ K2+3 and EOR with BET2, the sign of the current pitch
                        \ rate, so if the pitch and K(3 2 1) have the same sign,
                        \ A will be positive, else it will be negative. So A
                        \ will contain the sign bit of K(3 2 1) * beta, which is
                        \ the same as the sign of the above result, so we now
                        \ have:
                        \
                        \ (A P+2 P+1) = K2(3 2 1) * beta / 256

 LDX #6                 \ Set (A P+2 P+1) = (z_sign z_hi z_lo) + (A P+2 P+1)
 JSR MVT6               \                 = z + K2 * beta / 256

 STA INWK+8             \ Set z_sign = A = the sign of the result

 LDA P+1                \ Set z_lo = P+1, the low byte of the result
 STA INWK+6

 EOR #%11111111         \ Set P = ~z_lo (i.e. with all its bits flipped) so that
 STA P                  \ we can pass z_lo to MLTU2 below)

 LDA P+2                \ Set z_hi = P+2
 STA INWK+7

                        \ So we now have result 2 above:
                        \
                        \ (z_sign z_hi z_lo) = (A P+2 P+1)
                        \                    = z + K2 * beta / 256

 JSR MLTU2              \ MLTU2 doesn't change Q, and Q was set to beta in
                        \ the previous call to MLTU2, so this call does:
                        \
                        \ (A P+1 P) = (A ~P) * Q
                        \           = (z_hi z_lo) * beta

 STA P+2                \ Set P+2 = A = the high byte of the result, so we
                        \ now have:
                        \
                        \ P(2 1 0) = (z_hi z_lo) * beta

 LDA K2+3               \ Set y_sign = K2+3
 STA INWK+5

 EOR BET2               \ EOR y_sign with BET2, the sign of the current pitch
 EOR INWK+8             \ rate, and z_sign. If the result is positive jump to
 BPL MV43               \ MV43, otherwise this means beta * z and y have
                        \ different signs, i.e. P(2 1) and K2(3 2 1) have
                        \ different signs, so we need to add them in order to
                        \ calculate K2(2 1) - P(2 1)

 LDA P+1                \ Set (y_hi y_lo) = K2(2 1) + P(2 1)
 ADC K2+1
 STA INWK+3
 LDA P+2
 ADC K2+2
 STA INWK+4

 JMP MV44               \ Jump to MV44 to continue the calculation

.MV43

 LDA K2+1               \ Reversing the logic above, we need to subtract P(2 1)
 SBC P+1                \ and K2(3 2 1) to calculate K2(2 1) - P(2 1), so this
 STA INWK+3             \ sets (y_hi y_lo) = K2(2 1) - P(2 1)
 LDA K2+2
 SBC P+2
 STA INWK+4

 BCS MV44               \ If the above subtraction did not underflow, then
                        \ jump to MV44, otherwise we need to negate the result

 LDA #1                 \ Negate (y_sign y_hi y_lo) using two's complement,
 SBC INWK+3             \ first doing the low bytes:
 STA INWK+3             \
                        \ y_lo = 1 - y_lo

 LDA #0                 \ Then the high bytes:
 SBC INWK+4             \
 STA INWK+4             \ y_hi = 0 - y_hi

 LDA INWK+5             \ And finally flip the sign in y_sign
 EOR #%10000000
 STA INWK+5

.MV44

                        \ So we now have result 3 above:
                        \
                        \ (y_sign y_hi y_lo) = K2(2 1) - P(2 1)
                        \                    = K2 - beta * z

 LDX ALP1               \ Fetch the magnitude of the current roll into X, so
                        \ if the roll angle is alpha, X contains |alpha|

 LDA INWK+3             \ Set P = ~y_lo (i.e. with all its bits flipped) so that
 EOR #&FF               \ we can pass y_lo to MLTU2 below)
 STA P

 LDA INWK+4             \ Set A = y_hi

 JSR MLTU2-2            \ Set (A P+1 P) = (A ~P) * X
                        \               = (y_hi y_lo) * alpha

 STA P+2                \ Store the high byte of the result in P+2, so we now
                        \ have:
                        \
                        \ P(2 1 0) = (y_hi y_lo) * alpha

 LDA ALP2               \ Fetch the correct sign of the current roll angle alpha
 EOR INWK+5             \ from ALP2 and EOR with byte #5 (y_sign), so if the
                        \ correct roll angle and y_sign have the same sign, A
                        \ will be positive, else it will be negative. So A will
                        \ contain the sign bit of x_sign * correct alpha sign,
                        \ which is the same as the sign of the above result,
                        \ so we now have:
                        \
                        \ (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256

 LDX #0                 \ Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
 JSR MVT6               \                 = x + y * alpha / 256

 STA INWK+2             \ Set x_sign = A = the sign of the result

 LDA P+2                \ Set x_hi = P+2, the high byte of the result
 STA INWK+1

 LDA P+1                \ Set x_lo = P+1, the low byte of the result
 STA INWK

                        \ So we now have result 4 above:
                        \
                        \ x = x + alpha * y
                        \
                        \ and the rotation of (x, y, z) is done

\ ******************************************************************************
\
\       Name: MVEIT_FLIGHT (Part 6 of 6)
\       Type: Subroutine
\   Category: Moving
\    Summary: Move current ship: Move the ship in space according to our speed
\
\ ------------------------------------------------------------------------------
\
\ This routine has multiple stages. This stage does the following:
\
\   * Move the ship in space according to our speed (we already moved it
\     according to its own speed in part 3).
\
\ We do this by subtracting our speed (i.e. the distance we travel in this
\ iteration of the loop) from the other ship's z-coordinate. We subtract because
\ they appear to be "moving" in the opposite direction to us, and the whole
\ MVEIT routine is about moving the other ships rather than us (even though we
\ are the one doing the moving).
\
\ Other entry points:
\
\   MV45                Rejoin the MVEIT routine after the rotation, tactics and
\                       scanner code
\
\ ******************************************************************************

.MV45

 LDA DELTA              \ Set R to our speed in DELTA
 STA R

 LDA #%10000000         \ Set A to zeroes but with bit 7 set, so that (A R) is
                        \ a 16-bit number containing -R, or -speed

 LDX #6                 \ Set X to the z-axis so the call to MVT1 does this:
 JSR MVT1               \
                        \ (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + (A R)
                        \                    = (z_sign z_hi z_lo) - speed

 LDA TYPE               \ If the ship type is the sun (129) then skip the next
 AND #%10000001         \ instruction, otherwise return from the subroutine as
 CMP #129               \ we don't need to rotate the sun around its origin.
 BEQ P%+5               \ Having both the AND and the CMP is a little odd, as
                        \ the sun is the only ship type with bits 0 and 7 set,
                        \ so the AND has no effect and could be removed

 JMP MV3                \ The ship type is not the sun, so jump to MV3, skipping
                        \ the next instruction

 RTS                    \ Return from the subroutine, as the ship we are moving
                        \ is the sun and doesn't need any of the following

\ ******************************************************************************
\
\       Name: MVT1
\       Type: Subroutine
\   Category: Moving
\    Summary: Calculate (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
\
\ ------------------------------------------------------------------------------
\
\ Add the signed delta (A R) to a ship's coordinate, along the axis given in X.
\ Mathematically speaking, this routine translates the ship along a single axis
\ by a signed delta. Taking the example of X = 0, the x-axis, it does the
\ following:
\
\   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
\
\ (In practice, MVT1 is only ever called directly with A = 0 or 128, otherwise
\ it is always called via MVT-2, which clears A apart from the sign bit. The
\ routine is written to cope with a non-zero delta_hi, so it supports a full
\ 16-bit delta, but it appears that delta_hi is only ever used to hold the
\ sign of the delta.)
\
\ The comments below assume we are adding delta to the x-axis, though the axis
\ is determined by the value of X.
\
\ Arguments:
\
\   (A R)               The signed delta, so A = delta_hi and R = delta_lo
\
\   X                   Determines which coordinate axis of INWK to change:
\
\                         * X = 0 adds the delta to (x_lo, x_hi, x_sign)
\
\                         * X = 3 adds the delta to (y_lo, y_hi, y_sign)
\
\                         * X = 6 adds the delta to (z_lo, z_hi, z_sign)
\
\ Other entry points:
\
\   MVT1-2              Clear bits 0-6 of A before entering MVT1
\
\ ******************************************************************************

 AND #%10000000         \ Clear bits 0-6 of A

.MVT1

 ASL A                  \ Set the C flag to the sign bit of the delta, leaving
                        \ delta_hi << 1 in A

 STA S                  \ Set S = delta_hi << 1
                        \
                        \ This also clears bit 0 of S

 LDA #0                 \ Set T = just the sign bit of delta (in bit 7)
 ROR A
 STA T

 LSR S                  \ Set S = delta_hi >> 1
                        \       = |delta_hi|
                        \
                        \ This also clear the C flag, as we know that bit 0 of
                        \ S was clear before the LSR

 EOR INWK+2,X           \ If T EOR x_sign has bit 7 set, then x_sign and delta
 BMI MV10               \ have different signs, so jump to MV10

                        \ At this point, we know x_sign and delta have the same
                        \ sign, that sign is in T, and S contains |delta_hi|,
                        \ so now we want to do:
                        \
                        \   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (S R)
                        \
                        \ and then set the sign of the result to the same sign
                        \ as x_sign and delta

 LDA R                  \ First we add the low bytes, so:
 ADC INWK,X             \
 STA INWK,X             \   x_lo = x_lo + R

 LDA S                  \ Then we add the high bytes:
 ADC INWK+1,X           \
 STA INWK+1,X           \   x_hi = x_hi + S

 LDA INWK+2,X           \ And finally we add any carry into x_sign, and if the
 ADC #0                 \ sign of x_sign and delta in T is negative, make sure
 ORA T                  \ the result is negative (by OR'ing with T)
 STA INWK+2,X

 RTS                    \ Return from the subroutine

.MV10

                        \ If we get here, we know x_sign and delta have
                        \ different signs, with delta's sign in T, and
                        \ |delta_hi| in S, so now we want to do:
                        \
                        \   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - (S R)
                        \
                        \ and then set the sign of the result according to
                        \ the signs of x_sign and delta

 LDA INWK,X             \ First we subtract the low bytes, so:
 SEC                    \
 SBC R                  \   x_lo = x_lo - R
 STA INWK,X

 LDA INWK+1,X           \ Then we subtract the high bytes:
 SBC S                  \
 STA INWK+1,X           \   x_hi = x_hi - S

 LDA INWK+2,X           \ And finally we subtract any borrow from bits 0-6 of
 AND #%01111111         \ x_sign, and give the result the opposite sign bit to T
 SBC #0                 \ (i.e. give it the sign of the original x_sign)
 ORA #%10000000
 EOR T
 STA INWK+2,X

 BCS MV11               \ If the C flag is set by the above SBC, then our sum
                        \ above didn't underflow and is correct - to put it
                        \ another way, (x_sign x_hi x_lo) >= (S R) so the result
                        \ should indeed have the same sign as x_sign, so jump to
                        \ MV11 to return from the subroutine

                        \ Otherwise our subtraction underflowed because
                        \ (x_sign x_hi x_lo) < (S R), so we now need to flip the
                        \ subtraction around by using two's complement to this:
                        \
                        \   (S R) - (x_sign x_hi x_lo)
                        \
                        \ and then we need to give the result the same sign as
                        \ (S R), the delta, as that's the dominant figure in the
                        \ sum

 LDA #1                 \ First we subtract the low bytes, so:
 SBC INWK,X             \
 STA INWK,X             \   x_lo = 1 - x_lo

 LDA #0                 \ Then we subtract the high bytes:
 SBC INWK+1,X           \
 STA INWK+1,X           \   x_hi = 0 - x_hi

 LDA #0                 \ And then we subtract the sign bytes:
 SBC INWK+2,X           \
                        \   x_sign = 0 - x_sign

 AND #%01111111         \ Finally, we set the sign bit to the sign in T, the
 ORA T                  \ sign of the original delta, as the delta is the
 STA INWK+2,X           \ dominant figure in the sum

.MV11

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MVT6
\       Type: Subroutine
\   Category: Moving
\    Summary: Calculate (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
\
\ ------------------------------------------------------------------------------
\
\ Do the following calculation, for the coordinate given by X (so this is what
\ it does for the x-coordinate):
\
\   (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
\
\ A is a sign bit and is not included in the calculation, but bits 0-6 of A are
\ preserved. Bit 7 is set to the sign of the result.
\
\ Arguments:
\
\   A                   The sign of P(2 1) in bit 7
\
\   P(2 1)              The 16-bit value we want to add the coordinate to
\
\   X                   The coordinate to add, as follows:
\
\                         * If X = 0, add to (x_sign x_hi x_lo)
\
\                         * If X = 3, add to (y_sign y_hi y_lo)
\
\                         * If X = 6, add to (z_sign z_hi z_lo)
\
\ Returns:
\
\   A                   The sign of the result (in bit 7)
\
\ ******************************************************************************

.MVT6

 TAY                    \ Store argument A into Y, for later use

 EOR INWK+2,X           \ Set A = A EOR x_sign

 BMI MV50               \ If the sign is negative, i.e. A and x_sign have
                        \ different signs, jump to MV50

                        \ The signs are the same, so we can add the two
                        \ arguments and keep the sign to get the result

 LDA P+1                \ First we add the low bytes:
 CLC                    \
 ADC INWK,X             \   P+1 = P+1 + x_lo
 STA P+1

 LDA P+2                \ And then the high bytes:
 ADC INWK+1,X           \
 STA P+2                \   P+2 = P+2 + x_hi

 TYA                    \ Restore the original A argument that we stored earlier
                        \ so that we keep the original sign

 RTS                    \ Return from the subroutine

.MV50

 LDA INWK,X             \ First we subtract the low bytes:
 SEC                    \
 SBC P+1                \   P+1 = x_lo - P+1
 STA P+1

 LDA INWK+1,X           \ And then the high bytes:
 SBC P+2                \
 STA P+2                \   P+2 = x_hi - P+2

 BCC MV51               \ If the last subtraction underflowed, then the C flag
                        \ will be clear and x_hi < P+2, so jump to MV51 to
                        \ negate the result

 TYA                    \ Restore the original A argument that we stored earlier
 EOR #%10000000         \ but flip bit 7, which flips the sign. We do this
                        \ because x_hi >= P+2 so we want the result to have the
                        \ same sign as x_hi (as it's the dominant side in this
                        \ calculation). The sign of x_hi is x_sign, and x_sign
                        \ has the opposite sign to A, so we flip the sign in A
                        \ to return the correct result

 RTS                    \ Return from the subroutine

.MV51

 LDA #1                 \ Our subtraction underflowed, so we negate the result
 SBC P+1                \ using two's complement, first with the low byte:
 STA P+1                \
                        \   P+1 = 1 - P+1

 LDA #0                 \ And then the high byte:
 SBC P+2                \
 STA P+2                \   P+2 = 0 - P+2

 TYA                    \ Restore the original A argument that we stored earlier
                        \ as this is the correct sign for the result. This is
                        \ because x_hi < P+2, so we want to return the same sign
                        \ as P+2, the dominant side

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MV40
\       Type: Subroutine
\   Category: Moving
\    Summary: Rotate the planet or sun's location in space by the amount of
\             pitch and roll of our ship
\
\ ------------------------------------------------------------------------------
\
\ We implement this using the same equations as in part 5 of MVEIT, where we
\ rotated the current ship's location by our pitch and roll. Specifically, the
\ calculation is as follows:
\
\   1. K2 = y - alpha * x
\   2. z = z + beta * K2
\   3. y = K2 - beta * z
\   4. x = x + alpha * y
\
\ See the deep dive on "Rotating the universe" for more details on the above.
\
\ ******************************************************************************

.MV40

 LDA ALPHA              \ Set Q = -ALPHA, so Q contains the angle we want to
 EOR #%10000000         \ roll the planet through (i.e. in the opposite
 STA Q                  \ direction to our ship's roll angle alpha)

 LDA INWK               \ Set P(1 0) = (x_hi x_lo)
 STA P
 LDA INWK+1
 STA P+1

 LDA INWK+2             \ Set A = x_sign

 JSR MULT3              \ Set K(3 2 1 0) = (A P+1 P) * Q
                        \
                        \ which also means:
                        \
                        \   K(3 2 1) = (A P+1 P) * Q / 256
                        \            = x * -alpha / 256
                        \            = - alpha * x / 256

 LDX #3                 \ Set K(3 2 1) = (y_sign y_hi y_lo) + K(3 2 1)
 JSR MVT3               \              = y - alpha * x / 256

 LDA K+1                \ Set K2(2 1) = P(1 0) = K(2 1)
 STA K2+1
 STA P

 LDA K+2                \ Set K2+2 = K+2
 STA K2+2

 STA P+1                \ Set P+1 = K+2

 LDA BETA               \ Set Q = beta, the pitch angle of our ship
 STA Q

 LDA K+3                \ Set K+3 to K2+3, so now we have result 1 above:
 STA K2+3               \
                        \   K2(3 2 1) = K(3 2 1)
                        \             = y - alpha * x / 256

                        \ We also have:
                        \
                        \   A = K+3
                        \
                        \   P(1 0) = K(2 1)
                        \
                        \ so combined, these mean:
                        \
                        \   (A P+1 P) = K(3 2 1)
                        \             = K2(3 2 1)

 JSR MULT3              \ Set K(3 2 1 0) = (A P+1 P) * Q
                        \
                        \ which also means:
                        \
                        \   K(3 2 1) = (A P+1 P) * Q / 256
                        \            = K2(3 2 1) * beta / 256
                        \            = beta * K2 / 256

 LDX #6                 \ K(3 2 1) = (z_sign z_hi z_lo) + K(3 2 1)
 JSR MVT3               \          = z + beta * K2 / 256

 LDA K+1                \ Set P = K+1
 STA P

 STA INWK+6             \ Set z_lo = K+1

 LDA K+2                \ Set P+1 = K+2
 STA P+1

 STA INWK+7             \ Set z_hi = K+2

 LDA K+3                \ Set A = z_sign = K+3, so now we have:
 STA INWK+8             \
                        \   (z_sign z_hi z_lo) = K(3 2 1)
                        \                      = z + beta * K2 / 256

                        \ So we now have result 2 above:
                        \
                        \   z = z + beta * K2

 EOR #%10000000         \ Flip the sign bit of A to give A = -z_sign

 JSR MULT3              \ Set K(3 2 1 0) = (A P+1 P) * Q
                        \                = (-z_sign z_hi z_lo) * beta
                        \                = -z * beta

 LDA K+3                \ Set T to the sign bit of K(3 2 1 0), i.e. to the sign
 AND #%10000000         \ bit of -z * beta
 STA T

 EOR K2+3               \ If K2(3 2 1 0) has a different sign to K(3 2 1 0),
 BMI MV1                \ then EOR'ing them will produce a 1 in bit 7, so jump
                        \ to MV1 to take this into account

                        \ If we get here, K and K2 have the same sign, so we can
                        \ add them together to get the result we're after, and
                        \ then set the sign afterwards

 LDA K                  \ We now do the following sum:
 CLC                    \
 ADC K2                 \   (A y_hi y_lo -) = K(3 2 1 0) + K2(3 2 1 0)
                        \
                        \ starting with the low bytes (which we don't keep)
                        \
                        \ The CLC has no effect because MULT3 clears the C
                        \ flag, so this instruction could be removed (as it is
                        \ in the cassette version, for example)

 LDA K+1                \ We then do the middle bytes, which go into y_lo
 ADC K2+1
 STA INWK+3

 LDA K+2                \ And then the high bytes, which go into y_hi
 ADC K2+2
 STA INWK+4

 LDA K+3                \ And then the sign bytes into A, so overall we have the
 ADC K2+3               \ following, if we drop the low bytes from the result:
                        \
                        \   (A y_hi y_lo) = (K + K2) / 256

 JMP MV2                \ Jump to MV2 to skip the calculation for when K and K2
                        \ have different signs

.MV1

 LDA K                  \ If we get here then K2 and K have different signs, so
 SEC                    \ instead of adding, we need to subtract to get the
 SBC K2                 \ result we want, like this:
                        \
                        \   (A y_hi y_lo -) = K(3 2 1 0) - K2(3 2 1 0)
                        \
                        \ starting with the low bytes (which we don't keep)

 LDA K+1                \ We then do the middle bytes, which go into y_lo
 SBC K2+1
 STA INWK+3

 LDA K+2                \ And then the high bytes, which go into y_hi
 SBC K2+2
 STA INWK+4

 LDA K2+3               \ Now for the sign bytes, so first we extract the sign
 AND #%01111111         \ byte from K2 without the sign bit, so P = |K2+3|
 STA P

 LDA K+3                \ And then we extract the sign byte from K without the
 AND #%01111111         \ sign bit, so A = |K+3|

 SBC P                  \ And finally we subtract the sign bytes, so P = A - P
 STA P

                        \ By now we have the following, if we drop the low bytes
                        \ from the result:
                        \
                        \   (A y_hi y_lo) = (K - K2) / 256
                        \
                        \ so now we just need to make sure the sign of the
                        \ result is correct

 BCS MV2                \ If the C flag is set, then the last subtraction above
                        \ didn't underflow and the result is correct, so jump to
                        \ MV2 as we are done with this particular stage

 LDA #1                 \ Otherwise the subtraction above underflowed, as K2 is
 SBC INWK+3             \ the dominant part of the subtraction, so we need to
 STA INWK+3             \ negate the result using two's complement, starting
                        \ with the low bytes:
                        \
                        \   y_lo = 1 - y_lo

 LDA #0                 \ And then the high bytes:
 SBC INWK+4             \
 STA INWK+4             \   y_hi = 0 - y_hi

 LDA #0                 \ And finally the sign bytes:
 SBC P                  \
                        \   A = 0 - P

 ORA #%10000000         \ We now force the sign bit to be negative, so that the
                        \ final result below gets the opposite sign to K, which
                        \ we want as K2 is the dominant part of the sum

.MV2

 EOR T                  \ T contains the sign bit of K, so if K is negative,
                        \ this flips the sign of A

 STA INWK+5             \ Store A in y_sign

                        \ So we now have result 3 above:
                        \
                        \   y = K2 + K
                        \     = K2 - beta * z

 LDA ALPHA              \ Set A = alpha
 STA Q

 LDA INWK+3             \ Set P(1 0) = (y_hi y_lo)
 STA P
 LDA INWK+4
 STA P+1

 LDA INWK+5             \ Set A = y_sign

 JSR MULT3              \ Set K(3 2 1 0) = (A P+1 P) * Q
                        \                = (y_sign y_hi y_lo) * alpha
                        \                = y * alpha

 LDX #0                 \ Set K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
 JSR MVT3               \              = x + y * alpha / 256

 LDA K+1                \ Set (x_sign x_hi x_lo) = K(3 2 1)
 STA INWK               \                        = x + y * alpha / 256
 LDA K+2
 STA INWK+1
 LDA K+3
 STA INWK+2

                        \ So we now have result 4 above:
                        \
                        \   x = x + y * alpha

 JMP MV45               \ We have now finished rotating the planet or sun by
                        \ our pitch and roll, so jump back into the MVEIT
                        \ routine at MV45 to apply all the other movements

\ ******************************************************************************
\
\       Name: PU1
\       Type: Subroutine
\   Category: Flight
\    Summary: Flip the coordinate axes for the four different views
\  Deep dive: Flipping axes between space views
\
\ ------------------------------------------------------------------------------
\
\ This routine flips the relevant geometric axes in INWK depending on which
\ view we are looking through (front, rear, left, right).
\
\ ******************************************************************************

.PU1

 DEX                    \ Decrement the view, so now:
                        \
                        \   0 = rear
                        \   1 = left
                        \   2 = right

 BNE PU2                \ If the current view is left or right, jump to PU2,
                        \ otherwise this is the rear view, so continue on

 LDA INWK+2             \ Flip the sign of x_sign
 EOR #%10000000
 STA INWK+2

 LDA INWK+8             \ Flip the sign of z_sign
 EOR #%10000000
 STA INWK+8

 LDA INWK+10            \ Flip the sign of nosev_x_hi
 EOR #%10000000
 STA INWK+10

 LDA INWK+14            \ Flip the sign of nosev_z_hi
 EOR #%10000000
 STA INWK+14

 LDA INWK+16            \ Flip the sign of roofv_x_hi
 EOR #%10000000
 STA INWK+16

 LDA INWK+20            \ Flip the sign of roofv_z_hi
 EOR #%10000000
 STA INWK+20

 LDA INWK+22            \ Flip the sign of sidev_x_hi
 EOR #%10000000
 STA INWK+22

 LDA INWK+26            \ Flip the sign of roofv_z_hi
 EOR #%10000000
 STA INWK+26

 RTS                    \ Return from the subroutine

.PU2

                        \ We enter this with X set to the view, as follows:
                        \
                        \   1 = left
                        \   2 = right

 LDA #0                 \ Set RAT2 = 0 (left view) or -1 (right view)
 CPX #2
 ROR A
 STA RAT2

 EOR #%10000000         \ Set RAT = -1 (left view) or 0 (right view)
 STA RAT

 LDA INWK               \ Swap x_lo and z_lo
 LDX INWK+6
 STA INWK+6
 STX INWK

 LDA INWK+1             \ Swap x_hi and z_hi
 LDX INWK+7
 STA INWK+7
 STX INWK+1

 LDA INWK+2             \ Swap x_sign and z_sign
 EOR RAT                \ If left view, flip sign of new z_sign
 TAX                    \ If right view, flip sign of new x_sign
 LDA INWK+8
 EOR RAT2
 STA INWK+2
 STX INWK+8

 LDY #9                 \ Swap nosev_x_lo and nosev_z_lo
 JSR PUS1               \ Swap nosev_x_hi and nosev_z_hi
                        \ If left view, flip sign of new nosev_z_hi
                        \ If right view, flip sign of new nosev_x_hi

 LDY #15                \ Swap roofv_x_lo and roofv_z_lo
 JSR PUS1               \ Swap roofv_x_hi and roofv_z_hi
                        \ If left view, flip sign of new roofv_z_hi
                        \ If right view, flip sign of new roofv_x_hi

 LDY #21                \ Swap sidev_x_lo and sidev_z_lo
                        \ Swap sidev_x_hi and sidev_z_hi
                        \ If left view, flip sign of new sidev_z_hi
                        \ If right view, flip sign of new sidev_x_hi

.PUS1

 LDA INWK,Y             \ Swap the low x and z bytes for the vector in Y:
 LDX INWK+4,Y           \
 STA INWK+4,Y           \   * For Y =  9 swap nosev_x_lo and nosev_z_lo
 STX INWK,Y             \   * For Y = 15 swap roofv_x_lo and roofv_z_lo
                        \   * For Y = 21 swap sidev_x_lo and sidev_z_lo

 LDA INWK+1,Y           \ Swap the high x and z bytes for the offset in Y:
 EOR RAT                \
 TAX                    \   * If left view, flip sign of new z-coordinate
 LDA INWK+5,Y           \   * If right view, flip sign of new x-coordinate
 EOR RAT2
 STA INWK+1,Y
 STX INWK+5,Y

                        \ Fall through into LOOK1 to return from the subroutine

\ ******************************************************************************
\
\       Name: LOOK1
\       Type: Subroutine
\   Category: Flight
\    Summary: Initialise the space view
\
\ ------------------------------------------------------------------------------
\
\ Initialise the space view, with the direction of view given in X. This clears
\ the upper screen and draws the laser crosshairs, if the view in X has lasers
\ fitted. It also wipes all the ships from the scanner, so we can recalculate
\ ship positions for the new view (they get put back in the main flight loop).
\
\ Arguments:
\
\   X                   The space view to set:
\
\                         * 0 = front
\
\                         * 1 = rear
\
\                         * 2 = left
\
\                         * 3 = right
\
\ Other entry points:
\
\   LO2                 Contains an RTS
\
\ ******************************************************************************

.LO2

 RTS                    \ Return from the subroutine

.LQ

 STX VIEW               \ Set the current space view to X

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 0 (space
                        \ view)

 JSR SIGHT              \ Draw the laser crosshairs

 JMP NWSTARS            \ Set up a new stardust field and return from the
                        \ subroutine using a tail call

.LOOK1

 LDA #0                 \ Set A = 0, the type number of a space view

 LDY QQ11               \ If the current view is not a space view, jump up to LQ
 BNE LQ                 \ to set up a new space view

 CPX VIEW               \ If the current view is already of type X, jump to LO2
 BEQ LO2                \ to return from the subroutine (as LO2 contains an RTS)

 STX VIEW               \ Change the current space view to X

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 0 (space
                        \ view)

 JSR FLIP               \ Swap the x- and y-coordinates of all the stardust
                        \ particles and redraw the stardust field

 JSR WPSHPSS            \ Wipe all the ships from the scanner and mark them all
                        \ as not being shown on-screen

                        \ And fall through into SIGHT to draw the laser
                        \ crosshairs

\ ******************************************************************************
\
\       Name: SIGHT
\       Type: Subroutine
\   Category: Flight
\    Summary: Draw the laser crosshairs
\
\ ******************************************************************************

.SIGHT

 LDY VIEW               \ Fetch the laser power for our new view
 LDA LASER,Y

 BEQ LO2                \ If it is zero (i.e. there is no laser fitted to this
                        \ view), jump to LO2 to return from the subroutine (as
                        \ LO2 contains an RTS)

 LDA #128               \ Set QQ19 to the x-coordinate of the centre of the
 STA QQ19               \ screen

 LDA #Y-24              \ Set QQ19+1 to the y-coordinate of the centre of the
 STA QQ19+1             \ screen, minus 24 (because TT15 will add 24 to the
                        \ coordinate when it draws the crosshairs)

 LDA #20                \ Set QQ19+2 to size 20 for the crosshairs size
 STA QQ19+2

 JSR TT15               \ Call TT15 to draw crosshairs of size 20 just to the
                        \ left of the middle of the screen

 LDA #10                \ Set QQ19+2 to size 10 for the crosshairs size
 STA QQ19+2

 JMP TT15               \ Call TT15 to draw crosshairs of size 10 at the same
                        \ location, which will remove the centre part from the
                        \ laser crosshairs, leaving a gap in the middle, and
                        \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: iff_xor
\       Type: Variable
\   Category: Dashboard
\    Summary: The EOR value for different types of ship in the I.F.F. system
\             for creating striped sticks in the scanner
\  Deep dive: The I.F.F. system
\
\ ------------------------------------------------------------------------------
\
\ These are the EOR values for the I.F.F. system, which shows ships on the
\ scanner in the following colours, depending on the type index for this ship
\ (as returned by the iff_index routine). The EOR values determine whether the
\ stick is striped.
\
\ The colours for the normal dashboard palette are:
\
\   Index     Dot colour  Stick colour(s)     Ship types
\   -----     ----------  ---------------     ----------
\   0         Green       Green               Clean
\   1         Yellow      Yellow              Station tracked
\   2         Green       Green and yellow    Debris
\   3         Yellow      Yellow and red      Missile
\   4         Green       Green and red       Offender/fugitive
\
\ The colours for the escape pod dashboard palette are:
\
\   Index     Dot colour  Stick colour(s)     Ship types
\   -----     ----------  ---------------     ----------
\   0         Cyan        Cyan                Clean
\   1         White       White               Station tracked
\   2         Cyan        Cyan and white      Debris
\   3         White       White and red       Missile
\   4         Cyan        Cyan and red        Offender/fugitive
\
\ The EOR values have the following effect on the colour of the stick:
\
\   %00000000       Stick is a solid colour, in the base colour
\   %00001111       Stick is striped, in the base colour and base colour EOR %01
\   %11110000       Stick is striped, in the base colour and base colour EOR %10
\   %11111111       Stick is striped, in the base colour and base colour EOR %11
\
\ Taking the example of debris, the base colour from iff_base+2 is &FF, which is
\ %11111111, or a four-pixel byte of colour %11, or colour 3 in mode 5, or
\ green/cyan (green for the normal palette, cyan in the escape pod palette).
\
\ The EOR value from iff_xor+2 is &0F, which is %00001111, or a four-pixel byte
\ of %01 values. Applying this EOR to the base colour (%11) gives:
\
\   %11 EOR %01 = %10 = 2
\
\ and colour 2 in mode 5 is yellow/white (yellow for the normal palette, white
\ in the escape pod palette). So the stick colour for debris when we have an
\ I.F.F. system fitted is:
\
\   Green/cyan (the base colour) striped with yellow/white (the colour after
\   applying the EOR value)
\
\ If there is no I.F.F. system fitted, the index is 0 and the EOR value is 0,
\ which doesn't affect the default colour.
\
\ The last two entries are the same as the first two entries in iff_base, which
\ is the next variable, so they are commented out here to save two bytes.
\
\ ******************************************************************************

.iff_xor

 EQUB &00               \ Index 0: Clean = %00000000

 EQUB &00               \ Index 1: Station tracked = %00000000

 EQUB &0F               \ Index 2: Debris = %00001111

\EQUB &FF               \ Index 3: Missile = %11111111

\EQUB &F0               \ Index 4: Offender/fugitive = %11110000

\ ******************************************************************************
\
\       Name: iff_base
\       Type: Variable
\   Category: Dashboard
\    Summary: Base colours for different types of ship in the I.F.F. system
\  Deep dive: The I.F.F. system
\
\ ------------------------------------------------------------------------------
\
\ These are the base colours for the I.F.F. system, which shows ships on the
\ scanner in the following colours, depending on the type index for this ship
\ (as returned by the iff_index routine). The base colours determine the colour
\ of the dot, as well as the underlying colour of the stick (which can be
\ striped, depending on the corresponding EOR colour from iff_xor).
\
\ The colours for the normal dashboard palette are:
\
\   Index     Dot colour  Stick colour(s)     Ship types
\   0         Green       Green               Clean
\   1         Yellow      Yellow              Station tracked
\   2         Green       Green and yellow    Debris
\   3         Yellow      Yellow and red      Missile
\   4         Green       Green and red       Offender/fugitive
\
\ The colours for the escape pod dashboard palette are:
\
\   Index     Dot colour  Stick colour(s)     Ship types
\   0         Cyan        Cyan                Clean
\   1         White       White               Station tracked
\   2         Cyan        Cyan and white      Debris
\   3         White       White and red       Missile
\   4         Cyan        Cyan and red        Offender/fugitive
\
\ ******************************************************************************

.iff_base

 EQUB &FF               \ Index 0: Clean = green/cyan

 EQUB &F0               \ Index 1: Station tracked = yellow/white

 EQUB &FF               \ Index 2: Debris = green/cyan

 EQUB &F0               \ Index 3: Missile = yellow/white

 EQUB &FF               \ Index 4: Offender/fugitive = green/cyan

\ ******************************************************************************
\
\       Name: SCAN
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Display the current ship on the scanner by sending a draw_tail
\             command to the I/O processor
\  Deep dive: The 3D scanner
\             The I.F.F. system
\
\ ------------------------------------------------------------------------------
\
\ This is used both to display a ship on the scanner, and to erase it again.
\
\ Arguments:
\
\   INWK                The ship's data block
\
\ ******************************************************************************

.SC5

 RTS                    \ Return from the subroutine

.SCAN

 LDA INWK+31            \ Fetch the ship's scanner flag from byte #31

 AND #%00010000         \ If bit 4 is clear then the ship should not be shown
 BEQ SC5                \ on the scanner, so return from the subroutine (as SC5
                        \ contains an RTS)

 LDA TYPE               \ Fetch the ship's type from TYPE into A

 BMI SC5                \ If this is the planet or the sun, then the type will
                        \ have bit 7 set and we don't want to display it on the
                        \ scanner, so return from the subroutine (as SC5
                        \ contains an RTS)

 LDX CRGO               \ If we do not have an I.F.F. system fitted (i.e. CRGO
 BEQ iff_not            \ is zero), jump to iff_not to fetch the default
                        \ colours, which are those for a trader or innocent
                        \ bystander (i.e. X = 0)

                        \ If we get here then X = &FF (as CRGO is &FF if we have
                        \ an I.F.F. system fitted)

 LDY #36                \ Set A to byte #36 of the ship's blueprint, i.e. the
 LDA (INF),Y            \ NEWB flags

 ASL A                  \ If bit 6 is set, i.e. this is a cop, a space station
 ASL A                  \ or an escape pod, jump to iff_cop to set X = 1
 BCS iff_cop

 ASL A                  \ If bit 5 is set, i.e. this is an innocent bystander
 BCS iff_trade          \ (which applies to traders and some bounty hunters),
                        \ jump to iff_trade to set X = 0

 LDY TYPE               \ Set Y to the ship's type - 1
 DEY

 BEQ iff_missle         \ If Y = 0, i.e. this is a missile, then jump to
                        \ iff_missle to set X = 3

 CPY #8                 \ If Y < 8, i.e. this is a cargo canister, alloy plate,
 BCC iff_aster          \ boulder, asteroid or splinter, then jump to iff_aster
                        \ to set X = 2

                        \ If we get here then the ship is not the following:
                        \
                        \   * A cop/station/escape pod
                        \   * An innocent bystander/trader/good bounty hunter
                        \   * A missile
                        \   * Cargo or an asteroid
                        \
                        \ So it must be a pirate or a non-innocent bounty hunter

 INX                    \ X is &FF at this point, so this INX sets X = 0, and we
                        \ then fall through into the four INX instructions below
                        \ to set X = 4

.iff_missle

 INX                    \ If we jump to this point, then set X = 3

.iff_aster

 INX                    \ If we jump to this point, then set X = 2

.iff_cop

 INX                    \ If we jump to this point, then set X = 1

.iff_trade

 INX                    \ If we jump to this point, then set X = 0

.iff_not

 LDA iff_base,X         \ Set COL to the base colour for this ship, given the
 STA COL                \ I.F.F. colour index in X (this colour is used for both
                        \ the dot and stick)

 LDA iff_xor,X          \ Set Y2 to the alternating colour for this ship, given
 STA Y2                 \ the I.F.F. colour index in X (this colour is used for
                        \ making the stick striped, where appropriate)

 LDA INWK+1             \ If any of x_hi, y_hi and z_hi have a 1 in bit 6 or 7,
 ORA INWK+4             \ then the ship is too far away to be shown on the
 ORA INWK+7             \ scanner, so return from the subroutine (as SC5
 AND #%11000000         \ contains an RTS)
 BNE SC5

                        \ If we get here, we know x_hi, y_hi and z_hi are all
                        \ 63 (%00111111) or less

                        \ Now, we convert the x_hi coordinate of the ship into
                        \ the screen x-coordinate of the dot on the scanner,
                        \ using the following (see the deep dive on "The 3D
                        \ scanner" for an explanation):
                        \
                        \   X1 = 123 + (x_sign x_hi)

 LDA INWK+1             \ Set x_hi

 CLC                    \ Clear the C flag so we can do addition below

 LDX INWK+2             \ Set X = x_sign

 BPL SC2                \ If x_sign is positive, skip the following

 EOR #%11111111         \ x_sign is negative, so flip the bits in A and subtract
 ADC #1                 \ 1 to make it a negative number (bit 7 will now be set
                        \ as we confirmed above that bits 6 and 7 are clear). So
                        \ this gives A the sign of x_sign and gives it a value
                        \ range of -63 (%11000001) to 0

.SC2

 ADC #123               \ Set X1 = 123 + x_hi
 STA X1

                        \ Next, we convert the z_hi coordinate of the ship into
                        \ the y-coordinate of the base of the ship's stick,
                        \ like this (see the deep dive on "The 3D scanner" for
                        \ an explanation):
                        \
                        \   SC = 220 - (z_sign z_hi) / 4
                        \
                        \ though the following code actually does it like this:
                        \
                        \   SC = 255 - (35 + z_hi / 4)

 LDA INWK+7             \ Set A = z_hi / 4
 LSR A                  \
 LSR A                  \ So A is in the range 0-15

 CLC                    \ Clear the C flag

 LDX INWK+8             \ Set X = z_sign

 BPL SC3                \ If z_sign is positive, skip the following

 EOR #%11111111         \ z_sign is negative, so flip the bits in A and set the
 SEC                    \ C flag. As above, this makes A negative, this time
                        \ with a range of -16 (%11110000) to -1 (%11111111). And
                        \ as we are about to do an ADC, the SEC effectively adds
                        \ another 1 to that value, giving a range of -15 to 0

.SC3

 ADC #35                \ Set A = 35 + A to give a number in the range 20 to 50

 EOR #%11111111         \ Flip all the bits and store in SC, so SC is in the
 STA SC                 \ range 205 to 235, with a higher z_hi giving a lower SC

                        \ Now for the stick height, which we calculate using the
                        \ following (see the deep dive on "The 3D scanner" for
                        \ an explanation):
                        \
                        \ A = - (y_sign y_hi) / 2

 LDA INWK+4             \ Set A = y_hi / 2
 LSR A

 CLC                    \ Clear the C flag

 LDX INWK+5             \ Set X = y_sign

 BMI SCD6               \ If y_sign is negative, skip the following, as we
                        \ already have a positive value in A

 EOR #%11111111         \ y_sign is positive, so flip the bits in A and set the
 SEC                    \ C flag. This makes A negative, and as we are about to
                        \ do an ADC below, the SEC effectively adds another 1 to
                        \ that value to implement two's complement negation, so
                        \ we don't need to add another 1 here

.SCD6

                        \ We now have all the information we need to draw this
                        \ ship on the scanner, namely:
                        \
                        \   X1 = the screen x-coordinate of the ship's dot
                        \
                        \   SC = the screen y-coordinate of the base of the
                        \        stick
                        \
                        \   A = the screen height of the ship's stick, with the
                        \       correct sign for adding to the base of the stick
                        \       to get the dot's y-coordinate
                        \
                        \ First, though, we have to make sure the dot is inside
                        \ the dashboard, by moving it if necessary

 ADC SC                 \ Set A = SC + A, so A now contains the y-coordinate of
                        \ the end of the stick, plus the length of the stick, to
                        \ give us the screen y-coordinate of the dot

 BPL ld246              \ If the result has bit 0 clear, then the result has
                        \ overflowed and is bigger than 256, so jump to ld246 to
                        \ set A to the maximum allowed value of 246 (this
                        \ instruction isn't required as we test both the maximum
                        \ and minimum below, but it might save a few cycles)

 CMP #194               \ If A >= 194, skip the following instruction, as 194 is
 BCS P%+4               \ the minimum allowed value of A

 LDA #194               \ A < 194, so set A to 194, the minimum allowed value
                        \ for the y-coordinate of our ship's dot

 CMP #247               \ If A < 247, skip the following instruction, as 246 is
 BCC P%+4               \ the maximum allowed value of A

.ld246

 LDA #246               \ A >= 247, so set A to 246, the maximum allowed value
                        \ for the y-coordinate of our ship's dot

 STA Y1                 \ Store A in Y1, as it now contains the screen
                        \ y-coordinate for the ship's dot, clipped so that it
                        \ fits within the dashboard

 SEC                    \ Set A = A - SC to get the stick length, by reversing
 SBC SC                 \ the ADC SC we did above. This clears the C flag if the
                        \ result is negative (i.e. the stick length is negative)
                        \ and sets it if the result is positive (i.e. the stick
                        \ length is negative)

                        \ So now we have the following:
                        \
                        \   X1 = the screen x-coordinate of the ship's dot,
                        \        clipped to fit into the dashboard
                        \
                        \   Y1 = the screen y-coordinate of the ship's dot,
                        \        clipped to fit into the dashboard
                        \
                        \   SC = the screen y-coordinate of the base of the
                        \        stick
                        \
                        \   A = the screen height of the ship's stick, with the
                        \       correct sign for adding to the base of the stick
                        \       to get the dot's y-coordinate
                        \
                        \   C = 0 if A is negative, 1 if A is positive
                        \
                        \ and we can get on with drawing the dot and stick

 TAX                    \ Copy the stick height in A into X

 LDA #&91               \ Send command &91 to the I/O processor:
 JSR tube_write         \
                        \   draw_tail(x, y, base_colour, alt_colour, height)
                        \
                        \ which will draw a ship on the 3D scanner with a dot
                        \ and stick of the specified height and colour, possibly
                        \ with stripes

 LDA X1                 \ Send the first parameter to the I/O processor:
 JSR tube_write         \
                        \   * x1 = X1

 LDA Y1                 \ Send the second parameter to the I/O processor:
 JSR tube_write         \
                        \   * y1 = Y1

 LDA COL                \ Send the third parameter to the I/O processor:
 JSR tube_write         \
                        \   * base_colour = COL

 LDA Y2                 \ Send the fourth parameter to the I/O processor:
 JSR tube_write         \
                        \   * alt_colour = Y2

 TXA                    \ Send the fifth parameter to the I/O processor:
 JSR tube_write         \
                        \   * height = the stick height that we stored in X

 LDX #0                 \ Set X = 0 to ensure we return the same value as the
                        \ SCAN routine in the non-Tube version

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\ Save ELTM.bin
\
\ ******************************************************************************

 PRINT "ELITE M"
 PRINT "Assembled at ", ~CODE_M%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_M%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_M%

 PRINT "S.2.ELTM ", ~CODE_M%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_M%
\SAVE "versions/disc/3-assembled-output/2.ELTM.bin", CODE_M%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE SHIP BLUEPRINTS FILE
\
\ ******************************************************************************

 CODE_SHIPS% = P%
 LOAD_SHIPS% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\       Name: VERTEX
\       Type: Macro
\   Category: Drawing ships
\    Summary: Macro definition for adding vertices to ship blueprints
\  Deep dive: Ship blueprints
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used to build the ship blueprints:
\
\   VERTEX x, y, z, face1, face2, face3, face4, visibility
\
\ See the deep dive on "Ship blueprints" for details of how vertices are stored
\ in the ship blueprints, and the deep dive on "Drawing ships" for information
\ on how vertices are used to draw 3D wireframe ships.
\
\ Arguments:
\
\   x                   The vertex's x-coordinate
\
\   y                   The vertex's y-coordinate
\
\   z                   The vertex's z-coordinate
\
\   face1               The number of face 1 associated with this vertex
\
\   face2               The number of face 2 associated with this vertex
\
\   face3               The number of face 3 associated with this vertex
\
\   face4               The number of face 4 associated with this vertex
\
\   visibility          The visibility distance, beyond which the vertex is not
\                       shown
\
\ ******************************************************************************

MACRO VERTEX x, y, z, face1, face2, face3, face4, visibility

 IF x < 0
  s_x = 1 << 7
 ELSE
  s_x = 0
 ENDIF

 IF y < 0
  s_y = 1 << 6
 ELSE
  s_y = 0
 ENDIF

 IF z < 0
  s_z = 1 << 5
 ELSE
  s_z = 0
 ENDIF

 s = s_x + s_y + s_z + visibility
 f1 = face1 + (face2 << 4)
 f2 = face3 + (face4 << 4)
 ax = ABS(x)
 ay = ABS(y)
 az = ABS(z)

 EQUB ax, ay, az, s, f1, f2

ENDMACRO

\ ******************************************************************************
\
\       Name: EDGE
\       Type: Macro
\   Category: Drawing ships
\    Summary: Macro definition for adding edges to ship blueprints
\  Deep dive: Ship blueprints
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used to build the ship blueprints:
\
\   EDGE vertex1, vertex2, face1, face2, visibility
\
\ See the deep dive on "Ship blueprints" for details of how edges are stored
\ in the ship blueprints, and the deep dive on "Drawing ships" for information
\ on how edges are used to draw 3D wireframe ships.
\
\ Arguments:
\
\   vertex1             The number of the vertex at the start of the edge
\
\   vertex1             The number of the vertex at the end of the edge
\
\   face1               The number of face 1 associated with this edge
\
\   face2               The number of face 2 associated with this edge
\
\   visibility          The visibility distance, beyond which the edge is not
\                       shown
\
\ ******************************************************************************

MACRO EDGE vertex1, vertex2, face1, face2, visibility

 f = face1 + (face2 << 4)
 EQUB visibility, f, vertex1 << 2, vertex2 << 2

ENDMACRO

\ ******************************************************************************
\
\       Name: FACE
\       Type: Macro
\   Category: Drawing ships
\    Summary: Macro definition for adding faces to ship blueprints
\  Deep dive: Ship blueprints
\
\ ------------------------------------------------------------------------------
\
\ The following macro is used to build the ship blueprints:
\
\   FACE normal_x, normal_y, normal_z, visibility
\
\ See the deep dive on "Ship blueprints" for details of how faces are stored
\ in the ship blueprints, and the deep dive on "Drawing ships" for information
\ on how faces are used to draw 3D wireframe ships.
\
\ Arguments:
\
\   normal_x            The face normal's x-coordinate
\
\   normal_y            The face normal's y-coordinate
\
\   normal_z            The face normal's z-coordinate
\
\   visibility          The visibility distance, beyond which the edge is always
\                       shown
\
\ ******************************************************************************

MACRO FACE normal_x, normal_y, normal_z, visibility

 IF normal_x < 0
  s_x = 1 << 7
 ELSE
  s_x = 0
 ENDIF

 IF normal_y < 0
  s_y = 1 << 6
 ELSE
  s_y = 0
 ENDIF

 IF normal_z < 0
  s_z = 1 << 5
 ELSE
  s_z = 0
 ENDIF

 s = s_x + s_y + s_z + visibility
 ax = ABS(normal_x)
 ay = ABS(normal_y)
 az = ABS(normal_z)

 EQUB s, ax, ay, az

ENDMACRO

\ ******************************************************************************
\
\       Name: SHIP_DODO
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Dodecahedron ("Dodo") space station
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_DODO

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 180 * 180         \ Targetable area          = 180 * 180
 EQUB LO(SHIP_DODO_EDGES - SHIP_DODO)              \ Edges data offset (low)
 EQUB LO(SHIP_DODO_FACES - SHIP_DODO)              \ Faces data offset (low)
 EQUB 97                \ Max. edge count          = (97 - 1) / 4 = 24
 EQUB 0                 \ Gun vertex               = 0
 EQUB 54                \ Explosion count          = 12, as (4 * n) + 6 = 54
 EQUB 144               \ Number of vertices       = 144 / 6 = 24
 EQUB 34                \ Number of edges          = 34
 EQUW 0                 \ Bounty                   = 0
 EQUB 48                \ Number of faces          = 48 / 4 = 12
 EQUB 125               \ Visibility distance      = 125
 EQUB 240               \ Max. energy              = 240
 EQUB 0                 \ Max. speed               = 0
 EQUB HI(SHIP_DODO_EDGES - SHIP_DODO)              \ Edges data offset (high)
 EQUB HI(SHIP_DODO_FACES - SHIP_DODO)              \ Faces data offset (high)
 EQUB 0                 \ Normals are scaled by    = 2^0 = 1
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  150,  196,     1,      0,    5,     5,         31    \ Vertex 0
 VERTEX  143,   46,  196,     1,      0,    2,     2,         31    \ Vertex 1
 VERTEX   88, -121,  196,     2,      0,    3,     3,         31    \ Vertex 2
 VERTEX  -88, -121,  196,     3,      0,    4,     4,         31    \ Vertex 3
 VERTEX -143,   46,  196,     4,      0,    5,     5,         31    \ Vertex 4
 VERTEX    0,  243,   46,     5,      1,    6,     6,         31    \ Vertex 5
 VERTEX  231,   75,   46,     2,      1,    7,     7,         31    \ Vertex 6
 VERTEX  143, -196,   46,     3,      2,    8,     8,         31    \ Vertex 7
 VERTEX -143, -196,   46,     4,      3,    9,     9,         31    \ Vertex 8
 VERTEX -231,   75,   46,     5,      4,   10,    10,         31    \ Vertex 9
 VERTEX  143,  196,  -46,     6,      1,    7,     7,         31    \ Vertex 10
 VERTEX  231,  -75,  -46,     7,      2,    8,     8,         31    \ Vertex 11
 VERTEX    0, -243,  -46,     8,      3,    9,     9,         31    \ Vertex 12
 VERTEX -231,  -75,  -46,     9,      4,   10,    10,         31    \ Vertex 13
 VERTEX -143,  196,  -46,     6,      5,   10,    10,         31    \ Vertex 14
 VERTEX   88,  121, -196,     7,      6,   11,    11,         31    \ Vertex 15
 VERTEX  143,  -46, -196,     8,      7,   11,    11,         31    \ Vertex 16
 VERTEX    0, -150, -196,     9,      8,   11,    11,         31    \ Vertex 17
 VERTEX -143,  -46, -196,    10,      9,   11,    11,         31    \ Vertex 18
 VERTEX  -88,  121, -196,    10,      6,   11,    11,         31    \ Vertex 19
 VERTEX  -16,   32,  196,     0,      0,    0,     0,         30    \ Vertex 20
 VERTEX  -16,  -32,  196,     0,      0,    0,     0,         30    \ Vertex 21
 VERTEX   16,   32,  196,     0,      0,    0,     0,         23    \ Vertex 22
 VERTEX   16,  -32,  196,     0,      0,    0,     0,         23    \ Vertex 23

.SHIP_DODO_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         31    \ Edge 0
 EDGE       1,       2,     2,     0,         31    \ Edge 1
 EDGE       2,       3,     3,     0,         31    \ Edge 2
 EDGE       3,       4,     4,     0,         31    \ Edge 3
 EDGE       4,       0,     5,     0,         31    \ Edge 4
 EDGE       5,      10,     6,     1,         31    \ Edge 5
 EDGE      10,       6,     7,     1,         31    \ Edge 6
 EDGE       6,      11,     7,     2,         31    \ Edge 7
 EDGE      11,       7,     8,     2,         31    \ Edge 8
 EDGE       7,      12,     8,     3,         31    \ Edge 9
 EDGE      12,       8,     9,     3,         31    \ Edge 10
 EDGE       8,      13,     9,     4,         31    \ Edge 11
 EDGE      13,       9,    10,     4,         31    \ Edge 12
 EDGE       9,      14,    10,     5,         31    \ Edge 13
 EDGE      14,       5,     6,     5,         31    \ Edge 14
 EDGE      15,      16,    11,     7,         31    \ Edge 15
 EDGE      16,      17,    11,     8,         31    \ Edge 16
 EDGE      17,      18,    11,     9,         31    \ Edge 17
 EDGE      18,      19,    11,    10,         31    \ Edge 18
 EDGE      19,      15,    11,     6,         31    \ Edge 19
 EDGE       0,       5,     5,     1,         31    \ Edge 20
 EDGE       1,       6,     2,     1,         31    \ Edge 21
 EDGE       2,       7,     3,     2,         31    \ Edge 22
 EDGE       3,       8,     4,     3,         31    \ Edge 23
 EDGE       4,       9,     5,     4,         31    \ Edge 24
 EDGE      10,      15,     7,     6,         31    \ Edge 25
 EDGE      11,      16,     8,     7,         31    \ Edge 26
 EDGE      12,      17,     9,     8,         31    \ Edge 27
 EDGE      13,      18,    10,     9,         31    \ Edge 28
 EDGE      14,      19,    10,     6,         31    \ Edge 29
 EDGE      20,      21,     0,     0,         30    \ Edge 30
 EDGE      21,      23,     0,     0,         20    \ Edge 31
 EDGE      23,      22,     0,     0,         23    \ Edge 32
 EDGE      22,      20,     0,     0,         20    \ Edge 33

.SHIP_DODO_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,        0,      196,         31    \ Face 0
 FACE      103,      142,       88,         31    \ Face 1
 FACE      169,      -55,       89,         31    \ Face 2
 FACE        0,     -176,       88,         31    \ Face 3
 FACE     -169,      -55,       89,         31    \ Face 4
 FACE     -103,      142,       88,         31    \ Face 5
 FACE        0,      176,      -88,         31    \ Face 6
 FACE      169,       55,      -89,         31    \ Face 7
 FACE      103,     -142,      -88,         31    \ Face 8
 FACE     -103,     -142,      -88,         31    \ Face 9
 FACE     -169,       55,      -89,         31    \ Face 10
 FACE        0,        0,     -196,         31    \ Face 11

\ ******************************************************************************
\
\       Name: SHIP_CORIOLIS
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Coriolis space station
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_CORIOLIS

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 160 * 160         \ Targetable area          = 160 * 160
 EQUB LO(SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)      \ Edges data offset (low)
 EQUB LO(SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)      \ Faces data offset (low)
 EQUB 85                \ Max. edge count          = (85 - 1) / 4 = 21
 EQUB 0                 \ Gun vertex               = 0
 EQUB 54                \ Explosion count          = 12, as (4 * n) + 6 = 54
 EQUB 96                \ Number of vertices       = 96 / 6 = 16
 EQUB 28                \ Number of edges          = 28
 EQUW 0                 \ Bounty                   = 0
 EQUB 56                \ Number of faces          = 56 / 4 = 14
 EQUB 120               \ Visibility distance      = 120
 EQUB 240               \ Max. energy              = 240
 EQUB 0                 \ Max. speed               = 0
 EQUB HI(SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)      \ Edges data offset (high)
 EQUB HI(SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)      \ Faces data offset (high)
 EQUB 0                 \ Normals are scaled by    = 2^0 = 1
 EQUB %00000110         \ Laser power              = 0
                        \ Missiles                 = 6

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  160,    0,  160,     0,      1,    2,     6,         31    \ Vertex 0
 VERTEX    0,  160,  160,     0,      2,    3,     8,         31    \ Vertex 1
 VERTEX -160,    0,  160,     0,      3,    4,     7,         31    \ Vertex 2
 VERTEX    0, -160,  160,     0,      1,    4,     5,         31    \ Vertex 3
 VERTEX  160, -160,    0,     1,      5,    6,    10,         31    \ Vertex 4
 VERTEX  160,  160,    0,     2,      6,    8,    11,         31    \ Vertex 5
 VERTEX -160,  160,    0,     3,      7,    8,    12,         31    \ Vertex 6
 VERTEX -160, -160,    0,     4,      5,    7,     9,         31    \ Vertex 7
 VERTEX  160,    0, -160,     6,     10,   11,    13,         31    \ Vertex 8
 VERTEX    0,  160, -160,     8,     11,   12,    13,         31    \ Vertex 9
 VERTEX -160,    0, -160,     7,      9,   12,    13,         31    \ Vertex 10
 VERTEX    0, -160, -160,     5,      9,   10,    13,         31    \ Vertex 11
 VERTEX   10,  -30,  160,     0,      0,    0,     0,         30    \ Vertex 12
 VERTEX   10,   30,  160,     0,      0,    0,     0,         30    \ Vertex 13
 VERTEX  -10,   30,  160,     0,      0,    0,     0,         30    \ Vertex 14
 VERTEX  -10,  -30,  160,     0,      0,    0,     0,         30    \ Vertex 15

.SHIP_CORIOLIS_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       3,     0,     1,         31    \ Edge 0
 EDGE       0,       1,     0,     2,         31    \ Edge 1
 EDGE       1,       2,     0,     3,         31    \ Edge 2
 EDGE       2,       3,     0,     4,         31    \ Edge 3
 EDGE       3,       4,     1,     5,         31    \ Edge 4
 EDGE       0,       4,     1,     6,         31    \ Edge 5
 EDGE       0,       5,     2,     6,         31    \ Edge 6
 EDGE       5,       1,     2,     8,         31    \ Edge 7
 EDGE       1,       6,     3,     8,         31    \ Edge 8
 EDGE       2,       6,     3,     7,         31    \ Edge 9
 EDGE       2,       7,     4,     7,         31    \ Edge 10
 EDGE       3,       7,     4,     5,         31    \ Edge 11
 EDGE       8,      11,    10,    13,         31    \ Edge 12
 EDGE       8,       9,    11,    13,         31    \ Edge 13
 EDGE       9,      10,    12,    13,         31    \ Edge 14
 EDGE      10,      11,     9,    13,         31    \ Edge 15
 EDGE       4,      11,     5,    10,         31    \ Edge 16
 EDGE       4,       8,     6,    10,         31    \ Edge 17
 EDGE       5,       8,     6,    11,         31    \ Edge 18
 EDGE       5,       9,     8,    11,         31    \ Edge 19
 EDGE       6,       9,     8,    12,         31    \ Edge 20
 EDGE       6,      10,     7,    12,         31    \ Edge 21
 EDGE       7,      10,     7,     9,         31    \ Edge 22
 EDGE       7,      11,     5,     9,         31    \ Edge 23
 EDGE      12,      13,     0,     0,         30    \ Edge 24
 EDGE      13,      14,     0,     0,         30    \ Edge 25
 EDGE      14,      15,     0,     0,         30    \ Edge 26
 EDGE      15,      12,     0,     0,         30    \ Edge 27

.SHIP_CORIOLIS_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,        0,      160,         31    \ Face 0
 FACE      107,     -107,      107,         31    \ Face 1
 FACE      107,      107,      107,         31    \ Face 2
 FACE     -107,      107,      107,         31    \ Face 3
 FACE     -107,     -107,      107,         31    \ Face 4
 FACE        0,     -160,        0,         31    \ Face 5
 FACE      160,        0,        0,         31    \ Face 6
 FACE     -160,        0,        0,         31    \ Face 7
 FACE        0,      160,        0,         31    \ Face 8
 FACE     -107,     -107,     -107,         31    \ Face 9
 FACE      107,     -107,     -107,         31    \ Face 10
 FACE      107,      107,     -107,         31    \ Face 11
 FACE     -107,      107,     -107,         31    \ Face 12
 FACE        0,        0,     -160,         31    \ Face 13

\ ******************************************************************************
\
\       Name: SHIP_ESCAPE_POD
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for an escape pod
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_ESCAPE_POD

 EQUB 0 + (2 << 4)      \ Max. canisters on demise = 0
                        \ Market item when scooped = 2 + 1 = 3 (slaves)
 EQUW 16 * 16           \ Targetable area          = 16 * 16
 EQUB LO(SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)  \ Edges data offset (low)
 EQUB LO(SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)  \ Faces data offset (low)
 EQUB 25                \ Max. edge count          = (25 - 1) / 4 = 6
 EQUB 0                 \ Gun vertex               = 0
 EQUB 22                \ Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 24                \ Number of vertices       = 24 / 6 = 4
 EQUB 6                 \ Number of edges          = 6
 EQUW 0                 \ Bounty                   = 0
 EQUB 16                \ Number of faces          = 16 / 4 = 4
 EQUB 8                 \ Visibility distance      = 8
 EQUB 8                 \ Max. energy              = 8
 EQUB 8                 \ Max. speed               = 8
 EQUB HI(SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)  \ Edges data offset (high)
 EQUB HI(SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)  \ Faces data offset (high)
 EQUB 4                 \ Normals are scaled by    =  2^4 = 16
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   -7,    0,   36,     2,      1,    3,     3,         31    \ Vertex 0
 VERTEX   -7,  -14,  -12,     2,      0,    3,     3,         31    \ Vertex 1
 VERTEX   -7,   14,  -12,     1,      0,    3,     3,         31    \ Vertex 2
 VERTEX   21,    0,    0,     1,      0,    2,     2,         31    \ Vertex 3

.SHIP_ESCAPE_POD_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     2,         31    \ Edge 0
 EDGE       1,       2,     3,     0,         31    \ Edge 1
 EDGE       2,       3,     1,     0,         31    \ Edge 2
 EDGE       3,       0,     2,     1,         31    \ Edge 3
 EDGE       0,       2,     3,     1,         31    \ Edge 4
 EDGE       3,       1,     2,     0,         31    \ Edge 5

.SHIP_ESCAPE_POD_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE       52,        0,     -122,         31    \ Face 0
 FACE       39,      103,       30,         31    \ Face 1
 FACE       39,     -103,       30,         31    \ Face 2
 FACE     -112,        0,        0,         31    \ Face 3

\ ******************************************************************************
\
\       Name: SHIP_PLATE
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for an alloy plate
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_PLATE

 EQUB 0 + (8 << 4)      \ Max. canisters on demise = 0
                        \ Market item when scooped = 8 + 1 = 9 (Alloys)
 EQUW 10 * 10           \ Targetable area          = 10 * 10
 EQUB LO(SHIP_PLATE_EDGES - SHIP_PLATE)            \ Edges data offset (low)
 EQUB LO(SHIP_PLATE_FACES - SHIP_PLATE)            \ Faces data offset (low)
 EQUB 17                \ Max. edge count          = (17 - 1) / 4 = 4
 EQUB 0                 \ Gun vertex               = 0
 EQUB 10                \ Explosion count          = 1, as (4 * n) + 6 = 10
 EQUB 24                \ Number of vertices       = 24 / 6 = 4
 EQUB 4                 \ Number of edges          = 4
 EQUW 1                 \ Bounty                   = 1
 EQUB 4                 \ Number of faces          = 4 / 4 = 1
 EQUB 5                 \ Visibility distance      = 5
 EQUB 8                 \ Max. energy              = 8
 EQUB 16                \ Max. speed               = 16
 EQUB HI(SHIP_PLATE_EDGES - SHIP_PLATE)            \ Edges data offset (high)
 EQUB HI(SHIP_PLATE_FACES - SHIP_PLATE)            \ Faces data offset (high)
 EQUB 3                 \ Normals are scaled by    = 2^3 = 8
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -15,  -22,   -9,    15,     15,   15,    15,         31    \ Vertex 0
 VERTEX  -15,   38,   -9,    15,     15,   15,    15,         31    \ Vertex 1
 VERTEX   19,   32,   11,    15,     15,   15,    15,         20    \ Vertex 2
 VERTEX   10,  -46,    6,    15,     15,   15,    15,         20    \ Vertex 3

.SHIP_PLATE_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,    15,    15,         31    \ Edge 0
 EDGE       1,       2,    15,    15,         16    \ Edge 1
 EDGE       2,       3,    15,    15,         20    \ Edge 2
 EDGE       3,       0,    15,    15,         16    \ Edge 3

.SHIP_PLATE_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,        0,        0,          0    \ Face 0

\ ******************************************************************************
\
\       Name: SHIP_CANISTER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a cargo canister
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_CANISTER

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 20 * 20           \ Targetable area          = 20 * 20
 EQUB LO(SHIP_CANISTER_EDGES - SHIP_CANISTER)      \ Edges data offset (low)
 EQUB LO(SHIP_CANISTER_FACES - SHIP_CANISTER)      \ Faces data offset (low)
 EQUB 49                \ Max. edge count          = (49 - 1) / 4 = 12
 EQUB 0                 \ Gun vertex               = 0
 EQUB 18                \ Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                \ Number of vertices       = 60 / 6 = 10
 EQUB 15                \ Number of edges          = 15
 EQUW 1                 \ Bounty                   = 1
 EQUB 28                \ Number of faces          = 28 / 4 = 7
 EQUB 12                \ Visibility distance      = 12
 EQUB 8                 \ Max. energy              = 8
 EQUB 15                \ Max. speed               = 15
 EQUB HI(SHIP_CANISTER_EDGES - SHIP_CANISTER)      \ Edges data offset (high)
 EQUB HI(SHIP_CANISTER_FACES - SHIP_CANISTER)      \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   24,   16,    0,     0,      1,    5,     5,         31    \ Vertex 0
 VERTEX   24,    5,   15,     0,      1,    2,     2,         31    \ Vertex 1
 VERTEX   24,  -13,    9,     0,      2,    3,     3,         31    \ Vertex 2
 VERTEX   24,  -13,   -9,     0,      3,    4,     4,         31    \ Vertex 3
 VERTEX   24,    5,  -15,     0,      4,    5,     5,         31    \ Vertex 4
 VERTEX  -24,   16,    0,     1,      5,    6,     6,         31    \ Vertex 5
 VERTEX  -24,    5,   15,     1,      2,    6,     6,         31    \ Vertex 6
 VERTEX  -24,  -13,    9,     2,      3,    6,     6,         31    \ Vertex 7
 VERTEX  -24,  -13,   -9,     3,      4,    6,     6,         31    \ Vertex 8
 VERTEX  -24,    5,  -15,     4,      5,    6,     6,         31    \ Vertex 9

.SHIP_CANISTER_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     1,         31    \ Edge 0
 EDGE       1,       2,     0,     2,         31    \ Edge 1
 EDGE       2,       3,     0,     3,         31    \ Edge 2
 EDGE       3,       4,     0,     4,         31    \ Edge 3
 EDGE       0,       4,     0,     5,         31    \ Edge 4
 EDGE       0,       5,     1,     5,         31    \ Edge 5
 EDGE       1,       6,     1,     2,         31    \ Edge 6
 EDGE       2,       7,     2,     3,         31    \ Edge 7
 EDGE       3,       8,     3,     4,         31    \ Edge 8
 EDGE       4,       9,     4,     5,         31    \ Edge 9
 EDGE       5,       6,     1,     6,         31    \ Edge 10
 EDGE       6,       7,     2,     6,         31    \ Edge 11
 EDGE       7,       8,     3,     6,         31    \ Edge 12
 EDGE       8,       9,     4,     6,         31    \ Edge 13
 EDGE       9,       5,     5,     6,         31    \ Edge 14

.SHIP_CANISTER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE       96,        0,        0,         31    \ Face 0
 FACE        0,       41,       30,         31    \ Face 1
 FACE        0,      -18,       48,         31    \ Face 2
 FACE        0,      -51,        0,         31    \ Face 3
 FACE        0,      -18,      -48,         31    \ Face 4
 FACE        0,       41,      -30,         31    \ Face 5
 FACE      -96,        0,        0,         31    \ Face 6

\ ******************************************************************************
\
\       Name: SHIP_THARGOID
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Thargoid mothership
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_THARGOID

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 99 * 99           \ Targetable area          = 99 * 99
 EQUB LO(SHIP_THARGOID_EDGES - SHIP_THARGOID)      \ Edges data offset (low)
 EQUB LO(SHIP_THARGOID_FACES - SHIP_THARGOID)      \ Faces data offset (low)
 EQUB 101               \ Max. edge count          = (101 - 1) / 4 = 25
 EQUB 60                \ Gun vertex               = 60 / 4 = 15
 EQUB 38                \ Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 120               \ Number of vertices       = 120 / 6 = 20
 EQUB 26                \ Number of edges          = 26
 EQUW 500               \ Bounty                   = 500
 EQUB 40                \ Number of faces          = 40 / 4 = 10
 EQUB 55                \ Visibility distance      = 55
 EQUB 253               \ Max. energy              = 253
 EQUB 39                \ Max. speed               = 39
 EQUB HI(SHIP_THARGOID_EDGES - SHIP_THARGOID)      \ Edges data offset (high)
 EQUB HI(SHIP_THARGOID_FACES - SHIP_THARGOID)      \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00111000         \ Laser power              = 7
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   32,  -48,   48,     0,      4,    8,     8,         31    \ Vertex 0
 VERTEX   32,  -68,    0,     0,      1,    4,     4,         31    \ Vertex 1
 VERTEX   32,  -48,  -48,     1,      2,    4,     4,         31    \ Vertex 2
 VERTEX   32,    0,  -68,     2,      3,    4,     4,         31    \ Vertex 3
 VERTEX   32,   48,  -48,     3,      4,    5,     5,         31    \ Vertex 4
 VERTEX   32,   68,    0,     4,      5,    6,     6,         31    \ Vertex 5
 VERTEX   32,   48,   48,     4,      6,    7,     7,         31    \ Vertex 6
 VERTEX   32,    0,   68,     4,      7,    8,     8,         31    \ Vertex 7
 VERTEX  -24, -116,  116,     0,      8,    9,     9,         31    \ Vertex 8
 VERTEX  -24, -164,    0,     0,      1,    9,     9,         31    \ Vertex 9
 VERTEX  -24, -116, -116,     1,      2,    9,     9,         31    \ Vertex 10
 VERTEX  -24,    0, -164,     2,      3,    9,     9,         31    \ Vertex 11
 VERTEX  -24,  116, -116,     3,      5,    9,     9,         31    \ Vertex 12
 VERTEX  -24,  164,    0,     5,      6,    9,     9,         31    \ Vertex 13
 VERTEX  -24,  116,  116,     6,      7,    9,     9,         31    \ Vertex 14
 VERTEX  -24,    0,  164,     7,      8,    9,     9,         31    \ Vertex 15
 VERTEX  -24,   64,   80,     9,      9,    9,     9,         30    \ Vertex 16
 VERTEX  -24,   64,  -80,     9,      9,    9,     9,         30    \ Vertex 17
 VERTEX  -24,  -64,  -80,     9,      9,    9,     9,         30    \ Vertex 18
 VERTEX  -24,  -64,   80,     9,      9,    9,     9,         30    \ Vertex 19

.SHIP_THARGOID_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       7,     4,     8,         31    \ Edge 0
 EDGE       0,       1,     0,     4,         31    \ Edge 1
 EDGE       1,       2,     1,     4,         31    \ Edge 2
 EDGE       2,       3,     2,     4,         31    \ Edge 3
 EDGE       3,       4,     3,     4,         31    \ Edge 4
 EDGE       4,       5,     4,     5,         31    \ Edge 5
 EDGE       5,       6,     4,     6,         31    \ Edge 6
 EDGE       6,       7,     4,     7,         31    \ Edge 7
 EDGE       0,       8,     0,     8,         31    \ Edge 8
 EDGE       1,       9,     0,     1,         31    \ Edge 9
 EDGE       2,      10,     1,     2,         31    \ Edge 10
 EDGE       3,      11,     2,     3,         31    \ Edge 11
 EDGE       4,      12,     3,     5,         31    \ Edge 12
 EDGE       5,      13,     5,     6,         31    \ Edge 13
 EDGE       6,      14,     6,     7,         31    \ Edge 14
 EDGE       7,      15,     7,     8,         31    \ Edge 15
 EDGE       8,      15,     8,     9,         31    \ Edge 16
 EDGE       8,       9,     0,     9,         31    \ Edge 17
 EDGE       9,      10,     1,     9,         31    \ Edge 18
 EDGE      10,      11,     2,     9,         31    \ Edge 19
 EDGE      11,      12,     3,     9,         31    \ Edge 20
 EDGE      12,      13,     5,     9,         31    \ Edge 21
 EDGE      13,      14,     6,     9,         31    \ Edge 22
 EDGE      14,      15,     7,     9,         31    \ Edge 23
 EDGE      16,      17,     9,     9,         30    \ Edge 24
 EDGE      18,      19,     9,     9,         30    \ Edge 25

.SHIP_THARGOID_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      103,      -60,       25,         31    \ Face 0
 FACE      103,      -60,      -25,         31    \ Face 1
 FACE      103,      -25,      -60,         31    \ Face 2
 FACE      103,       25,      -60,         31    \ Face 3
 FACE       64,        0,        0,         31    \ Face 4
 FACE      103,       60,      -25,         31    \ Face 5
 FACE      103,       60,       25,         31    \ Face 6
 FACE      103,       25,       60,         31    \ Face 7
 FACE      103,      -25,       60,         31    \ Face 8
 FACE      -48,        0,        0,         31    \ Face 9

\ ******************************************************************************
\
\       Name: SHIP_THARGON
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Thargon
\  Deep dive: Ship blueprints
\
\ ------------------------------------------------------------------------------
\
\ The ship blueprint for the Thargon reuses the edges data from the cargo
\ canister, so the edges data offset is negative.
\
\ ******************************************************************************

.SHIP_THARGON

 EQUB 0 + (15 << 4)     \ Max. canisters on demise = 0
                        \ Market item when scooped = 15 + 1 = 16 (alien items)
 EQUW 40 * 40           \ Targetable area          = 40 * 40
 EQUB LO(SHIP_CANISTER_EDGES - SHIP_THARGON)       \ Edges from canister
 EQUB LO(SHIP_THARGON_FACES - SHIP_THARGON)        \ Faces data offset (low)
 EQUB 65                \ Max. edge count          = (65 - 1) / 4 = 16
 EQUB 0                 \ Gun vertex               = 0
 EQUB 18                \ Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                \ Number of vertices       = 60 / 6 = 10
 EQUB 15                \ Number of edges          = 15
 EQUW 50                \ Bounty                   = 50
 EQUB 28                \ Number of faces          = 28 / 4 = 7
 EQUB 20                \ Visibility distance      = 20
 EQUB 33                \ Max. energy              = 33
 EQUB 30                \ Max. speed               = 30
 EQUB HI(SHIP_CANISTER_EDGES - SHIP_THARGON)       \ Edges from canister
 EQUB HI(SHIP_THARGON_FACES - SHIP_THARGON)        \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00100000         \ Laser power              = 4
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   -9,    0,   40,     1,      0,    5,     5,         31    \ Vertex 0
 VERTEX   -9,  -38,   12,     1,      0,    2,     2,         31    \ Vertex 1
 VERTEX   -9,  -24,  -32,     2,      0,    3,     3,         31    \ Vertex 2
 VERTEX   -9,   24,  -32,     3,      0,    4,     4,         31    \ Vertex 3
 VERTEX   -9,   38,   12,     4,      0,    5,     5,         31    \ Vertex 4
 VERTEX    9,    0,   -8,     5,      1,    6,     6,         31    \ Vertex 5
 VERTEX    9,  -10,  -15,     2,      1,    6,     6,         31    \ Vertex 6
 VERTEX    9,   -6,  -26,     3,      2,    6,     6,         31    \ Vertex 7
 VERTEX    9,    6,  -26,     4,      3,    6,     6,         31    \ Vertex 8
 VERTEX    9,   10,  -15,     5,      4,    6,     6,         31    \ Vertex 9

.SHIP_THARGON_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      -36,        0,        0,         31    \ Face 0
 FACE       20,       -5,        7,         31    \ Face 1
 FACE       46,      -42,      -14,         31    \ Face 2
 FACE       36,        0,     -104,         31    \ Face 3
 FACE       46,       42,      -14,         31    \ Face 4
 FACE       20,        5,        7,         31    \ Face 5
 FACE       36,        0,        0,         31    \ Face 6

\ ******************************************************************************
\
\       Name: SHIP_BOULDER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a boulder
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_BOULDER

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 30 * 30           \ Targetable area          = 30 * 30
 EQUB LO(SHIP_BOULDER_EDGES - SHIP_BOULDER)        \ Edges data offset (low)
 EQUB LO(SHIP_BOULDER_FACES - SHIP_BOULDER)        \ Faces data offset (low)
 EQUB 45                \ Max. edge count          = (45 - 1) / 4 = 11
 EQUB 0                 \ Gun vertex               = 0
 EQUB 14                \ Explosion count          = 2, as (4 * n) + 6 = 14
 EQUB 42                \ Number of vertices       = 42 / 6 = 7
 EQUB 15                \ Number of edges          = 15
 EQUW 1                 \ Bounty                   = 1
 EQUB 40                \ Number of faces          = 40 / 4 = 10
 EQUB 20                \ Visibility distance      = 20
 EQUB 16                \ Max. energy              = 16
 EQUB 30                \ Max. speed               = 30
 EQUB HI(SHIP_BOULDER_EDGES - SHIP_BOULDER)        \ Edges data offset (high)
 EQUB HI(SHIP_BOULDER_FACES - SHIP_BOULDER)        \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,   37,  -11,     1,      0,    9,     5,         31    \ Vertex 0
 VERTEX   30,    7,   12,     2,      1,    6,     5,         31    \ Vertex 1
 VERTEX   28,   -7,  -12,     3,      2,    7,     6,         31    \ Vertex 2
 VERTEX    2,    0,  -39,     4,      3,    8,     7,         31    \ Vertex 3
 VERTEX  -28,   34,  -30,     4,      0,    9,     8,         31    \ Vertex 4
 VERTEX    5,  -10,   13,    15,     15,   15,    15,         31    \ Vertex 5
 VERTEX   20,   17,  -30,    15,     15,   15,    15,         31    \ Vertex 6

.SHIP_BOULDER_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     5,     1,         31    \ Edge 0
 EDGE       1,       2,     6,     2,         31    \ Edge 1
 EDGE       2,       3,     7,     3,         31    \ Edge 2
 EDGE       3,       4,     8,     4,         31    \ Edge 3
 EDGE       4,       0,     9,     0,         31    \ Edge 4
 EDGE       0,       5,     1,     0,         31    \ Edge 5
 EDGE       1,       5,     2,     1,         31    \ Edge 6
 EDGE       2,       5,     3,     2,         31    \ Edge 7
 EDGE       3,       5,     4,     3,         31    \ Edge 8
 EDGE       4,       5,     4,     0,         31    \ Edge 9
 EDGE       0,       6,     9,     5,         31    \ Edge 10
 EDGE       1,       6,     6,     5,         31    \ Edge 11
 EDGE       2,       6,     7,     6,         31    \ Edge 12
 EDGE       3,       6,     8,     7,         31    \ Edge 13
 EDGE       4,       6,     9,     8,         31    \ Edge 14

.SHIP_BOULDER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      -15,       -3,        8,         31    \ Face 0
 FACE       -7,       12,       30,         31    \ Face 1
 FACE       32,      -47,       24,         31    \ Face 2
 FACE       -3,      -39,       -7,         31    \ Face 3
 FACE       -5,       -4,       -1,         31    \ Face 4
 FACE       49,       84,        8,         31    \ Face 5
 FACE      112,       21,      -21,         31    \ Face 6
 FACE       76,      -35,      -82,         31    \ Face 7
 FACE       22,       56,     -137,         31    \ Face 8
 FACE       40,      110,      -38,         31    \ Face 9

\ ******************************************************************************
\
\       Name: SHIP_ASTEROID
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for an asteroid
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_ASTEROID

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 80 * 80           \ Targetable area          = 80 * 80
 EQUB LO(SHIP_ASTEROID_EDGES - SHIP_ASTEROID)      \ Edges data offset (low)
 EQUB LO(SHIP_ASTEROID_FACES - SHIP_ASTEROID)      \ Faces data offset (low)
 EQUB 65                \ Max. edge count          = (65 - 1) / 4 = 16
 EQUB 0                 \ Gun vertex               = 0
 EQUB 34                \ Explosion count          = 7, as (4 * n) + 6 = 34
 EQUB 54                \ Number of vertices       = 54 / 6 = 9
 EQUB 21                \ Number of edges          = 21
 EQUW 15                \ Bounty                   = 15
 EQUB 56                \ Number of faces          = 56 / 4 = 14
 EQUB 50                \ Visibility distance      = 50
 EQUB 56                \ Max. energy              = 56
 EQUB 30                \ Max. speed               = 30
 EQUB HI(SHIP_ASTEROID_EDGES - SHIP_ASTEROID)      \ Edges data offset (high)
 EQUB HI(SHIP_ASTEROID_FACES - SHIP_ASTEROID)      \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   80,    0,    15,     15,   15,    15,         31    \ Vertex 0
 VERTEX  -80,  -10,    0,    15,     15,   15,    15,         31    \ Vertex 1
 VERTEX    0,  -80,    0,    15,     15,   15,    15,         31    \ Vertex 2
 VERTEX   70,  -40,    0,    15,     15,   15,    15,         31    \ Vertex 3
 VERTEX   60,   50,    0,     5,      6,   12,    13,         31    \ Vertex 4
 VERTEX   50,    0,   60,    15,     15,   15,    15,         31    \ Vertex 5
 VERTEX  -40,    0,   70,     0,      1,    2,     3,         31    \ Vertex 6
 VERTEX    0,   30,  -75,    15,     15,   15,    15,         31    \ Vertex 7
 VERTEX    0,  -50,  -60,     8,      9,   10,    11,         31    \ Vertex 8

.SHIP_ASTEROID_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     7,         31    \ Edge 0
 EDGE       0,       4,     6,    13,         31    \ Edge 1
 EDGE       3,       4,     5,    12,         31    \ Edge 2
 EDGE       2,       3,     4,    11,         31    \ Edge 3
 EDGE       1,       2,     3,    10,         31    \ Edge 4
 EDGE       1,       6,     2,     3,         31    \ Edge 5
 EDGE       2,       6,     1,     3,         31    \ Edge 6
 EDGE       2,       5,     1,     4,         31    \ Edge 7
 EDGE       5,       6,     0,     1,         31    \ Edge 8
 EDGE       0,       5,     0,     6,         31    \ Edge 9
 EDGE       3,       5,     4,     5,         31    \ Edge 10
 EDGE       0,       6,     0,     2,         31    \ Edge 11
 EDGE       4,       5,     5,     6,         31    \ Edge 12
 EDGE       1,       8,     8,    10,         31    \ Edge 13
 EDGE       1,       7,     7,     8,         31    \ Edge 14
 EDGE       0,       7,     7,    13,         31    \ Edge 15
 EDGE       4,       7,    12,    13,         31    \ Edge 16
 EDGE       3,       7,     9,    12,         31    \ Edge 17
 EDGE       3,       8,     9,    11,         31    \ Edge 18
 EDGE       2,       8,    10,    11,         31    \ Edge 19
 EDGE       7,       8,     8,     9,         31    \ Edge 20

.SHIP_ASTEROID_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        9,       66,       81,         31    \ Face 0
 FACE        9,      -66,       81,         31    \ Face 1
 FACE      -72,       64,       31,         31    \ Face 2
 FACE      -64,      -73,       47,         31    \ Face 3
 FACE       45,      -79,       65,         31    \ Face 4
 FACE      135,       15,       35,         31    \ Face 5
 FACE       38,       76,       70,         31    \ Face 6
 FACE      -66,       59,      -39,         31    \ Face 7
 FACE      -67,      -15,      -80,         31    \ Face 8
 FACE       66,      -14,      -75,         31    \ Face 9
 FACE      -70,      -80,      -40,         31    \ Face 10
 FACE       58,     -102,      -51,         31    \ Face 11
 FACE       81,        9,      -67,         31    \ Face 12
 FACE       47,       94,      -63,         31    \ Face 13

\ ******************************************************************************
\
\       Name: SHIP_SPLINTER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a splinter
\  Deep dive: Ship blueprints
\
\ ------------------------------------------------------------------------------
\
\ The ship blueprint for the splinter is supposed to reuse the edges data from
\ the escape pod, but there is a bug in Elite-A that breaks splinters. The edges
\ data offset is negative, as it should be, but the offset value is incorrect
\ and doesn't even point to edge data - in the Tube version, it points into the
\ middle of the Thargoid's vertex data, while in the disc version it points to a
\ different place depending on the structure of the individual blueprint file.
\ In all cases the offset is wrong, so splinters in Elite-A appear as a random
\ mess of lines. The correct value of the offset should be:
\
\   SHIP_ESCAPE_POD_EDGES - SHIP_SPLINTER
\
\ split into the high byte and low byte, as it is in the disc version.
\
\ ******************************************************************************

.SHIP_SPLINTER

 EQUB 0 + (11 << 4)     \ Max. canisters on demise = 0
                        \ Market item when scooped = 11 + 1 = 12 (Minerals)
 EQUW 16 * 16           \ Targetable area          = 16 * 16

IF _RELEASED OR _SOURCE_DISC

 EQUB &5A               \ This value is incorrect (see above)

ELIF _BUG_FIX

 EQUB LO(SHIP_ESCAPE_POD_EDGES - SHIP_SPLINTER)    \ Edges from escape pod

ENDIF

 EQUB LO(SHIP_SPLINTER_FACES - SHIP_SPLINTER) + 24 \ Faces data offset (low)
 EQUB 25                \ Max. edge count          = (25 - 1) / 4 = 6
 EQUB 0                 \ Gun vertex               = 0
 EQUB 22                \ Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 24                \ Number of vertices       = 24 / 6 = 4
 EQUB 6                 \ Number of edges          = 6
 EQUW 1                 \ Bounty                   = 1
 EQUB 16                \ Number of faces          = 16 / 4 = 4
 EQUB 8                 \ Visibility distance      = 8
 EQUB 16                \ Max. energy              = 16
 EQUB 10                \ Max. speed               = 10

IF _RELEASED OR _SOURCE_DISC

 EQUB &FE               \ This value is incorrect (see above)

ELIF _BUG_FIX

 EQUB HI(SHIP_ESCAPE_POD_EDGES - SHIP_SPLINTER)    \ Edges from escape pod

ENDIF

 EQUB HI(SHIP_SPLINTER_FACES - SHIP_SPLINTER)      \ Faces data offset (low)
 EQUB 5                 \ Normals are scaled by    = 2^5 = 32
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -24,  -25,   16,     2,      1,    3,     3,         31    \ Vertex 0
 VERTEX    0,   12,  -10,     2,      0,    3,     3,         31    \ Vertex 1
 VERTEX   11,   -6,    2,     1,      0,    3,     3,         31    \ Vertex 2
 VERTEX   12,   42,    7,     1,      0,    2,     2,         31    \ Vertex 3

.SHIP_SPLINTER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE       35,        0,        4,         31    \ Face 0
 FACE        3,        4,        8,         31    \ Face 1
 FACE        1,        8,       12,         31    \ Face 2
 FACE       18,       12,        0,         31    \ Face 3

\ ******************************************************************************
\
\       Name: SHIP_SHUTTLE
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Shuttle
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_SHUTTLE

 EQUB 15                \ Max. canisters on demise = 15
 EQUW 50 * 50           \ Targetable area          = 50 * 50
 EQUB LO(SHIP_SHUTTLE_EDGES - SHIP_SHUTTLE)        \ Edges data offset (low)
 EQUB LO(SHIP_SHUTTLE_FACES - SHIP_SHUTTLE)        \ Faces data offset (low)
 EQUB 109               \ Max. edge count          = (109 - 1) / 4 = 27
 EQUB 0                 \ Gun vertex               = 0
 EQUB 38                \ Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 114               \ Number of vertices       = 114 / 6 = 19
 EQUB 30                \ Number of edges          = 30
 EQUW 0                 \ Bounty                   = 0
 EQUB 52                \ Number of faces          = 52 / 4 = 13
 EQUB 22                \ Visibility distance      = 22
 EQUB 32                \ Max. energy              = 32
 EQUB 8                 \ Max. speed               = 8
 EQUB HI(SHIP_SHUTTLE_EDGES - SHIP_SHUTTLE)        \ Edges data offset (high)
 EQUB HI(SHIP_SHUTTLE_FACES - SHIP_SHUTTLE)        \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -35,   47,    15,    15,    15,    15,         31     \ Vertex 0
 VERTEX  -35,    0,   47,    15,    15,    15,    15,         31     \ Vertex 1
 VERTEX    0,   35,   47,    15,    15,    15,    15,         31     \ Vertex 2
 VERTEX   35,    0,   47,    15,    15,    15,    15,         31     \ Vertex 3
 VERTEX  -40,  -40,  -53,     2,     1,     9,     3,         31     \ Vertex 4
 VERTEX  -40,   40,  -53,     4,     3,     9,     5,         31     \ Vertex 5
 VERTEX   40,   40,  -53,     6,     5,     9,     7,         31     \ Vertex 6
 VERTEX   40,  -40,  -53,     7,     1,     9,     8,         31     \ Vertex 7
 VERTEX   10,    0,  -53,     9,     9,     9,     9,         16     \ Vertex 8
 VERTEX    0,   -5,  -53,     9,     9,     9,     9,         16     \ Vertex 9
 VERTEX  -10,    0,  -53,     9,     9,     9,     9,          8     \ Vertex 10
 VERTEX    0,    5,  -53,     9,     9,     9,     9,          8     \ Vertex 11
 VERTEX    0,  -17,   71,    10,     0,    12,    11,         16     \ Vertex 12
 VERTEX    5,   -2,   61,    15,    15,     2,     0,          6     \ Vertex 13
 VERTEX    7,   23,   49,     1,     0,     4,    15,          7     \ Vertex 14
 VERTEX   21,    9,   49,     1,    10,    15,     3,          7     \ Vertex 15
 VERTEX   -5,   -2,   61,    11,     6,     3,     2,          6     \ Vertex 16
 VERTEX   -7,   23,   49,     8,    15,     0,    12,          7     \ Vertex 17
 VERTEX  -21,    9,   49,    15,     4,     8,     1,          7     \ Vertex 18

.SHIP_SHUTTLE_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     0,         31    \ Edge 0
 EDGE       1,       2,    10,     4,         31    \ Edge 1
 EDGE       2,       3,    11,     6,         31    \ Edge 2
 EDGE       0,       3,    12,     8,         31    \ Edge 3
 EDGE       0,       7,     8,     1,         31    \ Edge 4
 EDGE       0,       4,     2,     1,         24    \ Edge 5
 EDGE       1,       4,     3,     2,         31    \ Edge 6
 EDGE       1,       5,     4,     3,         24    \ Edge 7
 EDGE       2,       5,     5,     4,         31    \ Edge 8
 EDGE       2,       6,     6,     5,         12    \ Edge 9
 EDGE       3,       6,     7,     6,         31    \ Edge 10
 EDGE       3,       7,     8,     7,         24    \ Edge 11
 EDGE       4,       5,     9,     3,         31    \ Edge 12
 EDGE       5,       6,     9,     5,         31    \ Edge 13
 EDGE       6,       7,     9,     7,         31    \ Edge 14
 EDGE       4,       7,     9,     1,         31    \ Edge 15
 EDGE       0,      12,    12,     0,         16    \ Edge 16
 EDGE       1,      12,    10,     0,         16    \ Edge 17
 EDGE       2,      12,    11,    10,         16    \ Edge 18
 EDGE       3,      12,    12,    11,         16    \ Edge 19
 EDGE       8,       9,     9,     9,         16    \ Edge 20
 EDGE       9,      10,     9,     9,          6    \ Edge 21
 EDGE      10,      11,     9,     9,          8    \ Edge 22
 EDGE       8,      11,     9,     9,          6    \ Edge 23
 EDGE      13,      14,    11,    11,          4    \ Edge 24
 EDGE      14,      15,    11,    11,          7    \ Edge 25
 EDGE      13,      15,    11,    11,          6    \ Edge 26
 EDGE      16,      17,    10,    10,          4    \ Edge 27
 EDGE      17,      18,    10,    10,          7    \ Edge 28
 EDGE      16,      18,    10,    10,          6    \ Edge 29

.SHIP_SHUTTLE_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE     -110,     -110,       80,         31    \ Face 0
 FACE        0,     -149,        7,         31    \ Face 1
 FACE     -102,     -102,       46,         31    \ Face 2
 FACE     -149,        0,        7,         31    \ Face 3
 FACE     -102,      102,       46,         31    \ Face 4
 FACE        0,      149,        7,         31    \ Face 5
 FACE      102,      102,       46,         31    \ Face 6
 FACE      149,        0,        7,         31    \ Face 7
 FACE      102,     -102,       46,         31    \ Face 8
 FACE        0,        0,     -213,         31    \ Face 9
 FACE      -81,       81,      177,         31    \ Face 10
 FACE       81,       81,      177,         31    \ Face 11
 FACE      110,     -110,       80,         31    \ Face 12

\ ******************************************************************************
\
\       Name: SHIP_TRANSPORTER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Transporter
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_TRANSPORTER

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 50 * 50           \ Targetable area          = 50 * 50
 EQUB LO(SHIP_TRANSPORTER_EDGES - SHIP_TRANSPORTER)   \ Edges data offset (low)
 EQUB LO(SHIP_TRANSPORTER_FACES - SHIP_TRANSPORTER)   \ Faces data offset (low)
 EQUB 145               \ Max. edge count          = (145 - 1) / 4 = 36
 EQUB 48                \ Gun vertex               = 48 / 4 = 12
 EQUB 26                \ Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 222               \ Number of vertices       = 222 / 6 = 37
 EQUB 46                \ Number of edges          = 46
 EQUW 0                 \ Bounty                   = 0
 EQUB 56                \ Number of faces          = 56 / 4 = 14
 EQUB 16                \ Visibility distance      = 16
 EQUB 32                \ Max. energy              = 32
 EQUB 10                \ Max. speed               = 10
 EQUB HI(SHIP_TRANSPORTER_EDGES - SHIP_TRANSPORTER)   \ Edges data offset (high)
 EQUB HI(SHIP_TRANSPORTER_FACES - SHIP_TRANSPORTER)   \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   19,  -51,     6,     0,     7,     7,         31     \ Vertex 0
 VERTEX  -51,    7,  -51,     1,     0,     7,     7,         31     \ Vertex 1
 VERTEX  -57,   -7,  -51,     1,     0,     2,     2,         31     \ Vertex 2
 VERTEX  -51,  -17,  -51,     2,     0,     3,     3,         31     \ Vertex 3
 VERTEX   51,  -17,  -51,     3,     0,     4,     4,         31     \ Vertex 4
 VERTEX   57,   -7,  -51,     4,     0,     5,     5,         31     \ Vertex 5
 VERTEX   51,    7,  -51,     5,     0,     6,     6,         31     \ Vertex 6
 VERTEX    0,   12,   24,    15,    15,    15,    15,         18     \ Vertex 7
 VERTEX  -60,   -2,   24,     7,     1,     9,     8,         31     \ Vertex 8
 VERTEX  -66,  -17,   24,     2,     1,     9,     3,         31     \ Vertex 9
 VERTEX   66,  -17,   24,     4,     3,    10,     5,         31     \ Vertex 10
 VERTEX   60,   -2,   24,     6,     5,    11,    10,         31     \ Vertex 11
 VERTEX  -22,   -5,   61,     9,     8,    13,    12,         31     \ Vertex 12
 VERTEX  -27,  -17,   61,     9,     3,    13,    13,         31     \ Vertex 13
 VERTEX   27,  -17,   61,    10,     3,    13,    13,         31     \ Vertex 14
 VERTEX   22,   -5,   61,    11,    10,    13,    12,         31     \ Vertex 15
 VERTEX  -10,   11,    5,     7,     7,     7,     7,          6     \ Vertex 16
 VERTEX  -36,    5,    5,     7,     7,     7,     7,          6     \ Vertex 17
 VERTEX  -10,   13,  -14,     7,     7,     7,     7,          6     \ Vertex 18
 VERTEX  -36,    7,  -14,     7,     7,     7,     7,          6     \ Vertex 19
 VERTEX  -23,   12,  -29,     7,     7,     7,     7,          6     \ Vertex 20
 VERTEX  -23,   10,  -14,     7,     7,     7,     7,          6     \ Vertex 21
 VERTEX   10,   15,  -29,     6,     6,     6,     6,          6     \ Vertex 22
 VERTEX   36,    9,  -29,     6,     6,     6,     6,          6     \ Vertex 23
 VERTEX   23,   10,  -14,     6,     6,     6,     6,          6     \ Vertex 24
 VERTEX   10,   12,   -6,     6,     6,     6,     6,          6     \ Vertex 25
 VERTEX   36,    6,   -6,     6,     6,     6,     6,          6     \ Vertex 26
 VERTEX   23,    7,   16,     6,     6,     6,     6,          6     \ Vertex 27
 VERTEX   23,    9,   -6,     6,     6,     6,     6,          6     \ Vertex 28
 VERTEX  -33,  -17,  -26,     3,     3,     3,     3,          5     \ Vertex 29
 VERTEX  -33,  -17,   33,     3,     3,     3,     3,          5     \ Vertex 30
 VERTEX   33,  -17,  -26,     3,     3,     3,     3,          5     \ Vertex 31
 VERTEX   33,  -17,   33,     3,     3,     3,     3,          5     \ Vertex 32
 VERTEX  -25,   -6,  -51,     0,     0,     0,     0,          7     \ Vertex 33
 VERTEX   26,   -6,  -51,     0,     0,     0,     0,          7     \ Vertex 34
 VERTEX   17,    6,  -51,     0,     0,     0,     0,          4     \ Vertex 35
 VERTEX  -17,    6,  -51,     0,     0,     0,     0,          4     \ Vertex 36

.SHIP_TRANSPORTER_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    \ Edge 0
 EDGE       1,       2,     1,     0,         31    \ Edge 1
 EDGE       2,       3,     2,     0,         31    \ Edge 2
 EDGE       3,       4,     3,     0,         31    \ Edge 3
 EDGE       4,       5,     4,     0,         31    \ Edge 4
 EDGE       5,       6,     5,     0,         31    \ Edge 5
 EDGE       0,       6,     6,     0,         31    \ Edge 6
 EDGE       0,       7,     7,     6,         15    \ Edge 7
 EDGE       1,       8,     7,     1,         31    \ Edge 8
 EDGE       2,       9,     2,     1,         10    \ Edge 9
 EDGE       3,       9,     3,     2,         31    \ Edge 10
 EDGE       4,      10,     4,     3,         31    \ Edge 11
 EDGE       5,      10,     5,     4,         10    \ Edge 12
 EDGE       6,      11,     6,     5,         31    \ Edge 13
 EDGE       7,       8,     8,     7,         16    \ Edge 14
 EDGE       8,       9,     9,     1,         16    \ Edge 15
 EDGE      10,      11,    10,     5,         16    \ Edge 16
 EDGE       7,      11,    11,     6,         16    \ Edge 17
 EDGE       7,      15,    12,    11,         18    \ Edge 18
 EDGE       7,      12,    12,     8,         18    \ Edge 19
 EDGE       8,      12,     9,     8,         16    \ Edge 20
 EDGE       9,      13,     9,     3,         31    \ Edge 21
 EDGE      10,      14,    10,     3,         31    \ Edge 22
 EDGE      11,      15,    11,    10,         16    \ Edge 23
 EDGE      12,      13,    13,     9,         31    \ Edge 24
 EDGE      13,      14,    13,     3,         31    \ Edge 25
 EDGE      14,      15,    13,    10,         31    \ Edge 26
 EDGE      12,      15,    13,    12,         31    \ Edge 27
 EDGE      16,      17,     7,     7,          6    \ Edge 28
 EDGE      18,      19,     7,     7,          6    \ Edge 29
 EDGE      19,      20,     7,     7,          6    \ Edge 30
 EDGE      18,      20,     7,     7,          6    \ Edge 31
 EDGE      20,      21,     7,     7,          6    \ Edge 32
 EDGE      22,      23,     6,     6,          6    \ Edge 33
 EDGE      23,      24,     6,     6,          6    \ Edge 34
 EDGE      24,      22,     6,     6,          6    \ Edge 35
 EDGE      25,      26,     6,     6,          6    \ Edge 36
 EDGE      26,      27,     6,     6,          6    \ Edge 37
 EDGE      25,      27,     6,     6,          6    \ Edge 38
 EDGE      27,      28,     6,     6,          6    \ Edge 39
 EDGE      29,      30,     3,     3,          5    \ Edge 40
 EDGE      31,      32,     3,     3,          5    \ Edge 41
 EDGE      33,      34,     0,     0,          7    \ Edge 42
 EDGE      34,      35,     0,     0,          4    \ Edge 43
 EDGE      35,      36,     0,     0,          4    \ Edge 44
 EDGE      36,      33,     0,     0,          4    \ Edge 45

.SHIP_TRANSPORTER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,        0,     -103,         31    \ Face 0
 FACE     -111,       48,       -7,         31    \ Face 1
 FACE     -105,      -63,      -21,         31    \ Face 2
 FACE        0,      -34,        0,         31    \ Face 3
 FACE      105,      -63,      -21,         31    \ Face 4
 FACE      111,       48,       -7,         31    \ Face 5
 FACE        8,       32,        3,         31    \ Face 6
 FACE       -8,       32,        3,         31    \ Face 7
 FACE       -8,       34,       11,         18    \ Face 8
 FACE      -75,       32,       79,         31    \ Face 9
 FACE       75,       32,       79,         31    \ Face 10
 FACE        8,       34,       11,         18    \ Face 11
 FACE        0,       38,       17,         31    \ Face 12
 FACE        0,        0,      121,         31    \ Face 13

\ ******************************************************************************
\
\       Name: SHIP_COBRA_MK_3
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Cobra Mk III
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_COBRA_MK_3

 EQUB 3                 \ Max. canisters on demise = 3
 EQUW 95 * 95           \ Targetable area          = 95 * 95
 EQUB LO(SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)  \ Edges data offset (low)
 EQUB LO(SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)  \ Faces data offset (low)
 EQUB 153               \ Max. edge count          = (153 - 1) / 4 = 38
 EQUB 84                \ Gun vertex               = 84 / 4 = 21
 EQUB 42                \ Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 168               \ Number of vertices       = 168 / 6 = 28
 EQUB 38                \ Number of edges          = 38
 EQUW 200               \ Bounty                   = 200
 EQUB 52                \ Number of faces          = 52 / 4 = 13
 EQUB 50                \ Visibility distance      = 50
 EQUB 98                \ Max. energy              = 98
 EQUB 28                \ Max. speed               = 28
 EQUB HI(SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)  \ Edges data offset (low)
 EQUB HI(SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)  \ Faces data offset (low)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00100100         \ Laser power              = 4
                        \ Missiles                 = 4

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   32,    0,   76,    15,     15,   15,    15,         31    \ Vertex 0
 VERTEX  -32,    0,   76,    15,     15,   15,    15,         31    \ Vertex 1
 VERTEX    0,   26,   24,    15,     15,   15,    15,         31    \ Vertex 2
 VERTEX -120,   -3,   -8,     3,      7,   10,    10,         31    \ Vertex 3
 VERTEX  120,   -3,   -8,     4,      8,   12,    12,         31    \ Vertex 4
 VERTEX  -88,   16,  -40,    15,     15,   15,    15,         31    \ Vertex 5
 VERTEX   88,   16,  -40,    15,     15,   15,    15,         31    \ Vertex 6
 VERTEX  128,   -8,  -40,     8,      9,   12,    12,         31    \ Vertex 7
 VERTEX -128,   -8,  -40,     7,      9,   10,    10,         31    \ Vertex 8
 VERTEX    0,   26,  -40,     5,      6,    9,     9,         31    \ Vertex 9
 VERTEX  -32,  -24,  -40,     9,     10,   11,    11,         31    \ Vertex 10
 VERTEX   32,  -24,  -40,     9,     11,   12,    12,         31    \ Vertex 11
 VERTEX  -36,    8,  -40,     9,      9,    9,     9,         20    \ Vertex 12
 VERTEX   -8,   12,  -40,     9,      9,    9,     9,         20    \ Vertex 13
 VERTEX    8,   12,  -40,     9,      9,    9,     9,         20    \ Vertex 14
 VERTEX   36,    8,  -40,     9,      9,    9,     9,         20    \ Vertex 15
 VERTEX   36,  -12,  -40,     9,      9,    9,     9,         20    \ Vertex 16
 VERTEX    8,  -16,  -40,     9,      9,    9,     9,         20    \ Vertex 17
 VERTEX   -8,  -16,  -40,     9,      9,    9,     9,         20    \ Vertex 18
 VERTEX  -36,  -12,  -40,     9,      9,    9,     9,         20    \ Vertex 19
 VERTEX    0,    0,   76,     0,     11,   11,    11,          6    \ Vertex 20
 VERTEX    0,    0,   90,     0,     11,   11,    11,         31    \ Vertex 21
 VERTEX  -80,   -6,  -40,     9,      9,    9,     9,          8    \ Vertex 22
 VERTEX  -80,    6,  -40,     9,      9,    9,     9,          8    \ Vertex 23
 VERTEX  -88,    0,  -40,     9,      9,    9,     9,          6    \ Vertex 24
 VERTEX   80,    6,  -40,     9,      9,    9,     9,          8    \ Vertex 25
 VERTEX   88,    0,  -40,     9,      9,    9,     9,          6    \ Vertex 26
 VERTEX   80,   -6,  -40,     9,      9,    9,     9,          8    \ Vertex 27

.SHIP_COBRA_MK_3_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,    11,         31    \ Edge 0
 EDGE       0,       4,     4,    12,         31    \ Edge 1
 EDGE       1,       3,     3,    10,         31    \ Edge 2
 EDGE       3,       8,     7,    10,         31    \ Edge 3
 EDGE       4,       7,     8,    12,         31    \ Edge 4
 EDGE       6,       7,     8,     9,         31    \ Edge 5
 EDGE       6,       9,     6,     9,         31    \ Edge 6
 EDGE       5,       9,     5,     9,         31    \ Edge 7
 EDGE       5,       8,     7,     9,         31    \ Edge 8
 EDGE       2,       5,     1,     5,         31    \ Edge 9
 EDGE       2,       6,     2,     6,         31    \ Edge 10
 EDGE       3,       5,     3,     7,         31    \ Edge 11
 EDGE       4,       6,     4,     8,         31    \ Edge 12
 EDGE       1,       2,     0,     1,         31    \ Edge 13
 EDGE       0,       2,     0,     2,         31    \ Edge 14
 EDGE       8,      10,     9,    10,         31    \ Edge 15
 EDGE      10,      11,     9,    11,         31    \ Edge 16
 EDGE       7,      11,     9,    12,         31    \ Edge 17
 EDGE       1,      10,    10,    11,         31    \ Edge 18
 EDGE       0,      11,    11,    12,         31    \ Edge 19
 EDGE       1,       5,     1,     3,         29    \ Edge 20
 EDGE       0,       6,     2,     4,         29    \ Edge 21
 EDGE      20,      21,     0,    11,          6    \ Edge 22
 EDGE      12,      13,     9,     9,         20    \ Edge 23
 EDGE      18,      19,     9,     9,         20    \ Edge 24
 EDGE      14,      15,     9,     9,         20    \ Edge 25
 EDGE      16,      17,     9,     9,         20    \ Edge 26
 EDGE      15,      16,     9,     9,         19    \ Edge 27
 EDGE      14,      17,     9,     9,         17    \ Edge 28
 EDGE      13,      18,     9,     9,         19    \ Edge 29
 EDGE      12,      19,     9,     9,         19    \ Edge 30
 EDGE       2,       9,     5,     6,         30    \ Edge 31
 EDGE      22,      24,     9,     9,          6    \ Edge 32
 EDGE      23,      24,     9,     9,          6    \ Edge 33
 EDGE      22,      23,     9,     9,          8    \ Edge 34
 EDGE      25,      26,     9,     9,          6    \ Edge 35
 EDGE      26,      27,     9,     9,          6    \ Edge 36
 EDGE      25,      27,     9,     9,          8    \ Edge 37

.SHIP_COBRA_MK_3_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       62,       31,         31    \ Face 0
 FACE      -18,       55,       16,         31    \ Face 1
 FACE       18,       55,       16,         31    \ Face 2
 FACE      -16,       52,       14,         31    \ Face 3
 FACE       16,       52,       14,         31    \ Face 4
 FACE      -14,       47,        0,         31    \ Face 5
 FACE       14,       47,        0,         31    \ Face 6
 FACE      -61,      102,        0,         31    \ Face 7
 FACE       61,      102,        0,         31    \ Face 8
 FACE        0,        0,      -80,         31    \ Face 9
 FACE       -7,      -42,        9,         31    \ Face 10
 FACE        0,      -30,        6,         31    \ Face 11
 FACE        7,      -42,        9,         31    \ Face 12

\ ******************************************************************************
\
\       Name: SHIP_PYTHON
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Python
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_PYTHON

 EQUB 5                 \ Max. canisters on demise = 5
 EQUW 80 * 80           \ Targetable area          = 80 * 80
 EQUB LO(SHIP_PYTHON_EDGES - SHIP_PYTHON)          \ Edges data offset (low)
 EQUB LO(SHIP_PYTHON_FACES - SHIP_PYTHON)          \ Faces data offset (low)
 EQUB 85                \ Max. edge count          = (85 - 1) / 4 = 21
 EQUB 0                 \ Gun vertex               = 0
 EQUB 42                \ Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 66                \ Number of vertices       = 66 / 6 = 11
 EQUB 26                \ Number of edges          = 26
 EQUW 300               \ Bounty                   = 300
 EQUB 52                \ Number of faces          = 52 / 4 = 13
 EQUB 40                \ Visibility distance      = 40
 EQUB 125               \ Max. energy              = 125
 EQUB 20                \ Max. speed               = 20
 EQUB HI(SHIP_PYTHON_EDGES - SHIP_PYTHON)          \ Edges data offset (high)
 EQUB HI(SHIP_PYTHON_FACES - SHIP_PYTHON)          \ Faces data offset (high)
 EQUB 0                 \ Normals are scaled by    = 2^0 = 1
 EQUB %00101100         \ Laser power              = 5
                        \ Missiles                 = 4

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,  224,     0,      1,    2,     3,         31    \ Vertex 0
 VERTEX    0,   48,   48,     0,      1,    4,     5,         30    \ Vertex 1
 VERTEX   96,    0,  -16,    15,     15,   15,    15,         31    \ Vertex 2
 VERTEX  -96,    0,  -16,    15,     15,   15,    15,         31    \ Vertex 3
 VERTEX    0,   48,  -32,     4,      5,    8,     9,         30    \ Vertex 4
 VERTEX    0,   24, -112,     9,      8,   12,    12,         31    \ Vertex 5
 VERTEX  -48,    0, -112,     8,     11,   12,    12,         31    \ Vertex 6
 VERTEX   48,    0, -112,     9,     10,   12,    12,         31    \ Vertex 7
 VERTEX    0,  -48,   48,     2,      3,    6,     7,         30    \ Vertex 8
 VERTEX    0,  -48,  -32,     6,      7,   10,    11,         30    \ Vertex 9
 VERTEX    0,  -24, -112,    10,     11,   12,    12,         30    \ Vertex 10

.SHIP_PYTHON_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       8,     2,     3,         30    \ Edge 0
 EDGE       0,       3,     0,     2,         31    \ Edge 1
 EDGE       0,       2,     1,     3,         31    \ Edge 2
 EDGE       0,       1,     0,     1,         30    \ Edge 3
 EDGE       2,       4,     9,     5,         29    \ Edge 4
 EDGE       1,       2,     1,     5,         29    \ Edge 5
 EDGE       2,       8,     7,     3,         29    \ Edge 6
 EDGE       1,       3,     0,     4,         29    \ Edge 7
 EDGE       3,       8,     2,     6,         29    \ Edge 8
 EDGE       2,       9,     7,    10,         29    \ Edge 9
 EDGE       3,       4,     4,     8,         29    \ Edge 10
 EDGE       3,       9,     6,    11,         29    \ Edge 11
 EDGE       3,       5,     8,     8,          5    \ Edge 12
 EDGE       3,      10,    11,    11,          5    \ Edge 13
 EDGE       2,       5,     9,     9,          5    \ Edge 14
 EDGE       2,      10,    10,    10,          5    \ Edge 15
 EDGE       2,       7,     9,    10,         31    \ Edge 16
 EDGE       3,       6,     8,    11,         31    \ Edge 17
 EDGE       5,       6,     8,    12,         31    \ Edge 18
 EDGE       5,       7,     9,    12,         31    \ Edge 19
 EDGE       7,      10,    12,    10,         29    \ Edge 20
 EDGE       6,      10,    11,    12,         29    \ Edge 21
 EDGE       4,       5,     8,     9,         29    \ Edge 22
 EDGE       9,      10,    10,    11,         29    \ Edge 23
 EDGE       1,       4,     4,     5,         29    \ Edge 24
 EDGE       8,       9,     6,     7,         29    \ Edge 25

.SHIP_PYTHON_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      -27,       40,       11,         30    \ Face 0
 FACE       27,       40,       11,         30    \ Face 1
 FACE      -27,      -40,       11,         30    \ Face 2
 FACE       27,      -40,       11,         30    \ Face 3
 FACE      -19,       38,        0,         30    \ Face 4
 FACE       19,       38,        0,         30    \ Face 5
 FACE      -19,      -38,        0,         30    \ Face 6
 FACE       19,      -38,        0,         30    \ Face 7
 FACE      -25,       37,      -11,         30    \ Face 8
 FACE       25,       37,      -11,         30    \ Face 9
 FACE       25,      -37,      -11,         30    \ Face 10
 FACE      -25,      -37,      -11,         30    \ Face 11
 FACE        0,        0,     -112,         30    \ Face 12

\ ******************************************************************************
\
\       Name: SHIP_BOA
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Boa
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_BOA

 EQUB 5                 \ Max. canisters on demise = 5
 EQUW 70 * 70           \ Targetable area          = 70 * 70
 EQUB LO(SHIP_BOA_EDGES - SHIP_BOA)                \ Edges data offset (low)
 EQUB LO(SHIP_BOA_FACES - SHIP_BOA)                \ Faces data offset (low)
 EQUB 89                \ Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 \ Gun vertex               = 0
 EQUB 38                \ Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 78                \ Number of vertices       = 78 / 6 = 13
 EQUB 24                \ Number of edges          = 24
 EQUW 250               \ Bounty                   = 250
 EQUB 52                \ Number of faces          = 52 / 4 = 13
 EQUB 40                \ Visibility distance      = 40
 EQUB 164               \ Max. energy              = 164
 EQUB 24                \ Max. speed               = 24
 EQUB HI(SHIP_BOA_EDGES - SHIP_BOA)                \ Edges data offset (high)
 EQUB HI(SHIP_BOA_FACES - SHIP_BOA)                \ Faces data offset (high)
 EQUB 0                 \ Normals are scaled by    = 2^0 = 1
 EQUB %00101010         \ Laser power              = 5
                        \ Missiles                 = 2

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   93,    15,     15,   15,    15,         31    \ Vertex 0
 VERTEX    0,   40,  -87,     2,      0,    3,     3,         24    \ Vertex 1
 VERTEX   38,  -25,  -99,     1,      0,    4,     4,         24    \ Vertex 2
 VERTEX  -38,  -25,  -99,     2,      1,    5,     5,         24    \ Vertex 3
 VERTEX  -38,   40,  -59,     3,      2,    9,     6,         31    \ Vertex 4
 VERTEX   38,   40,  -59,     3,      0,   11,     6,         31    \ Vertex 5
 VERTEX   62,    0,  -67,     4,      0,   11,     8,         31    \ Vertex 6
 VERTEX   24,  -65,  -79,     4,      1,   10,     8,         31    \ Vertex 7
 VERTEX  -24,  -65,  -79,     5,      1,   10,     7,         31    \ Vertex 8
 VERTEX  -62,    0,  -67,     5,      2,    9,     7,         31    \ Vertex 9
 VERTEX    0,    7, -107,     2,      0,   10,    10,         22    \ Vertex 10
 VERTEX   13,   -9, -107,     1,      0,   10,    10,         22    \ Vertex 11
 VERTEX  -13,   -9, -107,     2,      1,   12,    12,         22    \ Vertex 12

.SHIP_BOA_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       5,    11,     6,         31    \ Edge 0
 EDGE       0,       7,    10,     8,         31    \ Edge 1
 EDGE       0,       9,     9,     7,         31    \ Edge 2
 EDGE       0,       4,     9,     6,         29    \ Edge 3
 EDGE       0,       6,    11,     8,         29    \ Edge 4
 EDGE       0,       8,    10,     7,         29    \ Edge 5
 EDGE       4,       5,     6,     3,         31    \ Edge 6
 EDGE       5,       6,    11,     0,         31    \ Edge 7
 EDGE       6,       7,     8,     4,         31    \ Edge 8
 EDGE       7,       8,    10,     1,         31    \ Edge 9
 EDGE       8,       9,     7,     5,         31    \ Edge 10
 EDGE       4,       9,     9,     2,         31    \ Edge 11
 EDGE       1,       4,     3,     2,         24    \ Edge 12
 EDGE       1,       5,     3,     0,         24    \ Edge 13
 EDGE       3,       9,     5,     2,         24    \ Edge 14
 EDGE       3,       8,     5,     1,         24    \ Edge 15
 EDGE       2,       6,     4,     0,         24    \ Edge 16
 EDGE       2,       7,     4,     1,         24    \ Edge 17
 EDGE       1,      10,     2,     0,         22    \ Edge 18
 EDGE       2,      11,     1,     0,         22    \ Edge 19
 EDGE       3,      12,     2,     1,         22    \ Edge 20
 EDGE      10,      11,    12,     0,         14    \ Edge 21
 EDGE      11,      12,    12,     1,         14    \ Edge 22
 EDGE      12,      10,    12,     2,         14    \ Edge 23

.SHIP_BOA_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE       43,       37,      -60,         31    \ Face 0
 FACE        0,      -45,      -89,         31    \ Face 1
 FACE      -43,       37,      -60,         31    \ Face 2
 FACE        0,       40,        0,         31    \ Face 3
 FACE       62,      -32,      -20,         31    \ Face 4
 FACE      -62,      -32,      -20,         31    \ Face 5
 FACE        0,       23,        6,         31    \ Face 6
 FACE      -23,      -15,        9,         31    \ Face 7
 FACE       23,      -15,        9,         31    \ Face 8
 FACE      -26,       13,       10,         31    \ Face 9
 FACE        0,      -31,       12,         31    \ Face 10
 FACE       26,       13,       10,         31    \ Face 11
 FACE        0,        0,     -107,         14    \ Face 12

\ ******************************************************************************
\
\       Name: SHIP_ANACONDA
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for an Anaconda
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_ANACONDA

 EQUB 7                 \ Max. canisters on demise = 7
 EQUW 100 * 100         \ Targetable area          = 100 * 100
 EQUB LO(SHIP_ANACONDA_EDGES - SHIP_ANACONDA)      \ Edges data offset (low)
 EQUB LO(SHIP_ANACONDA_FACES - SHIP_ANACONDA)      \ Faces data offset (low)
 EQUB 89                \ Max. edge count          = (89 - 1) / 4 = 22
 EQUB 48                \ Gun vertex               = 48 / 4 = 12
 EQUB 46                \ Explosion count          = 10, as (4 * n) + 6 = 46
 EQUB 90                \ Number of vertices       = 90 / 6 = 15
 EQUB 25                \ Number of edges          = 25
 EQUW 350               \ Bounty                   = 350
 EQUB 48                \ Number of faces          = 48 / 4 = 12
 EQUB 50                \ Visibility distance      = 50
 EQUB 252               \ Max. energy              = 252
 EQUB 14                \ Max. speed               = 14
 EQUB HI(SHIP_ANACONDA_EDGES - SHIP_ANACONDA)      \ Edges data offset (high)
 EQUB HI(SHIP_ANACONDA_FACES - SHIP_ANACONDA)      \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %01001111         \ Laser power              = 9
                        \ Missiles                 = 7

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    7,  -58,     1,      0,    5,     5,         30    \ Vertex 0
 VERTEX  -43,  -13,  -37,     1,      0,    2,     2,         30    \ Vertex 1
 VERTEX  -26,  -47,   -3,     2,      0,    3,     3,         30    \ Vertex 2
 VERTEX   26,  -47,   -3,     3,      0,    4,     4,         30    \ Vertex 3
 VERTEX   43,  -13,  -37,     4,      0,    5,     5,         30    \ Vertex 4
 VERTEX    0,   48,  -49,     5,      1,    6,     6,         30    \ Vertex 5
 VERTEX  -69,   15,  -15,     2,      1,    7,     7,         30    \ Vertex 6
 VERTEX  -43,  -39,   40,     3,      2,    8,     8,         31    \ Vertex 7
 VERTEX   43,  -39,   40,     4,      3,    9,     9,         31    \ Vertex 8
 VERTEX   69,   15,  -15,     5,      4,   10,    10,         30    \ Vertex 9
 VERTEX  -43,   53,  -23,    15,     15,   15,    15,         31    \ Vertex 10
 VERTEX  -69,   -1,   32,     7,      2,    8,     8,         31    \ Vertex 11
 VERTEX    0,    0,  254,    15,     15,   15,    15,         31    \ Vertex 12
 VERTEX   69,   -1,   32,     9,      4,   10,    10,         31    \ Vertex 13
 VERTEX   43,   53,  -23,    15,     15,   15,    15,         31    \ Vertex 14

.SHIP_ANACONDA_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         30    \ Edge 0
 EDGE       1,       2,     2,     0,         30    \ Edge 1
 EDGE       2,       3,     3,     0,         30    \ Edge 2
 EDGE       3,       4,     4,     0,         30    \ Edge 3
 EDGE       0,       4,     5,     0,         30    \ Edge 4
 EDGE       0,       5,     5,     1,         29    \ Edge 5
 EDGE       1,       6,     2,     1,         29    \ Edge 6
 EDGE       2,       7,     3,     2,         29    \ Edge 7
 EDGE       3,       8,     4,     3,         29    \ Edge 8
 EDGE       4,       9,     5,     4,         29    \ Edge 9
 EDGE       5,      10,     6,     1,         30    \ Edge 10
 EDGE       6,      10,     7,     1,         30    \ Edge 11
 EDGE       6,      11,     7,     2,         30    \ Edge 12
 EDGE       7,      11,     8,     2,         30    \ Edge 13
 EDGE       7,      12,     8,     3,         31    \ Edge 14
 EDGE       8,      12,     9,     3,         31    \ Edge 15
 EDGE       8,      13,     9,     4,         30    \ Edge 16
 EDGE       9,      13,    10,     4,         30    \ Edge 17
 EDGE       9,      14,    10,     5,         30    \ Edge 18
 EDGE       5,      14,     6,     5,         30    \ Edge 19
 EDGE      10,      14,    11,     6,         30    \ Edge 20
 EDGE      10,      12,    11,     7,         31    \ Edge 21
 EDGE      11,      12,     8,     7,         31    \ Edge 22
 EDGE      12,      13,    10,     9,         31    \ Edge 23
 EDGE      12,      14,    11,    10,         31    \ Edge 24

.SHIP_ANACONDA_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,      -51,      -49,         30    \ Face 0
 FACE      -51,       18,      -87,         30    \ Face 1
 FACE      -77,      -57,      -19,         30    \ Face 2
 FACE        0,      -90,       16,         31    \ Face 3
 FACE       77,      -57,      -19,         30    \ Face 4
 FACE       51,       18,      -87,         30    \ Face 5
 FACE        0,      111,      -20,         30    \ Face 6
 FACE      -97,       72,       24,         31    \ Face 7
 FACE     -108,      -68,       34,         31    \ Face 8
 FACE      108,      -68,       34,         31    \ Face 9
 FACE       97,       72,       24,         31    \ Face 10
 FACE        0,       94,       18,         31    \ Face 11

\ ******************************************************************************
\
\       Name: SHIP_WORM
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Worm
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_WORM

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 99 * 99           \ Targetable area          = 99 * 99
 EQUB LO(SHIP_WORM_EDGES - SHIP_WORM)              \ Edges data offset (low)
 EQUB LO(SHIP_WORM_FACES - SHIP_WORM)              \ Faces data offset (low)
 EQUB 73                \ Max. edge count          = (73 - 1) / 4 = 18
 EQUB 0                 \ Gun vertex               = 0
 EQUB 18                \ Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                \ Number of vertices       = 60 / 6 = 10
 EQUB 16                \ Number of edges          = 16
 EQUW 0                 \ Bounty                   = 0
 EQUB 32                \ Number of faces          = 32 / 4 = 8
 EQUB 19                \ Visibility distance      = 19
 EQUB 32                \ Max. energy              = 32
 EQUB 23                \ Max. speed               = 23
 EQUB HI(SHIP_WORM_EDGES - SHIP_WORM)              \ Edges data offset (high)
 EQUB HI(SHIP_WORM_FACES - SHIP_WORM)              \ Faces data offset (high)
 EQUB 3                 \ Normals are scaled by    = 2^3 = 8
 EQUB %00011000         \ Laser power              = 3
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   10,  -10,   35,     2,      0,    7,     7,         31    \ Vertex 0
 VERTEX  -10,  -10,   35,     3,      0,    7,     7,         31    \ Vertex 1
 VERTEX    5,    6,   15,     1,      0,    4,     2,         31    \ Vertex 2
 VERTEX   -5,    6,   15,     1,      0,    5,     3,         31    \ Vertex 3
 VERTEX   15,  -10,   25,     4,      2,    7,     7,         31    \ Vertex 4
 VERTEX  -15,  -10,   25,     5,      3,    7,     7,         31    \ Vertex 5
 VERTEX   26,  -10,  -25,     6,      4,    7,     7,         31    \ Vertex 6
 VERTEX  -26,  -10,  -25,     6,      5,    7,     7,         31    \ Vertex 7
 VERTEX    8,   14,  -25,     4,      1,    6,     6,         31    \ Vertex 8
 VERTEX   -8,   14,  -25,     5,      1,    6,     6,         31    \ Vertex 9

.SHIP_WORM_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    \ Edge 0
 EDGE       1,       5,     7,     3,         31    \ Edge 1
 EDGE       5,       7,     7,     5,         31    \ Edge 2
 EDGE       7,       6,     7,     6,         31    \ Edge 3
 EDGE       6,       4,     7,     4,         31    \ Edge 4
 EDGE       4,       0,     7,     2,         31    \ Edge 5
 EDGE       0,       2,     2,     0,         31    \ Edge 6
 EDGE       1,       3,     3,     0,         31    \ Edge 7
 EDGE       4,       2,     4,     2,         31    \ Edge 8
 EDGE       5,       3,     5,     3,         31    \ Edge 9
 EDGE       2,       8,     4,     1,         31    \ Edge 10
 EDGE       8,       6,     6,     4,         31    \ Edge 11
 EDGE       3,       9,     5,     1,         31    \ Edge 12
 EDGE       9,       7,     6,     5,         31    \ Edge 13
 EDGE       2,       3,     1,     0,         31    \ Edge 14
 EDGE       8,       9,     6,     1,         31    \ Edge 15

.SHIP_WORM_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       88,       70,         31    \ Face 0
 FACE        0,       69,       14,         31    \ Face 1
 FACE       70,       66,       35,         31    \ Face 2
 FACE      -70,       66,       35,         31    \ Face 3
 FACE       64,       49,       14,         31    \ Face 4
 FACE      -64,       49,       14,         31    \ Face 5
 FACE        0,        0,     -200,         31    \ Face 6
 FACE        0,      -80,        0,         31    \ Face 7

\ ******************************************************************************
\
\       Name: SHIP_MISSILE
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a missile
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_MISSILE

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 40 * 40           \ Targetable area          = 40 * 40
 EQUB LO(SHIP_MISSILE_EDGES - SHIP_MISSILE)        \ Edges data offset (low)
 EQUB LO(SHIP_MISSILE_FACES - SHIP_MISSILE)        \ Faces data offset (low)
 EQUB 81                \ Max. edge count          = (81 - 1) / 4 = 20
 EQUB 0                 \ Gun vertex               = 0
 EQUB 10                \ Explosion count          = 1, as (4 * n) + 6 = 10
 EQUB 102               \ Number of vertices       = 102 / 6 = 17
 EQUB 24                \ Number of edges          = 24
 EQUW 0                 \ Bounty                   = 0
 EQUB 36                \ Number of faces          = 36 / 4 = 9
 EQUB 14                \ Visibility distance      = 14
 EQUB 2                 \ Max. energy              = 2
 EQUB 44                \ Max. speed               = 44
 EQUB HI(SHIP_MISSILE_EDGES - SHIP_MISSILE)        \ Edges data offset (high)
 EQUB HI(SHIP_MISSILE_FACES - SHIP_MISSILE)        \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   68,     0,      1,    2,     3,         31    \ Vertex 0
 VERTEX    8,   -8,   36,     1,      2,    4,     5,         31    \ Vertex 1
 VERTEX    8,    8,   36,     2,      3,    4,     7,         31    \ Vertex 2
 VERTEX   -8,    8,   36,     0,      3,    6,     7,         31    \ Vertex 3
 VERTEX   -8,   -8,   36,     0,      1,    5,     6,         31    \ Vertex 4
 VERTEX    8,    8,  -44,     4,      7,    8,     8,         31    \ Vertex 5
 VERTEX    8,   -8,  -44,     4,      5,    8,     8,         31    \ Vertex 6
 VERTEX   -8,   -8,  -44,     5,      6,    8,     8,         31    \ Vertex 7
 VERTEX   -8,    8,  -44,     6,      7,    8,     8,         31    \ Vertex 8
 VERTEX   12,   12,  -44,     4,      7,    8,     8,          8    \ Vertex 9
 VERTEX   12,  -12,  -44,     4,      5,    8,     8,          8    \ Vertex 10
 VERTEX  -12,  -12,  -44,     5,      6,    8,     8,          8    \ Vertex 11
 VERTEX  -12,   12,  -44,     6,      7,    8,     8,          8    \ Vertex 12
 VERTEX   -8,    8,  -12,     6,      7,    7,     7,          8    \ Vertex 13
 VERTEX   -8,   -8,  -12,     5,      6,    6,     6,          8    \ Vertex 14
 VERTEX    8,    8,  -12,     4,      7,    7,     7,          8    \ Vertex 15
 VERTEX    8,   -8,  -12,     4,      5,    5,     5,          8    \ Vertex 16

.SHIP_MISSILE_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     2,         31    \ Edge 0
 EDGE       0,       2,     2,     3,         31    \ Edge 1
 EDGE       0,       3,     0,     3,         31    \ Edge 2
 EDGE       0,       4,     0,     1,         31    \ Edge 3
 EDGE       1,       2,     4,     2,         31    \ Edge 4
 EDGE       1,       4,     1,     5,         31    \ Edge 5
 EDGE       3,       4,     0,     6,         31    \ Edge 6
 EDGE       2,       3,     3,     7,         31    \ Edge 7
 EDGE       2,       5,     4,     7,         31    \ Edge 8
 EDGE       1,       6,     4,     5,         31    \ Edge 9
 EDGE       4,       7,     5,     6,         31    \ Edge 10
 EDGE       3,       8,     6,     7,         31    \ Edge 11
 EDGE       7,       8,     6,     8,         31    \ Edge 12
 EDGE       5,       8,     7,     8,         31    \ Edge 13
 EDGE       5,       6,     4,     8,         31    \ Edge 14
 EDGE       6,       7,     5,     8,         31    \ Edge 15
 EDGE       6,      10,     5,     8,          8    \ Edge 16
 EDGE       5,       9,     7,     8,          8    \ Edge 17
 EDGE       8,      12,     7,     8,          8    \ Edge 18
 EDGE       7,      11,     5,     8,          8    \ Edge 19
 EDGE       9,      15,     4,     7,          8    \ Edge 20
 EDGE      10,      16,     4,     5,          8    \ Edge 21
 EDGE      12,      13,     6,     7,          8    \ Edge 22
 EDGE      11,      14,     5,     6,          8    \ Edge 23

.SHIP_MISSILE_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      -64,        0,       16,         31    \ Face 0
 FACE        0,      -64,       16,         31    \ Face 1
 FACE       64,        0,       16,         31    \ Face 2
 FACE        0,       64,       16,         31    \ Face 3
 FACE       32,        0,        0,         31    \ Face 4
 FACE        0,      -32,        0,         31    \ Face 5
 FACE      -32,        0,        0,         31    \ Face 6
 FACE        0,       32,        0,         31    \ Face 7
 FACE        0,        0,     -176,         31    \ Face 8

\ ******************************************************************************
\
\       Name: SHIP_VIPER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Viper
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_VIPER

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 75 * 75           \ Targetable area          = 75 * 75
 EQUB LO(SHIP_VIPER_EDGES - SHIP_VIPER)            \ Edges data offset (low)
 EQUB LO(SHIP_VIPER_FACES - SHIP_VIPER)            \ Faces data offset (low)
 EQUB 77                \ Max. edge count          = (77 - 1) / 4 = 19
 EQUB 0                 \ Gun vertex               = 0
 EQUB 42                \ Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 90                \ Number of vertices       = 90 / 6 = 15
 EQUB 20                \ Number of edges          = 20
 EQUW 0                 \ Bounty                   = 0
 EQUB 28                \ Number of faces          = 28 / 4 = 7
 EQUB 23                \ Visibility distance      = 23
 EQUB 91                \ Max. energy              = 91
 EQUB 32                \ Max. speed               = 32
 EQUB HI(SHIP_VIPER_EDGES - SHIP_VIPER)            \ Edges data offset (high)
 EQUB HI(SHIP_VIPER_FACES - SHIP_VIPER)            \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00101001         \ Laser power              = 5
                        \ Missiles                 = 1

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   72,     1,      2,    3,     4,         31    \ Vertex 0
 VERTEX    0,   16,   24,     0,      1,    2,     2,         30    \ Vertex 1
 VERTEX    0,  -16,   24,     3,      4,    5,     5,         30    \ Vertex 2
 VERTEX   48,    0,  -24,     2,      4,    6,     6,         31    \ Vertex 3
 VERTEX  -48,    0,  -24,     1,      3,    6,     6,         31    \ Vertex 4
 VERTEX   24,  -16,  -24,     4,      5,    6,     6,         30    \ Vertex 5
 VERTEX  -24,  -16,  -24,     5,      3,    6,     6,         30    \ Vertex 6
 VERTEX   24,   16,  -24,     0,      2,    6,     6,         31    \ Vertex 7
 VERTEX  -24,   16,  -24,     0,      1,    6,     6,         31    \ Vertex 8
 VERTEX  -32,    0,  -24,     6,      6,    6,     6,         19    \ Vertex 9
 VERTEX   32,    0,  -24,     6,      6,    6,     6,         19    \ Vertex 10
 VERTEX    8,    8,  -24,     6,      6,    6,     6,         19    \ Vertex 11
 VERTEX   -8,    8,  -24,     6,      6,    6,     6,         19    \ Vertex 12
 VERTEX   -8,   -8,  -24,     6,      6,    6,     6,         18    \ Vertex 13
 VERTEX    8,   -8,  -24,     6,      6,    6,     6,         18    \ Vertex 14

.SHIP_VIPER_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       3,     2,     4,         31    \ Edge 0
 EDGE       0,       1,     1,     2,         30    \ Edge 1
 EDGE       0,       2,     3,     4,         30    \ Edge 2
 EDGE       0,       4,     1,     3,         31    \ Edge 3
 EDGE       1,       7,     0,     2,         30    \ Edge 4
 EDGE       1,       8,     0,     1,         30    \ Edge 5
 EDGE       2,       5,     4,     5,         30    \ Edge 6
 EDGE       2,       6,     3,     5,         30    \ Edge 7
 EDGE       7,       8,     0,     6,         31    \ Edge 8
 EDGE       5,       6,     5,     6,         30    \ Edge 9
 EDGE       4,       8,     1,     6,         31    \ Edge 10
 EDGE       4,       6,     3,     6,         30    \ Edge 11
 EDGE       3,       7,     2,     6,         31    \ Edge 12
 EDGE       3,       5,     6,     4,         30    \ Edge 13
 EDGE       9,      12,     6,     6,         19    \ Edge 14
 EDGE       9,      13,     6,     6,         18    \ Edge 15
 EDGE      10,      11,     6,     6,         19    \ Edge 16
 EDGE      10,      14,     6,     6,         18    \ Edge 17
 EDGE      11,      14,     6,     6,         16    \ Edge 18
 EDGE      12,      13,     6,     6,         16    \ Edge 19

.SHIP_VIPER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       32,        0,         31    \ Face 0
 FACE      -22,       33,       11,         31    \ Face 1
 FACE       22,       33,       11,         31    \ Face 2
 FACE      -22,      -33,       11,         31    \ Face 3
 FACE       22,      -33,       11,         31    \ Face 4
 FACE        0,      -32,        0,         31    \ Face 5
 FACE        0,        0,      -48,         31    \ Face 6

\ ******************************************************************************
\
\       Name: SHIP_SIDEWINDER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Sidewinder
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_SIDEWINDER

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 65 * 65           \ Targetable area          = 65 * 65
 EQUB LO(SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)  \ Edges data offset (low)
 EQUB LO(SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)  \ Faces data offset (low)
 EQUB 61                \ Max. edge count          = (61 - 1) / 4 = 15
 EQUB 0                 \ Gun vertex               = 0
 EQUB 30                \ Explosion count          = 6, as (4 * n) + 6 = 30
 EQUB 60                \ Number of vertices       = 60 / 6 = 10
 EQUB 15                \ Number of edges          = 15
 EQUW 100               \ Bounty                   = 100
 EQUB 28                \ Number of faces          = 28 / 4 = 7
 EQUB 20                \ Visibility distance      = 20
 EQUB 73                \ Max. energy              = 73
 EQUB 37                \ Max. speed               = 37
 EQUB HI(SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)  \ Edges data offset (high)
 EQUB HI(SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)  \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00100000         \ Laser power              = 4
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -32,    0,   36,     0,      1,    4,     5,         31    \ Vertex 0
 VERTEX   32,    0,   36,     0,      2,    5,     6,         31    \ Vertex 1
 VERTEX   64,    0,  -28,     2,      3,    6,     6,         31    \ Vertex 2
 VERTEX  -64,    0,  -28,     1,      3,    4,     4,         31    \ Vertex 3
 VERTEX    0,   16,  -28,     0,      1,    2,     3,         31    \ Vertex 4
 VERTEX    0,  -16,  -28,     3,      4,    5,     6,         31    \ Vertex 5
 VERTEX  -12,    6,  -28,     3,      3,    3,     3,         15    \ Vertex 6
 VERTEX   12,    6,  -28,     3,      3,    3,     3,         15    \ Vertex 7
 VERTEX   12,   -6,  -28,     3,      3,    3,     3,         12    \ Vertex 8
 VERTEX  -12,   -6,  -28,     3,      3,    3,     3,         12    \ Vertex 9

.SHIP_SIDEWINDER_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     5,         31    \ Edge 0
 EDGE       1,       2,     2,     6,         31    \ Edge 1
 EDGE       1,       4,     0,     2,         31    \ Edge 2
 EDGE       0,       4,     0,     1,         31    \ Edge 3
 EDGE       0,       3,     1,     4,         31    \ Edge 4
 EDGE       3,       4,     1,     3,         31    \ Edge 5
 EDGE       2,       4,     2,     3,         31    \ Edge 6
 EDGE       3,       5,     3,     4,         31    \ Edge 7
 EDGE       2,       5,     3,     6,         31    \ Edge 8
 EDGE       1,       5,     5,     6,         31    \ Edge 9
 EDGE       0,       5,     4,     5,         31    \ Edge 10
 EDGE       6,       7,     3,     3,         15    \ Edge 11
 EDGE       7,       8,     3,     3,         12    \ Edge 12
 EDGE       6,       9,     3,     3,         12    \ Edge 13
 EDGE       8,       9,     3,     3,         12    \ Edge 14

.SHIP_SIDEWINDER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       32,        8,         31    \ Face 0
 FACE      -12,       47,        6,         31    \ Face 1
 FACE       12,       47,        6,         31    \ Face 2
 FACE        0,        0,     -112,         31    \ Face 3
 FACE      -12,      -47,        6,         31    \ Face 4
 FACE        0,      -32,        8,         31    \ Face 5
 FACE       12,      -47,        6,         31    \ Face 6

\ ******************************************************************************
\
\       Name: SHIP_MAMBA
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Mamba
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_MAMBA

 EQUB 1                 \ Max. canisters on demise = 1
 EQUW 70 * 70           \ Targetable area          = 70 * 70
 EQUB LO(SHIP_MAMBA_EDGES - SHIP_MAMBA)            \ Edges data offset (low)
 EQUB LO(SHIP_MAMBA_FACES - SHIP_MAMBA)            \ Faces data offset (low)
 EQUB 93                \ Max. edge count          = (93 - 1) / 4 = 23
 EQUB 0                 \ Gun vertex               = 0
 EQUB 34                \ Explosion count          = 7, as (4 * n) + 6 = 34
 EQUB 150               \ Number of vertices       = 150 / 6 = 25
 EQUB 28                \ Number of edges          = 28
 EQUW 150               \ Bounty                   = 150
 EQUB 20                \ Number of faces          = 20 / 4 = 5
 EQUB 25                \ Visibility distance      = 25
 EQUB 80                \ Max. energy              = 80
 EQUB 30                \ Max. speed               = 30
 EQUB HI(SHIP_MAMBA_EDGES - SHIP_MAMBA)            \ Edges data offset (high)
 EQUB HI(SHIP_MAMBA_FACES - SHIP_MAMBA)            \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00100010         \ Laser power              = 4
                        \ Missiles                 = 2

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   64,     0,      1,    2,     3,         31    \ Vertex 0
 VERTEX  -64,   -8,  -32,     0,      2,    4,     4,         31    \ Vertex 1
 VERTEX  -32,    8,  -32,     1,      2,    4,     4,         30    \ Vertex 2
 VERTEX   32,    8,  -32,     1,      3,    4,     4,         30    \ Vertex 3
 VERTEX   64,   -8,  -32,     0,      3,    4,     4,         31    \ Vertex 4
 VERTEX   -4,    4,   16,     1,      1,    1,     1,         14    \ Vertex 5
 VERTEX    4,    4,   16,     1,      1,    1,     1,         14    \ Vertex 6
 VERTEX    8,    3,   28,     1,      1,    1,     1,         13    \ Vertex 7
 VERTEX   -8,    3,   28,     1,      1,    1,     1,         13    \ Vertex 8
 VERTEX  -20,   -4,   16,     0,      0,    0,     0,         20    \ Vertex 9
 VERTEX   20,   -4,   16,     0,      0,    0,     0,         20    \ Vertex 10
 VERTEX  -24,   -7,  -20,     0,      0,    0,     0,         20    \ Vertex 11
 VERTEX  -16,   -7,  -20,     0,      0,    0,     0,         16    \ Vertex 12
 VERTEX   16,   -7,  -20,     0,      0,    0,     0,         16    \ Vertex 13
 VERTEX   24,   -7,  -20,     0,      0,    0,     0,         20    \ Vertex 14
 VERTEX   -8,    4,  -32,     4,      4,    4,     4,         13    \ Vertex 15
 VERTEX    8,    4,  -32,     4,      4,    4,     4,         13    \ Vertex 16
 VERTEX    8,   -4,  -32,     4,      4,    4,     4,         14    \ Vertex 17
 VERTEX   -8,   -4,  -32,     4,      4,    4,     4,         14    \ Vertex 18
 VERTEX  -32,    4,  -32,     4,      4,    4,     4,          7    \ Vertex 19
 VERTEX   32,    4,  -32,     4,      4,    4,     4,          7    \ Vertex 20
 VERTEX   36,   -4,  -32,     4,      4,    4,     4,          7    \ Vertex 21
 VERTEX  -36,   -4,  -32,     4,      4,    4,     4,          7    \ Vertex 22
 VERTEX  -38,    0,  -32,     4,      4,    4,     4,          5    \ Vertex 23
 VERTEX   38,    0,  -32,     4,      4,    4,     4,          5    \ Vertex 24

.SHIP_MAMBA_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     2,         31    \ Edge 0
 EDGE       0,       4,     0,     3,         31    \ Edge 1
 EDGE       1,       4,     0,     4,         31    \ Edge 2
 EDGE       1,       2,     2,     4,         30    \ Edge 3
 EDGE       2,       3,     1,     4,         30    \ Edge 4
 EDGE       3,       4,     3,     4,         30    \ Edge 5
 EDGE       5,       6,     1,     1,         14    \ Edge 6
 EDGE       6,       7,     1,     1,         12    \ Edge 7
 EDGE       7,       8,     1,     1,         13    \ Edge 8
 EDGE       5,       8,     1,     1,         12    \ Edge 9
 EDGE       9,      11,     0,     0,         20    \ Edge 10
 EDGE       9,      12,     0,     0,         16    \ Edge 11
 EDGE      10,      13,     0,     0,         16    \ Edge 12
 EDGE      10,      14,     0,     0,         20    \ Edge 13
 EDGE      13,      14,     0,     0,         14    \ Edge 14
 EDGE      11,      12,     0,     0,         14    \ Edge 15
 EDGE      15,      16,     4,     4,         13    \ Edge 16
 EDGE      17,      18,     4,     4,         14    \ Edge 17
 EDGE      15,      18,     4,     4,         12    \ Edge 18
 EDGE      16,      17,     4,     4,         12    \ Edge 19
 EDGE      20,      21,     4,     4,          7    \ Edge 20
 EDGE      20,      24,     4,     4,          5    \ Edge 21
 EDGE      21,      24,     4,     4,          5    \ Edge 22
 EDGE      19,      22,     4,     4,          7    \ Edge 23
 EDGE      19,      23,     4,     4,          5    \ Edge 24
 EDGE      22,      23,     4,     4,          5    \ Edge 25
 EDGE       0,       2,     1,     2,         30    \ Edge 26
 EDGE       0,       3,     1,     3,         30    \ Edge 27

.SHIP_MAMBA_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,      -24,        2,         30    \ Face 0
 FACE        0,       24,        2,         30    \ Face 1
 FACE      -32,       64,       16,         30    \ Face 2
 FACE       32,       64,       16,         30    \ Face 3
 FACE        0,        0,     -127,         30    \ Face 4

\ ******************************************************************************
\
\       Name: SHIP_KRAIT
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Krait
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_KRAIT

 EQUB 1                 \ Max. canisters on demise = 1
 EQUW 60 * 60           \ Targetable area          = 60 * 60
 EQUB LO(SHIP_KRAIT_EDGES - SHIP_KRAIT)            \ Edges data offset (low)
 EQUB LO(SHIP_KRAIT_FACES - SHIP_KRAIT)            \ Faces data offset (low)
 EQUB 85                \ Max. edge count          = (85 - 1) / 4 = 21
 EQUB 0                 \ Gun vertex               = 0
 EQUB 18                \ Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 102               \ Number of vertices       = 102 / 6 = 17
 EQUB 21                \ Number of edges          = 21
 EQUW 100               \ Bounty                   = 100
 EQUB 24                \ Number of faces          = 24 / 4 = 6
 EQUB 25                \ Visibility distance      = 25
 EQUB 73                \ Max. energy              = 73
 EQUB 30                \ Max. speed               = 30
 EQUB HI(SHIP_KRAIT_EDGES - SHIP_KRAIT)            \ Edges data offset (high)
 EQUB HI(SHIP_KRAIT_FACES - SHIP_KRAIT)            \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00100000         \ Laser power              = 4
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   96,     1,      0,    3,     2,         31    \ Vertex 0
 VERTEX    0,   18,  -48,     3,      0,    5,     4,         31    \ Vertex 1
 VERTEX    0,  -18,  -48,     2,      1,    5,     4,         31    \ Vertex 2
 VERTEX   90,    0,   -3,     1,      0,    4,     4,         31    \ Vertex 3
 VERTEX  -90,    0,   -3,     3,      2,    5,     5,         31    \ Vertex 4
 VERTEX   90,    0,   87,     1,      0,    1,     1,         30    \ Vertex 5
 VERTEX  -90,    0,   87,     3,      2,    3,     3,         30    \ Vertex 6
 VERTEX    0,    5,   53,     0,      0,    3,     3,          9    \ Vertex 7
 VERTEX    0,    7,   38,     0,      0,    3,     3,          6    \ Vertex 8
 VERTEX  -18,    7,   19,     3,      3,    3,     3,          9    \ Vertex 9
 VERTEX   18,    7,   19,     0,      0,    0,     0,          9    \ Vertex 10
 VERTEX   18,   11,  -39,     4,      4,    4,     4,          8    \ Vertex 11
 VERTEX   18,  -11,  -39,     4,      4,    4,     4,          8    \ Vertex 12
 VERTEX   36,    0,  -30,     4,      4,    4,     4,          8    \ Vertex 13
 VERTEX  -18,   11,  -39,     5,      5,    5,     5,          8    \ Vertex 14
 VERTEX  -18,  -11,  -39,     5,      5,    5,     5,          8    \ Vertex 15
 VERTEX  -36,    0,  -30,     5,      5,    5,     5,          8    \ Vertex 16

.SHIP_KRAIT_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     0,         31    \ Edge 0
 EDGE       0,       2,     2,     1,         31    \ Edge 1
 EDGE       0,       3,     1,     0,         31    \ Edge 2
 EDGE       0,       4,     3,     2,         31    \ Edge 3
 EDGE       1,       4,     5,     3,         31    \ Edge 4
 EDGE       4,       2,     5,     2,         31    \ Edge 5
 EDGE       2,       3,     4,     1,         31    \ Edge 6
 EDGE       3,       1,     4,     0,         31    \ Edge 7
 EDGE       3,       5,     1,     0,         30    \ Edge 8
 EDGE       4,       6,     3,     2,         30    \ Edge 9
 EDGE       1,       2,     5,     4,          8    \ Edge 10
 EDGE       7,      10,     0,     0,          9    \ Edge 11
 EDGE       8,      10,     0,     0,          6    \ Edge 12
 EDGE       7,       9,     3,     3,          9    \ Edge 13
 EDGE       8,       9,     3,     3,          6    \ Edge 14
 EDGE      11,      13,     4,     4,          8    \ Edge 15
 EDGE      13,      12,     4,     4,          8    \ Edge 16
 EDGE      12,      11,     4,     4,          7    \ Edge 17
 EDGE      14,      15,     5,     5,          7    \ Edge 18
 EDGE      15,      16,     5,     5,          8    \ Edge 19
 EDGE      16,      14,     5,     5,          8    \ Edge 20

.SHIP_KRAIT_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        3,       24,        3,         31    \ Face 0
 FACE        3,      -24,        3,         31    \ Face 1
 FACE       -3,      -24,        3,         31    \ Face 2
 FACE       -3,       24,        3,         31    \ Face 3
 FACE       38,        0,      -77,         31    \ Face 4
 FACE      -38,        0,      -77,         31    \ Face 5

\ ******************************************************************************
\
\       Name: SHIP_ADDER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for an Adder
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_ADDER

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 50 * 50           \ Targetable area          = 50 * 50
 EQUB LO(SHIP_ADDER_EDGES - SHIP_ADDER)            \ Edges data offset (low)
 EQUB LO(SHIP_ADDER_FACES - SHIP_ADDER)            \ Faces data offset (low)
 EQUB 97                \ Max. edge count          = (97 - 1) / 4 = 24
 EQUB 0                 \ Gun vertex               = 0
 EQUB 22                \ Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 108               \ Number of vertices       = 108 / 6 = 18
 EQUB 29                \ Number of edges          = 29
 EQUW 40                \ Bounty                   = 40
 EQUB 60                \ Number of faces          = 60 / 4 = 15
 EQUB 23                \ Visibility distance      = 23
 EQUB 72                \ Max. energy              = 72
 EQUB 24                \ Max. speed               = 24
 EQUB HI(SHIP_ADDER_EDGES - SHIP_ADDER)            \ Edges data offset (high)
 EQUB HI(SHIP_ADDER_FACES - SHIP_ADDER)            \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00100001         \ Laser power              = 4
                        \ Missiles                 = 1

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,    0,   40,     1,      0,   12,    11,         31    \ Vertex 0
 VERTEX   18,    0,   40,     1,      0,    3,     2,         31    \ Vertex 1
 VERTEX   30,    0,  -24,     3,      2,    5,     4,         31    \ Vertex 2
 VERTEX   30,    0,  -40,     5,      4,    6,     6,         31    \ Vertex 3
 VERTEX   18,   -7,  -40,     6,      5,   14,     7,         31    \ Vertex 4
 VERTEX  -18,   -7,  -40,     8,      7,   14,    10,         31    \ Vertex 5
 VERTEX  -30,    0,  -40,     9,      8,   10,    10,         31    \ Vertex 6
 VERTEX  -30,    0,  -24,    10,      9,   12,    11,         31    \ Vertex 7
 VERTEX  -18,    7,  -40,     8,      7,   13,     9,         31    \ Vertex 8
 VERTEX   18,    7,  -40,     6,      4,   13,     7,         31    \ Vertex 9
 VERTEX  -18,    7,   13,     9,      0,   13,    11,         31    \ Vertex 10
 VERTEX   18,    7,   13,     2,      0,   13,     4,         31    \ Vertex 11
 VERTEX  -18,   -7,   13,    10,      1,   14,    12,         31    \ Vertex 12
 VERTEX   18,   -7,   13,     3,      1,   14,     5,         31    \ Vertex 13
 VERTEX  -11,    3,   29,     0,      0,    0,     0,          5    \ Vertex 14
 VERTEX   11,    3,   29,     0,      0,    0,     0,          5    \ Vertex 15
 VERTEX   11,    4,   24,     0,      0,    0,     0,          4    \ Vertex 16
 VERTEX  -11,    4,   24,     0,      0,    0,     0,          4    \ Vertex 17

.SHIP_ADDER_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         31    \ Edge 0
 EDGE       1,       2,     3,     2,          7    \ Edge 1
 EDGE       2,       3,     5,     4,         31    \ Edge 2
 EDGE       3,       4,     6,     5,         31    \ Edge 3
 EDGE       4,       5,    14,     7,         31    \ Edge 4
 EDGE       5,       6,    10,     8,         31    \ Edge 5
 EDGE       6,       7,    10,     9,         31    \ Edge 6
 EDGE       7,       0,    12,    11,          7    \ Edge 7
 EDGE       3,       9,     6,     4,         31    \ Edge 8
 EDGE       9,       8,    13,     7,         31    \ Edge 9
 EDGE       8,       6,     9,     8,         31    \ Edge 10
 EDGE       0,      10,    11,     0,         31    \ Edge 11
 EDGE       7,      10,    11,     9,         31    \ Edge 12
 EDGE       1,      11,     2,     0,         31    \ Edge 13
 EDGE       2,      11,     4,     2,         31    \ Edge 14
 EDGE       0,      12,    12,     1,         31    \ Edge 15
 EDGE       7,      12,    12,    10,         31    \ Edge 16
 EDGE       1,      13,     3,     1,         31    \ Edge 17
 EDGE       2,      13,     5,     3,         31    \ Edge 18
 EDGE      10,      11,    13,     0,         31    \ Edge 19
 EDGE      12,      13,    14,     1,         31    \ Edge 20
 EDGE       8,      10,    13,     9,         31    \ Edge 21
 EDGE       9,      11,    13,     4,         31    \ Edge 22
 EDGE       5,      12,    14,    10,         31    \ Edge 23
 EDGE       4,      13,    14,     5,         31    \ Edge 24
 EDGE      14,      15,     0,     0,          5    \ Edge 25
 EDGE      15,      16,     0,     0,          3    \ Edge 26
 EDGE      16,      17,     0,     0,          4    \ Edge 27
 EDGE      17,      14,     0,     0,          3    \ Edge 28

.SHIP_ADDER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       39,       10,         31    \ Face 0
 FACE        0,      -39,       10,         31    \ Face 1
 FACE       69,       50,       13,         31    \ Face 2
 FACE       69,      -50,       13,         31    \ Face 3
 FACE       30,       52,        0,         31    \ Face 4
 FACE       30,      -52,        0,         31    \ Face 5
 FACE        0,        0,     -160,         31    \ Face 6
 FACE        0,        0,     -160,         31    \ Face 7
 FACE        0,        0,     -160,         31    \ Face 8
 FACE      -30,       52,        0,         31    \ Face 9
 FACE      -30,      -52,        0,         31    \ Face 10
 FACE      -69,       50,       13,         31    \ Face 11
 FACE      -69,      -50,       13,         31    \ Face 12
 FACE        0,       28,        0,         31    \ Face 13
 FACE        0,      -28,        0,         31    \ Face 14

\ ******************************************************************************
\
\       Name: SHIP_GECKO
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Gecko
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_GECKO

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 99 * 99           \ Targetable area          = 99 * 99
 EQUB LO(SHIP_GECKO_EDGES - SHIP_GECKO)            \ Edges data offset (low)
 EQUB LO(SHIP_GECKO_FACES - SHIP_GECKO)            \ Faces data offset (low)
 EQUB 65                \ Max. edge count          = (65 - 1) / 4 = 16
 EQUB 0                 \ Gun vertex               = 0
 EQUB 26                \ Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 72                \ Number of vertices       = 72 / 6 = 12
 EQUB 17                \ Number of edges          = 17
 EQUW 55                \ Bounty                   = 55
 EQUB 36                \ Number of faces          = 36 / 4 = 9
 EQUB 18                \ Visibility distance      = 18
 EQUB 65                \ Max. energy              = 65
 EQUB 30                \ Max. speed               = 30
 EQUB HI(SHIP_GECKO_EDGES - SHIP_GECKO)            \ Edges data offset (high)
 EQUB HI(SHIP_GECKO_FACES - SHIP_GECKO)            \ Faces data offset (high)
 EQUB 3                 \ Normals are scaled by    = 2^3 = 8
 EQUB %00100000         \ Laser power              = 4
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -10,   -4,   47,     3,      0,    5,     4,         31    \ Vertex 0
 VERTEX   10,   -4,   47,     1,      0,    3,     2,         31    \ Vertex 1
 VERTEX  -16,    8,  -23,     5,      0,    7,     6,         31    \ Vertex 2
 VERTEX   16,    8,  -23,     1,      0,    8,     7,         31    \ Vertex 3
 VERTEX  -66,    0,   -3,     5,      4,    6,     6,         31    \ Vertex 4
 VERTEX   66,    0,   -3,     2,      1,    8,     8,         31    \ Vertex 5
 VERTEX  -20,  -14,  -23,     4,      3,    7,     6,         31    \ Vertex 6
 VERTEX   20,  -14,  -23,     3,      2,    8,     7,         31    \ Vertex 7
 VERTEX   -8,   -6,   33,     3,      3,    3,     3,         16    \ Vertex 8
 VERTEX    8,   -6,   33,     3,      3,    3,     3,         17    \ Vertex 9
 VERTEX   -8,  -13,  -16,     3,      3,    3,     3,         16    \ Vertex 10
 VERTEX    8,  -13,  -16,     3,      3,    3,     3,         17    \ Vertex 11

.SHIP_GECKO_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     0,         31    \ Edge 0
 EDGE       1,       5,     2,     1,         31    \ Edge 1
 EDGE       5,       3,     8,     1,         31    \ Edge 2
 EDGE       3,       2,     7,     0,         31    \ Edge 3
 EDGE       2,       4,     6,     5,         31    \ Edge 4
 EDGE       4,       0,     5,     4,         31    \ Edge 5
 EDGE       5,       7,     8,     2,         31    \ Edge 6
 EDGE       7,       6,     7,     3,         31    \ Edge 7
 EDGE       6,       4,     6,     4,         31    \ Edge 8
 EDGE       0,       2,     5,     0,         29    \ Edge 9
 EDGE       1,       3,     1,     0,         30    \ Edge 10
 EDGE       0,       6,     4,     3,         29    \ Edge 11
 EDGE       1,       7,     3,     2,         30    \ Edge 12
 EDGE       2,       6,     7,     6,         20    \ Edge 13
 EDGE       3,       7,     8,     7,         20    \ Edge 14
 EDGE       8,      10,     3,     3,         16    \ Edge 15
 EDGE       9,      11,     3,     3,         17    \ Edge 16

.SHIP_GECKO_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       31,        5,         31    \ Face 0
 FACE        4,       45,        8,         31    \ Face 1
 FACE       25,     -108,       19,         31    \ Face 2
 FACE        0,      -84,       12,         31    \ Face 3
 FACE      -25,     -108,       19,         31    \ Face 4
 FACE       -4,       45,        8,         31    \ Face 5
 FACE      -88,       16,     -214,         31    \ Face 6
 FACE        0,        0,     -187,         31    \ Face 7
 FACE       88,       16,     -214,         31    \ Face 8

\ ******************************************************************************
\
\       Name: SHIP_COBRA_MK_1
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Cobra Mk I
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_COBRA_MK_1

 EQUB 3                 \ Max. canisters on demise = 3
 EQUW 99 * 99           \ Targetable area          = 99 * 99
 EQUB LO(SHIP_COBRA_MK_1_EDGES - SHIP_COBRA_MK_1)  \ Edges data offset (low)
 EQUB LO(SHIP_COBRA_MK_1_FACES - SHIP_COBRA_MK_1)  \ Faces data offset (low)
 EQUB 69                \ Max. edge count          = (69 - 1) / 4 = 17
 EQUB 40                \ Gun vertex               = 40 / 4 = 10
 EQUB 26                \ Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 66                \ Number of vertices       = 66 / 6 = 11
 EQUB 18                \ Number of edges          = 18
 EQUW 75                \ Bounty                   = 75
 EQUB 40                \ Number of faces          = 40 / 4 = 10
 EQUB 19                \ Visibility distance      = 19
 EQUB 81                \ Max. energy              = 81
 EQUB 26                \ Max. speed               = 26
 EQUB HI(SHIP_COBRA_MK_1_EDGES - SHIP_COBRA_MK_1)  \ Edges data offset (high)
 EQUB HI(SHIP_COBRA_MK_1_FACES - SHIP_COBRA_MK_1)  \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00100010         \ Laser power              = 4
                        \ Missiles                 = 2

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,   -1,   50,     1,      0,    3,     2,         31    \ Vertex 0
 VERTEX   18,   -1,   50,     1,      0,    5,     4,         31    \ Vertex 1
 VERTEX  -66,    0,    7,     3,      2,    8,     8,         31    \ Vertex 2
 VERTEX   66,    0,    7,     5,      4,    9,     9,         31    \ Vertex 3
 VERTEX  -32,   12,  -38,     6,      2,    8,     7,         31    \ Vertex 4
 VERTEX   32,   12,  -38,     6,      4,    9,     7,         31    \ Vertex 5
 VERTEX  -54,  -12,  -38,     3,      1,    8,     7,         31    \ Vertex 6
 VERTEX   54,  -12,  -38,     5,      1,    9,     7,         31    \ Vertex 7
 VERTEX    0,   12,   -6,     2,      0,    6,     4,         20    \ Vertex 8
 VERTEX    0,   -1,   50,     1,      0,    1,     1,          2    \ Vertex 9
 VERTEX    0,   -1,   60,     1,      0,    1,     1,         31    \ Vertex 10

.SHIP_COBRA_MK_1_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       1,       0,     1,     0,         31    \ Edge 0
 EDGE       0,       2,     3,     2,         31    \ Edge 1
 EDGE       2,       6,     8,     3,         31    \ Edge 2
 EDGE       6,       7,     7,     1,         31    \ Edge 3
 EDGE       7,       3,     9,     5,         31    \ Edge 4
 EDGE       3,       1,     5,     4,         31    \ Edge 5
 EDGE       2,       4,     8,     2,         31    \ Edge 6
 EDGE       4,       5,     7,     6,         31    \ Edge 7
 EDGE       5,       3,     9,     4,         31    \ Edge 8
 EDGE       0,       8,     2,     0,         20    \ Edge 9
 EDGE       8,       1,     4,     0,         20    \ Edge 10
 EDGE       4,       8,     6,     2,         16    \ Edge 11
 EDGE       8,       5,     6,     4,         16    \ Edge 12
 EDGE       4,       6,     8,     7,         31    \ Edge 13
 EDGE       5,       7,     9,     7,         31    \ Edge 14
 EDGE       0,       6,     3,     1,         20    \ Edge 15
 EDGE       1,       7,     5,     1,         20    \ Edge 16
 EDGE      10,       9,     1,     0,          2    \ Edge 17

.SHIP_COBRA_MK_1_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       41,       10,         31    \ Face 0
 FACE        0,      -27,        3,         31    \ Face 1
 FACE       -8,       46,        8,         31    \ Face 2
 FACE      -12,      -57,       12,         31    \ Face 3
 FACE        8,       46,        8,         31    \ Face 4
 FACE       12,      -57,       12,         31    \ Face 5
 FACE        0,       49,        0,         31    \ Face 6
 FACE        0,        0,     -154,         31    \ Face 7
 FACE     -121,      111,      -62,         31    \ Face 8
 FACE      121,      111,      -62,         31    \ Face 9

\ ******************************************************************************
\
\       Name: SHIP_ASP_MK_2
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for an Asp Mk II
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_ASP_MK_2

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 60 * 60           \ Targetable area          = 60 * 60
 EQUB LO(SHIP_ASP_MK_2_EDGES - SHIP_ASP_MK_2)      \ Edges data offset (low)
 EQUB LO(SHIP_ASP_MK_2_FACES - SHIP_ASP_MK_2)      \ Faces data offset (low)
 EQUB 101               \ Max. edge count          = (101 - 1) / 4 = 25
 EQUB 32                \ Gun vertex               = 32 / 4 = 8
 EQUB 26                \ Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 114               \ Number of vertices       = 114 / 6 = 19
 EQUB 28                \ Number of edges          = 28
 EQUW 450               \ Bounty                   = 450
 EQUB 48                \ Number of faces          = 48 / 4 = 12
 EQUB 40                \ Visibility distance      = 40
 EQUB 109               \ Max. energy              = 109
 EQUB 40                \ Max. speed               = 40
 EQUB HI(SHIP_ASP_MK_2_EDGES - SHIP_ASP_MK_2)      \ Edges data offset (high)
 EQUB HI(SHIP_ASP_MK_2_FACES - SHIP_ASP_MK_2)      \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %01001001         \ Laser power              = 9
                        \ Missiles                 = 1

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -18,    0,     1,      0,    2,     2,         22    \ Vertex 0
 VERTEX    0,   -9,  -45,     2,      1,   11,    11,         31    \ Vertex 1
 VERTEX   43,    0,  -45,     6,      1,   11,    11,         31    \ Vertex 2
 VERTEX   69,   -3,    0,     6,      1,    9,     7,         31    \ Vertex 3
 VERTEX   43,  -14,   28,     1,      0,    7,     7,         31    \ Vertex 4
 VERTEX  -43,    0,  -45,     5,      2,   11,    11,         31    \ Vertex 5
 VERTEX  -69,   -3,    0,     5,      2,   10,     8,         31    \ Vertex 6
 VERTEX  -43,  -14,   28,     2,      0,    8,     8,         31    \ Vertex 7
 VERTEX   26,   -7,   73,     4,      0,    9,     7,         31    \ Vertex 8
 VERTEX  -26,   -7,   73,     4,      0,   10,     8,         31    \ Vertex 9
 VERTEX   43,   14,   28,     4,      3,    9,     6,         31    \ Vertex 10
 VERTEX  -43,   14,   28,     4,      3,   10,     5,         31    \ Vertex 11
 VERTEX    0,    9,  -45,     5,      3,   11,     6,         31    \ Vertex 12
 VERTEX  -17,    0,  -45,    11,     11,   11,    11,         10    \ Vertex 13
 VERTEX   17,    0,  -45,    11,     11,   11,    11,          9    \ Vertex 14
 VERTEX    0,   -4,  -45,    11,     11,   11,    11,         10    \ Vertex 15
 VERTEX    0,    4,  -45,    11,     11,   11,    11,          8    \ Vertex 16
 VERTEX    0,   -7,   73,     4,      0,    4,     0,         10    \ Vertex 17
 VERTEX    0,   -7,   83,     4,      0,    4,     0,         10    \ Vertex 18

.SHIP_ASP_MK_2_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     1,         22    \ Edge 0
 EDGE       0,       4,     1,     0,         22    \ Edge 1
 EDGE       0,       7,     2,     0,         22    \ Edge 2
 EDGE       1,       2,    11,     1,         31    \ Edge 3
 EDGE       2,       3,     6,     1,         31    \ Edge 4
 EDGE       3,       8,     9,     7,         16    \ Edge 5
 EDGE       8,       9,     4,     0,         31    \ Edge 6
 EDGE       6,       9,    10,     8,         16    \ Edge 7
 EDGE       5,       6,     5,     2,         31    \ Edge 8
 EDGE       1,       5,    11,     2,         31    \ Edge 9
 EDGE       3,       4,     7,     1,         31    \ Edge 10
 EDGE       4,       8,     7,     0,         31    \ Edge 11
 EDGE       6,       7,     8,     2,         31    \ Edge 12
 EDGE       7,       9,     8,     0,         31    \ Edge 13
 EDGE       2,      12,    11,     6,         31    \ Edge 14
 EDGE       5,      12,    11,     5,         31    \ Edge 15
 EDGE      10,      12,     6,     3,         22    \ Edge 16
 EDGE      11,      12,     5,     3,         22    \ Edge 17
 EDGE      10,      11,     4,     3,         22    \ Edge 18
 EDGE       6,      11,    10,     5,         31    \ Edge 19
 EDGE       9,      11,    10,     4,         31    \ Edge 20
 EDGE       3,      10,     9,     6,         31    \ Edge 21
 EDGE       8,      10,     9,     4,         31    \ Edge 22
 EDGE      13,      15,    11,    11,         10    \ Edge 23
 EDGE      15,      14,    11,    11,          9    \ Edge 24
 EDGE      14,      16,    11,    11,          8    \ Edge 25
 EDGE      16,      13,    11,    11,          8    \ Edge 26
 EDGE      18,      17,     4,     0,         10    \ Edge 27

.SHIP_ASP_MK_2_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,      -35,        5,         31    \ Face 0
 FACE        8,      -38,       -7,         31    \ Face 1
 FACE       -8,      -38,       -7,         31    \ Face 2
 FACE        0,       24,       -1,         22    \ Face 3
 FACE        0,       43,       19,         31    \ Face 4
 FACE       -6,       28,       -2,         31    \ Face 5
 FACE        6,       28,       -2,         31    \ Face 6
 FACE       59,      -64,       31,         31    \ Face 7
 FACE      -59,      -64,       31,         31    \ Face 8
 FACE       80,       46,       50,         31    \ Face 9
 FACE      -80,       46,       50,         31    \ Face 10
 FACE        0,        0,      -90,         31    \ Face 11

\ ******************************************************************************
\
\       Name: SHIP_FER_DE_LANCE
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Fer-de-Lance
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_FER_DE_LANCE

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 40 * 40           \ Targetable area          = 40 * 40
 EQUB LO(SHIP_FER_DE_LANCE_EDGES - SHIP_FER_DE_LANCE) \ Edges data offset (low)
 EQUB LO(SHIP_FER_DE_LANCE_FACES - SHIP_FER_DE_LANCE) \ Faces data offset (low)
 EQUB 105               \ Max. edge count          = (105 - 1) / 4 = 26
 EQUB 0                 \ Gun vertex               = 0
 EQUB 26                \ Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 114               \ Number of vertices       = 114 / 6 = 19
 EQUB 27                \ Number of edges          = 27
 EQUW 250               \ Bounty                   = 250
 EQUB 40                \ Number of faces          = 40 / 4 = 10
 EQUB 40                \ Visibility distance      = 40
 EQUB 83                \ Max. energy              = 83
 EQUB 30                \ Max. speed               = 30
 EQUB HI(SHIP_FER_DE_LANCE_EDGES - SHIP_FER_DE_LANCE) \ Edges data offset (high)
 EQUB HI(SHIP_FER_DE_LANCE_FACES - SHIP_FER_DE_LANCE) \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00110010         \ Laser power              = 6
                        \ Missiles                 = 2

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -14,  108,     1,      0,    9,     5,         31    \ Vertex 0
 VERTEX  -40,  -14,   -4,     2,      1,    9,     9,         31    \ Vertex 1
 VERTEX  -12,  -14,  -52,     3,      2,    9,     9,         31    \ Vertex 2
 VERTEX   12,  -14,  -52,     4,      3,    9,     9,         31    \ Vertex 3
 VERTEX   40,  -14,   -4,     5,      4,    9,     9,         31    \ Vertex 4
 VERTEX  -40,   14,   -4,     1,      0,    6,     2,         28    \ Vertex 5
 VERTEX  -12,    2,  -52,     3,      2,    7,     6,         28    \ Vertex 6
 VERTEX   12,    2,  -52,     4,      3,    8,     7,         28    \ Vertex 7
 VERTEX   40,   14,   -4,     4,      0,    8,     5,         28    \ Vertex 8
 VERTEX    0,   18,  -20,     6,      0,    8,     7,         15    \ Vertex 9
 VERTEX   -3,  -11,   97,     0,      0,    0,     0,         11    \ Vertex 10
 VERTEX  -26,    8,   18,     0,      0,    0,     0,          9    \ Vertex 11
 VERTEX  -16,   14,   -4,     0,      0,    0,     0,         11    \ Vertex 12
 VERTEX    3,  -11,   97,     0,      0,    0,     0,         11    \ Vertex 13
 VERTEX   26,    8,   18,     0,      0,    0,     0,          9    \ Vertex 14
 VERTEX   16,   14,   -4,     0,      0,    0,     0,         11    \ Vertex 15
 VERTEX    0,  -14,  -20,     9,      9,    9,     9,         12    \ Vertex 16
 VERTEX  -14,  -14,   44,     9,      9,    9,     9,         12    \ Vertex 17
 VERTEX   14,  -14,   44,     9,      9,    9,     9,         12    \ Vertex 18

.SHIP_FER_DE_LANCE_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     9,     1,         31    \ Edge 0
 EDGE       1,       2,     9,     2,         31    \ Edge 1
 EDGE       2,       3,     9,     3,         31    \ Edge 2
 EDGE       3,       4,     9,     4,         31    \ Edge 3
 EDGE       0,       4,     9,     5,         31    \ Edge 4
 EDGE       0,       5,     1,     0,         28    \ Edge 5
 EDGE       5,       6,     6,     2,         28    \ Edge 6
 EDGE       6,       7,     7,     3,         28    \ Edge 7
 EDGE       7,       8,     8,     4,         28    \ Edge 8
 EDGE       0,       8,     5,     0,         28    \ Edge 9
 EDGE       5,       9,     6,     0,         15    \ Edge 10
 EDGE       6,       9,     7,     6,         11    \ Edge 11
 EDGE       7,       9,     8,     7,         11    \ Edge 12
 EDGE       8,       9,     8,     0,         15    \ Edge 13
 EDGE       1,       5,     2,     1,         14    \ Edge 14
 EDGE       2,       6,     3,     2,         14    \ Edge 15
 EDGE       3,       7,     4,     3,         14    \ Edge 16
 EDGE       4,       8,     5,     4,         14    \ Edge 17
 EDGE      10,      11,     0,     0,          8    \ Edge 18
 EDGE      11,      12,     0,     0,          9    \ Edge 19
 EDGE      10,      12,     0,     0,         11    \ Edge 20
 EDGE      13,      14,     0,     0,          8    \ Edge 21
 EDGE      14,      15,     0,     0,          9    \ Edge 22
 EDGE      13,      15,     0,     0,         11    \ Edge 23
 EDGE      16,      17,     9,     9,         12    \ Edge 24
 EDGE      16,      18,     9,     9,         12    \ Edge 25
 EDGE      17,      18,     9,     9,          8    \ Edge 26

.SHIP_FER_DE_LANCE_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       24,        6,         28    \ Face 0
 FACE      -68,        0,       24,         31    \ Face 1
 FACE      -63,        0,      -37,         31    \ Face 2
 FACE        0,        0,     -104,         31    \ Face 3
 FACE       63,        0,      -37,         31    \ Face 4
 FACE       68,        0,       24,         31    \ Face 5
 FACE      -12,       46,      -19,         28    \ Face 6
 FACE        0,       45,      -22,         28    \ Face 7
 FACE       12,       46,      -19,         28    \ Face 8
 FACE        0,      -28,        0,         31    \ Face 9

\ ******************************************************************************
\
\       Name: SHIP_MORAY
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Moray
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_MORAY

 EQUB 1                 \ Max. canisters on demise = 1
 EQUW 30 * 30           \ Targetable area          = 30 * 30
 EQUB LO(SHIP_MORAY_EDGES - SHIP_MORAY)            \ Edges data offset (low)
 EQUB LO(SHIP_MORAY_FACES - SHIP_MORAY)            \ Faces data offset (low)
 EQUB 69                \ Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 \ Gun vertex               = 0
 EQUB 26                \ Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 84                \ Number of vertices       = 84 / 6 = 14
 EQUB 19                \ Number of edges          = 19
 EQUW 50                \ Bounty                   = 50
 EQUB 36                \ Number of faces          = 36 / 4 = 9
 EQUB 40                \ Visibility distance      = 40
 EQUB 89                \ Max. energy              = 89
 EQUB 25                \ Max. speed               = 25
 EQUB HI(SHIP_MORAY_EDGES - SHIP_MORAY)            \ Edges data offset (high)
 EQUB HI(SHIP_MORAY_FACES - SHIP_MORAY)            \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00101010         \ Laser power              = 5
                        \ Missiles                 = 2

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   15,    0,   65,     2,      0,    8,     7,         31    \ Vertex 0
 VERTEX  -15,    0,   65,     1,      0,    7,     6,         31    \ Vertex 1
 VERTEX    0,   18,  -40,    15,     15,   15,    15,         17    \ Vertex 2
 VERTEX  -60,    0,    0,     3,      1,    6,     6,         31    \ Vertex 3
 VERTEX   60,    0,    0,     5,      2,    8,     8,         31    \ Vertex 4
 VERTEX   30,  -27,  -10,     5,      4,    8,     7,         24    \ Vertex 5
 VERTEX  -30,  -27,  -10,     4,      3,    7,     6,         24    \ Vertex 6
 VERTEX   -9,   -4,  -25,     4,      4,    4,     4,          7    \ Vertex 7
 VERTEX    9,   -4,  -25,     4,      4,    4,     4,          7    \ Vertex 8
 VERTEX    0,  -18,  -16,     4,      4,    4,     4,          7    \ Vertex 9
 VERTEX   13,    3,   49,     0,      0,    0,     0,          5    \ Vertex 10
 VERTEX    6,    0,   65,     0,      0,    0,     0,          5    \ Vertex 11
 VERTEX  -13,    3,   49,     0,      0,    0,     0,          5    \ Vertex 12
 VERTEX   -6,    0,   65,     0,      0,    0,     0,          5    \ Vertex 13

.SHIP_MORAY_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    \ Edge 0
 EDGE       1,       3,     6,     1,         31    \ Edge 1
 EDGE       3,       6,     6,     3,         24    \ Edge 2
 EDGE       5,       6,     7,     4,         24    \ Edge 3
 EDGE       4,       5,     8,     5,         24    \ Edge 4
 EDGE       0,       4,     8,     2,         31    \ Edge 5
 EDGE       1,       6,     7,     6,         15    \ Edge 6
 EDGE       0,       5,     8,     7,         15    \ Edge 7
 EDGE       0,       2,     2,     0,         15    \ Edge 8
 EDGE       1,       2,     1,     0,         15    \ Edge 9
 EDGE       2,       3,     3,     1,         17    \ Edge 10
 EDGE       2,       4,     5,     2,         17    \ Edge 11
 EDGE       2,       5,     5,     4,         13    \ Edge 12
 EDGE       2,       6,     4,     3,         13    \ Edge 13
 EDGE       7,       8,     4,     4,          5    \ Edge 14
 EDGE       7,       9,     4,     4,          7    \ Edge 15
 EDGE       8,       9,     4,     4,          7    \ Edge 16
 EDGE      10,      11,     0,     0,          5    \ Edge 17
 EDGE      12,      13,     0,     0,          5    \ Edge 18

.SHIP_MORAY_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       43,        7,         31    \ Face 0
 FACE      -10,       49,        7,         31    \ Face 1
 FACE       10,       49,        7,         31    \ Face 2
 FACE      -59,      -28,     -101,         24    \ Face 3
 FACE        0,      -52,      -78,         24    \ Face 4
 FACE       59,      -28,     -101,         24    \ Face 5
 FACE      -72,      -99,       50,         31    \ Face 6
 FACE        0,      -83,       30,         31    \ Face 7
 FACE       72,      -99,       50,         31    \ Face 8

\ ******************************************************************************
\
\       Name: SHIP_CONSTRICTOR
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Constrictor
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_CONSTRICTOR

 EQUB 3 + (15 << 4)     \ Max. canisters on demise = 3
                        \ Market item when scooped = 15 + 1 = 16 (alien items)
 EQUW 99 * 99           \ Targetable area          = 99 * 99
 EQUB LO(SHIP_CONSTRICTOR_EDGES - SHIP_CONSTRICTOR)   \ Edges data offset (low)
 EQUB LO(SHIP_CONSTRICTOR_FACES - SHIP_CONSTRICTOR)   \ Faces data offset (low)
 EQUB 77                \ Max. edge count          = (77 - 1) / 4 = 19
 EQUB 0                 \ Gun vertex               = 0
 EQUB 46                \ Explosion count          = 10, as (4 * n) + 6 = 46
 EQUB 102               \ Number of vertices       = 102 / 6 = 17
 EQUB 24                \ Number of edges          = 24
 EQUW 0                 \ Bounty                   = 0
 EQUB 40                \ Number of faces          = 40 / 4 = 10
 EQUB 45                \ Visibility distance      = 45
 EQUB 115               \ Max. energy              = 115
 EQUB 55                \ Max. speed               = 55
 EQUB HI(SHIP_CONSTRICTOR_EDGES - SHIP_CONSTRICTOR)   \ Edges data offset (high)
 EQUB HI(SHIP_CONSTRICTOR_FACES - SHIP_CONSTRICTOR)   \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %01000111         \ Laser power              = 8
                        \ Missiles                 = 7

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   20,   -7,   80,     2,      0,    9,     9,         31    \ Vertex 0
 VERTEX  -20,   -7,   80,     1,      0,    9,     9,         31    \ Vertex 1
 VERTEX  -54,   -7,   40,     4,      1,    9,     9,         31    \ Vertex 2
 VERTEX  -54,   -7,  -40,     5,      4,    9,     8,         31    \ Vertex 3
 VERTEX  -20,   13,  -40,     6,      5,    8,     8,         31    \ Vertex 4
 VERTEX   20,   13,  -40,     7,      6,    8,     8,         31    \ Vertex 5
 VERTEX   54,   -7,  -40,     7,      3,    9,     8,         31    \ Vertex 6
 VERTEX   54,   -7,   40,     3,      2,    9,     9,         31    \ Vertex 7
 VERTEX   20,   13,    5,    15,     15,   15,    15,         31    \ Vertex 8
 VERTEX  -20,   13,    5,    15,     15,   15,    15,         31    \ Vertex 9
 VERTEX   20,   -7,   62,     9,      9,    9,     9,         18    \ Vertex 10
 VERTEX  -20,   -7,   62,     9,      9,    9,     9,         18    \ Vertex 11
 VERTEX   25,   -7,  -25,     9,      9,    9,     9,         18    \ Vertex 12
 VERTEX  -25,   -7,  -25,     9,      9,    9,     9,         18    \ Vertex 13
 VERTEX   15,   -7,  -15,     9,      9,    9,     9,         10    \ Vertex 14
 VERTEX  -15,   -7,  -15,     9,      9,    9,     9,         10    \ Vertex 15
 VERTEX    0,   -7,    0,    15,      9,    1,     0,          0    \ Vertex 16

.SHIP_CONSTRICTOR_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     9,     0,         31    \ Edge 0
 EDGE       1,       2,     9,     1,         31    \ Edge 1
 EDGE       1,       9,     1,     0,         31    \ Edge 2
 EDGE       0,       8,     2,     0,         31    \ Edge 3
 EDGE       0,       7,     9,     2,         31    \ Edge 4
 EDGE       7,       8,     3,     2,         31    \ Edge 5
 EDGE       2,       9,     4,     1,         31    \ Edge 6
 EDGE       2,       3,     9,     4,         31    \ Edge 7
 EDGE       6,       7,     9,     3,         31    \ Edge 8
 EDGE       6,       8,     7,     3,         31    \ Edge 9
 EDGE       5,       8,     7,     6,         31    \ Edge 10
 EDGE       4,       9,     6,     5,         31    \ Edge 11
 EDGE       3,       9,     5,     4,         31    \ Edge 12
 EDGE       3,       4,     8,     5,         31    \ Edge 13
 EDGE       4,       5,     8,     6,         31    \ Edge 14
 EDGE       5,       6,     8,     7,         31    \ Edge 15
 EDGE       3,       6,     9,     8,         31    \ Edge 16
 EDGE       8,       9,     6,     0,         31    \ Edge 17
 EDGE      10,      12,     9,     9,         18    \ Edge 18
 EDGE      12,      14,     9,     9,          5    \ Edge 19
 EDGE      14,      10,     9,     9,         10    \ Edge 20
 EDGE      11,      15,     9,     9,         10    \ Edge 21
 EDGE      13,      15,     9,     9,          5    \ Edge 22
 EDGE      11,      13,     9,     9,         18    \ Edge 23

.SHIP_CONSTRICTOR_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       55,       15,         31    \ Face 0
 FACE      -24,       75,       20,         31    \ Face 1
 FACE       24,       75,       20,         31    \ Face 2
 FACE       44,       75,        0,         31    \ Face 3
 FACE      -44,       75,        0,         31    \ Face 4
 FACE      -44,       75,        0,         31    \ Face 5
 FACE        0,       53,        0,         31    \ Face 6
 FACE       44,       75,        0,         31    \ Face 7
 FACE        0,        0,     -160,         31    \ Face 8
 FACE        0,      -27,        0,         31    \ Face 9

\ ******************************************************************************
\
\       Name: SHIP_DRAGON
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Dragon
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_DRAGON

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 26192             \ Targetable area          = 161.83 * 161.83
 EQUB LO(SHIP_DRAGON_EDGES - SHIP_DRAGON)          \ Edges data offset (low)
 EQUB LO(SHIP_DRAGON_FACES - SHIP_DRAGON)          \ Faces data offset (low)
 EQUB 65                \ Max. edge count          = (65 - 1) / 4 = 16
 EQUB 0                 \ Gun vertex               = 0
 EQUB 60                \ Explosion count          = 13, as (4 * n) + 6 = 60
 EQUB 54                \ Number of vertices       = 54 / 6 = 9
 EQUB 21                \ Number of edges          = 21
 EQUW 0                 \ Bounty                   = 0
 EQUB 56                \ Number of faces          = 56 / 4 = 14
 EQUB 32                \ Visibility distance      = 32
 EQUB 247               \ Max. energy              = 247
 EQUB 20                \ Max. speed               = 20
 EQUB HI(SHIP_DRAGON_EDGES - SHIP_DRAGON)          \ Edges data offset (high)
 EQUB HI(SHIP_DRAGON_FACES - SHIP_DRAGON)          \ Faces data offset (high)
 EQUB 0                 \ Normals are scaled by    = 2^0 = 1
 EQUB %01000111         \ Laser power              = 8
                        \ Missiles                 = 7

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,  250,    11,     6,     5,     0,         31     \ Vertex 0
 VERTEX  216,    0,  124,     7,     6,     1,     0,         31     \ Vertex 1
 VERTEX  216,    0, -124,     8,     7,     2,     1,         31     \ Vertex 2
 VERTEX    0,   40, -250,    13,    12,     3,     2,         31     \ Vertex 3
 VERTEX    0,  -40, -250,    13,    12,     9,     8,         31     \ Vertex 4
 VERTEX -216,    0, -124,    10,     9,     4,     3,         31     \ Vertex 5
 VERTEX -216,    0,  124,    11,    10,     5,     4,         31     \ Vertex 6
 VERTEX    0,   80,    0,    15,    15,    15,    15,         31     \ Vertex 7
 VERTEX    0,  -80,    0,    15,    15,    15,    15,         31     \ Vertex 8

.SHIP_DRAGON_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       1,       7,     1,     0,         31    \ Edge 0
 EDGE       2,       7,     2,     1,         31    \ Edge 1
 EDGE       3,       7,     3,     2,         31    \ Edge 2
 EDGE       5,       7,     4,     3,         31    \ Edge 3
 EDGE       6,       7,     5,     4,         31    \ Edge 4
 EDGE       0,       7,     0,     5,         31    \ Edge 5
 EDGE       1,       8,     7,     6,         31    \ Edge 6
 EDGE       2,       8,     8,     7,         31    \ Edge 7
 EDGE       4,       8,     9,     8,         31    \ Edge 8
 EDGE       5,       8,    10,     9,         31    \ Edge 9
 EDGE       6,       8,    11,    10,         31    \ Edge 10
 EDGE       0,       8,     6,    11,         31    \ Edge 11
 EDGE       0,       1,     6,     0,         31    \ Edge 12
 EDGE       1,       2,     7,     1,         31    \ Edge 13
 EDGE       5,       6,    10,     4,         31    \ Edge 14
 EDGE       0,       6,    11,     5,         31    \ Edge 15
 EDGE       2,       3,    12,     2,         31    \ Edge 16
 EDGE       2,       4,    12,     8,         31    \ Edge 17
 EDGE       3,       5,    13,     3,         31    \ Edge 18
 EDGE       4,       5,    13,     9,         31    \ Edge 19
 EDGE       3,       4,    13,    12,         31    \ Edge 20

.SHIP_DRAGON_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE       16,       90,       28,         31    \ Face 0
 FACE       33,       90,        0,         31    \ Face 1
 FACE       25,       91,      -14,         31    \ Face 2
 FACE      -25,       91,      -14,         31    \ Face 3
 FACE      -33,       90,        0,         31    \ Face 4
 FACE      -16,       90,       28,         31    \ Face 5
 FACE       16,      -90,       28,         31    \ Face 6
 FACE       33,      -90,        0,         31    \ Face 7
 FACE       25,      -91,      -14,         31    \ Face 8
 FACE      -25,      -91,      -14,         31    \ Face 9
 FACE      -33,      -90,        0,         31    \ Face 10
 FACE      -16,      -90,       28,         31    \ Face 11
 FACE       48,        0,      -82,         31    \ Face 12
 FACE      -48,        0,      -82,         31    \ Face 13

\ ******************************************************************************
\
\       Name: SHIP_MONITOR
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Monitor
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_MONITOR

 EQUB 4                 \ Max. canisters on demise = 4
 EQUW 13824             \ Targetable area          = 117.57 * 117.57
 EQUB LO(SHIP_MONITOR_EDGES - SHIP_MONITOR)        \ Edges data offset (low)
 EQUB LO(SHIP_MONITOR_FACES - SHIP_MONITOR)        \ Faces data offset (low)
 EQUB 101               \ Max. edge count          = (101 - 1) / 4 = 25
 EQUB 0                 \ Gun vertex               = 0
 EQUB 42                \ Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 102               \ Number of vertices       = 102 / 6 = 17
 EQUB 23                \ Number of edges          = 23
 EQUW 400               \ Bounty                   = 400
 EQUB 44                \ Number of faces          = 44 / 4 = 11
 EQUB 40                \ Visibility distance      = 40
 EQUB 132               \ Max. energy              = 132
 EQUB 16                \ Max. speed               = 16
 EQUB HI(SHIP_MONITOR_EDGES - SHIP_MONITOR)        \ Edges data offset (high)
 EQUB HI(SHIP_MONITOR_FACES - SHIP_MONITOR)        \ Faces data offset (high)
 EQUB 0                 \ Normals are scaled by    = 2^0 = 1
 EQUB %00110111         \ Laser power              = 6
                        \ Missiles                 = 7

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   10,  140,    15,    15,    15,    15,         31     \ Vertex 0
 VERTEX   20,   40,  -20,     3,     2,     1,     0,         31     \ Vertex 1
 VERTEX  -20,   40,  -20,     0,     5,     4,     3,         31     \ Vertex 2
 VERTEX   50,    0,   10,     8,     7,     2,     1,         31     \ Vertex 3
 VERTEX  -50,    0,   10,     6,     9,     5,     4,         31     \ Vertex 4
 VERTEX   30,    4,  -60,    10,    10,     8,     2,         31     \ Vertex 5
 VERTEX  -30,    4,  -60,    10,    10,     9,     4,         31     \ Vertex 6
 VERTEX   18,   20,  -60,    10,    10,     3,     2,         31     \ Vertex 7
 VERTEX  -18,   20,  -60,    10,    10,     4,     3,         31     \ Vertex 8
 VERTEX    0,  -20,  -60,    10,    10,     9,     8,         31     \ Vertex 9
 VERTEX    0,  -40,   10,     9,     8,     7,     6,         31     \ Vertex 10
 VERTEX    0,   34,   10,     0,     0,     0,     0,         10     \ Vertex 11
 VERTEX    0,   26,   50,     0,     0,     0,     0,         10     \ Vertex 12
 VERTEX   20,  -10,   60,     7,     7,     7,     7,         10     \ Vertex 13
 VERTEX   10,    0,  100,     7,     7,     7,     7,         10     \ Vertex 14
 VERTEX  -20,  -10,   60,     6,     6,     6,     6,         10     \ Vertex 15
 VERTEX  -10,    0,  100,     6,     6,     6,     6,         10     \ Vertex 16

.SHIP_MONITOR_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         31    \ Edge 0
 EDGE       1,       3,     2,     1,         31    \ Edge 1
 EDGE       1,       7,     3,     2,         31    \ Edge 2
 EDGE       2,       8,     4,     3,         31    \ Edge 3
 EDGE       2,       4,     5,     4,         31    \ Edge 4
 EDGE       0,       2,     0,     5,         31    \ Edge 5
 EDGE       1,       2,     3,     0,         31    \ Edge 6
 EDGE       0,      10,     7,     6,         31    \ Edge 7
 EDGE       3,      10,     8,     7,         31    \ Edge 8
 EDGE       9,      10,     9,     8,         31    \ Edge 9
 EDGE       4,      10,     6,     9,         31    \ Edge 10
 EDGE       0,       3,     7,     1,         31    \ Edge 11
 EDGE       3,       5,     8,     2,         31    \ Edge 12
 EDGE       6,       4,     9,     4,         31    \ Edge 13
 EDGE       4,       0,     6,     5,         31    \ Edge 14
 EDGE       7,       5,    10,     2,         31    \ Edge 15
 EDGE       8,       7,    10,     3,         31    \ Edge 16
 EDGE       8,       6,    10,     4,         31    \ Edge 17
 EDGE       5,       9,    10,     8,         31    \ Edge 18
 EDGE       6,       9,    10,     9,         31    \ Edge 19
 EDGE      11,      12,     0,     0,         10    \ Edge 20
 EDGE      13,      14,     7,     7,         10    \ Edge 21
 EDGE      15,      16,     6,     6,         10    \ Edge 22

.SHIP_MONITOR_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       62,       11,         31    \ Face 0
 FACE       44,       43,       13,         31    \ Face 1
 FACE       54,       28,      -16,         31    \ Face 2
 FACE        0,       57,      -28,         31    \ Face 3
 FACE      -54,       28,      -16,         31    \ Face 4
 FACE      -44,       43,       13,         31    \ Face 5
 FACE      -38,      -47,       18,         31    \ Face 6
 FACE       38,      -47,       18,         31    \ Face 7
 FACE       39,      -48,      -13,         31    \ Face 8
 FACE      -39,      -48,      -13,         31    \ Face 9
 FACE        0,        0,      -64,         31    \ Face 10

\ ******************************************************************************
\
\       Name: SHIP_OPHIDIAN
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for an Ophidian
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_OPHIDIAN

 EQUB 2                 \ Max. canisters on demise = 2
 EQUW 3720              \ Targetable area          = 60.99 * 60.99
 EQUB LO(SHIP_OPHIDIAN_EDGES - SHIP_OPHIDIAN)      \ Edges data offset (low)
 EQUB LO(SHIP_OPHIDIAN_FACES - SHIP_OPHIDIAN)      \ Faces data offset (low)
 EQUB 113               \ Max. edge count          = (113 - 1) / 4 = 28
 EQUB 0                 \ Gun vertex               = 0
 EQUB 60                \ Explosion count          = 13, as (4 * n) + 6 = 60
 EQUB 120               \ Number of vertices       = 120 / 6 = 20
 EQUB 30                \ Number of edges          = 30
 EQUW 50                \ Bounty                   = 50
 EQUB 48                \ Number of faces          = 48 / 4 = 12
 EQUB 20                \ Visibility distance      = 20
 EQUB 64                \ Max. energy              = 64
 EQUB 34                \ Max. speed               = 34
 EQUB HI(SHIP_OPHIDIAN_EDGES - SHIP_OPHIDIAN)      \ Edges data offset (high)
 EQUB HI(SHIP_OPHIDIAN_FACES - SHIP_OPHIDIAN)      \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00011010         \ Laser power              = 3
                        \ Missiles                 = 2

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -20,    0,   70,     8,     6,     2,     0,         31     \ Vertex 0
 VERTEX   20,    0,   70,     7,     6,     1,     0,         31     \ Vertex 1
 VERTEX    0,   10,   40,     2,     2,     1,     0,         31     \ Vertex 2
 VERTEX  -30,    0,   30,    10,     8,     4,     2,         31     \ Vertex 3
 VERTEX   30,    0,   30,     9,     7,     3,     1,         31     \ Vertex 4
 VERTEX    0,   16,   10,    15,    15,    15,    15,         31     \ Vertex 5
 VERTEX   20,   10,  -50,    11,     9,     5,     3,         31     \ Vertex 6
 VERTEX  -20,   10,  -50,    11,    10,     5,     4,         31     \ Vertex 7
 VERTEX  -30,    0,  -50,    11,    11,    10,     4,         31     \ Vertex 8
 VERTEX  -40,    0,  -50,    15,    15,    15,    15,         16     \ Vertex 9
 VERTEX  -30,    0,  -30,    15,    15,    15,    15,         16     \ Vertex 10
 VERTEX   30,    0,  -50,    11,    11,     9,     3,         31     \ Vertex 11
 VERTEX   40,    0,  -50,    15,    15,    15,    15,         16     \ Vertex 12
 VERTEX   30,    0,  -30,    15,    15,    15,    15,         16     \ Vertex 13
 VERTEX    0,  -10,  -50,    11,    11,    10,     9,         31     \ Vertex 14
 VERTEX    0,  -16,   20,    15,    15,    15,    15,         31     \ Vertex 15
 VERTEX   10,    4,  -50,    11,    11,    11,    11,         16     \ Vertex 16
 VERTEX   10,   -2,  -50,    11,    11,    11,    11,         16     \ Vertex 17
 VERTEX  -10,   -2,  -50,    11,    11,    11,    11,         16     \ Vertex 18
 VERTEX  -10,    4,  -50,    11,    11,    11,    11,         16     \ Vertex 19

.SHIP_OPHIDIAN_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     6,     0,         31    \ Edge 0
 EDGE       1,       2,     1,     0,         31    \ Edge 1
 EDGE       0,       2,     2,     0,         31    \ Edge 2
 EDGE       2,       5,     2,     1,         31    \ Edge 3
 EDGE       4,       5,     3,     1,         31    \ Edge 4
 EDGE       3,       5,     4,     2,         31    \ Edge 5
 EDGE       5,       6,     5,     3,         31    \ Edge 6
 EDGE       5,       7,     5,     4,         31    \ Edge 7
 EDGE       0,       3,     8,     2,         31    \ Edge 8
 EDGE       1,       4,     7,     1,         31    \ Edge 9
 EDGE       4,      11,     9,     3,         31    \ Edge 10
 EDGE       3,       8,    10,     4,         31    \ Edge 11
 EDGE       1,      15,     7,     6,         31    \ Edge 12
 EDGE       0,      15,     8,     6,         31    \ Edge 13
 EDGE       4,      15,     9,     7,         31    \ Edge 14
 EDGE       3,      15,    10,     8,         31    \ Edge 15
 EDGE      14,      15,    10,     9,         31    \ Edge 16
 EDGE       6,       7,    11,     5,         31    \ Edge 17
 EDGE       6,      11,    11,     3,         31    \ Edge 18
 EDGE       7,       8,    11,     4,         31    \ Edge 19
 EDGE      11,      14,    11,     9,         31    \ Edge 20
 EDGE       8,      14,    11,    10,         31    \ Edge 21
 EDGE      16,      17,    11,    11,         16    \ Edge 22
 EDGE      17,      18,    11,    11,         16    \ Edge 23
 EDGE      18,      19,    11,    11,         16    \ Edge 24
 EDGE      19,      16,    11,    11,         16    \ Edge 25
 EDGE      12,      13,     9,     3,         16    \ Edge 26
 EDGE      11,      12,     9,     3,         16    \ Edge 27
 EDGE      10,       9,    10,     4,         16    \ Edge 28
 EDGE       9,       8,    10,     4,         16    \ Edge 29

.SHIP_OPHIDIAN_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       37,       12,         31    \ Face 0
 FACE       11,       28,        5,         31    \ Face 1
 FACE      -11,       28,        5,         31    \ Face 2
 FACE       16,       34,        2,         31    \ Face 3
 FACE      -16,       34,        2,         31    \ Face 4
 FACE        0,       37,       -3,         31    \ Face 5
 FACE        0,      -31,       10,         31    \ Face 6
 FACE       10,      -20,        2,         31    \ Face 7
 FACE      -10,      -20,        2,         31    \ Face 8
 FACE       18,      -32,       -2,         31    \ Face 9
 FACE      -18,      -32,       -2,         31    \ Face 10
 FACE        0,        0,      -37,         31    \ Face 11

\ ******************************************************************************
\
\       Name: SHIP_GHAVIAL
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Ghavial
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_GHAVIAL

 EQUB 3                 \ Max. canisters on demise = 3
 EQUW 9728              \ Targetable area          = 98.63 * 98.63
 EQUB LO(SHIP_GHAVIAL_EDGES - SHIP_GHAVIAL)        \ Edges data offset (low)
 EQUB LO(SHIP_GHAVIAL_FACES - SHIP_GHAVIAL)        \ Faces data offset (low)
 EQUB 97                \ Max. edge count          = (97 - 1) / 4 = 24
 EQUB 0                 \ Gun vertex               = 0
 EQUB 34                \ Explosion count          = 7, as (4 * n) + 6 = 34
 EQUB 72                \ Number of vertices       = 72 / 6 = 12
 EQUB 22                \ Number of edges          = 22
 EQUW 100               \ Bounty                   = 100
 EQUB 48                \ Number of faces          = 48 / 4 = 12
 EQUB 10                \ Visibility distance      = 10
 EQUB 114               \ Max. energy              = 114
 EQUB 16                \ Max. speed               = 16
 EQUB HI(SHIP_GHAVIAL_EDGES - SHIP_GHAVIAL)        \ Edges data offset (high)
 EQUB HI(SHIP_GHAVIAL_FACES - SHIP_GHAVIAL)        \ Faces data offset (high)
 EQUB 0                 \ Normals are scaled by    = 2^0 = 1
 EQUB %00100111         \ Laser power              = 4
                        \ Missiles                 = 7

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   30,    0,  100,     7,     6,     1,     0,         31     \ Vertex 0
 VERTEX  -30,    0,  100,    11,     6,     5,     0,         31     \ Vertex 1
 VERTEX   40,   30,  -26,     3,     2,     1,     0,         31     \ Vertex 2
 VERTEX  -40,   30,  -26,     5,     4,     3,     0,         31     \ Vertex 3
 VERTEX   60,    0,  -20,     8,     7,     2,     1,         31     \ Vertex 4
 VERTEX   40,    0,  -60,     9,     8,     3,     2,         31     \ Vertex 5
 VERTEX  -60,    0,  -20,    11,    10,     5,     4,         31     \ Vertex 6
 VERTEX  -40,    0,  -60,    10,     9,     4,     3,         31     \ Vertex 7
 VERTEX    0,  -30,  -20,    15,    15,    15,    15,         31     \ Vertex 8
 VERTEX   10,   24,    0,     0,     0,     0,     0,          9     \ Vertex 9
 VERTEX  -10,   24,    0,     0,     0,     0,     0,          9     \ Vertex 10
 VERTEX    0,   22,   10,     0,     0,     0,     0,          9     \ Vertex 11

.SHIP_GHAVIAL_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       2,     1,     0,         31    \ Edge 0
 EDGE       4,       2,     2,     1,         31    \ Edge 1
 EDGE       5,       2,     3,     2,         31    \ Edge 2
 EDGE       3,       2,     0,     3,         31    \ Edge 3
 EDGE       7,       3,     4,     3,         31    \ Edge 4
 EDGE       6,       3,     5,     4,         31    \ Edge 5
 EDGE       3,       1,     0,     5,         31    \ Edge 6
 EDGE       0,       8,     7,     6,         31    \ Edge 7
 EDGE       4,       8,     8,     7,         31    \ Edge 8
 EDGE       5,       8,     9,     8,         31    \ Edge 9
 EDGE       7,       8,    10,     9,         31    \ Edge 10
 EDGE       6,       8,    11,    10,         31    \ Edge 11
 EDGE       1,       8,     6,    11,         31    \ Edge 12
 EDGE       1,       0,     6,     0,         31    \ Edge 13
 EDGE       0,       4,     7,     1,         31    \ Edge 14
 EDGE       4,       5,     8,     2,         31    \ Edge 15
 EDGE       5,       7,     9,     3,         31    \ Edge 16
 EDGE       7,       6,    10,     4,         31    \ Edge 17
 EDGE       6,       1,    11,     5,         31    \ Edge 18
 EDGE       9,      10,     0,     0,          9    \ Edge 19
 EDGE      10,      11,     0,     0,          9    \ Edge 20
 EDGE      11,       9,     0,     0,          9    \ Edge 21

.SHIP_GHAVIAL_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       62,       14,         31    \ Face 0
 FACE       51,       36,       12,         31    \ Face 1
 FACE       51,       28,      -25,         31    \ Face 2
 FACE        0,       48,      -42,         31    \ Face 3
 FACE      -51,       28,      -25,         31    \ Face 4
 FACE      -51,       36,       12,         31    \ Face 5
 FACE        0,      -62,       15,         31    \ Face 6
 FACE       28,      -56,        7,         31    \ Face 7
 FACE       27,      -55,      -13,         31    \ Face 8
 FACE        0,      -51,      -38,         31    \ Face 9
 FACE      -27,      -55,      -13,         31    \ Face 10
 FACE      -28,      -56,        7,         31    \ Face 11

\ ******************************************************************************
\
\       Name: SHIP_BUSHMASTER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Bushmaster
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_BUSHMASTER

 EQUB 0                 \ Max. canisters on demise = 0
 EQUW 4250              \ Targetable area          = 65.19 * 65.19
 EQUB LO(SHIP_BUSHMASTER_EDGES - SHIP_BUSHMASTER)  \ Edges data offset (low)
 EQUB LO(SHIP_BUSHMASTER_FACES - SHIP_BUSHMASTER)  \ Faces data offset (low)
 EQUB 81                \ Max. edge count          = (81 - 1) / 4 = 20
 EQUB 0                 \ Gun vertex               = 0
 EQUB 30                \ Explosion count          = 6, as (4 * n) + 6 = 30
 EQUB 72                \ Number of vertices       = 72 / 6 = 12
 EQUB 19                \ Number of edges          = 19
 EQUW 150               \ Bounty                   = 150
 EQUB 36                \ Number of faces          = 36 / 4 = 9
 EQUB 20                \ Visibility distance      = 20
 EQUB 74                \ Max. energy              = 74
 EQUB 35                \ Max. speed               = 35
 EQUB HI(SHIP_BUSHMASTER_EDGES - SHIP_BUSHMASTER)  \ Edges data offset (high)
 EQUB HI(SHIP_BUSHMASTER_FACES - SHIP_BUSHMASTER)  \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00100001         \ Laser power              = 4
                        \ Missiles                 = 1

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   60,     3,     2,     1,     0,         31     \ Vertex 0
 VERTEX   50,    0,   20,     7,     5,     3,     1,         31     \ Vertex 1
 VERTEX  -50,    0,   20,     6,     4,     2,     0,         31     \ Vertex 2
 VERTEX    0,   20,    0,     5,     4,     1,     0,         31     \ Vertex 3
 VERTEX    0,  -20,  -40,    15,    15,    15,    15,         31     \ Vertex 4
 VERTEX    0,   14,  -40,     8,     8,     5,     4,         31     \ Vertex 5
 VERTEX   40,    0,  -40,     8,     8,     7,     5,         31     \ Vertex 6
 VERTEX  -40,    0,  -40,     8,     8,     6,     4,         31     \ Vertex 7
 VERTEX    0,    4,  -40,     8,     8,     8,     8,         10     \ Vertex 8
 VERTEX   10,    0,  -40,     8,     8,     8,     8,         10     \ Vertex 9
 VERTEX    0,   -4,  -40,     8,     8,     8,     8,         10     \ Vertex 10
 VERTEX  -10,    0,  -40,     8,     8,     8,     8,         10     \ Vertex 11

.SHIP_BUSHMASTER_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     1,         31    \ Edge 0
 EDGE       0,       2,     2,     0,         31    \ Edge 1
 EDGE       0,       3,     1,     0,         31    \ Edge 2
 EDGE       0,       4,     3,     2,         31    \ Edge 3
 EDGE       3,       5,     5,     4,         31    \ Edge 4
 EDGE       2,       3,     4,     0,         31    \ Edge 5
 EDGE       1,       3,     5,     1,         31    \ Edge 6
 EDGE       2,       7,     6,     4,         31    \ Edge 7
 EDGE       1,       6,     7,     5,         31    \ Edge 8
 EDGE       2,       4,     6,     2,         31    \ Edge 9
 EDGE       1,       4,     7,     3,         31    \ Edge 10
 EDGE       5,       7,     8,     4,         31    \ Edge 11
 EDGE       5,       6,     8,     5,         31    \ Edge 12
 EDGE       4,       7,     8,     6,         31    \ Edge 13
 EDGE       4,       6,     8,     7,         31    \ Edge 14
 EDGE       8,       9,     8,     8,         10    \ Edge 15
 EDGE       9,      10,     8,     8,         10    \ Edge 16
 EDGE      10,      11,     8,     8,         10    \ Edge 17
 EDGE      11,       8,     8,     8,         10    \ Edge 18

.SHIP_BUSHMASTER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      -23,       88,       29,         31    \ Face 0
 FACE       23,       88,       29,         31    \ Face 1
 FACE      -14,      -93,       18,         31    \ Face 2
 FACE       14,      -93,       18,         31    \ Face 3
 FACE      -31,       89,      -13,         31    \ Face 4
 FACE       31,       89,      -13,         31    \ Face 5
 FACE      -42,      -85,       -7,         31    \ Face 6
 FACE       42,      -85,       -7,         31    \ Face 7
 FACE        0,        0,      -96,         31    \ Face 8

\ ******************************************************************************
\
\       Name: SHIP_RATTLER
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Rattler
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_RATTLER

 EQUB 2                 \ Max. canisters on demise = 2
 EQUW 6000              \ Targetable area          = 77.46 * 77.46
 EQUB LO(SHIP_RATTLER_EDGES - SHIP_RATTLER)        \ Edges data offset (low)
 EQUB LO(SHIP_RATTLER_FACES - SHIP_RATTLER)        \ Faces data offset (low)
 EQUB 89                \ Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 \ Gun vertex               = 0
 EQUB 42                \ Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 90                \ Number of vertices       = 90 / 6 = 15
 EQUB 26                \ Number of edges          = 26
 EQUW 150               \ Bounty                   = 150
 EQUB 52                \ Number of faces          = 52 / 4 = 13
 EQUB 10                \ Visibility distance      = 10
 EQUB 113               \ Max. energy              = 113
 EQUB 31                \ Max. speed               = 31
 EQUB HI(SHIP_RATTLER_EDGES - SHIP_RATTLER)        \ Edges data offset (high)
 EQUB HI(SHIP_RATTLER_FACES - SHIP_RATTLER)        \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00100010         \ Laser power              = 4
                        \ Missiles                 = 2

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   60,     9,     8,     3,     2,         31     \ Vertex 0
 VERTEX   40,    0,   40,    10,     9,     4,     3,         31     \ Vertex 1
 VERTEX  -40,    0,   40,     8,     7,     2,     1,         31     \ Vertex 2
 VERTEX   60,    0,    0,    11,    10,     5,     4,         31     \ Vertex 3
 VERTEX  -60,    0,    0,     7,     6,     1,     0,         31     \ Vertex 4
 VERTEX   70,    0,  -40,    12,    12,    11,     5,         31     \ Vertex 5
 VERTEX  -70,    0,  -40,    12,    12,     6,     0,         31     \ Vertex 6
 VERTEX    0,   20,  -40,    15,    15,    15,    15,         31     \ Vertex 7
 VERTEX    0,  -20,  -40,    15,    15,    15,    15,         31     \ Vertex 8
 VERTEX  -10,    6,  -40,    12,    12,    12,    12,         10     \ Vertex 9
 VERTEX  -10,   -6,  -40,    12,    12,    12,    12,         10     \ Vertex 10
 VERTEX  -20,    0,  -40,    12,    12,    12,    12,         10     \ Vertex 11
 VERTEX   10,    6,  -40,    12,    12,    12,    12,         10     \ Vertex 12
 VERTEX   10,   -6,  -40,    12,    12,    12,    12,         10     \ Vertex 13
 VERTEX   20,    0,  -40,    12,    12,    12,    12,         10     \ Vertex 14

.SHIP_RATTLER_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       4,       6,     6,     0,         31    \ Edge 0
 EDGE       2,       4,     7,     1,         31    \ Edge 1
 EDGE       0,       2,     8,     2,         31    \ Edge 2
 EDGE       0,       1,     9,     3,         31    \ Edge 3
 EDGE       1,       3,    10,     4,         31    \ Edge 4
 EDGE       3,       5,    11,     5,         31    \ Edge 5
 EDGE       6,       7,    12,     0,         31    \ Edge 6
 EDGE       6,       8,    12,     6,         31    \ Edge 7
 EDGE       4,       7,     1,     0,         31    \ Edge 8
 EDGE       4,       8,     7,     6,         31    \ Edge 9
 EDGE       2,       7,     2,     1,         31    \ Edge 10
 EDGE       2,       8,     8,     7,         31    \ Edge 11
 EDGE       0,       7,     3,     2,         31    \ Edge 12
 EDGE       0,       8,     9,     8,         31    \ Edge 13
 EDGE       1,       7,     4,     3,         31    \ Edge 14
 EDGE       1,       8,    10,     9,         31    \ Edge 15
 EDGE       3,       7,     5,     4,         31    \ Edge 16
 EDGE       3,       8,    11,    10,         31    \ Edge 17
 EDGE       5,       7,    12,     5,         31    \ Edge 18
 EDGE       5,       8,    12,    11,         31    \ Edge 19
 EDGE       9,      10,    12,    12,         10    \ Edge 20
 EDGE      10,      11,    12,    12,         10    \ Edge 21
 EDGE      11,       9,    12,    12,         10    \ Edge 22
 EDGE      12,      13,    12,    12,         10    \ Edge 23
 EDGE      13,      14,    12,    12,         10    \ Edge 24
 EDGE      14,      12,    12,    12,         10    \ Edge 25

.SHIP_RATTLER_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      -26,       92,        6,         31    \ Face 0
 FACE      -23,       92,       11,         31    \ Face 1
 FACE       -9,       93,       18,         31    \ Face 2
 FACE        9,       93,       18,         31    \ Face 3
 FACE       23,       92,       11,         31    \ Face 4
 FACE       26,       92,        6,         31    \ Face 5
 FACE      -26,      -92,        6,         31    \ Face 6
 FACE      -23,      -92,       11,         31    \ Face 7
 FACE       -9,      -93,       18,         31    \ Face 8
 FACE        9,      -93,       18,         31    \ Face 9
 FACE       23,      -92,       11,         31    \ Face 10
 FACE       26,      -92,        6,         31    \ Face 11
 FACE        0,        0,      -96,         31    \ Face 12

\ ******************************************************************************
\
\       Name: SHIP_IGUANA
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for an Iguana
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_IGUANA

 EQUB 1                 \ Max. canisters on demise = 1
 EQUW 3500              \ Targetable area          = 59.16 * 59.16
 EQUB LO(SHIP_IGUANA_EDGES - SHIP_IGUANA)          \ Edges data offset (low)
 EQUB LO(SHIP_IGUANA_FACES - SHIP_IGUANA)          \ Faces data offset (low)
 EQUB 81                \ Max. edge count          = (81 - 1) / 4 = 20
 EQUB 0                 \ Gun vertex               = 0
 EQUB 26                \ Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 90                \ Number of vertices       = 90 / 6 = 15
 EQUB 23                \ Number of edges          = 23
 EQUW 150               \ Bounty                   = 150
 EQUB 40                \ Number of faces          = 40 / 4 = 10
 EQUB 10                \ Visibility distance      = 10
 EQUB 90                \ Max. energy              = 90
 EQUB 33                \ Max. speed               = 33
 EQUB HI(SHIP_IGUANA_EDGES - SHIP_IGUANA)          \ Edges data offset (high)
 EQUB HI(SHIP_IGUANA_FACES - SHIP_IGUANA)          \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00100011         \ Laser power              = 4
                        \ Missiles                 = 3

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   90,     3,     2,     1,     0,         31     \ Vertex 0
 VERTEX    0,   20,   30,     6,     4,     2,     0,         31     \ Vertex 1
 VERTEX  -40,    0,   10,     5,     4,     1,     0,         31     \ Vertex 2
 VERTEX    0,  -20,   30,     7,     5,     3,     1,         31     \ Vertex 3
 VERTEX   40,    0,   10,     7,     6,     3,     2,         31     \ Vertex 4
 VERTEX    0,   20,  -40,     9,     8,     6,     4,         31     \ Vertex 5
 VERTEX  -40,    0,  -30,     8,     8,     5,     4,         31     \ Vertex 6
 VERTEX    0,  -20,  -40,     9,     8,     7,     5,         31     \ Vertex 7
 VERTEX   40,    0,  -30,     9,     9,     7,     6,         31     \ Vertex 8
 VERTEX  -40,    0,   40,     1,     1,     0,     0,         30     \ Vertex 9
 VERTEX   40,    0,   40,     3,     3,     2,     2,         30     \ Vertex 10
 VERTEX    0,    8,  -40,     9,     9,     8,     8,         10     \ Vertex 11
 VERTEX  -16,    0,  -36,     8,     8,     8,     8,         10     \ Vertex 12
 VERTEX    0,   -8,  -40,     9,     9,     8,     8,         10     \ Vertex 13
 VERTEX   16,    0,  -36,     9,     9,     9,     9,         10     \ Vertex 14

.SHIP_IGUANA_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     0,         31    \ Edge 0
 EDGE       0,       2,     1,     0,         31    \ Edge 1
 EDGE       0,       3,     3,     1,         31    \ Edge 2
 EDGE       0,       4,     3,     2,         31    \ Edge 3
 EDGE       1,       5,     6,     4,         31    \ Edge 4
 EDGE       2,       6,     5,     4,         31    \ Edge 5
 EDGE       3,       7,     7,     5,         31    \ Edge 6
 EDGE       4,       8,     7,     6,         31    \ Edge 7
 EDGE       5,       6,     8,     4,         31    \ Edge 8
 EDGE       6,       7,     8,     5,         31    \ Edge 9
 EDGE       5,       8,     9,     6,         31    \ Edge 10
 EDGE       7,       8,     9,     7,         31    \ Edge 11
 EDGE       1,       2,     4,     0,         31    \ Edge 12
 EDGE       2,       3,     5,     1,         31    \ Edge 13
 EDGE       1,       4,     6,     2,         31    \ Edge 14
 EDGE       3,       4,     7,     3,         31    \ Edge 15
 EDGE       5,       7,     9,     8,         31    \ Edge 16
 EDGE       2,       9,     1,     0,         30    \ Edge 17
 EDGE       4,      10,     3,     2,         30    \ Edge 18
 EDGE      11,      12,     8,     8,         10    \ Edge 19
 EDGE      13,      12,     8,     8,         10    \ Edge 20
 EDGE      11,      14,     9,     9,         10    \ Edge 21
 EDGE      13,      14,     9,     9,         10    \ Edge 22

.SHIP_IGUANA_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      -51,       77,       25,         31    \ Face 0
 FACE      -51,      -77,       25,         31    \ Face 1
 FACE       51,       77,       25,         31    \ Face 2
 FACE       51,      -77,       25,         31    \ Face 3
 FACE      -42,       85,        0,         31    \ Face 4
 FACE      -42,      -85,        0,         31    \ Face 5
 FACE       42,       85,        0,         31    \ Face 6
 FACE       42,      -85,        0,         31    \ Face 7
 FACE      -23,        0,      -93,         31    \ Face 8
 FACE       23,        0,      -93,         31    \ Face 9

\ ******************************************************************************
\
\       Name: SHIP_SHUTTLE_MK_2
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Shuttle Mk II
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_SHUTTLE_MK_2

 EQUB 15                \ Max. canisters on demise = 15
 EQUW 50 * 50           \ Targetable area          = 50 * 50
 EQUB LO(SHIP_SHUTTLE_MK_2_EDGES - SHIP_SHUTTLE_MK_2) \ Edges data offset (low)
 EQUB LO(SHIP_SHUTTLE_MK_2_FACES - SHIP_SHUTTLE_MK_2) \ Faces data offset (low)
 EQUB 89                \ Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 \ Gun vertex               = 0
 EQUB 38                \ Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 102               \ Number of vertices       = 102 / 6 = 17
 EQUB 28                \ Number of edges          = 28
 EQUW 0                 \ Bounty                   = 0
 EQUB 52                \ Number of faces          = 52 / 4 = 13
 EQUB 10                \ Visibility distance      = 10
 EQUB 32                \ Max. energy              = 32
 EQUB 9                 \ Max. speed               = 9
 EQUB HI(SHIP_SHUTTLE_MK_2_EDGES - SHIP_SHUTTLE_MK_2) \ Edges data offset (high)
 EQUB HI(SHIP_SHUTTLE_MK_2_FACES - SHIP_SHUTTLE_MK_2) \ Faces data offset (high)
 EQUB 2                 \ Normals are scaled by    = 2^2 = 4
 EQUB %00000000         \ Laser power              = 0
                        \ Missiles                 = 0

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   40,     3,     2,     1,     0,         31     \ Vertex 0
 VERTEX    0,   20,   30,     4,     3,     0,     0,         31     \ Vertex 1
 VERTEX  -20,    0,   30,     5,     1,     0,     0,         31     \ Vertex 2
 VERTEX    0,  -20,   30,     6,     2,     1,     1,         31     \ Vertex 3
 VERTEX   20,    0,   30,     7,     3,     2,     2,         31     \ Vertex 4
 VERTEX  -20,   20,   20,     8,     5,     4,     0,         31     \ Vertex 5
 VERTEX  -20,  -20,   20,     9,     6,     5,     1,         31     \ Vertex 6
 VERTEX   20,  -20,   20,    10,     7,     6,     2,         31     \ Vertex 7
 VERTEX   20,   20,   20,    11,     7,     4,     3,         31     \ Vertex 8
 VERTEX    0,   20,  -40,    12,    11,     8,     4,         31     \ Vertex 9
 VERTEX  -20,    0,  -40,    12,     9,     8,     5,         31     \ Vertex 10
 VERTEX    0,  -20,  -40,    12,    10,     9,     6,         31     \ Vertex 11
 VERTEX   20,    0,  -40,    12,    11,    10,     7,         31     \ Vertex 12
 VERTEX   -4,    4,  -40,    12,    12,    12,    12,         10     \ Vertex 13
 VERTEX   -4,   -4,  -40,    12,    12,    12,    12,         10     \ Vertex 14
 VERTEX    4,   -4,  -40,    12,    12,    12,    12,         10     \ Vertex 15
 VERTEX    4,    4,  -40,    12,    12,    12,    12,         10     \ Vertex 16

.SHIP_SHUTTLE_MK_2_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       2,     1,     0,         31    \ Edge 0
 EDGE       0,       3,     2,     1,         31    \ Edge 1
 EDGE       0,       4,     3,     2,         31    \ Edge 2
 EDGE       0,       1,     0,     3,         31    \ Edge 3
 EDGE       1,       5,     4,     0,         31    \ Edge 4
 EDGE       2,       5,     5,     0,         31    \ Edge 5
 EDGE       2,       6,     5,     1,         31    \ Edge 6
 EDGE       3,       6,     6,     1,         31    \ Edge 7
 EDGE       3,       7,     6,     2,         31    \ Edge 8
 EDGE       4,       7,     7,     2,         31    \ Edge 9
 EDGE       4,       8,     7,     3,         31    \ Edge 10
 EDGE       1,       8,     4,     3,         31    \ Edge 11
 EDGE       5,       9,     8,     4,         31    \ Edge 12
 EDGE       5,      10,     8,     5,         31    \ Edge 13
 EDGE       6,      10,     9,     5,         31    \ Edge 14
 EDGE       6,      11,     9,     6,         31    \ Edge 15
 EDGE       7,      11,    10,     6,         31    \ Edge 16
 EDGE       7,      12,    10,     7,         31    \ Edge 17
 EDGE       8,      12,    11,     7,         31    \ Edge 18
 EDGE       8,       9,    11,     4,         31    \ Edge 19
 EDGE       9,      10,    12,     8,         31    \ Edge 20
 EDGE      10,      11,    12,     9,         31    \ Edge 21
 EDGE      11,      12,    12,    10,         31    \ Edge 22
 EDGE      12,       9,    12,    11,         31    \ Edge 23
 EDGE      13,      14,    12,    12,         10    \ Edge 24
 EDGE      14,      15,    12,    12,         10    \ Edge 25
 EDGE      15,      16,    12,    12,         10    \ Edge 26
 EDGE      16,      13,    12,    12,         10    \ Edge 27

.SHIP_SHUTTLE_MK_2_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE      -39,       39,       78,         31    \ Face 0
 FACE      -39,      -39,       78,         31    \ Face 1
 FACE       39,      -39,       78,         31    \ Face 2
 FACE       39,       39,       78,         31    \ Face 3
 FACE        0,       96,        0,         31    \ Face 4
 FACE      -96,        0,        0,         31    \ Face 5
 FACE        0,      -96,        0,         31    \ Face 6
 FACE       96,        0,        0,         31    \ Face 7
 FACE      -66,       66,      -22,         31    \ Face 8
 FACE      -66,      -66,      -22,         31    \ Face 9
 FACE       66,      -66,      -22,         31    \ Face 10
 FACE       66,       66,      -22,         31    \ Face 11
 FACE        0,        0,      -96,         31    \ Face 12

\ ******************************************************************************
\
\       Name: SHIP_CHAMELEON
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprint for a Chameleon
\  Deep dive: Ship blueprints
\
\ ******************************************************************************

.SHIP_CHAMELEON

 EQUB 3                 \ Max. canisters on demise = 3
 EQUW 4000              \ Targetable area          = 63.24 * 63.24
 EQUB LO(SHIP_CHAMELEON_EDGES - SHIP_CHAMELEON)    \ Edges data offset (low)
 EQUB LO(SHIP_CHAMELEON_FACES - SHIP_CHAMELEON)    \ Faces data offset (low)
 EQUB 89                \ Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 \ Gun vertex               = 0
 EQUB 26                \ Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 108               \ Number of vertices       = 108 / 6 = 18
 EQUB 29                \ Number of edges          = 29
 EQUW 200               \ Bounty                   = 200
 EQUB 52                \ Number of faces          = 52 / 4 = 13
 EQUB 10                \ Visibility distance      = 10
 EQUB 100               \ Max. energy              = 100
 EQUB 29                \ Max. speed               = 29
 EQUB HI(SHIP_CHAMELEON_EDGES - SHIP_CHAMELEON)    \ Edges data offset (high)
 EQUB HI(SHIP_CHAMELEON_FACES - SHIP_CHAMELEON)    \ Faces data offset (high)
 EQUB 1                 \ Normals are scaled by    = 2^1 = 2
 EQUB %00100011         \ Laser power              = 4
                        \ Missiles                 = 3

\          x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,    0,  110,     5,     2,     1,     0,         31     \ Vertex 0
 VERTEX   18,    0,  110,     4,     3,     1,     0,         31     \ Vertex 1
 VERTEX  -40,    0,    0,    11,     8,     5,     2,         31     \ Vertex 2
 VERTEX   -8,   24,    0,     8,     6,     2,     2,         31     \ Vertex 3
 VERTEX    8,   24,    0,     9,     6,     3,     3,         31     \ Vertex 4
 VERTEX   40,    0,    0,    10,     9,     4,     3,         31     \ Vertex 5
 VERTEX    8,  -24,    0,    10,     7,     4,     4,         31     \ Vertex 6
 VERTEX   -8,  -24,    0,    11,     7,     5,     5,         31     \ Vertex 7
 VERTEX    0,   24,   40,     6,     3,     2,     0,         31     \ Vertex 8
 VERTEX    0,  -24,   40,     7,     5,     4,     1,         31     \ Vertex 9
 VERTEX  -32,    0,  -40,    12,    11,     8,     8,         31     \ Vertex 10
 VERTEX    0,   24,  -40,    12,     9,     8,     6,         31     \ Vertex 11
 VERTEX   32,    0,  -40,    12,    10,     9,     9,         31     \ Vertex 12
 VERTEX    0,  -24,  -40,    12,    11,    10,     7,         31     \ Vertex 13
 VERTEX   -8,    0,  -40,    12,    12,    12,    12,         10     \ Vertex 14
 VERTEX    0,    8,  -40,    12,    12,    12,    12,         10     \ Vertex 15
 VERTEX    8,    0,  -40,    12,    12,    12,    12,         10     \ Vertex 16
 VERTEX    0,   -8,  -40,    12,    12,    12,    12,         10     \ Vertex 17

.SHIP_CHAMELEON_EDGES

\     vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         31    \ Edge 0
 EDGE       0,       8,     2,     0,         31    \ Edge 1
 EDGE       0,       9,     5,     1,         31    \ Edge 2
 EDGE       1,       8,     3,     0,         31    \ Edge 3
 EDGE       1,       9,     4,     1,         31    \ Edge 4
 EDGE       1,       5,     4,     3,         31    \ Edge 5
 EDGE       0,       2,     5,     2,         31    \ Edge 6
 EDGE       3,       8,     6,     2,         31    \ Edge 7
 EDGE       4,       8,     6,     3,         31    \ Edge 8
 EDGE       7,       9,     5,     7,         31    \ Edge 9
 EDGE       6,       9,     4,     7,         31    \ Edge 10
 EDGE       4,       5,     9,     3,         31    \ Edge 11
 EDGE       5,       6,    10,     4,         31    \ Edge 12
 EDGE       2,       3,     8,     2,         31    \ Edge 13
 EDGE       2,       7,    11,     5,         31    \ Edge 14
 EDGE       2,      10,    11,     8,         31    \ Edge 15
 EDGE       5,      12,    10,     9,         31    \ Edge 16
 EDGE       3,      11,     8,     6,         31    \ Edge 17
 EDGE       7,      13,    11,     7,         31    \ Edge 18
 EDGE       4,      11,     9,     6,         31    \ Edge 19
 EDGE       6,      13,    10,     7,         31    \ Edge 20
 EDGE      10,      11,    12,     8,         31    \ Edge 21
 EDGE      10,      13,    12,    11,         31    \ Edge 22
 EDGE      11,      12,    12,     9,         31    \ Edge 23
 EDGE      12,      13,    12,    10,         31    \ Edge 24
 EDGE      14,      15,    12,    12,         10    \ Edge 25
 EDGE      15,      16,    12,    12,         10    \ Edge 26
 EDGE      16,      17,    12,    12,         10    \ Edge 27
 EDGE      17,      14,    12,    12,         10    \ Edge 28

.SHIP_CHAMELEON_FACES

\     normal_x, normal_y, normal_z, visibility
 FACE        0,       90,       31,         31    \ Face 0
 FACE        0,      -90,       31,         31    \ Face 1
 FACE      -57,       76,       11,         31    \ Face 2
 FACE       57,       76,       11,         31    \ Face 3
 FACE       57,      -76,       11,         31    \ Face 4
 FACE      -57,      -76,       11,         31    \ Face 5
 FACE        0,       96,        0,         31    \ Face 6
 FACE        0,      -96,        0,         31    \ Face 7
 FACE      -57,       76,      -11,         31    \ Face 8
 FACE       57,       76,      -11,         31    \ Face 9
 FACE       57,      -76,      -11,         31    \ Face 10
 FACE      -57,      -76,      -11,         31    \ Face 11
 FACE        0,        0,      -96,         31    \ Face 12

\ ******************************************************************************
\
\       Name: ship_list
\       Type: Variable
\   Category: Drawing ships
\    Summary: A list of all available ship types in Elite-A, for populating
\             the ship blueprints table
\  Deep dive: Ship blueprints in Elite-A
\
\ ******************************************************************************

.ship_list

 EQUW SHIP_DODO         \  0 = Dodo station
 EQUW SHIP_CORIOLIS     \  1 = Coriolis station
 EQUW SHIP_ESCAPE_POD   \  2 = Escape pod
 EQUW SHIP_PLATE        \  3 = Alloy plate
 EQUW SHIP_CANISTER     \  4 = Cargo canister
 EQUW SHIP_BOULDER      \  5 = Boulder
 EQUW SHIP_ASTEROID     \  6 = Asteroid
 EQUW SHIP_SPLINTER     \  7 = Splinter
 EQUW SHIP_SHUTTLE      \  8 = Shuttle
 EQUW SHIP_TRANSPORTER  \  9 = Transporter
 EQUW SHIP_COBRA_MK_3   \ 10 = Cobra Mk III
 EQUW SHIP_PYTHON       \ 11 = Python
 EQUW SHIP_BOA          \ 12 = Boa
 EQUW SHIP_ANACONDA     \ 13 = Anaconda
 EQUW SHIP_WORM         \ 14 = Worm
 EQUW SHIP_MISSILE      \ 15 = Missile
 EQUW SHIP_VIPER        \ 16 = Viper
 EQUW SHIP_SIDEWINDER   \ 17 = Sidewinder
 EQUW SHIP_MAMBA        \ 18 = Mamba
 EQUW SHIP_KRAIT        \ 19 = Krait
 EQUW SHIP_ADDER        \ 20 = Adder
 EQUW SHIP_GECKO        \ 21 = Gecko
 EQUW SHIP_COBRA_MK_1   \ 22 = Cobra Mk I
 EQUW SHIP_ASP_MK_2     \ 23 = Asp Mk II
 EQUW SHIP_FER_DE_LANCE \ 24 = Fer-de-Lance
 EQUW SHIP_MORAY        \ 25 = Moray
 EQUW SHIP_THARGOID     \ 26 = Thargoid
 EQUW SHIP_THARGON      \ 27 = Thargon
 EQUW SHIP_CONSTRICTOR  \ 28 = Constrictor
 EQUW SHIP_DRAGON       \ 29 = Dragon
 EQUW SHIP_MONITOR      \ 30 = Monitor
 EQUW SHIP_OPHIDIAN     \ 31 = Ophidian
 EQUW SHIP_GHAVIAL      \ 32 = Ghavial
 EQUW SHIP_BUSHMASTER   \ 33 = Bushmaster
 EQUW SHIP_RATTLER      \ 34 = Rattler
 EQUW SHIP_IGUANA       \ 35 = Iguana
 EQUW SHIP_SHUTTLE_MK_2 \ 36 = Shuttle Mk II
 EQUW SHIP_CHAMELEON    \ 37 = Chameleon

 EQUW 0                 \ 38 = No ship

\ ******************************************************************************
\
\       Name: XX21
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprints lookup table for flight in Elite-A
\  Deep dive: Ship blueprints in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   ship_data           The extended ship blueprints table for Elite-A, which
\                       includes an extra entry at the start for our current
\                       ship
\
\ ******************************************************************************

.ship_data

 EQUW 0                 \         0 = Our current ship

.XX21

 EQUW SHIP_MISSILE      \ MSL  =  1 = Missile                            Missile
 EQUW 0                 \                                                Station
 EQUW SHIP_ESCAPE_POD   \ ESC  =  3 = Escape pod                      Escape pod
 EQUW SHIP_PLATE        \ PLT  =  4 = Alloy plate                          Cargo
 EQUW SHIP_CANISTER     \ OIL  =  5 = Cargo canister                       Cargo
 EQUW SHIP_BOULDER      \         6 = Boulder                             Mining
 EQUW SHIP_ASTEROID     \ AST  =  7 = Asteroid                            Mining
 EQUW SHIP_SPLINTER     \ SPL  =  8 = Splinter                            Mining
 EQUW 0                 \                                                Shuttle
 EQUW SHIP_TRANSPORTER  \        10 = Transporter                    Transporter
 EQUW 0                 \                                                 Trader
 EQUW 0                 \                                                 Trader
 EQUW 0                 \                                                 Trader
 EQUW 0                 \                                             Large ship
 EQUW 0                 \                                             Small ship
 EQUW SHIP_VIPER        \ COPS = 16 = Viper                                  Cop
 EQUW 0                 \                                                 Pirate
 EQUW 0                 \                                                 Pirate
 EQUW 0                 \                                                 Pirate
 EQUW 0                 \                                                 Pirate
 EQUW 0                 \                                                 Pirate
 EQUW 0                 \                                                 Pirate
 EQUW 0                 \                                                 Pirate
 EQUW 0                 \                                                 Pirate
 EQUW 0                 \                                          Bounty hunter
 EQUW 0                 \                                          Bounty hunter
 EQUW 0                 \                                          Bounty hunter
 EQUW 0                 \                                          Bounty hunter
 EQUW SHIP_THARGOID     \ THG  = 29 = Thargoid                          Thargoid
 EQUW SHIP_THARGON      \ TGL  = 30 = Thargon                           Thargoid
 EQUW SHIP_CONSTRICTOR  \ CON  = 31 = Constrictor                    Constrictor

\ ******************************************************************************
\
\       Name: E%
\       Type: Variable
\   Category: Drawing ships
\    Summary: Ship blueprints default NEWB flags
\  Deep dive: Ship blueprints
\             Advanced tactics with the NEWB flags
\
\ ------------------------------------------------------------------------------
\
\ When spawning a new ship, the bits from this table are applied to the new
\ ship's NEWB flags in byte #36 (i.e. a set bit in this table will set that bit
\ in the NEWB flags). In other words, if a ship blueprint is set to one of the
\ following, then all spawned ships of that type will be too: trader, bounty
\ hunter, hostile, pirate, innocent, cop.
\
\ The NEWB flags are as follows:
\
\   * Bit 0: Trader flag (0 = not a trader, 1 = trader)
\   * Bit 1: Bounty hunter flag (0 = not a bounty hunter, 1 = bounty hunter)
\   * Bit 2: Hostile flag (0 = not hostile, 1 = hostile)
\   * Bit 3: Pirate flag (0 = not a pirate, 1 = pirate)
\   * Bit 4: Docking flag (0 = not docking, 1 = docking)
\   * Bit 5: Innocent bystander (0 = normal, 1 = innocent bystander)
\   * Bit 6: Cop flag (0 = not a cop, 1 = cop)
\   * Bit 7: For spawned ships: ship been scooped or has docked
\
\ See the deep dive on "Advanced tactics with the NEWB flags" for details of
\ how this works.
\
\ Other entry points:
\
\   ship_flags          The extended NEWB flags table for Elite-A, which
\                       includes an extra entry at the start for our current
\                       ship
\ ******************************************************************************

.ship_flags

 EQUB %00000000         \ Our current ship

.E%

 EQUB %00000000         \ Missile
 EQUB %01000000         \ Coriolis space station                             Cop
 EQUB %01000001         \ Escape pod                                 Cop, trader
 EQUB %00000000         \ Alloy plate
 EQUB %00000000         \ Cargo canister
 EQUB %00000000         \ Boulder
 EQUB %00000000         \ Asteroid
 EQUB %00000000         \ Splinter
 EQUB %00100001         \ Shuttle                               Trader, innocent
 EQUB %01100001         \ Transporter                      Trader, innocent, cop
 EQUB %00100000         \ Cobra Mk III                                  Innocent
 EQUB %00100001         \ Python                                Trader, innocent
 EQUB %00100000         \ Boa                                           Innocent
 EQUB %10100001         \ Anaconda                  Trader, innocent, escape pod
 EQUB %00001100         \ Rock hermit (asteroid)                 Hostile, pirate
 EQUB %11000010         \ Viper                   Bounty hunter, cop, escape pod
 EQUB %00001100         \ Sidewinder                             Hostile, pirate
 EQUB %00001100         \ Mamba                                  Hostile, pirate
 EQUB %00000100         \ Krait                                          Hostile
 EQUB %00001100         \ Adder                                  Hostile, pirate
 EQUB %00000100         \ Gecko                                          Hostile
 EQUB %00001100         \ Cobra Mk I                             Hostile, pirate
 EQUB %00000100         \ Worm                                           Hostile
 EQUB %00001100         \ Cobra Mk III (pirate)                  Hostile, pirate
 EQUB %00000010         \ Asp Mk II                                Bounty hunter
 EQUB %00100010         \ Python (pirate)                Innocent, bounty hunter
 EQUB %00000010         \ Fer-de-lance                             Bounty hunter
 EQUB %00100010         \ Moray                          Innocent, bounty hunter
 EQUB %00001100         \ Thargoid                               Hostile, pirate
 EQUB %00000100         \ Thargon                                        Hostile
 EQUB %10001100         \ Constrictor                Hostile, pirate, escape pod

\ ******************************************************************************
\
\       Name: ship_bits
\       Type: Variable
\   Category: Drawing ships
\    Summary: Table of allowed ship blueprint positions for each ship type
\  Deep dive: Ship blueprints in Elite-A
\
\ ******************************************************************************

.ship_bits

\       Blueprint position in ship_data
\       1 = allowed, 0 = not allowed
\
\       30        20        10        0
\       |         |         |         |
\       v         v         v         v
\      10987654321098765432109876543210

 EQUD %00000000000000000000000000000100         \  0 = Dodo station
 EQUD %00000000000000000000000000000100         \  1 = Coriolis station
 EQUD %00000000000000000000000000001000         \  2 = Escape pod
 EQUD %00000000000000000000000000010000         \  3 = Alloy plate
 EQUD %00000000000000000000000000100000         \  4 = Cargo canister
 EQUD %00000000000000000000000001000000         \  5 = Boulder
 EQUD %00000000000000000000000010000000         \  6 = Asteroid
 EQUD %00000000000000000000000100000000         \  7 = Splinter
 EQUD %00000000000000000000001000000000         \  8 = Shuttle
 EQUD %00000000000000000000010000000000         \  9 = Transporter
 EQUD %00011111111000000011100000000000         \ 10 = Cobra Mk III
 EQUD %00011001110000000011100000000000         \ 11 = Python
 EQUD %00000000000000000011100000000000         \ 12 = Boa
 EQUD %00000000000000000100000000000000         \ 13 = Anaconda
 EQUD %00000001110000001000000000000000         \ 14 = Worm
 EQUD %00000000000000000000000000000010         \ 15 = Missile
 EQUD %00000000000000010000000000000000         \ 16 = Viper
 EQUD %00010001111111101000000000000000         \ 17 = Sidewinder
 EQUD %00010001111111100000000000000000         \ 18 = Mamba
 EQUD %00010001111111100000000000000000         \ 19 = Krait
 EQUD %00011001111110000011000000000000         \ 20 = Adder
 EQUD %00011001111111100000000000000000         \ 21 = Gecko
 EQUD %00011001111111100010000000000000         \ 22 = Cobra Mk I
 EQUD %00011001000000000000000000000000         \ 23 = Asp Mk II
 EQUD %00011111000000000010000000000000         \ 24 = Fer-de-Lance
 EQUD %00011001110000000011000000000000         \ 25 = Moray
 EQUD %00100000000000000000000000000000         \ 26 = Thargoid
 EQUD %01000000000000000000000000000000         \ 27 = Thargon
 EQUD %10000000000000000000000000000000         \ 28 = Constrictor
 EQUD %00000000000000000100000000000000         \ 29 = Dragon
 EQUD %00010001000000000011100000000000         \ 30 = Monitor
 EQUD %00010001111000000011000000000000         \ 31 = Ophidian
 EQUD %00010000000000000011100000000000         \ 32 = Ghavial
 EQUD %00011101111100000000000000000000         \ 33 = Bushmaster
 EQUD %00010001110000000011000000000000         \ 34 = Rattler
 EQUD %00011101111100000010000000000000         \ 35 = Iguana
 EQUD %00000000000000000000011000000000         \ 36 = Shuttle Mk II
 EQUD %00010001110000000011000000000000         \ 37 = Chameleon

 EQUD %00011111111111100111111000000000         \ 38 = No ship

\ ******************************************************************************
\
\       Name: ship_bytes
\       Type: Variable
\   Category: Drawing ships
\    Summary: Table of data used when adding each ship type to the positions in
\             the blueprints table
\  Deep dive: Ship blueprints in Elite-A
\
\ ------------------------------------------------------------------------------
\
\ This table contains ship data that's used when populating the ship blueprint
\ positions in LOMOD, and installing a ship into a blueprint position in
\ install_ship.
\
\ Each ship type has four associated bytes, but only the first two are used:
\
\   * Byte #0 is used in LOMOD when populating the ship blueprint positions. It
\     is the probability (out of 256) of installing this ship into one of the
\     positions in which it is allowed. So, if the figure is 100 (as it is for
\     the Mamba and Sidewinder), then the chance of us adding this ship to a
\     blueprint position is 100/256, or a 39% chance, while the much rarer
\     Dragon has a value of 3, so its probability of being added is 3/256, or a
\     1.2% chance
\
\   * Byte #1 determines whether this ship type comes with an escape pod fitted
\     as standard: if bit 7 is set it does have an escape pod, otherwise it
\     doesn't
\
\ ******************************************************************************

.ship_bytes

 EQUB   0, %00000000, 0, 2      \  0 = Dodo station
 EQUB   0, %00000000, 0, 2      \  1 = Coriolis station
 EQUB   0, %00000000, 0, 2      \  2 = Escape pod
 EQUB   0, %00000000, 0, 2      \  3 = Alloy plate
 EQUB   0, %00000000, 0, 2      \  4 = Cargo canister
 EQUB   0, %00000000, 0, 2      \  5 = Boulder
 EQUB   0, %00000000, 0, 2      \  6 = Asteroid
 EQUB   0, %00000000, 0, 2      \  7 = Splinter
 EQUB  50, %00000000, 0, 0      \  8 = Shuttle
 EQUB  50, %00000000, 0, 0      \  9 = Transporter
 EQUB  70, %10000000, 0, 2      \ 10 = Cobra Mk III
 EQUB  65, %10000000, 0, 2      \ 11 = Python
 EQUB  60, %10000000, 0, 2      \ 12 = Boa
 EQUB  10, %10000000, 0, 0      \ 13 = Anaconda
 EQUB  15, %00000000, 0, 0      \ 14 = Worm
 EQUB   0, %00000000, 0, 0      \ 15 = Missile
 EQUB   0, %10000000, 0, 2      \ 16 = Viper
 EQUB  90, %00000000, 0, 2      \ 17 = Sidewinder
 EQUB 100, %10000000, 0, 2      \ 18 = Mamba
 EQUB 100, %10000000, 0, 2      \ 19 = Krait
 EQUB  85, %10000000, 0, 2      \ 20 = Adder
 EQUB  80, %10000000, 0, 2      \ 21 = Gecko
 EQUB  80, %10000000, 0, 2      \ 22 = Cobra Mk I
 EQUB  10, %10000000, 0, 0      \ 23 = Asp Mk II
 EQUB  60, %10000000, 0, 1      \ 24 = Fer-de-Lance
 EQUB  60, %10000000, 0, 1      \ 25 = Moray
 EQUB   0, %00000000, 0, 2      \ 26 = Thargoid
 EQUB   0, %00000000, 0, 2      \ 27 = Thargon
 EQUB   0, %00000000, 0, 2      \ 28 = Constrictor
 EQUB   3, %00000000, 0, 0      \ 29 = Dragon
 EQUB  30, %10000000, 0, 0      \ 30 = Monitor
 EQUB  75, %10000000, 0, 2      \ 31 = Ophidian
 EQUB  50, %10000000, 0, 1      \ 32 = Ghavial
 EQUB  75, %10000000, 0, 2      \ 33 = Bushmaster
 EQUB  55, %10000000, 0, 1      \ 34 = Rattler
 EQUB  60, %10000000, 0, 1      \ 35 = Iguana
 EQUB  50, %00000000, 0, 0      \ 36 = Shuttle Mk II
 EQUB  45, %10000000, 0, 1      \ 37 = Chameleon

 EQUB 255, %00000000, 0, 0      \ 38 = No ship

\ ******************************************************************************
\
\ Save 2.SHIPS.bin
\
\ ******************************************************************************

 PRINT "SHIPS"
 PRINT "Assembled at ", ~CODE_SHIPS%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_SHIPS%)
 PRINT "Execute at ", ~LOAD_SHIPS%
 PRINT "Reload at ", ~LOAD_SHIPS%

 PRINT "S.2.SHIPS ", ~CODE_SHIPS%, " ", ~P%, " ", ~LOAD_SHIPS%, " ", ~LOAD_SHIPS%
\SAVE "3-assembled-output/2.SHIPS.bin", CODE_SHIPS%, P%, LOAD_SHIPS%

\ ******************************************************************************
\
\ Save 2.T.bin
\
\ ******************************************************************************

 PRINT "S.2.T ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD%
 SAVE "3-assembled-output/2.T.bin", CODE%, P%, LOAD%